!function(Cd,Fl){"object"==typeof exports&&"object"==typeof module?module.exports=Fl():"function"==typeof define&&define.amd?define([],Fl):"object"==typeof exports?exports.AFRAME=Fl():Cd.AFRAME=Fl()}(self,()=>(()=>{var Cd={8167:ot=>{var ht=Object.prototype.toString;ot.exports=function(I){return I.BYTES_PER_ELEMENT&&"[object ArrayBuffer]"===ht.call(I.buffer)||Array.isArray(I)}},5734:ot=>{ot.exports=function(ht,I){return"number"==typeof ht?ht:"number"==typeof I?I:0}},7961:(ot,ht)=>{"use strict";ht.byteLength=function(D){var B=_(D),M=B[1];return 3*(B[0]+M)/4-M},ht.toByteArray=function(D){var B,C,pt,M=_(D),k=M[0],F=M[1],G=new $(3*(k+(pt=F))/4-pt),Q=0,X=F>0?k-4:k;for(C=0;C<X;C+=4)B=U[D.charCodeAt(C)]<<18|U[D.charCodeAt(C+1)]<<12|U[D.charCodeAt(C+2)]<<6|U[D.charCodeAt(C+3)],G[Q++]=B>>16&255,G[Q++]=B>>8&255,G[Q++]=255&B;return 2===F&&(B=U[D.charCodeAt(C)]<<2|U[D.charCodeAt(C+1)]>>4,G[Q++]=255&B),1===F&&(B=U[D.charCodeAt(C)]<<10|U[D.charCodeAt(C+1)]<<4|U[D.charCodeAt(C+2)]>>2,G[Q++]=B>>8&255,G[Q++]=255&B),G},ht.fromByteArray=function(D){for(var B,C=D.length,M=C%3,k=[],F=16383,G=0,Q=C-M;G<Q;G+=F)k.push(E(D,G,G+F>Q?Q:G+F));return 1===M?k.push(I[(B=D[C-1])>>2]+I[B<<4&63]+"=="):2===M&&k.push(I[(B=(D[C-2]<<8)+D[C-1])>>10]+I[B>>4&63]+I[B<<2&63]+"="),k.join("")};for(var I=[],U=[],$=typeof Uint8Array<"u"?Uint8Array:Array,O="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",N=0;N<64;++N)I[N]=O[N],U[O.charCodeAt(N)]=N;function _(D){var B=D.length;if(B%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var C=D.indexOf("=");return-1===C&&(C=B),[C,C===B?0:4-C%4]}function E(D,B,C){for(var k,F=[],G=B;G<C;G+=3)F.push(I[(k=(D[G]<<16&16711680)+(D[G+1]<<8&65280)+(255&D[G+2]))>>18&63]+I[k>>12&63]+I[k>>6&63]+I[63&k]);return F.join("")}U["-".charCodeAt(0)]=62,U["_".charCodeAt(0)]=63},911:(ot,ht,I)=>{var U=I(9922).hp;ot.exports=function($,O){if(U.isBuffer($)&&U.isBuffer(O)){if("function"==typeof $.equals)return $.equals(O);if($.length!==O.length)return!1;for(var N=0;N<$.length;N++)if($[N]!==O[N])return!1;return!0}}},9922:(ot,ht,I)=>{"use strict";const U=I(7961),$=I(1024),O="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;ht.hp=E,ht.IS=50;const N=2147483647;function _(q){if(q>N)throw new RangeError('The value "'+q+'" is invalid for option "size"');const st=new Uint8Array(q);return Object.setPrototypeOf(st,E.prototype),st}function E(q,st,ut){if("number"==typeof q){if("string"==typeof st)throw new TypeError('The "string" argument must be of type string. Received type number');return C(q)}return D(q,st,ut)}function D(q,st,ut){if("string"==typeof q)return function(Ht,Ae){if("string"==typeof Ae&&""!==Ae||(Ae="utf8"),!E.isEncoding(Ae))throw new TypeError("Unknown encoding: "+Ae);const Wt=0|G(Ht,Ae);let _e=_(Wt);const We=_e.write(Ht,Ae);return We!==Wt&&(_e=_e.slice(0,We)),_e}(q,st);if(ArrayBuffer.isView(q))return function(Ht){if(ys(Ht,Uint8Array)){const Ae=new Uint8Array(Ht);return k(Ae.buffer,Ae.byteOffset,Ae.byteLength)}return M(Ht)}(q);if(null==q)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof q);if(ys(q,ArrayBuffer)||q&&ys(q.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(ys(q,SharedArrayBuffer)||q&&ys(q.buffer,SharedArrayBuffer)))return k(q,st,ut);if("number"==typeof q)throw new TypeError('The "value" argument must not be of type number. Received type number');const Z=q.valueOf&&q.valueOf();if(null!=Z&&Z!==q)return E.from(Z,st,ut);const _t=function(Ht){if(E.isBuffer(Ht)){const Ae=0|F(Ht.length),Wt=_(Ae);return 0===Wt.length||Ht.copy(Wt,0,0,Ae),Wt}return void 0!==Ht.length?"number"!=typeof Ht.length||To(Ht.length)?_(0):M(Ht):"Buffer"===Ht.type&&Array.isArray(Ht.data)?M(Ht.data):void 0}(q);if(_t)return _t;if(typeof Symbol<"u"&&null!=Symbol.toPrimitive&&"function"==typeof q[Symbol.toPrimitive])return E.from(q[Symbol.toPrimitive]("string"),st,ut);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof q)}function B(q){if("number"!=typeof q)throw new TypeError('"size" argument must be of type number');if(q<0)throw new RangeError('The value "'+q+'" is invalid for option "size"')}function C(q){return B(q),_(q<0?0:0|F(q))}function M(q){const st=q.length<0?0:0|F(q.length),ut=_(st);for(let Z=0;Z<st;Z+=1)ut[Z]=255&q[Z];return ut}function k(q,st,ut){if(st<0||q.byteLength<st)throw new RangeError('"offset" is outside of buffer bounds');if(q.byteLength<st+(ut||0))throw new RangeError('"length" is outside of buffer bounds');let Z;return Z=void 0===st&&void 0===ut?new Uint8Array(q):void 0===ut?new Uint8Array(q,st):new Uint8Array(q,st,ut),Object.setPrototypeOf(Z,E.prototype),Z}function F(q){if(q>=N)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+N.toString(16)+" bytes");return 0|q}function G(q,st){if(E.isBuffer(q))return q.length;if(ArrayBuffer.isView(q)||ys(q,ArrayBuffer))return q.byteLength;if("string"!=typeof q)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof q);const ut=q.length,Z=arguments.length>2&&!0===arguments[2];if(!Z&&0===ut)return 0;let _t=!1;for(;;)switch(st){case"ascii":case"latin1":case"binary":return ut;case"utf8":case"utf-8":return Xa(q).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*ut;case"hex":return ut>>>1;case"base64":return Ya(q).length;default:if(_t)return Z?-1:Xa(q).length;st=(""+st).toLowerCase(),_t=!0}}function Q(q,st,ut){let Z=!1;if((void 0===st||st<0)&&(st=0),st>this.length||((void 0===ut||ut>this.length)&&(ut=this.length),ut<=0)||(ut>>>=0)<=(st>>>=0))return"";for(q||(q="utf8");;)switch(q){case"hex":return xe(this,st,ut);case"utf8":case"utf-8":return xt(this,st,ut);case"ascii":return Yt(this,st,ut);case"latin1":case"binary":return ve(this,st,ut);case"base64":return et(this,st,ut);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ge(this,st,ut);default:if(Z)throw new TypeError("Unknown encoding: "+q);q=(q+"").toLowerCase(),Z=!0}}function X(q,st,ut){const Z=q[st];q[st]=q[ut],q[ut]=Z}function lt(q,st,ut,Z,_t){if(0===q.length)return-1;if("string"==typeof ut?(Z=ut,ut=0):ut>2147483647?ut=2147483647:ut<-2147483648&&(ut=-2147483648),To(ut=+ut)&&(ut=_t?0:q.length-1),ut<0&&(ut=q.length+ut),ut>=q.length){if(_t)return-1;ut=q.length-1}else if(ut<0){if(!_t)return-1;ut=0}if("string"==typeof st&&(st=E.from(st,Z)),E.isBuffer(st))return 0===st.length?-1:rt(q,st,ut,Z,_t);if("number"==typeof st)return st&=255,"function"==typeof Uint8Array.prototype.indexOf?_t?Uint8Array.prototype.indexOf.call(q,st,ut):Uint8Array.prototype.lastIndexOf.call(q,st,ut):rt(q,[st],ut,Z,_t);throw new TypeError("val must be string, number or Buffer")}function rt(q,st,ut,Z,_t){let Ht,Ae=1,Wt=q.length,_e=st.length;if(void 0!==Z&&("ucs2"===(Z=String(Z).toLowerCase())||"ucs-2"===Z||"utf16le"===Z||"utf-16le"===Z)){if(q.length<2||st.length<2)return-1;Ae=2,Wt/=2,_e/=2,ut/=2}function We(hn,kn){return 1===Ae?hn[kn]:hn.readUInt16BE(kn*Ae)}if(_t){let hn=-1;for(Ht=ut;Ht<Wt;Ht++)if(We(q,Ht)===We(st,-1===hn?0:Ht-hn)){if(-1===hn&&(hn=Ht),Ht-hn+1===_e)return hn*Ae}else-1!==hn&&(Ht-=Ht-hn),hn=-1}else for(ut+_e>Wt&&(ut=Wt-_e),Ht=ut;Ht>=0;Ht--){let hn=!0;for(let kn=0;kn<_e;kn++)if(We(q,Ht+kn)!==We(st,kn)){hn=!1;break}if(hn)return Ht}return-1}function pt(q,st,ut,Z){ut=Number(ut)||0;const _t=q.length-ut;Z?(Z=Number(Z))>_t&&(Z=_t):Z=_t;const Ht=st.length;let Ae;for(Z>Ht/2&&(Z=Ht/2),Ae=0;Ae<Z;++Ae){const Wt=parseInt(st.substr(2*Ae,2),16);if(To(Wt))return Ae;q[ut+Ae]=Wt}return Ae}function vt(q,st,ut,Z){return _i(Xa(st,q.length-ut),q,ut,Z)}function bt(q,st,ut,Z){return _i(function(_t){const Ht=[];for(let Ae=0;Ae<_t.length;++Ae)Ht.push(255&_t.charCodeAt(Ae));return Ht}(st),q,ut,Z)}function ft(q,st,ut,Z){return _i(Ya(st),q,ut,Z)}function wt(q,st,ut,Z){return _i(function(_t,Ht){let Ae,Wt,_e;const We=[];for(let hn=0;hn<_t.length&&!((Ht-=2)<0);++hn)Ae=_t.charCodeAt(hn),Wt=Ae>>8,_e=Ae%256,We.push(_e),We.push(Wt);return We}(st,q.length-ut),q,ut,Z)}function et(q,st,ut){return U.fromByteArray(0===st&&ut===q.length?q:q.slice(st,ut))}function xt(q,st,ut){ut=Math.min(q.length,ut);const Z=[];let _t=st;for(;_t<ut;){const Ht=q[_t];let Ae=null,Wt=Ht>239?4:Ht>223?3:Ht>191?2:1;if(_t+Wt<=ut){let _e,We,hn,kn;switch(Wt){case 1:Ht<128&&(Ae=Ht);break;case 2:_e=q[_t+1],128==(192&_e)&&(kn=(31&Ht)<<6|63&_e,kn>127&&(Ae=kn));break;case 3:_e=q[_t+1],We=q[_t+2],128==(192&_e)&&128==(192&We)&&(kn=(15&Ht)<<12|(63&_e)<<6|63&We,kn>2047&&(kn<55296||kn>57343)&&(Ae=kn));break;case 4:_e=q[_t+1],We=q[_t+2],hn=q[_t+3],128==(192&_e)&&128==(192&We)&&128==(192&hn)&&(kn=(15&Ht)<<18|(63&_e)<<12|(63&We)<<6|63&hn,kn>65535&&kn<1114112&&(Ae=kn))}}null===Ae?(Ae=65533,Wt=1):Ae>65535&&(Ae-=65536,Z.push(Ae>>>10&1023|55296),Ae=56320|1023&Ae),Z.push(Ae),_t+=Wt}return function(Ht){const Ae=Ht.length;if(Ae<=Rt)return String.fromCharCode.apply(String,Ht);let Wt="",_e=0;for(;_e<Ae;)Wt+=String.fromCharCode.apply(String,Ht.slice(_e,_e+=Rt));return Wt}(Z)}(E.TYPED_ARRAY_SUPPORT=function(){try{const q=new Uint8Array(1),st={foo:function(){return 42}};return Object.setPrototypeOf(st,Uint8Array.prototype),Object.setPrototypeOf(q,st),42===q.foo()}catch{return!1}}())||typeof console>"u"||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(E.prototype,"parent",{enumerable:!0,get:function(){if(E.isBuffer(this))return this.buffer}}),Object.defineProperty(E.prototype,"offset",{enumerable:!0,get:function(){if(E.isBuffer(this))return this.byteOffset}}),E.poolSize=8192,E.from=function(q,st,ut){return D(q,st,ut)},Object.setPrototypeOf(E.prototype,Uint8Array.prototype),Object.setPrototypeOf(E,Uint8Array),E.alloc=function(q,st,ut){return _t=st,Ht=ut,B(Z=q),Z<=0?_(Z):void 0!==_t?"string"==typeof Ht?_(Z).fill(_t,Ht):_(Z).fill(_t):_(Z);var Z,_t,Ht},E.allocUnsafe=function(q){return C(q)},E.allocUnsafeSlow=function(q){return C(q)},E.isBuffer=function(q){return null!=q&&!0===q._isBuffer&&q!==E.prototype},E.compare=function(q,st){if(ys(q,Uint8Array)&&(q=E.from(q,q.offset,q.byteLength)),ys(st,Uint8Array)&&(st=E.from(st,st.offset,st.byteLength)),!E.isBuffer(q)||!E.isBuffer(st))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(q===st)return 0;let ut=q.length,Z=st.length;for(let _t=0,Ht=Math.min(ut,Z);_t<Ht;++_t)if(q[_t]!==st[_t]){ut=q[_t],Z=st[_t];break}return ut<Z?-1:Z<ut?1:0},E.isEncoding=function(q){switch(String(q).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},E.concat=function(q,st){if(!Array.isArray(q))throw new TypeError('"list" argument must be an Array of Buffers');if(0===q.length)return E.alloc(0);let ut;if(void 0===st)for(st=0,ut=0;ut<q.length;++ut)st+=q[ut].length;const Z=E.allocUnsafe(st);let _t=0;for(ut=0;ut<q.length;++ut){let Ht=q[ut];if(ys(Ht,Uint8Array))_t+Ht.length>Z.length?(E.isBuffer(Ht)||(Ht=E.from(Ht)),Ht.copy(Z,_t)):Uint8Array.prototype.set.call(Z,Ht,_t);else{if(!E.isBuffer(Ht))throw new TypeError('"list" argument must be an Array of Buffers');Ht.copy(Z,_t)}_t+=Ht.length}return Z},E.byteLength=G,E.prototype._isBuffer=!0,E.prototype.swap16=function(){const q=this.length;if(q%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let st=0;st<q;st+=2)X(this,st,st+1);return this},E.prototype.swap32=function(){const q=this.length;if(q%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let st=0;st<q;st+=4)X(this,st,st+3),X(this,st+1,st+2);return this},E.prototype.swap64=function(){const q=this.length;if(q%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let st=0;st<q;st+=8)X(this,st,st+7),X(this,st+1,st+6),X(this,st+2,st+5),X(this,st+3,st+4);return this},E.prototype.toLocaleString=E.prototype.toString=function(){const q=this.length;return 0===q?"":0===arguments.length?xt(this,0,q):Q.apply(this,arguments)},E.prototype.equals=function(q){if(!E.isBuffer(q))throw new TypeError("Argument must be a Buffer");return this===q||0===E.compare(this,q)},E.prototype.inspect=function(){let q="";const st=ht.IS;return q=this.toString("hex",0,st).replace(/(.{2})/g,"$1 ").trim(),this.length>st&&(q+=" ... "),"<Buffer "+q+">"},O&&(E.prototype[O]=E.prototype.inspect),E.prototype.compare=function(q,st,ut,Z,_t){if(ys(q,Uint8Array)&&(q=E.from(q,q.offset,q.byteLength)),!E.isBuffer(q))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof q);if(void 0===st&&(st=0),void 0===ut&&(ut=q?q.length:0),void 0===Z&&(Z=0),void 0===_t&&(_t=this.length),st<0||ut>q.length||Z<0||_t>this.length)throw new RangeError("out of range index");if(Z>=_t&&st>=ut)return 0;if(Z>=_t)return-1;if(st>=ut)return 1;if(this===q)return 0;let Ht=(_t>>>=0)-(Z>>>=0),Ae=(ut>>>=0)-(st>>>=0);const Wt=Math.min(Ht,Ae),_e=this.slice(Z,_t),We=q.slice(st,ut);for(let hn=0;hn<Wt;++hn)if(_e[hn]!==We[hn]){Ht=_e[hn],Ae=We[hn];break}return Ht<Ae?-1:Ae<Ht?1:0},E.prototype.includes=function(q,st,ut){return-1!==this.indexOf(q,st,ut)},E.prototype.indexOf=function(q,st,ut){return lt(this,q,st,ut,!0)},E.prototype.lastIndexOf=function(q,st,ut){return lt(this,q,st,ut,!1)},E.prototype.write=function(q,st,ut,Z){if(void 0===st)Z="utf8",ut=this.length,st=0;else if(void 0===ut&&"string"==typeof st)Z=st,ut=this.length,st=0;else{if(!isFinite(st))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");st>>>=0,isFinite(ut)?(ut>>>=0,void 0===Z&&(Z="utf8")):(Z=ut,ut=void 0)}const _t=this.length-st;if((void 0===ut||ut>_t)&&(ut=_t),q.length>0&&(ut<0||st<0)||st>this.length)throw new RangeError("Attempt to write outside buffer bounds");Z||(Z="utf8");let Ht=!1;for(;;)switch(Z){case"hex":return pt(this,q,st,ut);case"utf8":case"utf-8":return vt(this,q,st,ut);case"ascii":case"latin1":case"binary":return bt(this,q,st,ut);case"base64":return ft(this,q,st,ut);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return wt(this,q,st,ut);default:if(Ht)throw new TypeError("Unknown encoding: "+Z);Z=(""+Z).toLowerCase(),Ht=!0}},E.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const Rt=4096;function Yt(q,st,ut){let Z="";ut=Math.min(q.length,ut);for(let _t=st;_t<ut;++_t)Z+=String.fromCharCode(127&q[_t]);return Z}function ve(q,st,ut){let Z="";ut=Math.min(q.length,ut);for(let _t=st;_t<ut;++_t)Z+=String.fromCharCode(q[_t]);return Z}function xe(q,st,ut){const Z=q.length;(!st||st<0)&&(st=0),(!ut||ut<0||ut>Z)&&(ut=Z);let _t="";for(let Ht=st;Ht<ut;++Ht)_t+=qs[q[Ht]];return _t}function Ge(q,st,ut){const Z=q.slice(st,ut);let _t="";for(let Ht=0;Ht<Z.length-1;Ht+=2)_t+=String.fromCharCode(Z[Ht]+256*Z[Ht+1]);return _t}function en(q,st,ut){if(q%1!=0||q<0)throw new RangeError("offset is not uint");if(q+st>ut)throw new RangeError("Trying to access beyond buffer length")}function nn(q,st,ut,Z,_t,Ht){if(!E.isBuffer(q))throw new TypeError('"buffer" argument must be a Buffer instance');if(st>_t||st<Ht)throw new RangeError('"value" argument is out of bounds');if(ut+Z>q.length)throw new RangeError("Index out of range")}function vn(q,st,ut,Z,_t){ua(st,Z,_t,q,ut,7);let Ht=Number(st&BigInt(4294967295));q[ut++]=Ht,Ht>>=8,q[ut++]=Ht,Ht>>=8,q[ut++]=Ht,Ht>>=8,q[ut++]=Ht;let Ae=Number(st>>BigInt(32)&BigInt(4294967295));return q[ut++]=Ae,Ae>>=8,q[ut++]=Ae,Ae>>=8,q[ut++]=Ae,Ae>>=8,q[ut++]=Ae,ut}function _n(q,st,ut,Z,_t){ua(st,Z,_t,q,ut,7);let Ht=Number(st&BigInt(4294967295));q[ut+7]=Ht,Ht>>=8,q[ut+6]=Ht,Ht>>=8,q[ut+5]=Ht,Ht>>=8,q[ut+4]=Ht;let Ae=Number(st>>BigInt(32)&BigInt(4294967295));return q[ut+3]=Ae,Ae>>=8,q[ut+2]=Ae,Ae>>=8,q[ut+1]=Ae,Ae>>=8,q[ut]=Ae,ut+8}function nr(q,st,ut,Z,_t,Ht){if(ut+Z>q.length)throw new RangeError("Index out of range");if(ut<0)throw new RangeError("Index out of range")}function hr(q,st,ut,Z,_t){return st=+st,ut>>>=0,_t||nr(q,0,ut,4),$.write(q,st,ut,Z,23,4),ut+4}function Cs(q,st,ut,Z,_t){return st=+st,ut>>>=0,_t||nr(q,0,ut,8),$.write(q,st,ut,Z,52,8),ut+8}E.prototype.slice=function(q,st){const ut=this.length;(q=~~q)<0?(q+=ut)<0&&(q=0):q>ut&&(q=ut),(st=void 0===st?ut:~~st)<0?(st+=ut)<0&&(st=0):st>ut&&(st=ut),st<q&&(st=q);const Z=this.subarray(q,st);return Object.setPrototypeOf(Z,E.prototype),Z},E.prototype.readUintLE=E.prototype.readUIntLE=function(q,st,ut){q>>>=0,st>>>=0,ut||en(q,st,this.length);let Z=this[q],_t=1,Ht=0;for(;++Ht<st&&(_t*=256);)Z+=this[q+Ht]*_t;return Z},E.prototype.readUintBE=E.prototype.readUIntBE=function(q,st,ut){q>>>=0,st>>>=0,ut||en(q,st,this.length);let Z=this[q+--st],_t=1;for(;st>0&&(_t*=256);)Z+=this[q+--st]*_t;return Z},E.prototype.readUint8=E.prototype.readUInt8=function(q,st){return q>>>=0,st||en(q,1,this.length),this[q]},E.prototype.readUint16LE=E.prototype.readUInt16LE=function(q,st){return q>>>=0,st||en(q,2,this.length),this[q]|this[q+1]<<8},E.prototype.readUint16BE=E.prototype.readUInt16BE=function(q,st){return q>>>=0,st||en(q,2,this.length),this[q]<<8|this[q+1]},E.prototype.readUint32LE=E.prototype.readUInt32LE=function(q,st){return q>>>=0,st||en(q,4,this.length),(this[q]|this[q+1]<<8|this[q+2]<<16)+16777216*this[q+3]},E.prototype.readUint32BE=E.prototype.readUInt32BE=function(q,st){return q>>>=0,st||en(q,4,this.length),16777216*this[q]+(this[q+1]<<16|this[q+2]<<8|this[q+3])},E.prototype.readBigUInt64LE=se(function(q){Oa(q>>>=0,"offset");const st=this[q],ut=this[q+7];void 0!==st&&void 0!==ut||ha(q,this.length-8);const Z=st+256*this[++q]+65536*this[++q]+this[++q]*2**24,_t=this[++q]+256*this[++q]+65536*this[++q]+ut*2**24;return BigInt(Z)+(BigInt(_t)<<BigInt(32))}),E.prototype.readBigUInt64BE=se(function(q){Oa(q>>>=0,"offset");const st=this[q],ut=this[q+7];void 0!==st&&void 0!==ut||ha(q,this.length-8);const Z=st*2**24+65536*this[++q]+256*this[++q]+this[++q],_t=this[++q]*2**24+65536*this[++q]+256*this[++q]+ut;return(BigInt(Z)<<BigInt(32))+BigInt(_t)}),E.prototype.readIntLE=function(q,st,ut){q>>>=0,st>>>=0,ut||en(q,st,this.length);let Z=this[q],_t=1,Ht=0;for(;++Ht<st&&(_t*=256);)Z+=this[q+Ht]*_t;return _t*=128,Z>=_t&&(Z-=Math.pow(2,8*st)),Z},E.prototype.readIntBE=function(q,st,ut){q>>>=0,st>>>=0,ut||en(q,st,this.length);let Z=st,_t=1,Ht=this[q+--Z];for(;Z>0&&(_t*=256);)Ht+=this[q+--Z]*_t;return _t*=128,Ht>=_t&&(Ht-=Math.pow(2,8*st)),Ht},E.prototype.readInt8=function(q,st){return q>>>=0,st||en(q,1,this.length),128&this[q]?-1*(255-this[q]+1):this[q]},E.prototype.readInt16LE=function(q,st){q>>>=0,st||en(q,2,this.length);const ut=this[q]|this[q+1]<<8;return 32768&ut?4294901760|ut:ut},E.prototype.readInt16BE=function(q,st){q>>>=0,st||en(q,2,this.length);const ut=this[q+1]|this[q]<<8;return 32768&ut?4294901760|ut:ut},E.prototype.readInt32LE=function(q,st){return q>>>=0,st||en(q,4,this.length),this[q]|this[q+1]<<8|this[q+2]<<16|this[q+3]<<24},E.prototype.readInt32BE=function(q,st){return q>>>=0,st||en(q,4,this.length),this[q]<<24|this[q+1]<<16|this[q+2]<<8|this[q+3]},E.prototype.readBigInt64LE=se(function(q){Oa(q>>>=0,"offset");const st=this[q],ut=this[q+7];return void 0!==st&&void 0!==ut||ha(q,this.length-8),(BigInt(this[q+4]+256*this[q+5]+65536*this[q+6]+(ut<<24))<<BigInt(32))+BigInt(st+256*this[++q]+65536*this[++q]+16777216*this[++q])}),E.prototype.readBigInt64BE=se(function(q){Oa(q>>>=0,"offset");const st=this[q],ut=this[q+7];void 0!==st&&void 0!==ut||ha(q,this.length-8);const Z=(st<<24)+65536*this[++q]+256*this[++q]+this[++q];return(BigInt(Z)<<BigInt(32))+BigInt(16777216*this[++q]+65536*this[++q]+256*this[++q]+ut)}),E.prototype.readFloatLE=function(q,st){return q>>>=0,st||en(q,4,this.length),$.read(this,q,!0,23,4)},E.prototype.readFloatBE=function(q,st){return q>>>=0,st||en(q,4,this.length),$.read(this,q,!1,23,4)},E.prototype.readDoubleLE=function(q,st){return q>>>=0,st||en(q,8,this.length),$.read(this,q,!0,52,8)},E.prototype.readDoubleBE=function(q,st){return q>>>=0,st||en(q,8,this.length),$.read(this,q,!1,52,8)},E.prototype.writeUintLE=E.prototype.writeUIntLE=function(q,st,ut,Z){q=+q,st>>>=0,ut>>>=0,Z||nn(this,q,st,ut,Math.pow(2,8*ut)-1,0);let _t=1,Ht=0;for(this[st]=255&q;++Ht<ut&&(_t*=256);)this[st+Ht]=q/_t&255;return st+ut},E.prototype.writeUintBE=E.prototype.writeUIntBE=function(q,st,ut,Z){q=+q,st>>>=0,ut>>>=0,Z||nn(this,q,st,ut,Math.pow(2,8*ut)-1,0);let _t=ut-1,Ht=1;for(this[st+_t]=255&q;--_t>=0&&(Ht*=256);)this[st+_t]=q/Ht&255;return st+ut},E.prototype.writeUint8=E.prototype.writeUInt8=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,1,255,0),this[st]=255&q,st+1},E.prototype.writeUint16LE=E.prototype.writeUInt16LE=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,2,65535,0),this[st]=255&q,this[st+1]=q>>>8,st+2},E.prototype.writeUint16BE=E.prototype.writeUInt16BE=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,2,65535,0),this[st]=q>>>8,this[st+1]=255&q,st+2},E.prototype.writeUint32LE=E.prototype.writeUInt32LE=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,4,4294967295,0),this[st+3]=q>>>24,this[st+2]=q>>>16,this[st+1]=q>>>8,this[st]=255&q,st+4},E.prototype.writeUint32BE=E.prototype.writeUInt32BE=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,4,4294967295,0),this[st]=q>>>24,this[st+1]=q>>>16,this[st+2]=q>>>8,this[st+3]=255&q,st+4},E.prototype.writeBigUInt64LE=se(function(q,st=0){return vn(this,q,st,BigInt(0),BigInt("0xffffffffffffffff"))}),E.prototype.writeBigUInt64BE=se(function(q,st=0){return _n(this,q,st,BigInt(0),BigInt("0xffffffffffffffff"))}),E.prototype.writeIntLE=function(q,st,ut,Z){if(q=+q,st>>>=0,!Z){const Wt=Math.pow(2,8*ut-1);nn(this,q,st,ut,Wt-1,-Wt)}let _t=0,Ht=1,Ae=0;for(this[st]=255&q;++_t<ut&&(Ht*=256);)q<0&&0===Ae&&0!==this[st+_t-1]&&(Ae=1),this[st+_t]=(q/Ht|0)-Ae&255;return st+ut},E.prototype.writeIntBE=function(q,st,ut,Z){if(q=+q,st>>>=0,!Z){const Wt=Math.pow(2,8*ut-1);nn(this,q,st,ut,Wt-1,-Wt)}let _t=ut-1,Ht=1,Ae=0;for(this[st+_t]=255&q;--_t>=0&&(Ht*=256);)q<0&&0===Ae&&0!==this[st+_t+1]&&(Ae=1),this[st+_t]=(q/Ht|0)-Ae&255;return st+ut},E.prototype.writeInt8=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,1,127,-128),q<0&&(q=255+q+1),this[st]=255&q,st+1},E.prototype.writeInt16LE=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,2,32767,-32768),this[st]=255&q,this[st+1]=q>>>8,st+2},E.prototype.writeInt16BE=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,2,32767,-32768),this[st]=q>>>8,this[st+1]=255&q,st+2},E.prototype.writeInt32LE=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,4,2147483647,-2147483648),this[st]=255&q,this[st+1]=q>>>8,this[st+2]=q>>>16,this[st+3]=q>>>24,st+4},E.prototype.writeInt32BE=function(q,st,ut){return q=+q,st>>>=0,ut||nn(this,q,st,4,2147483647,-2147483648),q<0&&(q=4294967295+q+1),this[st]=q>>>24,this[st+1]=q>>>16,this[st+2]=q>>>8,this[st+3]=255&q,st+4},E.prototype.writeBigInt64LE=se(function(q,st=0){return vn(this,q,st,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),E.prototype.writeBigInt64BE=se(function(q,st=0){return _n(this,q,st,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),E.prototype.writeFloatLE=function(q,st,ut){return hr(this,q,st,!0,ut)},E.prototype.writeFloatBE=function(q,st,ut){return hr(this,q,st,!1,ut)},E.prototype.writeDoubleLE=function(q,st,ut){return Cs(this,q,st,!0,ut)},E.prototype.writeDoubleBE=function(q,st,ut){return Cs(this,q,st,!1,ut)},E.prototype.copy=function(q,st,ut,Z){if(!E.isBuffer(q))throw new TypeError("argument should be a Buffer");if(ut||(ut=0),Z||0===Z||(Z=this.length),st>=q.length&&(st=q.length),st||(st=0),Z>0&&Z<ut&&(Z=ut),Z===ut||0===q.length||0===this.length)return 0;if(st<0)throw new RangeError("targetStart out of bounds");if(ut<0||ut>=this.length)throw new RangeError("Index out of range");if(Z<0)throw new RangeError("sourceEnd out of bounds");Z>this.length&&(Z=this.length),q.length-st<Z-ut&&(Z=q.length-st+ut);const _t=Z-ut;return this===q&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(st,ut,Z):Uint8Array.prototype.set.call(q,this.subarray(ut,Z),st),_t},E.prototype.fill=function(q,st,ut,Z){if("string"==typeof q){if("string"==typeof st?(Z=st,st=0,ut=this.length):"string"==typeof ut&&(Z=ut,ut=this.length),void 0!==Z&&"string"!=typeof Z)throw new TypeError("encoding must be a string");if("string"==typeof Z&&!E.isEncoding(Z))throw new TypeError("Unknown encoding: "+Z);if(1===q.length){const Ht=q.charCodeAt(0);("utf8"===Z&&Ht<128||"latin1"===Z)&&(q=Ht)}}else"number"==typeof q?q&=255:"boolean"==typeof q&&(q=Number(q));if(st<0||this.length<st||this.length<ut)throw new RangeError("Out of range index");if(ut<=st)return this;let _t;if(st>>>=0,ut=void 0===ut?this.length:ut>>>0,q||(q=0),"number"==typeof q)for(_t=st;_t<ut;++_t)this[_t]=q;else{const Ht=E.isBuffer(q)?q:E.from(q,Z),Ae=Ht.length;if(0===Ae)throw new TypeError('The value "'+q+'" is invalid for argument "value"');for(_t=0;_t<ut-st;++_t)this[_t+st]=Ht[_t%Ae]}return this};const Ti={};function Is(q,st,ut){Ti[q]=class extends ut{constructor(){super(),Object.defineProperty(this,"message",{value:st.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${q}]`,delete this.name}get code(){return q}set code(Z){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:Z,writable:!0})}toString(){return`${this.name} [${q}]: ${this.message}`}}}function As(q){let st="",ut=q.length;const Z="-"===q[0]?1:0;for(;ut>=Z+4;ut-=3)st=`_${q.slice(ut-3,ut)}${st}`;return`${q.slice(0,ut)}${st}`}function ua(q,st,ut,Z,_t,Ht){if(q>ut||q<st){const Ae="bigint"==typeof st?"n":"";let Wt;throw Wt=Ht>3?0===st||st===BigInt(0)?`>= 0${Ae} and < 2${Ae} ** ${8*(Ht+1)}${Ae}`:`>= -(2${Ae} ** ${8*(Ht+1)-1}${Ae}) and < 2 ** ${8*(Ht+1)-1}${Ae}`:`>= ${st}${Ae} and <= ${ut}${Ae}`,new Ti.ERR_OUT_OF_RANGE("value",Wt,q)}var Ae,Wt,_e;Ae=Z,_e=Ht,Oa(Wt=_t,"offset"),void 0!==Ae[Wt]&&void 0!==Ae[Wt+_e]||ha(Wt,Ae.length-(_e+1))}function Oa(q,st){if("number"!=typeof q)throw new Ti.ERR_INVALID_ARG_TYPE(st,"number",q)}function ha(q,st,ut){throw Math.floor(q)!==q?(Oa(q,ut),new Ti.ERR_OUT_OF_RANGE(ut||"offset","an integer",q)):st<0?new Ti.ERR_BUFFER_OUT_OF_BOUNDS:new Ti.ERR_OUT_OF_RANGE(ut||"offset",`>= ${ut?1:0} and <= ${st}`,q)}Is("ERR_BUFFER_OUT_OF_BOUNDS",function(q){return q?`${q} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),Is("ERR_INVALID_ARG_TYPE",function(q,st){return`The "${q}" argument must be of type number. Received type ${typeof st}`},TypeError),Is("ERR_OUT_OF_RANGE",function(q,st,ut){let Z=`The value of "${q}" is out of range.`,_t=ut;return Number.isInteger(ut)&&Math.abs(ut)>4294967296?_t=As(String(ut)):"bigint"==typeof ut&&(_t=String(ut),(ut>BigInt(2)**BigInt(32)||ut<-(BigInt(2)**BigInt(32)))&&(_t=As(_t)),_t+="n"),Z+=` It must be ${st}. Received ${_t}`,Z},RangeError);const js=/[^+/0-9A-Za-z-_]/g;function Xa(q,st){let ut;st=st||1/0;const Z=q.length;let _t=null;const Ht=[];for(let Ae=0;Ae<Z;++Ae){if(ut=q.charCodeAt(Ae),ut>55295&&ut<57344){if(!_t){if(ut>56319){(st-=3)>-1&&Ht.push(239,191,189);continue}if(Ae+1===Z){(st-=3)>-1&&Ht.push(239,191,189);continue}_t=ut;continue}if(ut<56320){(st-=3)>-1&&Ht.push(239,191,189),_t=ut;continue}ut=65536+(_t-55296<<10|ut-56320)}else _t&&(st-=3)>-1&&Ht.push(239,191,189);if(_t=null,ut<128){if((st-=1)<0)break;Ht.push(ut)}else if(ut<2048){if((st-=2)<0)break;Ht.push(ut>>6|192,63&ut|128)}else if(ut<65536){if((st-=3)<0)break;Ht.push(ut>>12|224,ut>>6&63|128,63&ut|128)}else{if(!(ut<1114112))throw new Error("Invalid code point");if((st-=4)<0)break;Ht.push(ut>>18|240,ut>>12&63|128,ut>>6&63|128,63&ut|128)}}return Ht}function Ya(q){return U.toByteArray(function(st){if((st=(st=st.split("=")[0]).trim().replace(js,"")).length<2)return"";for(;st.length%4!=0;)st+="=";return st}(q))}function _i(q,st,ut,Z){let _t;for(_t=0;_t<Z&&!(_t+ut>=st.length||_t>=q.length);++_t)st[_t+ut]=q[_t];return _t}function ys(q,st){return q instanceof st||null!=q&&null!=q.constructor&&null!=q.constructor.name&&q.constructor.name===st.name}function To(q){return q!=q}const qs=function(){const q="0123456789abcdef",st=new Array(256);for(let ut=0;ut<16;++ut){const Z=16*ut;for(let _t=0;_t<16;++_t)st[Z+_t]=q[ut]+q[_t]}return st}();function se(q){return typeof BigInt>"u"?Ct:q}function Ct(){throw new Error("BigInt not supported")}},9089:ot=>{"use strict";ot.exports=function(ht){var I=[];return I.toString=function(){return this.map(function(U){var $="",O=void 0!==U[5];return U[4]&&($+="@supports (".concat(U[4],") {")),U[2]&&($+="@media ".concat(U[2]," {")),O&&($+="@layer".concat(U[5].length>0?" ".concat(U[5]):""," {")),$+=ht(U),O&&($+="}"),U[2]&&($+="}"),U[4]&&($+="}"),$}).join("")},I.i=function(U,$,O,N,_){"string"==typeof U&&(U=[[null,U,void 0]]);var E={};if(O)for(var D=0;D<this.length;D++){var B=this[D][0];null!=B&&(E[B]=!0)}for(var C=0;C<U.length;C++){var M=[].concat(U[C]);O&&E[M[0]]||(void 0!==_&&(void 0===M[5]||(M[1]="@layer".concat(M[5].length>0?" ".concat(M[5]):""," {").concat(M[1],"}")),M[5]=_),$&&(M[2]&&(M[1]="@media ".concat(M[2]," {").concat(M[1],"}")),M[2]=$),N&&(M[4]?(M[1]="@supports (".concat(M[4],") {").concat(M[1],"}"),M[4]=N):M[4]="".concat(N)),I.push(M))}},I}},6492:ot=>{"use strict";ot.exports=function(ht,I){return I||(I={}),ht&&(ht=String(ht.__esModule?ht.default:ht),/^['"].*['"]$/.test(ht)&&(ht=ht.slice(1,-1)),I.hash&&(ht+=I.hash),/["'() \t\n]|(%20)/.test(ht)||I.needQuotes?'"'.concat(ht.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):ht)}},963:ot=>{"use strict";ot.exports=function(ht){var I=ht[1],U=ht[3];if(!U)return I;if("function"==typeof btoa){var $=btoa(unescape(encodeURIComponent(JSON.stringify(U)))),O="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat($),N="/*# ".concat(O," */");return[I].concat([N]).join("\n")}return[I].join("\n")}},307:ot=>{var ht=1e3,I=6e4,U=60*I,$=24*U;function O(N,_,E,D){var B=_>=1.5*E;return Math.round(N/E)+" "+D+(B?"s":"")}ot.exports=function(N,_){_=_||{};var E,D,C,M,B=typeof N;if("string"===B&&N.length>0)return function(C){if(!((C=String(C)).length>100)){var M=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(C);if(M){var k=parseFloat(M[1]);switch((M[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*k;case"weeks":case"week":case"w":return 6048e5*k;case"days":case"day":case"d":return k*$;case"hours":case"hour":case"hrs":case"hr":case"h":return k*U;case"minutes":case"minute":case"mins":case"min":case"m":return k*I;case"seconds":case"second":case"secs":case"sec":case"s":return k*ht;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return k;default:return}}}}(N);if("number"===B&&isFinite(N))return _.long?(E=N,(D=Math.abs(E))>=$?O(E,D,$,"day"):D>=U?O(E,D,U,"hour"):D>=I?O(E,D,I,"minute"):D>=ht?O(E,D,ht,"second"):E+" ms"):(C=N,(M=Math.abs(C))>=$?Math.round(C/$)+"d":M>=U?Math.round(C/U)+"h":M>=I?Math.round(C/I)+"m":M>=ht?Math.round(C/ht)+"s":C+"ms");throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(N))}},8878:(ot,ht,I)=>{ht.formatArgs=function($){if($[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+$[0]+(this.useColors?"%c ":" ")+"+"+ot.exports.humanize(this.diff),!this.useColors)return;const O="color: "+this.color;$.splice(1,0,O,"color: inherit");let N=0,_=0;$[0].replace(/%[a-zA-Z%]/g,E=>{"%%"!==E&&(N++,"%c"===E&&(_=N))}),$.splice(_,0,O)},ht.save=function($){try{$?ht.storage.setItem("debug",$):ht.storage.removeItem("debug")}catch{}},ht.load=function(){let $;try{$=ht.storage.getItem("debug")}catch{}return!$&&typeof process<"u"&&"env"in process&&($=process.env.DEBUG),$},ht.useColors=function(){return!(typeof window>"u"||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||(typeof navigator>"u"||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&(typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},ht.storage=function(){try{return localStorage}catch{}}(),ht.destroy=(()=>{let $=!1;return()=>{$||($=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),ht.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],ht.log=console.debug||console.log||(()=>{}),ot.exports=I(8945)(ht);const{formatters:U}=ot.exports;U.j=function($){try{return JSON.stringify($)}catch(O){return"[UnexpectedJSONParseError]: "+O.message}}},8945:(ot,ht,I)=>{ot.exports=function(U){function $(_){let E,D,B,C=null;function M(...k){if(!M.enabled)return;const F=M,G=Number(new Date);F.diff=G-(E||G),F.prev=E,F.curr=G,E=G,k[0]=$.coerce(k[0]),"string"!=typeof k[0]&&k.unshift("%O");let X=0;k[0]=k[0].replace(/%([a-zA-Z%])/g,(lt,rt)=>{if("%%"===lt)return"%";X++;const pt=$.formatters[rt];return"function"==typeof pt&&(lt=pt.call(F,k[X]),k.splice(X,1),X--),lt}),$.formatArgs.call(F,k),(F.log||$.log).apply(F,k)}return M.namespace=_,M.useColors=$.useColors(),M.color=$.selectColor(_),M.extend=O,M.destroy=$.destroy,Object.defineProperty(M,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==C?C:(D!==$.namespaces&&(D=$.namespaces,B=$.enabled(_)),B),set:k=>{C=k}}),"function"==typeof $.init&&$.init(M),M}function O(_,E){const D=$(this.namespace+(void 0===E?":":E)+_);return D.log=this.log,D}function N(_){return _.toString().substring(2,_.toString().length-2).replace(/\.\*\?$/,"*")}return $.debug=$,$.default=$,$.coerce=function(_){return _ instanceof Error?_.stack||_.message:_},$.disable=function(){const _=[...$.names.map(N),...$.skips.map(N).map(E=>"-"+E)].join(",");return $.enable(""),_},$.enable=function(_){let E;$.save(_),$.namespaces=_,$.names=[],$.skips=[];const D=("string"==typeof _?_:"").split(/[\s,]+/),B=D.length;for(E=0;E<B;E++)D[E]&&("-"===(_=D[E].replace(/\*/g,".*?"))[0]?$.skips.push(new RegExp("^"+_.slice(1)+"$")):$.names.push(new RegExp("^"+_+"$")))},$.enabled=function(_){if("*"===_[_.length-1])return!0;let E,D;for(E=0,D=$.skips.length;E<D;E++)if($.skips[E].test(_))return!1;for(E=0,D=$.names.length;E<D;E++)if($.names[E].test(_))return!0;return!1},$.humanize=I(307),$.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(U).forEach(_=>{$[_]=U[_]}),$.names=[],$.skips=[],$.formatters={},$.selectColor=function(_){let E=0;for(let D=0;D<_.length;D++)E=(E<<5)-E+_.charCodeAt(D),E|=0;return $.colors[Math.abs(E)%$.colors.length]},$.enable($.load()),$}},1124:(ot,ht,I)=>{"use strict";var U=I(6240),$=Object.prototype.hasOwnProperty,O=Object.prototype.propertyIsEnumerable;function N(E,D,B){var C=D[B];if(null!=C){if($.call(E,B)&&null==E[B])throw new TypeError("Cannot convert undefined or null to object ("+B+")");E[B]=$.call(E,B)&&U(C)?_(Object(E[B]),D[B]):C}}function _(E,D){if(E===D)return E;for(var B in D=Object(D))$.call(D,B)&&N(E,D,B);if(Object.getOwnPropertySymbols)for(var C=Object.getOwnPropertySymbols(D),M=0;M<C.length;M++)O.call(D,C[M])&&N(E,D,C[M]);return E}ot.exports=function(E){E=function(B){if(null==B)throw new TypeError("Sources cannot be null or undefined");return Object(B)}(E);for(var D=1;D<arguments.length;D++)_(E,arguments[D]);return E}},8480:ot=>{ot.exports=function(ht){switch(ht){case"int8":return Int8Array;case"int16":return Int16Array;case"int32":return Int32Array;case"uint8":return Uint8Array;case"uint16":return Uint16Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;case"array":return Array;case"uint8_clamped":return Uint8ClampedArray}}},919:(ot,ht,I)=>{var U;U=typeof window<"u"?window:void 0!==I.g?I.g:typeof self<"u"?self:{},ot.exports=U},1024:(ot,ht)=>{ht.read=function(I,U,$,O,N){var _,E,D=8*N-O-1,B=(1<<D)-1,C=B>>1,M=-7,k=$?N-1:0,F=$?-1:1,G=I[U+k];for(k+=F,_=G&(1<<-M)-1,G>>=-M,M+=D;M>0;_=256*_+I[U+k],k+=F,M-=8);for(E=_&(1<<-M)-1,_>>=-M,M+=O;M>0;E=256*E+I[U+k],k+=F,M-=8);if(0===_)_=1-C;else{if(_===B)return E?NaN:1/0*(G?-1:1);E+=Math.pow(2,O),_-=C}return(G?-1:1)*E*Math.pow(2,_-O)},ht.write=function(I,U,$,O,N,_){var E,D,B,C=8*_-N-1,M=(1<<C)-1,k=M>>1,F=23===N?Math.pow(2,-24)-Math.pow(2,-77):0,G=O?0:_-1,Q=O?1:-1,X=U<0||0===U&&1/U<0?1:0;for(U=Math.abs(U),isNaN(U)||U===1/0?(D=isNaN(U)?1:0,E=M):(E=Math.floor(Math.log(U)/Math.LN2),U*(B=Math.pow(2,-E))<1&&(E--,B*=2),(U+=E+k>=1?F/B:F*Math.pow(2,1-k))*B>=2&&(E++,B/=2),E+k>=M?(D=0,E=M):E+k>=1?(D=(U*B-1)*Math.pow(2,N),E+=k):(D=U*Math.pow(2,k-1)*Math.pow(2,N),E=0));N>=8;I[$+G]=255&D,G+=Q,D/=256,N-=8);for(E=E<<N|D,C+=N;C>0;I[$+G]=255&E,G+=Q,E/=256,C-=8);I[$+G-Q]|=128*X}},2225:ot=>{function ht(I){return!!I.constructor&&"function"==typeof I.constructor.isBuffer&&I.constructor.isBuffer(I)}ot.exports=function(I){return null!=I&&(ht(I)||"function"==typeof(U=I).readFloatLE&&"function"==typeof U.slice&&ht(U.slice(0,0))||!!I._isBuffer);var U}},8847:ot=>{ot.exports=function(I){if(!I)return!1;var U=ht.call(I);return"[object Function]"===U||"function"==typeof I&&"[object RegExp]"!==U||typeof window<"u"&&(I===window.setTimeout||I===window.alert||I===window.confirm||I===window.prompt)};var ht=Object.prototype.toString},6240:ot=>{"use strict";ot.exports=function(ht){var I=typeof ht;return null!==ht&&("object"===I||"function"===I)}},5651:(ot,ht,I)=>{var U=I(5406),$=I(4597),O=I(5734),N=["x","e","a","o","n","s","r","c","u","m","v","w","z"],_=["m","w"],E=["H","I","N","E","F","K","L","T","U","V","W","X","Y","Z"],D="\t".charCodeAt(0),B=" ".charCodeAt(0);function C(Q){this.glyphs=[],this._measure=this.computeMetrics.bind(this),this.update(Q)}function M(Q){return new Function(["return function "+Q+"() {","  return this._"+Q,"}"].join("\n"))()}function k(Q,X){if(!Q.chars||0===Q.chars.length)return null;var lt=G(Q.chars,X);return lt>=0?Q.chars[lt]:null}function F(Q,X,lt){if(!Q.kernings||0===Q.kernings.length)return 0;for(var rt=Q.kernings,pt=0;pt<rt.length;pt++){var vt=rt[pt];if(vt.first===X&&vt.second===lt)return vt.amount}return 0}function G(Q,X,lt){for(var rt=lt=lt||0;rt<Q.length;rt++)if(Q[rt].id===X)return rt;return-1}ot.exports=function(Q){return new C(Q)},C.prototype.update=function(Q){if(Q=$({measure:this._measure},Q),this._opt=Q,this._opt.tabSize=O(this._opt.tabSize,4),!Q.font)throw new Error("must provide a valid bitmap font");var X=this.glyphs,lt=Q.text||"",rt=Q.font;this._setupSpaceGlyphs(rt);var pt=U.lines(lt,Q),vt=Q.width||0;X.length=0;var en,bt=pt.reduce(function(en,nn){return Math.max(en,nn.width,vt)},0),ft=0,wt=0,et=O(Q.lineHeight,rt.common.lineHeight),xt=rt.common.base,Rt=et-xt,Yt=Q.letterSpacing||0,ve=et*pt.length-Rt,xe="center"===(en=this._opt.align)?1:"right"===en?2:0;wt-=ve,this._width=bt,this._height=ve,this._descender=et-xt,this._baseline=xt,this._xHeight=function(en){for(var nn=0;nn<N.length;nn++){var vn=N[nn].charCodeAt(0),_n=G(en.chars,vn);if(_n>=0)return en.chars[_n].height}return 0}(rt),this._capHeight=function(en){for(var nn=0;nn<E.length;nn++){var vn=E[nn].charCodeAt(0),_n=G(en.chars,vn);if(_n>=0)return en.chars[_n].height}return 0}(rt),this._lineHeight=et,this._ascender=et-Rt-this._xHeight;var Ge=this;pt.forEach(function(en,nn){for(var vn,nr=en.end,hr=en.width,Cs=en.start;Cs<nr;Cs++){var Ti=lt.charCodeAt(Cs),Is=Ge.getGlyph(rt,Ti);if(Is){vn&&(ft+=F(rt,vn.id,Is.id));var As=ft;1===xe?As+=(bt-hr)/2:2===xe&&(As+=bt-hr),X.push({position:[As,wt],data:Is,index:Cs,line:nn}),ft+=Is.xadvance+Yt,vn=Is}}wt+=et,ft=0}),this._linesTotal=pt.length},C.prototype._setupSpaceGlyphs=function(Q){if(this._fallbackSpaceGlyph=null,this._fallbackTabGlyph=null,Q.chars&&0!==Q.chars.length){var X=k(Q,B)||function(rt){for(var pt=0;pt<_.length;pt++){var vt=_[pt].charCodeAt(0),bt=G(rt.chars,vt);if(bt>=0)return rt.chars[bt]}return 0}(Q)||Q.chars[0],lt=this._opt.tabSize*X.xadvance;this._fallbackSpaceGlyph=X,this._fallbackTabGlyph=$(X,{x:0,y:0,xadvance:lt,id:D,xoffset:0,yoffset:0,width:0,height:0})}},C.prototype.getGlyph=function(Q,X){return k(Q,X)||(X===D?this._fallbackTabGlyph:X===B?this._fallbackSpaceGlyph:null)},C.prototype.computeMetrics=function(Q,X,lt,rt){var pt,vt=this._opt.letterSpacing||0,bt=this._opt.font,ft=0,wt=0,et=0;if(!bt.chars||0===bt.chars.length)return{start:X,end:X,width:0};lt=Math.min(Q.length,lt);for(var xt=X;xt<lt;xt++){var Rt,Yt=Q.charCodeAt(xt);if(Rt=this.getGlyph(bt,Yt)){var ve=(ft+=pt?F(bt,pt.id,Rt.id):0)+Rt.xadvance+vt,xe=ft+Rt.width;if(xe>=rt||ve>=rt)break;ft=ve,wt=xe,pt=Rt}et++}return pt&&(wt+=pt.xoffset),{start:X,end:X+et,width:wt}},["width","height","descender","ascender","xHeight","baseline","capHeight","lineHeight"].forEach(function(Q){Object.defineProperty(C.prototype,Q,{get:M(Q),configurable:!0})})},5751:(ot,ht,I)=>{var U=I(9922).hp,$=I(3558),O=function(){},N=I(1476),_=I(7034),E=I(7480),D=I(573),B=I(4597),C=self.XMLHttpRequest&&"withCredentials"in new XMLHttpRequest;ot.exports=function(M,k){k="function"==typeof k?k:O,"string"==typeof M?M={uri:M}:M||(M={}),M.binary&&(M=function(F){if(C)return B(F,{responseType:"arraybuffer"});if(void 0===self.XMLHttpRequest)throw new Error("your browser does not support XHR loading");var G=new self.XMLHttpRequest;return G.overrideMimeType("text/plain; charset=x-user-defined"),B({xhr:G},F)}(M)),$(M,function(F,G,Q){if(F)return k(F);if(!/^2/.test(G.statusCode))return k(new Error("http status code: "+G.statusCode));if(!Q)return k(new Error("no body result"));var lt,rt=!1;if("[object ArrayBuffer]"===Object.prototype.toString.call(Q)){var pt=new Uint8Array(Q);Q=U.from(pt,"binary")}D(Q)&&(rt=!0,"string"==typeof Q&&(Q=U.from(Q,"binary"))),rt||(U.isBuffer(Q)&&(Q=Q.toString(M.encoding)),Q=Q.trim());try{var vt=G.headers["content-type"];lt=rt?E(Q):/json/.test(vt)||"{"===Q.charAt(0)?JSON.parse(Q):/xml/.test(vt)||"<"===Q.charAt(0)?_(Q):N(Q)}catch(bt){k(new Error("error parsing font "+bt.message)),k=O}k(null,lt)})}},573:(ot,ht,I)=>{var U=I(9922).hp,$=I(911),O=U.from([66,77,70,3]);ot.exports=function(N){return"string"==typeof N?"BMF"===N.substring(0,3):N.length>4&&$(N.slice(0,4),O)}},1476:ot=>{function ht(U,$){if(!(U=U.replace(/\t+/g," ").trim()))return null;var O=U.indexOf(" ");if(-1===O)throw new Error("no named row at line "+$);var N=U.substring(0,O);U=(U=(U=(U=U.substring(O+1)).replace(/letter=[\'\"]\S+[\'\"]/gi,"")).split("=")).map(function(C){return C.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g)});for(var _=[],E=0;E<U.length;E++){var D=U[E];0===E?_.push({key:D[0],data:""}):E===U.length-1?_[_.length-1].data=I(D[0]):(_[_.length-1].data=I(D[0]),_.push({key:D[1],data:""}))}var B={key:N,data:{}};return _.forEach(function(C){B.data[C.key]=C.data}),B}function I(U){return U&&0!==U.length?0===U.indexOf('"')||0===U.indexOf("'")?U.substring(1,U.length-1):-1!==U.indexOf(",")?U.split(",").map(function(O){return parseInt(O,10)}):parseInt(U,10):""}ot.exports=function(U){if(!U)throw new Error("no data provided");var $={pages:[],chars:[],kernings:[]},O=(U=U.toString().trim()).split(/\r\n?|\n/g);if(0===O.length)throw new Error("no data in BMFont file");for(var N=0;N<O.length;N++){var _=ht(O[N],N);if(_)if("page"===_.key){if("number"!=typeof _.data.id)throw new Error("malformed file at line "+N+" -- needs page id=N");if("string"!=typeof _.data.file)throw new Error("malformed file at line "+N+' -- needs page file="path"');$.pages[_.data.id]=_.data.file}else"chars"===_.key||"kernings"===_.key||("char"===_.key?$.chars.push(_.data):"kerning"===_.key?$.kernings.push(_.data):$[_.key]=_.data)}return $}},7480:ot=>{var ht=[66,77,70];function I($,O,N){if(N>O.length-1)return 0;var D,B,C,_=O.readUInt8(N++),E=O.readInt32LE(N);switch(N+=4,_){case 1:$.info=function(D,B){var C={};C.size=D.readInt16LE(B);var M=D.readUInt8(B+2);return C.smooth=M>>7&1,C.unicode=M>>6&1,C.italic=M>>5&1,C.bold=M>>4&1,M>>3&1&&(C.fixedHeight=1),C.charset=D.readUInt8(B+3)||"",C.stretchH=D.readUInt16LE(B+4),C.aa=D.readUInt8(B+6),C.padding=[D.readInt8(B+7),D.readInt8(B+8),D.readInt8(B+9),D.readInt8(B+10)],C.spacing=[D.readInt8(B+11),D.readInt8(B+12)],C.outline=D.readUInt8(B+13),C.face=U(D,B+14).toString("utf8"),C}(O,N);break;case 2:$.common=((C={}).lineHeight=(D=O).readUInt16LE(B=N),C.base=D.readUInt16LE(B+2),C.scaleW=D.readUInt16LE(B+4),C.scaleH=D.readUInt16LE(B+6),C.pages=D.readUInt16LE(B+8),D.readUInt8(B+10),C.packed=0,C.alphaChnl=D.readUInt8(B+11),C.redChnl=D.readUInt8(B+12),C.greenChnl=D.readUInt8(B+13),C.blueChnl=D.readUInt8(B+14),C);break;case 3:$.pages=function(D,B,C){for(var M=[],k=U(D,B),F=k.length+1,G=C/F,Q=0;Q<G;Q++)M[Q]=D.slice(B,B+k.length).toString("utf8"),B+=F;return M}(O,N,E);break;case 4:$.chars=function(D,B,C){for(var M=[],k=C/20,F=0;F<k;F++){var G={},Q=20*F;G.id=D.readUInt32LE(B+0+Q),G.x=D.readUInt16LE(B+4+Q),G.y=D.readUInt16LE(B+6+Q),G.width=D.readUInt16LE(B+8+Q),G.height=D.readUInt16LE(B+10+Q),G.xoffset=D.readInt16LE(B+12+Q),G.yoffset=D.readInt16LE(B+14+Q),G.xadvance=D.readInt16LE(B+16+Q),G.page=D.readUInt8(B+18+Q),G.chnl=D.readUInt8(B+19+Q),M[F]=G}return M}(O,N,E);break;case 5:$.kernings=function(D,B,C){for(var M=[],k=C/10,F=0;F<k;F++){var G={},Q=10*F;G.first=D.readUInt32LE(B+0+Q),G.second=D.readUInt32LE(B+4+Q),G.amount=D.readInt16LE(B+8+Q),M[F]=G}return M}(O,N,E)}return 5+E}function U($,O){for(var N=O;N<$.length&&0!==$[N];N++);return $.slice(O,N)}ot.exports=function($){if($.length<6)throw new Error("invalid buffer length for BMFont");if(!ht.every(function(D,B){return $.readUInt8(B)===D}))throw new Error("BMFont missing BMF byte header");var N=3;if($.readUInt8(N++)>3)throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");for(var _={kernings:[],chars:[]},E=0;E<5;E++)N+=I(_,$,N);return _}},7034:(ot,ht,I)=>{var U=I(7829),$=I(1896),O={scaleh:"scaleH",scalew:"scaleW",stretchh:"stretchH",lineheight:"lineHeight",alphachnl:"alphaChnl",redchnl:"redChnl",greenchnl:"greenChnl",bluechnl:"blueChnl"};function N(_){return function(D){for(var B=[],C=0;C<D.attributes.length;C++)B.push(D.attributes[C]);return B}(_).reduce(function(D,B){var C;return D[(C=B.nodeName,O[C.toLowerCase()]||C)]=B.nodeValue,D},{})}ot.exports=function(_){_=_.toString();var E=$(_),D={pages:[],chars:[],kernings:[]};["info","common"].forEach(function(Q){var X=E.getElementsByTagName(Q)[0];X&&(D[Q]=U(N(X)))});var B=E.getElementsByTagName("pages")[0];if(!B)throw new Error("malformed file -- no <pages> element");for(var C=B.getElementsByTagName("page"),M=0;M<C.length;M++){var k=C[M],F=parseInt(k.getAttribute("id"),10),G=k.getAttribute("file");if(isNaN(F))throw new Error('malformed file -- page "id" attribute is NaN');if(!G)throw new Error('malformed file -- needs page "file" attribute');D.pages[parseInt(F,10)]=G}return["chars","kernings"].forEach(function(Q){var X=E.getElementsByTagName(Q)[0];if(X)for(var lt=Q.substring(0,Q.length-1),rt=X.getElementsByTagName(lt),pt=0;pt<rt.length;pt++)D[Q].push(U(N(rt[pt])))}),D}},7829:ot=>{var ht="chasrset";ot.exports=function(I){for(var U in ht in I&&(I.charset=I[ht],delete I[ht]),I)"face"!==U&&"charset"!==U&&(I[U]="padding"===U||"spacing"===U?I[U].split(",").map(function($){return parseInt($,10)}):parseInt(I[U],10));return I}},3216:ot=>{var ht=function(I){return I.replace(/^\s+|\s+$/g,"")};ot.exports=function(I){if(!I)return{};for(var $={},O=ht(I).split("\n"),N=0;N<O.length;N++){var _=O[N],E=_.indexOf(":"),D=ht(_.slice(0,E)).toLowerCase(),B=ht(_.slice(E+1));void 0===$[D]?$[D]=B:"[object Array]"===Object.prototype.toString.call($[D])?$[D].push(B):$[D]=[$[D],B]}return $}},9035:(ot,ht,I)=>{var U=I(8480),$=I(8167),O=I(2225),N=[0,2,3],_=[2,1,3];ot.exports=function(E,D){E&&($(E)||O(E))||(D=E||{},E=null);for(var B="string"==typeof(D="number"==typeof D?{count:D}:D||{}).type?D.type:"uint16",M=D.start||0,k=!1!==D.clockwise?N:_,F=k[0],G=k[1],Q=k[2],X=6*("number"==typeof D.count?D.count:1),lt=E||new(U(B))(X),rt=0,pt=0;rt<X;rt+=6,pt+=4){var vt=rt+M;lt[vt+0]=pt+0,lt[vt+1]=pt+1,lt[vt+2]=pt+2,lt[vt+3]=pt+F,lt[vt+4]=pt+G,lt[vt+5]=pt+Q}return lt}},4635:(ot,ht,I)=>{"use strict";I.d(ht,{A:()=>ki});var U={update:null,begin:null,loopBegin:null,changeBegin:null,change:null,changeComplete:null,loopComplete:null,complete:null,loop:1,direction:"normal",autoplay:!0,timelineOffset:0},$={duration:1e3,delay:0,endDelay:0,easing:"easeOutElastic(1, .5)",round:0},O=["translateX","translateY","translateZ","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ","skew","skewX","skewY","perspective"],N={CSS:{},springs:{}};function _(Ut,jt,be){return Math.min(Math.max(Ut,jt),be)}function E(Ut,jt){return Ut.indexOf(jt)>-1}function D(Ut,jt){return Ut.apply(null,jt)}var B=/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,C=/^rgb/,M=/^hsl/,k={arr:function(Ut){return Array.isArray(Ut)},obj:function(Ut){return E(Object.prototype.toString.call(Ut),"Object")},pth:function(Ut){return k.obj(Ut)&&Ut.hasOwnProperty("totalLength")},svg:function(Ut){return Ut instanceof SVGElement},inp:function(Ut){return Ut instanceof HTMLInputElement},dom:function(Ut){return Ut.nodeType||k.svg(Ut)},str:function(Ut){return"string"==typeof Ut},fnc:function(Ut){return"function"==typeof Ut},und:function(Ut){return void 0===Ut},hex:function(Ut){return B.test(Ut)},rgb:function(Ut){return C.test(Ut)},hsl:function(Ut){return M.test(Ut)},col:function(Ut){return k.hex(Ut)||k.rgb(Ut)||k.hsl(Ut)},key:function(Ut){return!U.hasOwnProperty(Ut)&&!$.hasOwnProperty(Ut)&&"targets"!==Ut&&"keyframes"!==Ut}},F=/\(([^)]+)\)/;function G(Ut){var jt=F.exec(Ut);return jt?jt[1].split(",").map(function(be){return parseFloat(be)}):[]}function Q(Ut,jt){var be=G(Ut),Ze=_(k.und(be[0])?1:be[0],.1,100),tn=_(k.und(be[1])?100:be[1],.1,100),ke=_(k.und(be[2])?10:be[2],.1,100),pn=_(k.und(be[3])?0:be[3],.1,100),cn=Math.sqrt(tn/Ze),bn=ke/(2*Math.sqrt(tn*Ze)),qe=bn<1?cn*Math.sqrt(1-bn*bn):0,Sn=bn<1?(bn*cn-pn)/qe:-pn+cn;function Mr(jn){var Kn=jt?jt*jn/1e3:jn;return Kn=bn<1?Math.exp(-Kn*bn*cn)*(1*Math.cos(qe*Kn)+Sn*Math.sin(qe*Kn)):(1+Sn*Kn)*Math.exp(-Kn*cn),0===jn||1===jn?jn:1-Kn}return jt?Mr:function(){var jn=N.springs[Ut];if(jn)return jn;for(var Kn=.16666666666666666,gn=0,vr=0;;)if(1===Mr(gn+=Kn)){if(++vr>=16)break}else vr=0;var Tr=gn*Kn*1e3;return N.springs[Ut]=Tr,Tr}}function X(Ut,jt){void 0===Ut&&(Ut=1),void 0===jt&&(jt=.5);var be=_(Ut,1,10),Ze=_(jt,.1,2);return function(tn){return 0===tn||1===tn?tn:-be*Math.pow(2,10*(tn-1))*Math.sin((tn-1-Ze/(2*Math.PI)*Math.asin(1/be))*(2*Math.PI)/Ze)}}function lt(Ut){return void 0===Ut&&(Ut=10),function(jt){return Math.round(jt*Ut)*(1/Ut)}}var rt=function(){function jt(pn,cn){return 1-3*cn+3*pn}function be(pn,cn){return 3*cn-6*pn}function Ze(pn){return 3*pn}function tn(pn,cn,bn){return((jt(cn,bn)*pn+be(cn,bn))*pn+Ze(cn))*pn}function ke(pn,cn,bn){return 3*jt(cn,bn)*pn*pn+2*be(cn,bn)*pn+Ze(cn)}return function(pn,cn,bn,qe){if(0<=pn&&pn<=1&&0<=bn&&bn<=1){var Sn=new Float32Array(11);if(pn!==cn||bn!==qe)for(var Mr=0;Mr<11;++Mr)Sn[Mr]=tn(.1*Mr,pn,bn);return function(jn){return pn===cn&&bn===qe||0===jn||1===jn?jn:tn(function(Kn){for(var gn=0,vr=1;10!==vr&&Sn[vr]<=Kn;++vr)gn+=.1;--vr;var Tr=gn+(Kn-Sn[vr])/(Sn[vr+1]-Sn[vr])*.1,rr=ke(Tr,pn,bn);return rr>=.001?function(wn,br,xi,cr){for(var ai=0;ai<4;++ai){var ci=ke(br,xi,cr);if(0===ci)return br;br-=(tn(br,xi,cr)-wn)/ci}return br}(Kn,Tr,pn,bn):0===rr?Tr:function(wn,br,xi,cr,ai){var ci,Ri,jr=0;do{(ci=tn(Ri=br+(xi-br)/2,cr,ai)-wn)>0?xi=Ri:br=Ri}while(Math.abs(ci)>1e-7&&++jr<10);return Ri}(Kn,gn,gn+.1,pn,bn)}(jn),cn,qe)}}}}(),pt=function(){var Ut=["Quad","Cubic","Quart","Quint","Sine","Expo","Circ","Back","Elastic"],jt={In:[[.55,.085,.68,.53],[.55,.055,.675,.19],[.895,.03,.685,.22],[.755,.05,.855,.06],[.47,0,.745,.715],[.95,.05,.795,.035],[.6,.04,.98,.335],[.6,-.28,.735,.045],X],Out:[[.25,.46,.45,.94],[.215,.61,.355,1],[.165,.84,.44,1],[.23,1,.32,1],[.39,.575,.565,1],[.19,1,.22,1],[.075,.82,.165,1],[.175,.885,.32,1.275],function(pn,cn){return function(bn){return 1-X(pn,cn)(1-bn)}}],InOut:[[.455,.03,.515,.955],[.645,.045,.355,1],[.77,0,.175,1],[.86,0,.07,1],[.445,.05,.55,.95],[1,0,0,1],[.785,.135,.15,.86],[.68,-.55,.265,1.55],function(pn,cn){return function(bn){return bn<.5?X(pn,cn)(2*bn)/2:1-X(pn,cn)(-2*bn+2)/2}}]},be={linear:[.25,.25,.75,.75]};for(var Ze in jt)for(var tn=0,ke=jt[Ze].length;tn<ke;tn++)be["ease"+Ze+Ut[tn]]=jt[Ze][tn];return be}();function vt(Ut,jt){if(k.fnc(Ut))return Ut;var be=Ut.split("(")[0],Ze=pt[be],tn=G(Ut);switch(be){case"spring":return Q(Ut,jt);case"cubicBezier":return D(rt,tn);case"steps":return D(lt,tn);default:return k.fnc(Ze)?D(Ze,tn):D(rt,Ze)}}function bt(Ut){try{return document.querySelectorAll(Ut)}catch{return}}var ft=[];function wt(Ut,jt){for(var be=ft,Ze=Ut.length,tn=arguments.length>=2?arguments[1]:void 0,ke=0;ke<Ze;ke++)if(ke in Ut){var pn=Ut[ke];jt.call(tn,pn,ke,Ut)&&be.push(pn)}return(ft=Ut).length=0,be}function et(Ut,jt){jt||(jt=[]);for(var be=0,Ze=Ut.length;be<Ze;be++){var tn=Ut[be];Array.isArray(tn)?et(tn,jt):jt.push(tn)}return jt}function xt(Ut){return k.arr(Ut)?Ut:(k.str(Ut)&&(Ut=bt(Ut)||Ut),Ut instanceof NodeList||Ut instanceof HTMLCollection?[].slice.call(Ut):[Ut])}function Rt(Ut,jt){return Ut.some(function(be){return be===jt})}function Yt(Ut){var jt={};for(var be in Ut)jt[be]=Ut[be];return jt}function ve(Ut,jt){var be=Yt(Ut);for(var Ze in Ut)be[Ze]=jt.hasOwnProperty(Ze)?jt[Ze]:Ut[Ze];return be}function xe(Ut,jt){var be=Yt(Ut);for(var Ze in jt)be[Ze]=k.und(Ut[Ze])?jt[Ze]:Ut[Ze];return be}var Ge=/rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g,en=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,nn=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,vn=/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g,_n=/hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g,nr=/([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/;function hr(Ut){var jt=nr.exec(Ut);if(jt)return jt[2]}function Cs(Ut,jt){return k.fnc(Ut)?Ut(jt.target,jt.id,jt.total):Ut}function Ti(Ut,jt){return Ut.getAttribute(jt)}function Is(Ut,jt,be){if(Rt([be,"deg","rad","turn"],hr(jt)))return jt;var Ze=N.CSS[jt+be];if(!k.und(Ze))return Ze;var tn=document.createElement(Ut.tagName),ke=Ut.parentNode&&Ut.parentNode!==document?Ut.parentNode:document.body;ke.appendChild(tn),tn.style.position="absolute",tn.style.width=100+be;var pn=100/tn.offsetWidth;ke.removeChild(tn);var cn=pn*parseFloat(jt);return N.CSS[jt+be]=cn,cn}function As(Ut,jt,be){if(jt in Ut.style){var Ze=jt.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),tn=Ut.style[jt]||getComputedStyle(Ut).getPropertyValue(Ze)||"0";return be?Is(Ut,tn,be):tn}}function ua(Ut,jt){return k.dom(Ut)&&!k.inp(Ut)&&(Ti(Ut,jt)||k.svg(Ut)&&Ut[jt])?"attribute":k.dom(Ut)&&Rt(O,jt)?"transform":k.dom(Ut)&&"transform"!==jt&&As(Ut,jt)?"css":null!=Ut[jt]?"object":void 0}var Oa=/(\w+)\(([^)]*)\)/g;function ha(Ut){if(k.dom(Ut)){for(var jt,be=Ut.style.transform||"",Ze=new Map;jt=Oa.exec(be);)Ze.set(jt[1],jt[2]);return Ze}}function js(Ut,jt,be,Ze){switch(ua(Ut,jt)){case"transform":return tn=Ut,pn=Ze,cn=be,bn=E(ke=jt,"scale")?1:0+(E(Sn=ke,"translate")||"perspective"===Sn?"px":E(Sn,"rotate")||E(Sn,"skew")?"deg":void 0),qe=ha(tn).get(ke)||bn,pn&&(pn.transforms.list.set(ke,qe),pn.transforms.last=ke),cn?Is(tn,qe,cn):qe;case"css":return As(Ut,jt,be);case"attribute":return Ti(Ut,jt);default:return Ut[jt]||0}var tn,ke,pn,cn,Sn,bn,qe}var Xa=/^(\*=|\+=|-=)/;function Ya(Ut,jt){var be=Xa.exec(Ut);if(!be)return Ut;var Ze=hr(Ut)||0,tn=parseFloat(jt),ke=parseFloat(Ut.replace(be[0],""));switch(be[0][0]){case"+":return tn+ke+Ze;case"-":return tn-ke+Ze;case"*":return tn*ke+Ze}}var _i=/\s/g;function ys(Ut,jt){if(k.col(Ut))return k.rgb(tn=Ut)?(pn=Ge.exec(ke=tn))?"rgba("+pn[1]+",1)":ke:k.hex(tn)?(bn=tn.replace(en,function(Sn,Mr,jn,Kn){return Mr+Mr+jn+jn+Kn+Kn}),qe=nn.exec(bn),"rgba("+parseInt(qe[1],16)+","+parseInt(qe[2],16)+","+parseInt(qe[3],16)+",1)"):k.hsl(tn)?function(cn){var bn,qe,Sn,Mr=vn.exec(cn)||_n.exec(cn),jn=parseInt(Mr[1],10)/360,Kn=parseInt(Mr[2],10)/100,gn=parseInt(Mr[3],10)/100,vr=Mr[4]||1;function Tr(br,xi,cr){return cr<0&&(cr+=1),cr>1&&(cr-=1),cr<.16666666666666666?br+6*(xi-br)*cr:cr<.5?xi:cr<.6666666666666666?br+(xi-br)*(.6666666666666666-cr)*6:br}if(0==Kn)bn=qe=Sn=gn;else{var rr=gn<.5?gn*(1+Kn):gn+Kn-gn*Kn,wn=2*gn-rr;bn=Tr(wn,rr,jn+.3333333333333333),qe=Tr(wn,rr,jn),Sn=Tr(wn,rr,jn-.3333333333333333)}return"rgba("+255*bn+","+255*qe+","+255*Sn+","+vr+")"}(tn):void 0;var tn,bn,qe,ke,pn,be=hr(Ut),Ze=be?Ut.substr(0,Ut.length-be.length):Ut;return jt&&!_i.test(Ut)?Ze+jt:Ze}function To(Ut,jt){return Math.sqrt(Math.pow(jt.x-Ut.x,2)+Math.pow(jt.y-Ut.y,2))}function qs(Ut){for(var jt,be=Ut.points,Ze=0,tn=0;tn<be.numberOfItems;tn++){var ke=be.getItem(tn);tn>0&&(Ze+=To(jt,ke)),jt=ke}return Ze}function se(Ut){if(Ut.getTotalLength)return Ut.getTotalLength();switch(Ut.tagName.toLowerCase()){case"circle":return 2*Math.PI*Ti(Ut,"r");case"rect":return 2*Ti(jt=Ut,"width")+2*Ti(jt,"height");case"line":return function(jt){return To({x:Ti(jt,"x1"),y:Ti(jt,"y1")},{x:Ti(jt,"x2"),y:Ti(jt,"y2")})}(Ut);case"polyline":return qs(Ut);case"polygon":return function(jt){var be=jt.points;return qs(jt)+To(be.getItem(be.numberOfItems-1),be.getItem(0))}(Ut)}var jt}function Ct(Ut,jt){var be=jt||{},Ze=be.el||function(qe){for(var Sn=qe.parentNode;k.svg(Sn)&&k.svg((Sn=Sn.parentNode).parentNode););return Sn}(Ut),tn=Ze.getBoundingClientRect(),ke=Ti(Ze,"viewBox"),pn=tn.width,cn=tn.height,bn=be.viewBox||(ke?ke.split(" "):[0,0,pn,cn]);return{el:Ze,viewBox:bn,x:bn[0]/1,y:bn[1]/1,w:pn/bn[2],h:cn/bn[3]}}function q(Ut,jt){function be(cn){return void 0===cn&&(cn=0),Ut.el.getPointAtLength(jt+cn>=1?jt+cn:0)}var Ze=Ct(Ut.el,Ut.svg),tn=be(),ke=be(-1),pn=be(1);switch(Ut.property){case"x":return(tn.x-Ze.x)*Ze.w;case"y":return(tn.y-Ze.y)*Ze.h;case"angle":return 180*Math.atan2(pn.y-ke.y,pn.x-ke.x)/Math.PI}}var st=/-?\d*\.?\d+/g;function ut(Ut,jt){var be=ys(k.pth(Ut)?Ut.totalLength:Ut,jt)+"";return{original:be,numbers:be.match(st)?be.match(st).map(Number):[0],strings:k.str(Ut)||jt?be.split(st):[]}}function Z(Ut){return wt(Ut?et(k.arr(Ut)?Ut.map(xt):xt(Ut)):[],function(jt,be,Ze){return Ze.indexOf(jt)===be})}function _t(Ut){var jt=Z(Ut);return jt.map(function(be,Ze){return{target:be,id:Ze,total:jt.length,transforms:{list:ha(be)}}})}var Ht=/^spring/;function Ae(Ut,jt){var be=Yt(jt);if(Ht.test(be.easing)&&(be.duration=Q(be.easing)),k.arr(Ut)){var Ze=Ut.length;2!==Ze||k.obj(Ut[0])?k.fnc(jt.duration)||(be.duration=jt.duration/Ze):Ut={value:Ut}}var tn=k.arr(Ut)?Ut:[Ut];return tn.map(function(ke,pn){var cn=k.obj(ke)&&!k.pth(ke)?ke:{value:ke};return k.und(cn.delay)&&(cn.delay=pn?0:jt.delay),k.und(cn.endDelay)&&(cn.endDelay=pn===tn.length-1?jt.endDelay:0),cn}).map(function(ke){return xe(ke,be)})}var Wt={css:function(Ut,jt,be){return Ut.style[jt]=be},attribute:function(Ut,jt,be){return Ut.setAttribute(jt,be)},object:function(Ut,jt,be){return Ut[jt]=be},transform:function(Ut,jt,be,Ze,tn){if(Ze.list.set(jt,be),jt===Ze.last||tn){var ke="";Ze.list.forEach(function(pn,cn){ke+=cn+"("+pn+") "}),Ut.style.transform=ke}}};function _e(Ut,jt){for(var be=_t(Ut),Ze=0,tn=be.length;Ze<tn;Ze++){var ke=be[Ze];for(var pn in jt){var cn=Cs(jt[pn],ke),bn=ke.target,qe=hr(cn),Sn=js(bn,pn,qe,ke),Mr=Ya(ys(cn,qe||hr(Sn)),Sn),jn=ua(bn,pn);Wt[jn](bn,pn,Mr,ke.transforms,!0)}}}function hn(Ut,jt){var be=Ut.length,Ze=function(ke){return ke.timelineOffset?ke.timelineOffset:0},tn={};return tn.duration=be?Math.max.apply(Math,Ut.map(function(ke){return Ze(ke)+ke.duration})):jt.duration,tn.delay=be?Math.min.apply(Math,Ut.map(function(ke){return Ze(ke)+ke.delay})):jt.delay,tn.endDelay=be?tn.duration-Math.max.apply(Math,Ut.map(function(ke){return Ze(ke)+ke.duration-ke.endDelay})):jt.endDelay,tn}var kn,Hr=0,Wr=[],ii=[],mo=function(){function Ut(){kn=requestAnimationFrame(jt)}function jt(be){var Ze=Wr.length;if(Ze){for(var tn=0;tn<Ze;){var ke=Wr[tn];if(ke.paused){var pn=Wr.indexOf(ke);pn>-1&&(Wr.splice(pn,1),Ze=Wr.length)}else ke.tick(be);tn++}Ut()}else kn=cancelAnimationFrame(kn)}return Ut}();function si(Ut){void 0===Ut&&(Ut={});var jt,be=0,Ze=0,tn=0,ke=0,pn=null;function cn(){return window.Promise&&new Promise(function(rr){return pn=rr})}var rr,wn,br,xi,cr,ai,ci,Ri,bn=cn(),qe=(wn=ve(U,rr=Ut),xi=function(jr,de){var go=[],_o=de.keyframes;for(var Bi in _o&&(de=xe(function(Ta){for(var da=wt(et(Ta.map(function(Ms){return Object.keys(Ms)})),function(Ms){return k.key(Ms)}).reduce(function(Ms,_a){return Ms.indexOf(_a)<0&&Ms.push(_a),Ms},[]),pa={},Ss=function(Ms){var _a=da[Ms];pa[_a]=Ta.map(function(Pa){var Ys={};for(var Ks in Pa)k.key(Ks)?Ks==_a&&(Ys.value=Pa[Ks]):Ys[Ks]=Pa[Ks];return Ys})},Xs=0;Xs<da.length;Xs++)Ss(Xs);return pa}(_o),de)),de)k.key(Bi)&&go.push({name:Bi,tweens:Ae(de[Bi],jr)});return go}(br=ve($,rr),rr),ai=function We(Ut,jt){return wt(et(Ut.map(function(be){return jt.map(function(Ze){return function(tn,ke){var qe,Sn,Mr,pn=ua(tn.target,ke.name);if(pn){var cn=(Sn=tn,(qe=ke).tweens.map(function(jn){var Kn=function(ai,ci){var Ri={};for(var jr in ai){var de=Cs(ai[jr],ci);k.arr(de)&&1===(de=de.map(function(go){return Cs(go,ci)})).length&&(de=de[0]),Ri[jr]=de}return Ri.duration=parseFloat(Ri.duration),Ri.delay=parseFloat(Ri.delay),Ri}(jn,Sn),gn=Kn.value,vr=k.arr(gn)?gn[1]:gn,Tr=hr(vr),rr=js(Sn.target,qe.name,Tr,Sn),wn=Mr?Mr.to.original:rr,br=k.arr(gn)?gn[0]:wn,xi=hr(br)||hr(rr),cr=Tr||xi;return k.und(vr)&&(vr=wn),Kn.from=ut(br,cr),Kn.to=ut(Ya(vr,br),cr),Kn.start=Mr?Mr.end:0,Kn.end=Kn.start+Kn.delay+Kn.duration+Kn.endDelay,Kn.easing=vt(Kn.easing,Kn.duration),Kn.isPath=k.pth(gn),Kn.isColor=k.col(Kn.from.original),Kn.isColor&&(Kn.round=1),Mr=Kn,Kn})),bn=cn[cn.length-1];return{type:pn,property:ke.name,animatable:tn,tweens:cn,duration:bn.end,delay:cn[0].delay,endDelay:bn.endDelay}}}(be,Ze)})})),function(be){return!k.und(be)})}(cr=_t(rr.targets),xi),ci=hn(ai,br),Ri=Hr,Hr++,xe(wn,{id:Ri,children:[],animatables:cr,animations:ai,duration:ci.duration,delay:ci.delay,endDelay:ci.endDelay}));function Sn(){qe.reversed=!qe.reversed;for(var rr=0,wn=jt.length;rr<wn;rr++)jt[rr].reversed=qe.reversed}function Mr(rr){return qe.reversed?qe.duration-rr:rr}function jn(){be=0,Ze=Mr(qe.currentTime)*(1/si.speed)}function Kn(rr,wn){wn&&wn.seek(rr-wn.timelineOffset)}function gn(rr){for(var wn=0,br=qe.animations,xi=br.length;wn<xi;){var cr=br[wn],ai=cr.animatable,ci=cr.tweens,Ri=ci.length-1,jr=ci[Ri];Ri&&(jr=wt(ci,function(oi){return rr<oi.end})[0]||jr);for(var de=_(rr-jr.start-jr.delay,0,jr.duration)/jr.duration,go=isNaN(de)?1:jr.easing(de),_o=jr.to.strings,Bi=jr.round,Ta=[],da=jr.to.numbers.length,pa=void 0,Ss=0;Ss<da;Ss++){var Xs=void 0,Ms=jr.to.numbers[Ss],_a=jr.from.numbers[Ss]||0;Xs=jr.isPath?q(jr.value,go*Ms):_a+go*(Ms-_a),Bi&&(jr.isColor&&Ss>2||(Xs=Math.round(Xs*Bi)/Bi)),Ta.push(Xs)}var Pa=_o.length;if(Pa){pa=_o[0];for(var Ys=0;Ys<Pa;Ys++){var Ks=_o[Ys+1],Ka=Ta[Ys];isNaN(Ka)||(pa+=Ks?Ka+Ks:Ka+" ")}}else pa=Ta[0];Wt[cr.type](ai.target,cr.property,pa,ai.transforms),cr.currentValue=pa,wn++}}function vr(rr){qe[rr]&&!qe.passThrough&&qe[rr](qe)}function Tr(rr){var wn=qe.duration,br=qe.delay,xi=wn-qe.endDelay,cr=Mr(rr);qe.progress=_(cr/wn*100,0,100),qe.reversePlayback=cr<qe.currentTime,jt&&function(ai){if(qe.reversePlayback)for(var ci=ke;ci--;)Kn(ai,jt[ci]);else for(var Ri=0;Ri<ke;Ri++)Kn(ai,jt[Ri])}(cr),!qe.began&&qe.currentTime>0&&(qe.began=!0,vr("begin"),vr("loopBegin")),cr<=br&&0!==qe.currentTime&&gn(0),(cr>=xi&&qe.currentTime!==wn||!wn)&&gn(wn),cr>br&&cr<xi?(qe.changeBegan||(qe.changeBegan=!0,qe.changeCompleted=!1,vr("changeBegin")),vr("change"),gn(cr)):qe.changeBegan&&(qe.changeCompleted=!0,qe.changeBegan=!1,vr("changeComplete")),qe.currentTime=_(cr,0,wn),qe.began&&vr("update"),rr>=wn&&(Ze=0,qe.remaining&&!0!==qe.remaining&&qe.remaining--,qe.remaining?(be=tn,vr("loopComplete"),vr("loopBegin"),"alternate"===qe.direction&&Sn()):(qe.paused=!0,qe.completed||(qe.completed=!0,vr("loopComplete"),vr("complete"),"Promise"in window&&(pn(),bn=cn()))))}return qe.reset=function(){var rr=qe.direction;qe.passThrough=!1,qe.currentTime=0,qe.progress=0,qe.paused=!0,qe.began=!1,qe.changeBegan=!1,qe.completed=!1,qe.changeCompleted=!1,qe.reversePlayback=!1,qe.reversed="reverse"===rr,qe.remaining=qe.loop;for(var wn=ke=(jt=qe.children).length;wn--;)qe.children[wn].reset();(qe.reversed&&!0!==qe.loop||"alternate"===rr&&1===qe.loop)&&qe.remaining++,gn(0)},qe.set=function(rr,wn){return _e(rr,wn),qe},qe.tick=function(rr){tn=rr,be||(be=tn),Tr((tn+(Ze-be))*si.speed)},qe.seek=function(rr){Tr(Mr(rr))},qe.pause=function(){qe.paused=!0,jn()},qe.play=function(){qe.paused&&(qe.paused=!1,Wr.push(qe),jn(),kn||mo())},qe.reverse=function(){Sn(),jn()},qe.restart=function(){qe.reset(),qe.play()},qe.finished=bn,qe.reset(),qe.autoplay&&qe.play(),qe}function lr(Ut,jt){for(var be=jt.length;be--;)Rt(Ut,jt[be].animatable.target)&&jt.splice(be,1)}document.addEventListener("visibilitychange",function(){if(document.hidden){for(var Ut=0,jt=Wr.length;Ut<jt;Ut++)activeInstance[Ut].pause();ii=Wr.slice(0),Wr=[]}else for(var be=0,Ze=ii.length;be<Ze;be++)ii[be].play()}),si.version="3.0.0",si.speed=1,si.running=Wr,si.remove=function(Ut){for(var jt=Z(Ut),be=Wr.length;be--;){var Ze=Wr[be],tn=Ze.animations,ke=Ze.children;lr(jt,tn);for(var pn=ke.length;pn--;){var cn=ke[pn],bn=cn.animations;lr(jt,bn),bn.length||cn.children.length||ke.splice(pn,1)}tn.length||ke.length||Ze.pause()}},si.get=js,si.set=_e,si.convertPx=Is,si.path=function(Ut,jt){var be=k.str(Ut)?bt(Ut)[0]:Ut,Ze=jt||100;return function(tn){return{property:tn,el:be,svg:Ct(be),totalLength:se(be)*(Ze/100)}}},si.setDashoffset=function(Ut){var jt=se(Ut);return Ut.setAttribute("stroke-dasharray",jt),jt},si.stagger=function(Ut,jt){void 0===jt&&(jt={});var be=jt.direction||"normal",Ze=jt.easing?vt(jt.easing):null,tn=jt.grid,ke=jt.axis,pn=jt.from||0,cn="first"===pn,bn="center"===pn,qe="last"===pn,Sn=k.arr(Ut),Mr=parseFloat(Sn?Ut[0]:Ut),jn=Sn?parseFloat(Ut[1]):0,Kn=hr(Sn?Ut[1]:Ut)||0,gn=jt.start||0+(Sn?Mr:0),vr=[],Tr=0;return function(rr,wn,br){if(cn&&(pn=0),bn&&(pn=(br-1)/2),qe&&(pn=br-1),!vr.length){for(var xi=0;xi<br;xi++){if(tn){var cr=bn?(tn[0]-1)/2:pn%tn[0],ai=bn?(tn[1]-1)/2:Math.floor(pn/tn[0]),ci=cr-xi%tn[0],Ri=ai-Math.floor(xi/tn[0]),jr=Math.sqrt(ci*ci+Ri*Ri);"x"===ke&&(jr=-ci),"y"===ke&&(jr=-Ri),vr.push(jr)}else vr.push(Math.abs(pn-xi));Tr=Math.max.apply(Math,vr)}Ze&&(vr=vr.map(function(de){return Ze(de/Tr)*Tr})),"reverse"===be&&(vr=vr.map(function(de){return ke?de<0?-1*de:-de:Math.abs(Tr-de)}))}return gn+(Sn?(jn-Mr)/Tr:Mr)*(Math.round(100*vr[wn])/100)+Kn}},si.timeline=function(Ut){void 0===Ut&&(Ut={});var jt=si(Ut);return jt.duration=0,jt.add=function(be,Ze){var tn=Wr.indexOf(jt),ke=jt.children;function pn(jn){jn.passThrough=!0}tn>-1&&Wr.splice(tn,1);for(var cn=0;cn<ke.length;cn++)pn(ke[cn]);var bn=xe(be,ve($,Ut));bn.targets=bn.targets||Ut.targets;var qe=jt.duration;bn.autoplay=!1,bn.direction=jt.direction,bn.timelineOffset=k.und(Ze)?qe:Ya(Ze,qe),pn(jt),jt.seek(bn.timelineOffset);var Sn=si(bn);pn(Sn),ke.push(Sn);var Mr=hn(ke,Ut);return jt.delay=Mr.delay,jt.endDelay=Mr.endDelay,jt.duration=Mr.duration,jt.seek(0),jt.reset(),jt.autoplay&&jt.play(),jt},jt},si.easing=vt,si.penner=pt,si.random=function(Ut,jt){return Math.floor(Math.random()*(jt-Ut+1))+Ut};const ki=si},4433:(ot,ht,I)=>{var U=I(5651),$=I(9035),O=I(7106),N=I(1684);ot.exports=function(E){return new _(E)};class _ extends THREE.BufferGeometry{constructor(D){super(),"string"==typeof D&&(D={text:D}),this._opt=Object.assign({},D),D&&this.update(D)}update(D){if("string"==typeof D&&(D={text:D}),!(D=Object.assign({},this._opt,D)).font)throw new TypeError("must specify a { font } in options");this.layout=U(D);var B=!1!==D.flipY,C=D.font,M=C.common.scaleW,k=C.common.scaleH,F=this.layout.glyphs.filter(function(rt){var pt=rt.data;return pt.width*pt.height>0});this.visibleGlyphs=F;var G=O.positions(F),Q=O.uvs(F,M,k,B),X=$([],{clockwise:!0,type:"uint16",count:F.length});if(this.setIndex(X),this.setAttribute("position",new THREE.BufferAttribute(G,2)),this.setAttribute("uv",new THREE.BufferAttribute(Q,2)),!D.multipage&&"page"in this.attributes)this.removeAttribute("page");else if(D.multipage){var lt=O.pages(F);this.setAttribute("page",new THREE.BufferAttribute(lt,1))}null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere()}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);var D=this.attributes.position.array;if(!D||!this.attributes.position.itemSize||D.length<2)return this.boundingSphere.radius=0,void this.boundingSphere.center.set(0,0,0);N.computeSphere(D,this.boundingSphere),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);var D=this.boundingBox,B=this.attributes.position.array;!B||!this.attributes.position.itemSize||B.length<2?D.makeEmpty():N.computeBox(B,D)}}},1684:ot=>{var ht={min:[0,0],max:[0,0]};function I(U){var $=U.length/2;ht.min[0]=U[0],ht.min[1]=U[1],ht.max[0]=U[0],ht.max[1]=U[1];for(var O=0;O<$;O++){var N=U[2*O+0],_=U[2*O+1];ht.min[0]=Math.min(N,ht.min[0]),ht.min[1]=Math.min(_,ht.min[1]),ht.max[0]=Math.max(N,ht.max[0]),ht.max[1]=Math.max(_,ht.max[1])}}ot.exports.computeBox=function(U,$){I(U),$.min.set(ht.min[0],ht.min[1],0),$.max.set(ht.max[0],ht.max[1],0)},ot.exports.computeSphere=function(U,$){I(U);var O=ht.min[0],N=ht.min[1],_=ht.max[0]-O,E=ht.max[1]-N,D=Math.sqrt(_*_+E*E);$.center.set(O+_/2,N+E/2,0),$.radius=D/2}},7106:ot=>{ot.exports.pages=function(ht){var I=new Float32Array(4*ht.length*1),U=0;return ht.forEach(function($){var O=$.data.page||0;I[U++]=O,I[U++]=O,I[U++]=O,I[U++]=O}),I},ot.exports.uvs=function(ht,I,U,$){var O=new Float32Array(4*ht.length*2),N=0;return ht.forEach(function(_){var E=_.data,B=E.y+E.height,C=E.x/I,M=E.y/U,k=(E.x+E.width)/I,F=B/U;$&&(M=(U-E.y)/U,F=(U-B)/U),O[N++]=C,O[N++]=M,O[N++]=C,O[N++]=F,O[N++]=k,O[N++]=F,O[N++]=k,O[N++]=M}),O},ot.exports.positions=function(ht){var I=new Float32Array(4*ht.length*2),U=0;return ht.forEach(function($){var O=$.data,N=$.position[0]+O.xoffset,_=$.position[1]+O.yoffset,E=O.width,D=O.height;I[U++]=N,I[U++]=_,I[U++]=N,I[U++]=_+D,I[U++]=N+E,I[U++]=_+D,I[U++]=N+E,I[U++]=_}),I}},9835:function(ot,ht,I){ot.exports=function(){"use strict";var $,G,U=typeof window<"u"?window:void 0!==I.g?I.g:typeof self<"u"?self:{},O=function(){return/Android/i.test(navigator.userAgent)||/iPhone|iPad|iPod/i.test(navigator.userAgent)},N=function(F,G){for(var Q=0,X=F.length;Q<X;Q++)G[Q]=F[Q]},_=function(F,G){for(var Q in G)G.hasOwnProperty(Q)&&(F[Q]=G[Q]);return F},D=((G={exports:{}}).exports=function(){var Q,X,lt,K,pt=function(){function K(mt,It){for(var Mt=0;Mt<It.length;Mt++){var Gt=It[Mt];Gt.enumerable=Gt.enumerable||!1,Gt.configurable=!0,"value"in Gt&&(Gt.writable=!0),Object.defineProperty(mt,Gt.key,Gt)}}return function(mt,It,Mt){return It&&K(mt.prototype,It),Mt&&K(mt,Mt),mt}}(),vt=function(mt,It){if(Array.isArray(mt))return mt;if(Symbol.iterator in Object(mt))return function K(mt,It){var Mt=[],Gt=!0,Xt=!1,Me=void 0;try{for(var sn,un=mt[Symbol.iterator]();!(Gt=(sn=un.next()).done)&&(Mt.push(sn.value),!It||Mt.length!==It);Gt=!0);}catch(Ie){Xt=!0,Me=Ie}finally{try{!Gt&&un.return&&un.return()}finally{if(Xt)throw Me}}return Mt}(mt,It);throw new TypeError("Invalid attempt to destructure non-iterable instance")},et=function(K,mt,It){return K+(mt-K)*It},xt=(K=/iPad|iPhone|iPod/.test(navigator.platform),function(){return K}),Rt=function(){var K=-1!==navigator.userAgent.indexOf("Version")&&-1!==navigator.userAgent.indexOf("Android")&&-1!==navigator.userAgent.indexOf("Chrome");return function(){return K}}(),Yt=function(){var K=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);return function(){return K}}(),ve=function(){var K=-1!==navigator.userAgent.indexOf("Firefox")&&-1!==navigator.userAgent.indexOf("Android");return function(){return K}}(),xe=(Q=navigator.userAgent.match(/.*Chrome\/([0-9]+)/),X=Q?parseInt(Q[1],10):null,function(){return X}),Ge=function(){var K;return K=xt()&&Yt()&&-1!==navigator.userAgent.indexOf("13_4"),function(){return K}}(),en=function(){var K=!1;if(65===xe()){var mt=navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);if(mt){var It=mt[1].split("."),Mt=vt(It,4),Xt=Mt[3];K=3325===parseInt(Mt[2],10)&&parseInt(Xt,10)<148}}return function(){return K}}(),nn=function(){var K=-1!==navigator.userAgent.indexOf("R7 Build");return function(){return K}}(),vn=function(){var K=90==window.orientation||-90==window.orientation;return nn()?!K:K},nr=function(){return Math.max(window.screen.width,window.screen.height)*window.devicePixelRatio},hr=function(){return Math.min(window.screen.width,window.screen.height)*window.devicePixelRatio},Ti=function(){if(document.exitFullscreen)document.exitFullscreen();else if(document.webkitExitFullscreen)document.webkitExitFullscreen();else if(document.mozCancelFullScreen)document.mozCancelFullScreen();else{if(!document.msExitFullscreen)return!1;document.msExitFullscreen()}return!0},As=function(K,mt,It,Mt){var Gt=K.createShader(K.VERTEX_SHADER);K.shaderSource(Gt,mt),K.compileShader(Gt);var Xt=K.createShader(K.FRAGMENT_SHADER);K.shaderSource(Xt,It),K.compileShader(Xt);var Me=K.createProgram();for(var sn in K.attachShader(Me,Gt),K.attachShader(Me,Xt),Mt)K.bindAttribLocation(Me,Mt[sn],sn);return K.linkProgram(Me),K.deleteShader(Gt),K.deleteShader(Xt),Me},ua=function(K,mt){for(var It={},Mt=K.getProgramParameter(mt,K.ACTIVE_UNIFORMS),Gt="",Xt=0;Xt<Mt;Xt++)It[Gt=K.getActiveUniform(mt,Xt).name.replace("[0]","")]=K.getUniformLocation(mt,Gt);return It},ha=function(){var K,mt=!1;return K=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(K)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(K.substr(0,4)))&&(mt=!0),mt},js=function(K,mt){for(var It in mt)mt.hasOwnProperty(It)&&(K[It]=mt[It]);return K},Xa=function(K){if(xt()){var mt=K.style.width,It=K.style.height;K.style.width=parseInt(mt)+1+"px",K.style.height=parseInt(It)+"px",setTimeout(function(){K.style.width=mt,K.style.height=It},100)}window.canvas=K},Ya=function(){var K=Math.PI/180,mt=.25*Math.PI;var Me=new Float32Array([0,0,0,1]),sn=new Float32Array([0,0,0]);function un(Ie,Be,Pn,Xn,dr,Ar){(function It(Ie,Be,Pn,Xn){var dr=Math.tan(Be?Be.upDegrees*K:mt),Ar=Math.tan(Be?Be.downDegrees*K:mt),xr=Math.tan(Be?Be.leftDegrees*K:mt),_r=Math.tan(Be?Be.rightDegrees*K:mt),Pr=2/(xr+_r),ui=2/(dr+Ar);return Ie[0]=Pr,Ie[1]=0,Ie[2]=0,Ie[3]=0,Ie[4]=0,Ie[5]=ui,Ie[6]=0,Ie[7]=0,Ie[8]=-(xr-_r)*Pr*.5,Ie[9]=(dr-Ar)*ui*.5,Ie[10]=Xn/(Pn-Xn),Ie[11]=-1,Ie[12]=0,Ie[13]=0,Ie[14]=Xn*Pn/(Pn-Xn),Ie[15]=0,Ie})(Ie,Xn||null,Ar.depthNear,Ar.depthFar),function Mt(Ie,Be,Pn){var Xn=Be[0],dr=Be[1],Ar=Be[2],xr=Be[3],_r=Xn+Xn,Pr=dr+dr,ui=Ar+Ar,us=Xn*_r,Fi=Xn*Pr,rs=Xn*ui,Ts=dr*Pr,Js=dr*ui,hs=Ar*ui,ds=xr*_r,$i=xr*Pr,Zs=xr*ui;return Ie[0]=1-(Ts+hs),Ie[1]=Fi+Zs,Ie[2]=rs-$i,Ie[3]=0,Ie[4]=Fi-Zs,Ie[5]=1-(us+hs),Ie[6]=Js+ds,Ie[7]=0,Ie[8]=rs+$i,Ie[9]=Js-ds,Ie[10]=1-(us+Ts),Ie[11]=0,Ie[12]=Pn[0],Ie[13]=Pn[1],Ie[14]=Pn[2],Ie[15]=1,Ie}(Be,Pn.orientation||Me,Pn.position||sn),dr&&function Gt(Ie,Be,Pn){var Xn,dr,Ar,xr,_r,Pr,ui,us,Fi,rs,Ts,Js,hs=Pn[0],ds=Pn[1],$i=Pn[2];return Be===Ie?(Ie[12]=Be[0]*hs+Be[4]*ds+Be[8]*$i+Be[12],Ie[13]=Be[1]*hs+Be[5]*ds+Be[9]*$i+Be[13],Ie[14]=Be[2]*hs+Be[6]*ds+Be[10]*$i+Be[14],Ie[15]=Be[3]*hs+Be[7]*ds+Be[11]*$i+Be[15]):(dr=Be[1],Ar=Be[2],xr=Be[3],_r=Be[4],Pr=Be[5],ui=Be[6],us=Be[7],Fi=Be[8],rs=Be[9],Ts=Be[10],Js=Be[11],Ie[0]=Xn=Be[0],Ie[1]=dr,Ie[2]=Ar,Ie[3]=xr,Ie[4]=_r,Ie[5]=Pr,Ie[6]=ui,Ie[7]=us,Ie[8]=Fi,Ie[9]=rs,Ie[10]=Ts,Ie[11]=Js,Ie[12]=Xn*hs+_r*ds+Fi*$i+Be[12],Ie[13]=dr*hs+Pr*ds+rs*$i+Be[13],Ie[14]=Ar*hs+ui*ds+Ts*$i+Be[14],Ie[15]=xr*hs+us*ds+Js*$i+Be[15]),Ie}(Be,Be,dr),function Xt(Ie,Be){var Pn=Be[0],Xn=Be[1],dr=Be[2],Ar=Be[3],xr=Be[4],_r=Be[5],Pr=Be[6],ui=Be[7],us=Be[8],Fi=Be[9],rs=Be[10],Ts=Be[11],Js=Be[12],hs=Be[13],ds=Be[14],$i=Be[15],Zs=Pn*_r-Xn*xr,Qo=Pn*Pr-dr*xr,Ja=Pn*ui-Ar*xr,Za=Xn*Pr-dr*_r,Ao=Xn*ui-Ar*_r,hl=dr*ui-Ar*Pr,dl=us*hs-Fi*Js,Ho=us*ds-rs*Js,pl=us*$i-Ts*Js,yo=Fi*ds-rs*hs,Pl=Fi*$i-Ts*hs,Wo=rs*$i-Ts*ds,wi=Zs*Wo-Qo*Pl+Ja*yo+Za*pl-Ao*Ho+hl*dl;return wi?(Ie[0]=(_r*Wo-Pr*Pl+ui*yo)*(wi=1/wi),Ie[1]=(dr*Pl-Xn*Wo-Ar*yo)*wi,Ie[2]=(hs*hl-ds*Ao+$i*Za)*wi,Ie[3]=(rs*Ao-Fi*hl-Ts*Za)*wi,Ie[4]=(Pr*pl-xr*Wo-ui*Ho)*wi,Ie[5]=(Pn*Wo-dr*pl+Ar*Ho)*wi,Ie[6]=(ds*Ja-Js*hl-$i*Qo)*wi,Ie[7]=(us*hl-rs*Ja+Ts*Qo)*wi,Ie[8]=(xr*Pl-_r*pl+ui*dl)*wi,Ie[9]=(Xn*pl-Pn*Pl-Ar*dl)*wi,Ie[10]=(Js*Ao-hs*Ja+$i*Zs)*wi,Ie[11]=(Fi*Ja-us*Ao-Ts*Zs)*wi,Ie[12]=(_r*Ho-xr*yo-Pr*dl)*wi,Ie[13]=(Pn*yo-Xn*Ho+dr*dl)*wi,Ie[14]=(hs*Qo-Js*Za-ds*Zs)*wi,Ie[15]=(us*Za-Fi*Qo+rs*Zs)*wi,Ie):null}(Be,Be)}return function(Ie,Be,Pn){return!(!Ie||!Be||(Ie.pose=Be,Ie.timestamp=Be.timestamp,un(Ie.leftProjectionMatrix,Ie.leftViewMatrix,Be,Pn._getFieldOfView("left"),Pn._getEyeOffset("left"),Pn),un(Ie.rightProjectionMatrix,Ie.rightViewMatrix,Be,Pn._getFieldOfView("right"),Pn._getEyeOffset("right"),Pn),0))}}(),ys=function(K){var It=K.indexOf("://"),Mt=K.indexOf("/",-1!==It?It+3:0);return-1===Mt&&(Mt=K.length),K.substring(0,Mt)},qs=(lt={},function(K,mt){void 0===lt[K]&&(console.warn("webvr-polyfill: "+mt),lt[K]=!0)}),se=function(K,mt){qs(K,K+" has been deprecated. This may not work on native WebVR displays. "+(mt?"Please use "+mt+" instead.":""))};var q=function Ct(K,mt,It){if(mt){for(var Mt=[],Gt=null,Xt=0;Xt<mt.length;++Xt)switch(Me=mt[Xt]){case K.TEXTURE_BINDING_2D:case K.TEXTURE_BINDING_CUBE_MAP:if((un=mt[++Xt])<K.TEXTURE0||un>K.TEXTURE31){console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit"),Mt.push(null,null);break}Gt||(Gt=K.getParameter(K.ACTIVE_TEXTURE)),K.activeTexture(un),Mt.push(K.getParameter(Me),null);break;case K.ACTIVE_TEXTURE:Gt=K.getParameter(K.ACTIVE_TEXTURE),Mt.push(null);break;default:Mt.push(K.getParameter(Me))}for(It(K),Xt=0;Xt<mt.length;++Xt){var Me=mt[Xt],sn=Mt[Xt];switch(Me){case K.ACTIVE_TEXTURE:break;case K.ARRAY_BUFFER_BINDING:K.bindBuffer(K.ARRAY_BUFFER,sn);break;case K.COLOR_CLEAR_VALUE:K.clearColor(sn[0],sn[1],sn[2],sn[3]);break;case K.COLOR_WRITEMASK:K.colorMask(sn[0],sn[1],sn[2],sn[3]);break;case K.CURRENT_PROGRAM:K.useProgram(sn);break;case K.ELEMENT_ARRAY_BUFFER_BINDING:K.bindBuffer(K.ELEMENT_ARRAY_BUFFER,sn);break;case K.FRAMEBUFFER_BINDING:K.bindFramebuffer(K.FRAMEBUFFER,sn);break;case K.RENDERBUFFER_BINDING:K.bindRenderbuffer(K.RENDERBUFFER,sn);break;case K.TEXTURE_BINDING_2D:if((un=mt[++Xt])<K.TEXTURE0||un>K.TEXTURE31)break;K.activeTexture(un),K.bindTexture(K.TEXTURE_2D,sn);break;case K.TEXTURE_BINDING_CUBE_MAP:var un;if((un=mt[++Xt])<K.TEXTURE0||un>K.TEXTURE31)break;K.activeTexture(un),K.bindTexture(K.TEXTURE_CUBE_MAP,sn);break;case K.VIEWPORT:K.viewport(sn[0],sn[1],sn[2],sn[3]);break;case K.BLEND:case K.CULL_FACE:case K.DEPTH_TEST:case K.SCISSOR_TEST:case K.STENCIL_TEST:sn?K.enable(Me):K.disable(Me);break;default:console.log("No GL restore behavior for 0x"+Me.toString(16))}Gt&&K.activeTexture(Gt)}}else It(K)},st=["attribute vec2 position;","attribute vec3 texCoord;","varying vec2 vTexCoord;","uniform vec4 viewportOffsetScale[2];","void main() {","  vec4 viewport = viewportOffsetScale[int(texCoord.z)];","  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;","  gl_Position = vec4( position, 1.0, 1.0 );","}"].join("\n"),ut=["precision mediump float;","uniform sampler2D diffuse;","varying vec2 vTexCoord;","void main() {","  gl_FragColor = texture2D(diffuse, vTexCoord);","}"].join("\n");function Z(K,mt,It,Mt){this.gl=K,this.cardboardUI=mt,this.bufferScale=It,this.dirtySubmitFrameBindings=Mt,this.ctxAttribs=K.getContextAttributes(),this.instanceExt=K.getExtension("ANGLE_instanced_arrays"),this.meshWidth=20,this.meshHeight=20,this.bufferWidth=K.drawingBufferWidth,this.bufferHeight=K.drawingBufferHeight,this.realBindFramebuffer=K.bindFramebuffer,this.realEnable=K.enable,this.realDisable=K.disable,this.realColorMask=K.colorMask,this.realClearColor=K.clearColor,this.realViewport=K.viewport,xt()||(this.realCanvasWidth=Object.getOwnPropertyDescriptor(K.canvas.__proto__,"width"),this.realCanvasHeight=Object.getOwnPropertyDescriptor(K.canvas.__proto__,"height")),this.isPatched=!1,this.lastBoundFramebuffer=null,this.cullFace=!1,this.depthTest=!1,this.blend=!1,this.scissorTest=!1,this.stencilTest=!1,this.viewport=[0,0,0,0],this.colorMask=[!0,!0,!0,!0],this.clearColor=[0,0,0,0],this.attribs={position:0,texCoord:1},this.program=As(K,st,ut,this.attribs),this.uniforms=ua(K,this.program),this.viewportOffsetScale=new Float32Array(8),this.setTextureBounds(),this.vertexBuffer=K.createBuffer(),this.indexBuffer=K.createBuffer(),this.indexCount=0,this.renderTarget=K.createTexture(),this.framebuffer=K.createFramebuffer(),this.depthStencilBuffer=null,this.depthBuffer=null,this.stencilBuffer=null,this.ctxAttribs.depth&&this.ctxAttribs.stencil?this.depthStencilBuffer=K.createRenderbuffer():this.ctxAttribs.depth?this.depthBuffer=K.createRenderbuffer():this.ctxAttribs.stencil&&(this.stencilBuffer=K.createRenderbuffer()),this.patch(),this.onResize()}Z.prototype.destroy=function(){var K=this.gl;this.unpatch(),K.deleteProgram(this.program),K.deleteBuffer(this.vertexBuffer),K.deleteBuffer(this.indexBuffer),K.deleteTexture(this.renderTarget),K.deleteFramebuffer(this.framebuffer),this.depthStencilBuffer&&K.deleteRenderbuffer(this.depthStencilBuffer),this.depthBuffer&&K.deleteRenderbuffer(this.depthBuffer),this.stencilBuffer&&K.deleteRenderbuffer(this.stencilBuffer),this.cardboardUI&&this.cardboardUI.destroy()},Z.prototype.onResize=function(){var K=this.gl,mt=this;q(K,[K.RENDERBUFFER_BINDING,K.TEXTURE_BINDING_2D,K.TEXTURE0],function(Mt){mt.realBindFramebuffer.call(Mt,Mt.FRAMEBUFFER,null),mt.scissorTest&&mt.realDisable.call(Mt,Mt.SCISSOR_TEST),mt.realColorMask.call(Mt,!0,!0,!0,!0),mt.realViewport.call(Mt,0,0,Mt.drawingBufferWidth,Mt.drawingBufferHeight),mt.realClearColor.call(Mt,0,0,0,1),Mt.clear(Mt.COLOR_BUFFER_BIT),mt.realBindFramebuffer.call(Mt,Mt.FRAMEBUFFER,mt.framebuffer),Mt.bindTexture(Mt.TEXTURE_2D,mt.renderTarget),Mt.texImage2D(Mt.TEXTURE_2D,0,mt.ctxAttribs.alpha?Mt.RGBA:Mt.RGB,mt.bufferWidth,mt.bufferHeight,0,mt.ctxAttribs.alpha?Mt.RGBA:Mt.RGB,Mt.UNSIGNED_BYTE,null),Mt.texParameteri(Mt.TEXTURE_2D,Mt.TEXTURE_MAG_FILTER,Mt.LINEAR),Mt.texParameteri(Mt.TEXTURE_2D,Mt.TEXTURE_MIN_FILTER,Mt.LINEAR),Mt.texParameteri(Mt.TEXTURE_2D,Mt.TEXTURE_WRAP_S,Mt.CLAMP_TO_EDGE),Mt.texParameteri(Mt.TEXTURE_2D,Mt.TEXTURE_WRAP_T,Mt.CLAMP_TO_EDGE),Mt.framebufferTexture2D(Mt.FRAMEBUFFER,Mt.COLOR_ATTACHMENT0,Mt.TEXTURE_2D,mt.renderTarget,0),mt.ctxAttribs.depth&&mt.ctxAttribs.stencil?(Mt.bindRenderbuffer(Mt.RENDERBUFFER,mt.depthStencilBuffer),Mt.renderbufferStorage(Mt.RENDERBUFFER,Mt.DEPTH_STENCIL,mt.bufferWidth,mt.bufferHeight),Mt.framebufferRenderbuffer(Mt.FRAMEBUFFER,Mt.DEPTH_STENCIL_ATTACHMENT,Mt.RENDERBUFFER,mt.depthStencilBuffer)):mt.ctxAttribs.depth?(Mt.bindRenderbuffer(Mt.RENDERBUFFER,mt.depthBuffer),Mt.renderbufferStorage(Mt.RENDERBUFFER,Mt.DEPTH_COMPONENT16,mt.bufferWidth,mt.bufferHeight),Mt.framebufferRenderbuffer(Mt.FRAMEBUFFER,Mt.DEPTH_ATTACHMENT,Mt.RENDERBUFFER,mt.depthBuffer)):mt.ctxAttribs.stencil&&(Mt.bindRenderbuffer(Mt.RENDERBUFFER,mt.stencilBuffer),Mt.renderbufferStorage(Mt.RENDERBUFFER,Mt.STENCIL_INDEX8,mt.bufferWidth,mt.bufferHeight),Mt.framebufferRenderbuffer(Mt.FRAMEBUFFER,Mt.STENCIL_ATTACHMENT,Mt.RENDERBUFFER,mt.stencilBuffer)),!Mt.checkFramebufferStatus(Mt.FRAMEBUFFER)===Mt.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer incomplete!"),mt.realBindFramebuffer.call(Mt,Mt.FRAMEBUFFER,mt.lastBoundFramebuffer),mt.scissorTest&&mt.realEnable.call(Mt,Mt.SCISSOR_TEST),mt.realColorMask.apply(Mt,mt.colorMask),mt.realViewport.apply(Mt,mt.viewport),mt.realClearColor.apply(Mt,mt.clearColor)}),this.cardboardUI&&this.cardboardUI.onResize()},Z.prototype.patch=function(){if(!this.isPatched){var K=this,mt=this.gl.canvas,It=this.gl;xt()||(mt.width=nr()*this.bufferScale,mt.height=hr()*this.bufferScale,Object.defineProperty(mt,"width",{configurable:!0,enumerable:!0,get:function(){return K.bufferWidth},set:function(Mt){K.bufferWidth=Mt,K.realCanvasWidth.set.call(mt,Mt),K.onResize()}}),Object.defineProperty(mt,"height",{configurable:!0,enumerable:!0,get:function(){return K.bufferHeight},set:function(Mt){K.bufferHeight=Mt,K.realCanvasHeight.set.call(mt,Mt),K.onResize()}})),this.lastBoundFramebuffer=It.getParameter(It.FRAMEBUFFER_BINDING),null==this.lastBoundFramebuffer&&(this.lastBoundFramebuffer=this.framebuffer,this.gl.bindFramebuffer(It.FRAMEBUFFER,this.framebuffer)),this.gl.bindFramebuffer=function(Mt,Gt){K.lastBoundFramebuffer=Gt||K.framebuffer,K.realBindFramebuffer.call(It,Mt,K.lastBoundFramebuffer)},this.cullFace=It.getParameter(It.CULL_FACE),this.depthTest=It.getParameter(It.DEPTH_TEST),this.blend=It.getParameter(It.BLEND),this.scissorTest=It.getParameter(It.SCISSOR_TEST),this.stencilTest=It.getParameter(It.STENCIL_TEST),It.enable=function(Mt){switch(Mt){case It.CULL_FACE:K.cullFace=!0;break;case It.DEPTH_TEST:K.depthTest=!0;break;case It.BLEND:K.blend=!0;break;case It.SCISSOR_TEST:K.scissorTest=!0;break;case It.STENCIL_TEST:K.stencilTest=!0}K.realEnable.call(It,Mt)},It.disable=function(Mt){switch(Mt){case It.CULL_FACE:K.cullFace=!1;break;case It.DEPTH_TEST:K.depthTest=!1;break;case It.BLEND:K.blend=!1;break;case It.SCISSOR_TEST:K.scissorTest=!1;break;case It.STENCIL_TEST:K.stencilTest=!1}K.realDisable.call(It,Mt)},this.colorMask=It.getParameter(It.COLOR_WRITEMASK),It.colorMask=function(Mt,Gt,Xt,Me){K.colorMask[0]=Mt,K.colorMask[1]=Gt,K.colorMask[2]=Xt,K.colorMask[3]=Me,K.realColorMask.call(It,Mt,Gt,Xt,Me)},this.clearColor=It.getParameter(It.COLOR_CLEAR_VALUE),It.clearColor=function(Mt,Gt,Xt,Me){K.clearColor[0]=Mt,K.clearColor[1]=Gt,K.clearColor[2]=Xt,K.clearColor[3]=Me,K.realClearColor.call(It,Mt,Gt,Xt,Me)},this.viewport=It.getParameter(It.VIEWPORT),It.viewport=function(Mt,Gt,Xt,Me){K.viewport[0]=Mt,K.viewport[1]=Gt,K.viewport[2]=Xt,K.viewport[3]=Me,K.realViewport.call(It,Mt,Gt,Xt,Me)},this.isPatched=!0,Xa(mt)}},Z.prototype.unpatch=function(){if(this.isPatched){var K=this.gl,mt=this.gl.canvas;xt()||(Object.defineProperty(mt,"width",this.realCanvasWidth),Object.defineProperty(mt,"height",this.realCanvasHeight)),mt.width=this.bufferWidth,mt.height=this.bufferHeight,K.bindFramebuffer=this.realBindFramebuffer,K.enable=this.realEnable,K.disable=this.realDisable,K.colorMask=this.realColorMask,K.clearColor=this.realClearColor,K.viewport=this.realViewport,this.lastBoundFramebuffer==this.framebuffer&&K.bindFramebuffer(K.FRAMEBUFFER,null),this.isPatched=!1,setTimeout(function(){Xa(mt)},1)}},Z.prototype.setTextureBounds=function(K,mt){K||(K=[0,0,.5,1]),mt||(mt=[.5,0,.5,1]),this.viewportOffsetScale[0]=K[0],this.viewportOffsetScale[1]=K[1],this.viewportOffsetScale[2]=K[2],this.viewportOffsetScale[3]=K[3],this.viewportOffsetScale[4]=mt[0],this.viewportOffsetScale[5]=mt[1],this.viewportOffsetScale[6]=mt[2],this.viewportOffsetScale[7]=mt[3]},Z.prototype.submitFrame=function(){var K=this.gl,mt=this,It=[];if(this.dirtySubmitFrameBindings||It.push(K.CURRENT_PROGRAM,K.ARRAY_BUFFER_BINDING,K.ELEMENT_ARRAY_BUFFER_BINDING,K.TEXTURE_BINDING_2D,K.TEXTURE0),q(K,It,function(Gt){mt.realBindFramebuffer.call(Gt,Gt.FRAMEBUFFER,null);var Xt=0,Me=0;mt.instanceExt&&(Xt=Gt.getVertexAttrib(mt.attribs.position,mt.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE),Me=Gt.getVertexAttrib(mt.attribs.texCoord,mt.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)),mt.cullFace&&mt.realDisable.call(Gt,Gt.CULL_FACE),mt.depthTest&&mt.realDisable.call(Gt,Gt.DEPTH_TEST),mt.blend&&mt.realDisable.call(Gt,Gt.BLEND),mt.scissorTest&&mt.realDisable.call(Gt,Gt.SCISSOR_TEST),mt.stencilTest&&mt.realDisable.call(Gt,Gt.STENCIL_TEST),mt.realColorMask.call(Gt,!0,!0,!0,!0),mt.realViewport.call(Gt,0,0,Gt.drawingBufferWidth,Gt.drawingBufferHeight),(mt.ctxAttribs.alpha||xt())&&(mt.realClearColor.call(Gt,0,0,0,1),Gt.clear(Gt.COLOR_BUFFER_BIT)),Gt.useProgram(mt.program),Gt.bindBuffer(Gt.ELEMENT_ARRAY_BUFFER,mt.indexBuffer),Gt.bindBuffer(Gt.ARRAY_BUFFER,mt.vertexBuffer),Gt.enableVertexAttribArray(mt.attribs.position),Gt.enableVertexAttribArray(mt.attribs.texCoord),Gt.vertexAttribPointer(mt.attribs.position,2,Gt.FLOAT,!1,20,0),Gt.vertexAttribPointer(mt.attribs.texCoord,3,Gt.FLOAT,!1,20,8),mt.instanceExt&&(0!=Xt&&mt.instanceExt.vertexAttribDivisorANGLE(mt.attribs.position,0),0!=Me&&mt.instanceExt.vertexAttribDivisorANGLE(mt.attribs.texCoord,0)),Gt.activeTexture(Gt.TEXTURE0),Gt.uniform1i(mt.uniforms.diffuse,0),Gt.bindTexture(Gt.TEXTURE_2D,mt.renderTarget),Gt.uniform4fv(mt.uniforms.viewportOffsetScale,mt.viewportOffsetScale),Gt.drawElements(Gt.TRIANGLES,mt.indexCount,Gt.UNSIGNED_SHORT,0),mt.cardboardUI&&mt.cardboardUI.renderNoState(),mt.realBindFramebuffer.call(mt.gl,Gt.FRAMEBUFFER,mt.framebuffer),mt.ctxAttribs.preserveDrawingBuffer||(mt.realClearColor.call(Gt,0,0,0,0),Gt.clear(Gt.COLOR_BUFFER_BIT)),mt.dirtySubmitFrameBindings||mt.realBindFramebuffer.call(Gt,Gt.FRAMEBUFFER,mt.lastBoundFramebuffer),mt.cullFace&&mt.realEnable.call(Gt,Gt.CULL_FACE),mt.depthTest&&mt.realEnable.call(Gt,Gt.DEPTH_TEST),mt.blend&&mt.realEnable.call(Gt,Gt.BLEND),mt.scissorTest&&mt.realEnable.call(Gt,Gt.SCISSOR_TEST),mt.stencilTest&&mt.realEnable.call(Gt,Gt.STENCIL_TEST),mt.realColorMask.apply(Gt,mt.colorMask),mt.realViewport.apply(Gt,mt.viewport),!mt.ctxAttribs.alpha&&mt.ctxAttribs.preserveDrawingBuffer||mt.realClearColor.apply(Gt,mt.clearColor),mt.instanceExt&&(0!=Xt&&mt.instanceExt.vertexAttribDivisorANGLE(mt.attribs.position,Xt),0!=Me&&mt.instanceExt.vertexAttribDivisorANGLE(mt.attribs.texCoord,Me))}),xt()){var Mt=K.canvas;Mt.width==mt.bufferWidth&&Mt.height==mt.bufferHeight||(mt.bufferWidth=Mt.width,mt.bufferHeight=Mt.height,mt.onResize())}},Z.prototype.updateDeviceInfo=function(K){var mt=this.gl,It=this;q(mt,[mt.ARRAY_BUFFER_BINDING,mt.ELEMENT_ARRAY_BUFFER_BINDING],function(Gt){var Xt=It.computeMeshVertices_(It.meshWidth,It.meshHeight,K);if(Gt.bindBuffer(Gt.ARRAY_BUFFER,It.vertexBuffer),Gt.bufferData(Gt.ARRAY_BUFFER,Xt,Gt.STATIC_DRAW),!It.indexCount){var Me=It.computeMeshIndices_(It.meshWidth,It.meshHeight);Gt.bindBuffer(Gt.ELEMENT_ARRAY_BUFFER,It.indexBuffer),Gt.bufferData(Gt.ELEMENT_ARRAY_BUFFER,Me,Gt.STATIC_DRAW),It.indexCount=Me.length}})},Z.prototype.computeMeshVertices_=function(K,mt,It){for(var Mt=new Float32Array(2*K*mt*5),Gt=It.getLeftEyeVisibleTanAngles(),Xt=It.getLeftEyeNoLensTanAngles(),Me=It.getLeftEyeVisibleScreenRect(Xt),sn=0,un=0;un<2;un++){for(var Ie=0;Ie<mt;Ie++)for(var Be=0;Be<K;Be++,sn++){var Pn=Be/(K-1),Xn=Ie/(mt-1),dr=Pn,Ar=Xn,xr=et(Gt[0],Gt[2],Pn),_r=et(Gt[3],Gt[1],Xn),Pr=Math.sqrt(xr*xr+_r*_r),ui=It.distortion.distortInverse(Pr);Xn=2*(Me.y+(Xn=(_r*ui/Pr-Xt[3])/(Xt[1]-Xt[3]))*Me.height-.5),Mt[5*sn+0]=Pn=2*(Me.x+(Pn=(xr*ui/Pr-Xt[0])/(Xt[2]-Xt[0]))*Me.width-.5),Mt[5*sn+1]=Xn,Mt[5*sn+2]=dr,Mt[5*sn+3]=Ar,Mt[5*sn+4]=un}var Fi=Gt[2]-Gt[0];Gt[0]=-(Fi+Gt[0]),Gt[2]=Fi-Gt[2],Xt[0]=-((Fi=Xt[2]-Xt[0])+Xt[0]),Xt[2]=Fi-Xt[2],Me.x=1-(Me.x+Me.width)}return Mt},Z.prototype.computeMeshIndices_=function(K,mt){for(var It=new Uint16Array(2*(K-1)*(mt-1)*6),Mt=K/2,Gt=mt/2,Xt=0,Me=0,sn=0;sn<2;sn++)for(var un=0;un<mt;un++)for(var Ie=0;Ie<K;Ie++,Xt++)0!=Ie&&0!=un&&(Ie<=Mt==un<=Gt?(It[Me++]=Xt,It[Me++]=Xt-K-1,It[Me++]=Xt-K,It[Me++]=Xt-K-1,It[Me++]=Xt,It[Me++]=Xt-1):(It[Me++]=Xt-1,It[Me++]=Xt-K,It[Me++]=Xt,It[Me++]=Xt-K,It[Me++]=Xt-1,It[Me++]=Xt-K-1));return It},Z.prototype.getOwnPropertyDescriptor_=function(K,mt){var It=Object.getOwnPropertyDescriptor(K,mt);return void 0!==It.get&&void 0!==It.set||(It.configurable=!0,It.enumerable=!0,It.get=function(){return this.getAttribute(mt)},It.set=function(Mt){this.setAttribute(mt,Mt)}),It};var _t=["attribute vec2 position;","uniform mat4 projectionMat;","void main() {","  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );","}"].join("\n"),Ht=["precision mediump float;","uniform vec4 color;","void main() {","  gl_FragColor = color;","}"].join("\n"),Ae=Math.PI/180;function si(K){this.gl=K,this.attribs={position:0},this.program=As(K,_t,Ht,this.attribs),this.uniforms=ua(K,this.program),this.vertexBuffer=K.createBuffer(),this.gearOffset=0,this.gearVertexCount=0,this.arrowOffset=0,this.arrowVertexCount=0,this.projMat=new Float32Array(16),this.listener=null,this.onResize()}function lr(K){this.coefficients=K}si.prototype.destroy=function(){var K=this.gl;this.listener&&K.canvas.removeEventListener("click",this.listener,!1),K.deleteProgram(this.program),K.deleteBuffer(this.vertexBuffer)},si.prototype.listen=function(K,mt){var It=this.gl.canvas;this.listener=function(Mt){var Gt=It.clientWidth/2;Mt.clientX>Gt-42&&Mt.clientX<Gt+42&&Mt.clientY>It.clientHeight-42?K(Mt):Mt.clientX<42&&Mt.clientY<42&&mt(Mt)},It.addEventListener("click",this.listener,!1)},si.prototype.onResize=function(){var K=this.gl,mt=this;q(K,[K.ARRAY_BUFFER_BINDING],function(Mt){var Gt=[],Xt=Mt.drawingBufferWidth/2,Me=Math.max(screen.width,screen.height)*window.devicePixelRatio,sn=Mt.drawingBufferWidth/Me*window.devicePixelRatio,un=4*sn/2,Ie=42*sn,Be=28*sn/2,Pn=14*sn;function Xn(Pr,ui){var us=(90-Pr)*Ae,Fi=Math.cos(us),rs=Math.sin(us);Gt.push(.3125*Fi*Be+Xt,.3125*rs*Be+Be),Gt.push(ui*Fi*Be+Xt,ui*rs*Be+Be)}Gt.push(Xt-un,Ie),Gt.push(Xt-un,Mt.drawingBufferHeight),Gt.push(Xt+un,Ie),Gt.push(Xt+un,Mt.drawingBufferHeight),mt.gearOffset=Gt.length/2;for(var dr=0;dr<=6;dr++){var Ar=60*dr;Xn(Ar,1),Xn(Ar+12,1),Xn(Ar+20,.75),Xn(Ar+40,.75),Xn(Ar+48,1)}function xr(Pr,ui){Gt.push(Pn+Pr,Mt.drawingBufferHeight-Pn-ui)}mt.gearVertexCount=Gt.length/2-mt.gearOffset,mt.arrowOffset=Gt.length/2;var _r=un/Math.sin(45*Ae);xr(0,Be),xr(Be,0),xr(Be+_r,_r),xr(_r,Be+_r),xr(_r,Be-_r),xr(0,Be),xr(Be,2*Be),xr(Be+_r,2*Be-_r),xr(_r,Be-_r),xr(0,Be),xr(_r,Be-un),xr(28*sn,Be-un),xr(_r,Be+un),xr(28*sn,Be+un),mt.arrowVertexCount=Gt.length/2-mt.arrowOffset,Mt.bindBuffer(Mt.ARRAY_BUFFER,mt.vertexBuffer),Mt.bufferData(Mt.ARRAY_BUFFER,new Float32Array(Gt),Mt.STATIC_DRAW)})},si.prototype.render=function(){var K=this.gl,mt=this;q(K,[K.CULL_FACE,K.DEPTH_TEST,K.BLEND,K.SCISSOR_TEST,K.STENCIL_TEST,K.COLOR_WRITEMASK,K.VIEWPORT,K.CURRENT_PROGRAM,K.ARRAY_BUFFER_BINDING],function(Mt){Mt.disable(Mt.CULL_FACE),Mt.disable(Mt.DEPTH_TEST),Mt.disable(Mt.BLEND),Mt.disable(Mt.SCISSOR_TEST),Mt.disable(Mt.STENCIL_TEST),Mt.colorMask(!0,!0,!0,!0),Mt.viewport(0,0,Mt.drawingBufferWidth,Mt.drawingBufferHeight),mt.renderNoState()})},si.prototype.renderNoState=function(){var K=this.gl;K.useProgram(this.program),K.bindBuffer(K.ARRAY_BUFFER,this.vertexBuffer),K.enableVertexAttribArray(this.attribs.position),K.vertexAttribPointer(this.attribs.position,2,K.FLOAT,!1,8,0),K.uniform4f(this.uniforms.color,1,1,1,1),function(K,mt,It,Mt,Gt,Xt,Me){var sn=1/(mt-It),un=1/(Mt-Gt),Ie=1/(Xt-Me);K[0]=-2*sn,K[1]=0,K[2]=0,K[3]=0,K[4]=0,K[5]=-2*un,K[6]=0,K[7]=0,K[8]=0,K[9]=0,K[10]=2*Ie,K[11]=0,K[12]=(mt+It)*sn,K[13]=(Gt+Mt)*un,K[14]=(Me+Xt)*Ie,K[15]=1}(this.projMat,0,K.drawingBufferWidth,0,K.drawingBufferHeight,.1,1024),K.uniformMatrix4fv(this.uniforms.projectionMat,!1,this.projMat),K.drawArrays(K.TRIANGLE_STRIP,0,4),K.drawArrays(K.TRIANGLE_STRIP,this.gearOffset,this.gearVertexCount),K.drawArrays(K.TRIANGLE_STRIP,this.arrowOffset,this.arrowVertexCount)},lr.prototype.distortInverse=function(K){for(var mt=0,It=1,Mt=K-this.distort(mt);Math.abs(It-mt)>1e-4;){var Gt=K-this.distort(It),Xt=It-Gt*((It-mt)/(Gt-Mt));mt=It,It=Xt,Mt=Gt}return It},lr.prototype.distort=function(K){for(var mt=K*K,It=0,Mt=0;Mt<this.coefficients.length;Mt++)It=mt*(It+this.coefficients[Mt]);return(It+1)*K};var ki=Math.PI/180,Ut=180/Math.PI,jt=function(K,mt,It){this.x=K||0,this.y=mt||0,this.z=It||0};jt.prototype={constructor:jt,set:function(K,mt,It){return this.x=K,this.y=mt,this.z=It,this},copy:function(K){return this.x=K.x,this.y=K.y,this.z=K.z,this},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},normalize:function(){var K=this.length();return 0!==K?this.multiplyScalar(1/K):(this.x=0,this.y=0,this.z=0),this},multiplyScalar:function(K){this.x*=K,this.y*=K,this.z*=K},applyQuaternion:function(K){var mt=this.x,It=this.y,Mt=this.z,Gt=K.x,Xt=K.y,Me=K.z,sn=K.w,un=sn*mt+Xt*Mt-Me*It,Ie=sn*It+Me*mt-Gt*Mt,Be=sn*Mt+Gt*It-Xt*mt,Pn=-Gt*mt-Xt*It-Me*Mt;return this.x=un*sn+Pn*-Gt+Ie*-Me-Be*-Xt,this.y=Ie*sn+Pn*-Xt+Be*-Gt-un*-Me,this.z=Be*sn+Pn*-Me+un*-Xt-Ie*-Gt,this},dot:function(K){return this.x*K.x+this.y*K.y+this.z*K.z},crossVectors:function(K,mt){var It=K.x,Mt=K.y,Gt=K.z,Xt=mt.x,Me=mt.y,sn=mt.z;return this.x=Mt*sn-Gt*Me,this.y=Gt*Xt-It*sn,this.z=It*Me-Mt*Xt,this}};var be,Ze,ke=function(K,mt,It,Mt){this.x=K||0,this.y=mt||0,this.z=It||0,this.w=void 0!==Mt?Mt:1};function pn(K){this.width=K.width||nr(),this.height=K.height||hr(),this.widthMeters=K.widthMeters,this.heightMeters=K.heightMeters,this.bevelMeters=K.bevelMeters}ke.prototype={constructor:ke,set:function(K,mt,It,Mt){return this.x=K,this.y=mt,this.z=It,this.w=Mt,this},copy:function(K){return this.x=K.x,this.y=K.y,this.z=K.z,this.w=K.w,this},setFromEulerXYZ:function(K,mt,It){var Mt=Math.cos(K/2),Gt=Math.cos(mt/2),Xt=Math.cos(It/2),Me=Math.sin(K/2),sn=Math.sin(mt/2),un=Math.sin(It/2);return this.x=Me*Gt*Xt+Mt*sn*un,this.y=Mt*sn*Xt-Me*Gt*un,this.z=Mt*Gt*un+Me*sn*Xt,this.w=Mt*Gt*Xt-Me*sn*un,this},setFromEulerYXZ:function(K,mt,It){var Mt=Math.cos(K/2),Gt=Math.cos(mt/2),Xt=Math.cos(It/2),Me=Math.sin(K/2),sn=Math.sin(mt/2),un=Math.sin(It/2);return this.x=Me*Gt*Xt+Mt*sn*un,this.y=Mt*sn*Xt-Me*Gt*un,this.z=Mt*Gt*un-Me*sn*Xt,this.w=Mt*Gt*Xt+Me*sn*un,this},setFromAxisAngle:function(K,mt){var It=mt/2,Mt=Math.sin(It);return this.x=K.x*Mt,this.y=K.y*Mt,this.z=K.z*Mt,this.w=Math.cos(It),this},multiply:function(K){return this.multiplyQuaternions(this,K)},multiplyQuaternions:function(K,mt){var It=K.x,Mt=K.y,Gt=K.z,Xt=K.w,Me=mt.x,sn=mt.y,un=mt.z,Ie=mt.w;return this.x=It*Ie+Xt*Me+Mt*un-Gt*sn,this.y=Mt*Ie+Xt*sn+Gt*Me-It*un,this.z=Gt*Ie+Xt*un+It*sn-Mt*Me,this.w=Xt*Ie-It*Me-Mt*sn-Gt*un,this},inverse:function(){return this.x*=-1,this.y*=-1,this.z*=-1,this.normalize(),this},normalize:function(){var K=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===K?(this.x=0,this.y=0,this.z=0,this.w=1):(this.x=this.x*(K=1/K),this.y=this.y*K,this.z=this.z*K,this.w=this.w*K),this},slerp:function(K,mt){if(0===mt)return this;if(1===mt)return this.copy(K);var It=this.x,Mt=this.y,Gt=this.z,Xt=this.w,Me=Xt*K.w+It*K.x+Mt*K.y+Gt*K.z;if(Me<0?(this.w=-K.w,this.x=-K.x,this.y=-K.y,this.z=-K.z,Me=-Me):this.copy(K),Me>=1)return this.w=Xt,this.x=It,this.y=Mt,this.z=Gt,this;var sn=Math.acos(Me),un=Math.sqrt(1-Me*Me);if(Math.abs(un)<.001)return this.w=.5*(Xt+this.w),this.x=.5*(It+this.x),this.y=.5*(Mt+this.y),this.z=.5*(Gt+this.z),this;var Ie=Math.sin((1-mt)*sn)/un,Be=Math.sin(mt*sn)/un;return this.w=Xt*Ie+this.w*Be,this.x=It*Ie+this.x*Be,this.y=Mt*Ie+this.y*Be,this.z=Gt*Ie+this.z*Be,this},setFromUnitVectors:(1e-6,function(K,mt){return void 0===be&&(be=new jt),(Ze=K.dot(mt)+1)<1e-6?(Ze=0,Math.abs(K.x)>Math.abs(K.z)?be.set(-K.y,K.x,0):be.set(0,-K.z,K.y)):be.crossVectors(K,mt),this.x=be.x,this.y=be.y,this.z=be.z,this.w=Ze,this.normalize(),this})};var cn=new pn({widthMeters:.11,heightMeters:.062,bevelMeters:.004}),bn=new pn({widthMeters:.1038,heightMeters:.0584,bevelMeters:.004}),qe={CardboardV1:new Mr({id:"CardboardV1",label:"Cardboard I/O 2014",fov:40,interLensDistance:.06,baselineLensDistance:.035,screenLensDistance:.042,distortionCoefficients:[.441,.156],inverseCoefficients:[-.4410035,.42756155,-.4804439,.5460139,-.58821183,.5733938,-.48303202,.33299083,-.17573841,.0651772,-.01488963,.001559834]}),CardboardV2:new Mr({id:"CardboardV2",label:"Cardboard I/O 2015",fov:60,interLensDistance:.064,baselineLensDistance:.035,screenLensDistance:.039,distortionCoefficients:[.34,.55],inverseCoefficients:[-.33836704,-.18162185,.862655,-1.2462051,1.0560602,-.58208317,.21609078,-.05444823,.009177956,-.0009904169,6183535e-11,-16981803e-13]})};function Sn(K,mt){this.viewer=qe.CardboardV2,this.updateDeviceParams(K),this.distortion=new lr(this.viewer.distortionCoefficients);for(var It=0;It<mt.length;It++){var Mt=mt[It];qe[Mt.id]=new Mr(Mt)}}function Mr(K){this.id=K.id,this.label=K.label,this.fov=K.fov,this.interLensDistance=K.interLensDistance,this.baselineLensDistance=K.baselineLensDistance,this.screenLensDistance=K.screenLensDistance,this.distortionCoefficients=K.distortionCoefficients,this.inverseCoefficients=K.inverseCoefficients}Sn.prototype.updateDeviceParams=function(K){this.device=this.determineDevice_(K)||this.device},Sn.prototype.getDevice=function(){return this.device},Sn.prototype.setViewer=function(K){this.viewer=K,this.distortion=new lr(this.viewer.distortionCoefficients)},Sn.prototype.determineDevice_=function(K){if(!K)return xt()?(console.warn("Using fallback iOS device measurements."),bn):(console.warn("Using fallback Android device measurements."),cn);var Mt=.0254/K.ydpi;return new pn({widthMeters:.0254/K.xdpi*nr(),heightMeters:Mt*hr(),bevelMeters:.001*K.bevelMm})},Sn.prototype.getDistortedFieldOfViewLeftEye=function(){var K=this.viewer,mt=this.device,It=this.distortion,Mt=K.screenLensDistance,Xt=K.interLensDistance/2,Me=K.baselineLensDistance-mt.bevelMeters,sn=mt.heightMeters-Me,un=Ut*Math.atan(It.distort((mt.widthMeters-K.interLensDistance)/2/Mt)),Ie=Ut*Math.atan(It.distort(Xt/Mt)),Be=Ut*Math.atan(It.distort(Me/Mt)),Pn=Ut*Math.atan(It.distort(sn/Mt));return{leftDegrees:Math.min(un,K.fov),rightDegrees:Math.min(Ie,K.fov),downDegrees:Math.min(Be,K.fov),upDegrees:Math.min(Pn,K.fov)}},Sn.prototype.getLeftEyeVisibleTanAngles=function(){var K=this.viewer,mt=this.device,It=this.distortion,Mt=Math.tan(-ki*K.fov),Gt=Math.tan(ki*K.fov),Xt=Math.tan(ki*K.fov),Me=Math.tan(-ki*K.fov),sn=mt.widthMeters/4,un=mt.heightMeters/2,Be=K.interLensDistance/2-sn,Pn=-(K.baselineLensDistance-mt.bevelMeters-un),Xn=K.screenLensDistance,dr=It.distort((Be-sn)/Xn),Ar=It.distort((Pn+un)/Xn),xr=It.distort((Be+sn)/Xn),_r=It.distort((Pn-un)/Xn),Pr=new Float32Array(4);return Pr[0]=Math.max(Mt,dr),Pr[1]=Math.min(Gt,Ar),Pr[2]=Math.min(Xt,xr),Pr[3]=Math.max(Me,_r),Pr},Sn.prototype.getLeftEyeNoLensTanAngles=function(){var K=this.viewer,mt=this.device,It=this.distortion,Mt=new Float32Array(4),Gt=It.distortInverse(Math.tan(-ki*K.fov)),Xt=It.distortInverse(Math.tan(ki*K.fov)),Me=It.distortInverse(Math.tan(ki*K.fov)),sn=It.distortInverse(Math.tan(-ki*K.fov)),un=mt.widthMeters/4,Ie=mt.heightMeters/2,Pn=K.interLensDistance/2-un,Xn=-(K.baselineLensDistance-mt.bevelMeters-Ie),dr=K.screenLensDistance,xr=(Xn+Ie)/dr,_r=(Pn+un)/dr,Pr=(Xn-Ie)/dr;return Mt[0]=Math.max(Gt,(Pn-un)/dr),Mt[1]=Math.min(Xt,xr),Mt[2]=Math.min(Me,_r),Mt[3]=Math.max(sn,Pr),Mt},Sn.prototype.getLeftEyeVisibleScreenRect=function(K){var mt=this.viewer,It=this.device,Mt=mt.screenLensDistance,Gt=(It.widthMeters-mt.interLensDistance)/2,Xt=mt.baselineLensDistance-It.bevelMeters,Me=(K[0]*Mt+Gt)/It.widthMeters,Ie=(K[3]*Mt+Xt)/It.heightMeters;return{x:Me,y:Ie,width:(K[2]*Mt+Gt)/It.widthMeters-Me,height:(K[1]*Mt+Xt)/It.heightMeters-Ie}},Sn.prototype.getFieldOfViewLeftEye=function(K){return K?this.getUndistortedFieldOfViewLeftEye():this.getDistortedFieldOfViewLeftEye()},Sn.prototype.getFieldOfViewRightEye=function(K){var mt=this.getFieldOfViewLeftEye(K);return{leftDegrees:mt.rightDegrees,rightDegrees:mt.leftDegrees,upDegrees:mt.upDegrees,downDegrees:mt.downDegrees}},Sn.prototype.getUndistortedFieldOfViewLeftEye=function(){var K=this.getUndistortedParams_();return{leftDegrees:Ut*Math.atan(K.outerDist),rightDegrees:Ut*Math.atan(K.innerDist),downDegrees:Ut*Math.atan(K.bottomDist),upDegrees:Ut*Math.atan(K.topDist)}},Sn.prototype.getUndistortedViewportLeftEye=function(){var K=this.getUndistortedParams_(),It=this.device,Mt=this.viewer.screenLensDistance,Me=It.width/(It.widthMeters/Mt),sn=It.height/(It.heightMeters/Mt),un=Math.round((K.eyePosX-K.outerDist)*Me),Ie=Math.round((K.eyePosY-K.bottomDist)*sn);return{x:un,y:Ie,width:Math.round((K.eyePosX+K.innerDist)*Me)-un,height:Math.round((K.eyePosY+K.topDist)*sn)-Ie}},Sn.prototype.getUndistortedParams_=function(){var K=this.viewer,mt=this.device,Mt=K.screenLensDistance,Gt=K.interLensDistance/2/Mt,Me=mt.heightMeters/Mt,sn=mt.widthMeters/Mt/2-Gt,un=(K.baselineLensDistance-mt.bevelMeters)/Mt,Be=this.distortion.distortInverse(Math.tan(ki*K.fov)),Pn=Math.min(sn,Be),Xn=Math.min(Gt,Be),dr=Math.min(un,Be);return{outerDist:Pn,innerDist:Xn,topDist:Math.min(Me-un,Be),bottomDist:dr,eyePosX:sn,eyePosY:un}},Sn.Viewers=qe;var jn={format:1,last_updated:"2019-11-09T17:36:14Z",devices:[{type:"android",rules:[{mdmh:"asus/*/Nexus 7/*"},{ua:"Nexus 7"}],dpi:[320.8,323],bw:3,ac:500},{type:"android",rules:[{mdmh:"asus/*/ASUS_X00PD/*"},{ua:"ASUS_X00PD"}],dpi:245,bw:3,ac:500},{type:"android",rules:[{mdmh:"asus/*/ASUS_X008D/*"},{ua:"ASUS_X008D"}],dpi:282,bw:3,ac:500},{type:"android",rules:[{mdmh:"asus/*/ASUS_Z00AD/*"},{ua:"ASUS_Z00AD"}],dpi:[403,404.6],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Google/*/Pixel 2 XL/*"},{ua:"Pixel 2 XL"}],dpi:537.9,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Google/*/Pixel 3 XL/*"},{ua:"Pixel 3 XL"}],dpi:[558.5,553.8],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Google/*/Pixel XL/*"},{ua:"Pixel XL"}],dpi:[537.9,533],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Google/*/Pixel 3/*"},{ua:"Pixel 3"}],dpi:442.4,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Google/*/Pixel 2/*"},{ua:"Pixel 2"}],dpi:441,bw:3,ac:500},{type:"android",rules:[{mdmh:"Google/*/Pixel/*"},{ua:"Pixel"}],dpi:[432.6,436.7],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"HTC/*/HTC6435LVW/*"},{ua:"HTC6435LVW"}],dpi:[449.7,443.3],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"HTC/*/HTC One XL/*"},{ua:"HTC One XL"}],dpi:[315.3,314.6],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"htc/*/Nexus 9/*"},{ua:"Nexus 9"}],dpi:289,bw:3,ac:500},{type:"android",rules:[{mdmh:"HTC/*/HTC One M9/*"},{ua:"HTC One M9"}],dpi:[442.5,443.3],bw:3,ac:500},{type:"android",rules:[{mdmh:"HTC/*/HTC One_M8/*"},{ua:"HTC One_M8"}],dpi:[449.7,447.4],bw:3,ac:500},{type:"android",rules:[{mdmh:"HTC/*/HTC One/*"},{ua:"HTC One"}],dpi:472.8,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Huawei/*/Nexus 6P/*"},{ua:"Nexus 6P"}],dpi:[515.1,518],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Huawei/*/BLN-L24/*"},{ua:"HONORBLN-L24"}],dpi:480,bw:4,ac:500},{type:"android",rules:[{mdmh:"Huawei/*/BKL-L09/*"},{ua:"BKL-L09"}],dpi:403,bw:3.47,ac:500},{type:"android",rules:[{mdmh:"LENOVO/*/Lenovo PB2-690Y/*"},{ua:"Lenovo PB2-690Y"}],dpi:[457.2,454.713],bw:3,ac:500},{type:"android",rules:[{mdmh:"LGE/*/Nexus 5X/*"},{ua:"Nexus 5X"}],dpi:[422,419.9],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"LGE/*/LGMS345/*"},{ua:"LGMS345"}],dpi:[221.7,219.1],bw:3,ac:500},{type:"android",rules:[{mdmh:"LGE/*/LG-D800/*"},{ua:"LG-D800"}],dpi:[422,424.1],bw:3,ac:500},{type:"android",rules:[{mdmh:"LGE/*/LG-D850/*"},{ua:"LG-D850"}],dpi:[537.9,541.9],bw:3,ac:500},{type:"android",rules:[{mdmh:"LGE/*/VS985 4G/*"},{ua:"VS985 4G"}],dpi:[537.9,535.6],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"LGE/*/Nexus 5/*"},{ua:"Nexus 5 B"}],dpi:[442.4,444.8],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"LGE/*/Nexus 4/*"},{ua:"Nexus 4"}],dpi:[319.8,318.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"LGE/*/LG-P769/*"},{ua:"LG-P769"}],dpi:[240.6,247.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"LGE/*/LGMS323/*"},{ua:"LGMS323"}],dpi:[206.6,204.6],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"LGE/*/LGLS996/*"},{ua:"LGLS996"}],dpi:[403.4,401.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Micromax/*/4560MMX/*"},{ua:"4560MMX"}],dpi:[240,219.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Micromax/*/A250/*"},{ua:"Micromax A250"}],dpi:[480,446.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Micromax/*/Micromax AQ4501/*"},{ua:"Micromax AQ4501"}],dpi:240,bw:3,ac:500},{type:"android",rules:[{mdmh:"motorola/*/G5/*"},{ua:"Moto G (5) Plus"}],dpi:[403.4,403],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/DROID RAZR/*"},{ua:"DROID RAZR"}],dpi:[368.1,256.7],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/XT830C/*"},{ua:"XT830C"}],dpi:[254,255.9],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/XT1021/*"},{ua:"XT1021"}],dpi:[254,256.7],bw:3,ac:500},{type:"android",rules:[{mdmh:"motorola/*/XT1023/*"},{ua:"XT1023"}],dpi:[254,256.7],bw:3,ac:500},{type:"android",rules:[{mdmh:"motorola/*/XT1028/*"},{ua:"XT1028"}],dpi:[326.6,327.6],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/XT1034/*"},{ua:"XT1034"}],dpi:[326.6,328.4],bw:3,ac:500},{type:"android",rules:[{mdmh:"motorola/*/XT1053/*"},{ua:"XT1053"}],dpi:[315.3,316.1],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/XT1562/*"},{ua:"XT1562"}],dpi:[403.4,402.7],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/Nexus 6/*"},{ua:"Nexus 6 B"}],dpi:[494.3,489.7],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/XT1063/*"},{ua:"XT1063"}],dpi:[295,296.6],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/XT1064/*"},{ua:"XT1064"}],dpi:[295,295.6],bw:3,ac:500},{type:"android",rules:[{mdmh:"motorola/*/XT1092/*"},{ua:"XT1092"}],dpi:[422,424.1],bw:3,ac:500},{type:"android",rules:[{mdmh:"motorola/*/XT1095/*"},{ua:"XT1095"}],dpi:[422,423.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"motorola/*/G4/*"},{ua:"Moto G (4)"}],dpi:401,bw:4,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/A0001/*"},{ua:"A0001"}],dpi:[403.4,401],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONE E1001/*"},{ua:"ONE E1001"}],dpi:[442.4,441.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONE E1003/*"},{ua:"ONE E1003"}],dpi:[442.4,441.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONE E1005/*"},{ua:"ONE E1005"}],dpi:[442.4,441.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONE A2001/*"},{ua:"ONE A2001"}],dpi:[391.9,405.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONE A2003/*"},{ua:"ONE A2003"}],dpi:[391.9,405.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONE A2005/*"},{ua:"ONE A2005"}],dpi:[391.9,405.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONEPLUS A3000/*"},{ua:"ONEPLUS A3000"}],dpi:401,bw:3,ac:500},{type:"android",rules:[{mdmh:"OnePlus/*/ONEPLUS A3003/*"},{ua:"ONEPLUS A3003"}],dpi:401,bw:3,ac:500},{type:"android",rules:[{mdmh:"OnePlus/*/ONEPLUS A3010/*"},{ua:"ONEPLUS A3010"}],dpi:401,bw:3,ac:500},{type:"android",rules:[{mdmh:"OnePlus/*/ONEPLUS A5000/*"},{ua:"ONEPLUS A5000 "}],dpi:[403.411,399.737],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONE A5010/*"},{ua:"ONEPLUS A5010"}],dpi:[403,400],bw:2,ac:1e3},{type:"android",rules:[{mdmh:"OnePlus/*/ONEPLUS A6000/*"},{ua:"ONEPLUS A6000"}],dpi:401,bw:3,ac:500},{type:"android",rules:[{mdmh:"OnePlus/*/ONEPLUS A6003/*"},{ua:"ONEPLUS A6003"}],dpi:401,bw:3,ac:500},{type:"android",rules:[{mdmh:"OnePlus/*/ONEPLUS A6010/*"},{ua:"ONEPLUS A6010"}],dpi:401,bw:2,ac:500},{type:"android",rules:[{mdmh:"OnePlus/*/ONEPLUS A6013/*"},{ua:"ONEPLUS A6013"}],dpi:401,bw:2,ac:500},{type:"android",rules:[{mdmh:"OPPO/*/X909/*"},{ua:"X909"}],dpi:[442.4,444.1],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/GT-I9082/*"},{ua:"GT-I9082"}],dpi:[184.7,185.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G360P/*"},{ua:"SM-G360P"}],dpi:[196.7,205.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/Nexus S/*"},{ua:"Nexus S"}],dpi:[234.5,229.8],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/GT-I9300/*"},{ua:"GT-I9300"}],dpi:[304.8,303.9],bw:5,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-T230NU/*"},{ua:"SM-T230NU"}],dpi:216,bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SGH-T399/*"},{ua:"SGH-T399"}],dpi:[217.7,231.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SGH-M919/*"},{ua:"SGH-M919"}],dpi:[440.8,437.7],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-N9005/*"},{ua:"SM-N9005"}],dpi:[386.4,387],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SAMSUNG-SM-N900A/*"},{ua:"SAMSUNG-SM-N900A"}],dpi:[386.4,387.7],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/GT-I9500/*"},{ua:"GT-I9500"}],dpi:[442.5,443.3],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/GT-I9505/*"},{ua:"GT-I9505"}],dpi:439.4,bw:4,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G900F/*"},{ua:"SM-G900F"}],dpi:[415.6,431.6],bw:5,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G900M/*"},{ua:"SM-G900M"}],dpi:[415.6,431.6],bw:5,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G800F/*"},{ua:"SM-G800F"}],dpi:326.8,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G906S/*"},{ua:"SM-G906S"}],dpi:[562.7,572.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/GT-I9300/*"},{ua:"GT-I9300"}],dpi:[306.7,304.8],bw:5,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-T535/*"},{ua:"SM-T535"}],dpi:[142.6,136.4],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-N920C/*"},{ua:"SM-N920C"}],dpi:[515.1,518.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-N920P/*"},{ua:"SM-N920P"}],dpi:[386.3655,390.144],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-N920W8/*"},{ua:"SM-N920W8"}],dpi:[515.1,518.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/GT-I9300I/*"},{ua:"GT-I9300I"}],dpi:[304.8,305.8],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/GT-I9195/*"},{ua:"GT-I9195"}],dpi:[249.4,256.7],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SPH-L520/*"},{ua:"SPH-L520"}],dpi:[249.4,255.9],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SAMSUNG-SGH-I717/*"},{ua:"SAMSUNG-SGH-I717"}],dpi:285.8,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SPH-D710/*"},{ua:"SPH-D710"}],dpi:[217.7,204.2],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/GT-N7100/*"},{ua:"GT-N7100"}],dpi:265.1,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SCH-I605/*"},{ua:"SCH-I605"}],dpi:265.1,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/Galaxy Nexus/*"},{ua:"Galaxy Nexus"}],dpi:[315.3,314.2],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-N910H/*"},{ua:"SM-N910H"}],dpi:[515.1,518],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-N910C/*"},{ua:"SM-N910C"}],dpi:[515.2,520.2],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G130M/*"},{ua:"SM-G130M"}],dpi:[165.9,164.8],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G928I/*"},{ua:"SM-G928I"}],dpi:[515.1,518.4],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G920F/*"},{ua:"SM-G920F"}],dpi:580.6,bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G920P/*"},{ua:"SM-G920P"}],dpi:[522.5,577],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G925F/*"},{ua:"SM-G925F"}],dpi:580.6,bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G925V/*"},{ua:"SM-G925V"}],dpi:[522.5,576.6],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G930F/*"},{ua:"SM-G930F"}],dpi:576.6,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G935F/*"},{ua:"SM-G935F"}],dpi:533,bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G950F/*"},{ua:"SM-G950F"}],dpi:[562.707,565.293],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G955U/*"},{ua:"SM-G955U"}],dpi:[522.514,525.762],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G955F/*"},{ua:"SM-G955F"}],dpi:[522.514,525.762],bw:3,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G960F/*"},{ua:"SM-G960F"}],dpi:[569.575,571.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G9600/*"},{ua:"SM-G9600"}],dpi:[569.575,571.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G960T/*"},{ua:"SM-G960T"}],dpi:[569.575,571.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G960N/*"},{ua:"SM-G960N"}],dpi:[569.575,571.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G960U/*"},{ua:"SM-G960U"}],dpi:[569.575,571.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G9608/*"},{ua:"SM-G9608"}],dpi:[569.575,571.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G960FD/*"},{ua:"SM-G960FD"}],dpi:[569.575,571.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G960W/*"},{ua:"SM-G960W"}],dpi:[569.575,571.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G965F/*"},{ua:"SM-G965F"}],dpi:529,bw:2,ac:1e3},{type:"android",rules:[{mdmh:"Sony/*/C6903/*"},{ua:"C6903"}],dpi:[442.5,443.3],bw:3,ac:500},{type:"android",rules:[{mdmh:"Sony/*/D6653/*"},{ua:"D6653"}],dpi:[428.6,427.6],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Sony/*/E6653/*"},{ua:"E6653"}],dpi:[428.6,425.7],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Sony/*/E6853/*"},{ua:"E6853"}],dpi:[403.4,401.9],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Sony/*/SGP321/*"},{ua:"SGP321"}],dpi:[224.7,224.1],bw:3,ac:500},{type:"android",rules:[{mdmh:"TCT/*/ALCATEL ONE TOUCH Fierce/*"},{ua:"ALCATEL ONE TOUCH Fierce"}],dpi:[240,247.5],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"THL/*/thl 5000/*"},{ua:"thl 5000"}],dpi:[480,443.3],bw:3,ac:1e3},{type:"android",rules:[{mdmh:"Fly/*/IQ4412/*"},{ua:"IQ4412"}],dpi:307.9,bw:3,ac:1e3},{type:"android",rules:[{mdmh:"ZTE/*/ZTE Blade L2/*"},{ua:"ZTE Blade L2"}],dpi:240,bw:3,ac:500},{type:"android",rules:[{mdmh:"BENEVE/*/VR518/*"},{ua:"VR518"}],dpi:480,bw:3,ac:500},{type:"ios",rules:[{res:[640,960]}],dpi:[325.1,328.4],bw:4,ac:1e3},{type:"ios",rules:[{res:[640,1136]}],dpi:[317.1,320.2],bw:3,ac:1e3},{type:"ios",rules:[{res:[750,1334]}],dpi:326.4,bw:4,ac:1e3},{type:"ios",rules:[{res:[1242,2208]}],dpi:[453.6,458.4],bw:4,ac:1e3},{type:"ios",rules:[{res:[1125,2001]}],dpi:[410.9,415.4],bw:4,ac:1e3},{type:"ios",rules:[{res:[1125,2436]}],dpi:458,bw:4,ac:1e3},{type:"android",rules:[{mdmh:"Huawei/*/EML-L29/*"},{ua:"EML-L29"}],dpi:428,bw:3.45,ac:500},{type:"android",rules:[{mdmh:"Nokia/*/Nokia 7.1/*"},{ua:"Nokia 7.1"}],dpi:[432,431.9],bw:3,ac:500},{type:"ios",rules:[{res:[1242,2688]}],dpi:458,bw:4,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G570M/*"},{ua:"SM-G570M"}],dpi:320,bw:3.684,ac:1e3},{type:"android",rules:[{mdmh:"samsung/*/SM-G970F/*"},{ua:"SM-G970F"}],dpi:438,bw:2.281,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G973F/*"},{ua:"SM-G973F"}],dpi:550,bw:2.002,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G975F/*"},{ua:"SM-G975F"}],dpi:522,bw:2.054,ac:500},{type:"android",rules:[{mdmh:"samsung/*/SM-G977F/*"},{ua:"SM-G977F"}],dpi:505,bw:2.334,ac:500},{type:"ios",rules:[{res:[828,1792]}],dpi:326,bw:5,ac:500}]};function Kn(K,mt){if(this.dpdb=jn,this.recalculateDeviceParams_(),K){this.onDeviceParamsUpdated=mt;var It=new XMLHttpRequest,Mt=this;It.open("GET",K,!0),It.addEventListener("load",function(){Mt.loading=!1,It.status>=200&&It.status<=299?(Mt.dpdb=JSON.parse(It.response),Mt.recalculateDeviceParams_()):console.error("Error loading online DPDB!")}),It.send()}}function gn(K){this.xdpi=K.xdpi,this.ydpi=K.ydpi,this.bevelMm=K.bevelMm}function vr(K,mt){this.set(K,mt)}function Tr(K,mt){this.kFilter=K,this.isDebug=mt,this.currentAccelMeasurement=new vr,this.currentGyroMeasurement=new vr,this.previousGyroMeasurement=new vr,this.filterQ=xt()?new ke(-1,0,0,1):new ke(1,0,0,1),this.previousFilterQ=new ke,this.previousFilterQ.copy(this.filterQ),this.accelQ=new ke,this.isOrientationInitialized=!1,this.estimatedGravity=new jt,this.measuredGravity=new jt,this.gyroIntegralQ=new ke}function rr(K,mt){this.predictionTimeS=K,this.isDebug=mt,this.previousQ=new ke,this.previousTimestampS=null,this.deltaQ=new ke,this.outQ=new ke}function wn(K,mt,It,Mt){this.yawOnly=It,this.accelerometer=new jt,this.gyroscope=new jt,this.filter=new Tr(K,Mt),this.posePredictor=new rr(mt,Mt),this.isFirefoxAndroid=ve(),this.isIOS=xt();var Gt=xe();this.isDeviceMotionInRadians=!this.isIOS&&Gt&&Gt<66,this.isWithoutDeviceMotion=en()||Ge(),this.filterToWorldQ=new ke,xt()?this.filterToWorldQ.setFromAxisAngle(new jt(1,0,0),Math.PI/2):this.filterToWorldQ.setFromAxisAngle(new jt(1,0,0),-Math.PI/2),this.inverseWorldToScreenQ=new ke,this.worldToScreenQ=new ke,this.originalPoseAdjustQ=new ke,this.originalPoseAdjustQ.setFromAxisAngle(new jt(0,0,1),-window.orientation*Math.PI/180),this.setScreenTransform_(),vn()&&this.filterToWorldQ.multiply(this.inverseWorldToScreenQ),this.resetQ=new ke,this.orientationOut_=new Float32Array(4),this.start()}Kn.prototype.getDeviceParams=function(){return this.deviceParams},Kn.prototype.recalculateDeviceParams_=function(){var K=this.calcDeviceParams_();K?(this.deviceParams=K,this.onDeviceParamsUpdated&&this.onDeviceParamsUpdated(this.deviceParams)):console.error("Failed to recalculate device parameters.")},Kn.prototype.calcDeviceParams_=function(){var K=this.dpdb;if(!K)return console.error("DPDB not available."),null;if(1!=K.format)return console.error("DPDB has unexpected format version."),null;if(!K.devices||!K.devices.length)return console.error("DPDB does not have a devices section."),null;var mt=navigator.userAgent||navigator.vendor||window.opera,It=nr(),Mt=hr();if(!K.devices)return console.error("DPDB has no devices section."),null;for(var Gt=0;Gt<K.devices.length;Gt++){var Xt=K.devices[Gt];if(Xt.rules)if("ios"==Xt.type||"android"==Xt.type){if(xt()==("ios"==Xt.type)){for(var Me=!1,sn=0;sn<Xt.rules.length;sn++)if(this.ruleMatches_(Xt.rules[sn],mt,It,Mt)){Me=!0;break}if(Me)return new gn({xdpi:Xt.dpi[0]||Xt.dpi,ydpi:Xt.dpi[1]||Xt.dpi,bevelMm:Xt.bw})}}else console.warn("Device["+Gt+"] has invalid type.");else console.warn("Device["+Gt+"] has no rules section.")}return console.warn("No DPDB device match."),null},Kn.prototype.ruleMatches_=function(K,mt,It,Mt){if(!K.ua&&!K.res||(K.ua&&"SM"===K.ua.substring(0,2)&&(K.ua=K.ua.substring(0,7)),K.ua&&mt.indexOf(K.ua)<0))return!1;if(K.res){if(!K.res[0]||!K.res[1])return!1;var Gt=K.res[0],Xt=K.res[1];if(Math.min(It,Mt)!=Math.min(Gt,Xt)||Math.max(It,Mt)!=Math.max(Gt,Xt))return!1}return!0},vr.prototype.set=function(K,mt){this.sample=K,this.timestampS=mt},vr.prototype.copy=function(K){this.set(K.sample,K.timestampS)},Tr.prototype.addAccelMeasurement=function(K,mt){this.currentAccelMeasurement.set(K,mt)},Tr.prototype.addGyroMeasurement=function(K,mt){this.currentGyroMeasurement.set(K,mt),function(K){return!(isNaN(K)||K<=.001||K>1)}(mt-this.previousGyroMeasurement.timestampS)&&this.run_(),this.previousGyroMeasurement.copy(this.currentGyroMeasurement)},Tr.prototype.run_=function(){if(!this.isOrientationInitialized)return this.accelQ=this.accelToQuaternion_(this.currentAccelMeasurement.sample),this.previousFilterQ.copy(this.accelQ),void(this.isOrientationInitialized=!0);var mt=this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample,this.currentGyroMeasurement.timestampS-this.previousGyroMeasurement.timestampS);this.gyroIntegralQ.multiply(mt),this.filterQ.copy(this.previousFilterQ),this.filterQ.multiply(mt);var It=new ke;It.copy(this.filterQ),It.inverse(),this.estimatedGravity.set(0,0,-1),this.estimatedGravity.applyQuaternion(It),this.estimatedGravity.normalize(),this.measuredGravity.copy(this.currentAccelMeasurement.sample),this.measuredGravity.normalize();var Mt=new ke;Mt.setFromUnitVectors(this.estimatedGravity,this.measuredGravity),Mt.inverse(),this.isDebug&&console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)",Ut*function(K){return K.w>1?(console.warn("getQuaternionAngle: w > 1"),0):2*Math.acos(K.w)}(Mt),this.estimatedGravity.x.toFixed(1),this.estimatedGravity.y.toFixed(1),this.estimatedGravity.z.toFixed(1),this.measuredGravity.x.toFixed(1),this.measuredGravity.y.toFixed(1),this.measuredGravity.z.toFixed(1));var Gt=new ke;Gt.copy(this.filterQ),Gt.multiply(Mt),this.filterQ.slerp(Gt,1-this.kFilter),this.previousFilterQ.copy(this.filterQ)},Tr.prototype.getOrientation=function(){return this.filterQ},Tr.prototype.accelToQuaternion_=function(K){var mt=new jt;mt.copy(K),mt.normalize();var It=new ke;return It.setFromUnitVectors(new jt(0,0,-1),mt),It.inverse(),It},Tr.prototype.gyroToQuaternionDelta_=function(K,mt){var It=new ke,Mt=new jt;return Mt.copy(K),Mt.normalize(),It.setFromAxisAngle(Mt,K.length()*mt),It},rr.prototype.getPrediction=function(K,mt,It){if(!this.previousTimestampS)return this.previousQ.copy(K),this.previousTimestampS=It,K;var Mt=new jt;Mt.copy(mt),Mt.normalize();var Gt=mt.length();return Gt<20*ki?(this.isDebug&&console.log("Moving slowly, at %s deg/s: no prediction",(Ut*Gt).toFixed(1)),this.outQ.copy(K),this.previousQ.copy(K),this.outQ):(this.deltaQ.setFromAxisAngle(Mt,Gt*this.predictionTimeS),this.outQ.copy(this.previousQ),this.outQ.multiply(this.deltaQ),this.previousQ.copy(K),this.previousTimestampS=It,this.outQ)},wn.prototype.getPosition=function(){return null},wn.prototype.getOrientation=function(){var K=void 0;if(this.isWithoutDeviceMotion&&this._deviceOrientationQ)return this.deviceOrientationFixQ=this.deviceOrientationFixQ||(It=(new ke).setFromAxisAngle(new jt(0,0,-1),0),Mt=new ke,-90===window.orientation?Mt.setFromAxisAngle(new jt(0,1,0),Math.PI/-2):Mt.setFromAxisAngle(new jt(0,1,0),Math.PI/2),It.multiply(Mt)),this.deviceOrientationFilterToWorldQ=this.deviceOrientationFilterToWorldQ||((mt=new ke).setFromAxisAngle(new jt(1,0,0),-Math.PI/2),mt),K=this._deviceOrientationQ,(Gt=new ke).copy(K),Gt.multiply(this.deviceOrientationFilterToWorldQ),Gt.multiply(this.resetQ),Gt.multiply(this.worldToScreenQ),Gt.multiplyQuaternions(this.deviceOrientationFixQ,Gt),this.yawOnly&&(Gt.x=0,Gt.z=0,Gt.normalize()),this.orientationOut_[0]=Gt.x,this.orientationOut_[1]=Gt.y,this.orientationOut_[2]=Gt.z,this.orientationOut_[3]=Gt.w,this.orientationOut_;var mt,It,Mt,Gt,Xt=this.filter.getOrientation();return K=this.posePredictor.getPrediction(Xt,this.gyroscope,this.previousTimestampS),(Gt=new ke).copy(this.filterToWorldQ),Gt.multiply(this.resetQ),Gt.multiply(K),Gt.multiply(this.worldToScreenQ),this.yawOnly&&(Gt.x=0,Gt.z=0,Gt.normalize()),this.orientationOut_[0]=Gt.x,this.orientationOut_[1]=Gt.y,this.orientationOut_[2]=Gt.z,this.orientationOut_[3]=Gt.w,this.orientationOut_},wn.prototype.resetPose=function(){this.resetQ.copy(this.filter.getOrientation()),this.resetQ.x=0,this.resetQ.y=0,this.resetQ.z*=-1,this.resetQ.normalize(),vn()&&this.resetQ.multiply(this.inverseWorldToScreenQ),this.resetQ.multiply(this.originalPoseAdjustQ)},wn.prototype.onDeviceOrientation_=function(K){this._deviceOrientationQ=this._deviceOrientationQ||new ke;var mt=K.alpha,It=K.beta,Mt=K.gamma;mt=(mt||0)*Math.PI/180,It=(It||0)*Math.PI/180,Mt=(Mt||0)*Math.PI/180,this._deviceOrientationQ.setFromEulerYXZ(It,mt,-Mt)},wn.prototype.onDeviceMotion_=function(K){this.updateDeviceMotion_(K)},wn.prototype.updateDeviceMotion_=function(K){var mt=K.accelerationIncludingGravity,It=K.rotationRate,Mt=K.timeStamp/1e3,Gt=Mt-this.previousTimestampS;return Gt<0?(qs("fusion-pose-sensor:invalid:non-monotonic","Invalid timestamps detected: non-monotonic timestamp from devicemotion"),void(this.previousTimestampS=Mt)):Gt<=.001||Gt>1?(qs("fusion-pose-sensor:invalid:outside-threshold","Invalid timestamps detected: Timestamp from devicemotion outside expected range."),void(this.previousTimestampS=Mt)):(this.accelerometer.set(-mt.x,-mt.y,-mt.z),It&&(nn()?this.gyroscope.set(-It.beta,It.alpha,It.gamma):this.gyroscope.set(It.alpha,It.beta,It.gamma),this.isDeviceMotionInRadians||this.gyroscope.multiplyScalar(Math.PI/180),this.filter.addGyroMeasurement(this.gyroscope,Mt)),this.filter.addAccelMeasurement(this.accelerometer,Mt),void(this.previousTimestampS=Mt))},wn.prototype.onOrientationChange_=function(K){this.setScreenTransform_()},wn.prototype.onMessage_=function(K){var mt=K.data;mt&&mt.type&&"devicemotion"===mt.type.toLowerCase()&&this.updateDeviceMotion_(mt.deviceMotionEvent)},wn.prototype.setScreenTransform_=function(){switch(this.worldToScreenQ.set(0,0,0,1),window.orientation){case 0:break;case 90:this.worldToScreenQ.setFromAxisAngle(new jt(0,0,1),-Math.PI/2);break;case-90:this.worldToScreenQ.setFromAxisAngle(new jt(0,0,1),Math.PI/2)}this.inverseWorldToScreenQ.copy(this.worldToScreenQ),this.inverseWorldToScreenQ.inverse()},wn.prototype.start=function(){this.onDeviceMotionCallback_=this.onDeviceMotion_.bind(this),this.onOrientationChangeCallback_=this.onOrientationChange_.bind(this),this.onMessageCallback_=this.onMessage_.bind(this),this.onDeviceOrientationCallback_=this.onDeviceOrientation_.bind(this),xt()&&function(){var K=window.self!==window.top,mt=ys(document.referrer),It=ys(window.location.href);return K&&mt!==It}()&&window.addEventListener("message",this.onMessageCallback_),window.addEventListener("orientationchange",this.onOrientationChangeCallback_),this.isWithoutDeviceMotion?window.addEventListener("deviceorientation",this.onDeviceOrientationCallback_):window.addEventListener("devicemotion",this.onDeviceMotionCallback_)},wn.prototype.stop=function(){window.removeEventListener("devicemotion",this.onDeviceMotionCallback_),window.removeEventListener("deviceorientation",this.onDeviceOrientationCallback_),window.removeEventListener("orientationchange",this.onOrientationChangeCallback_),window.removeEventListener("message",this.onMessageCallback_)};var xi=new jt(1,0,0),cr=new jt(0,0,1),ai=new ke;ai.setFromAxisAngle(xi,-Math.PI/2),ai.multiply((new ke).setFromAxisAngle(cr,Math.PI/2));var ci=function(){function K(mt){(function(K,mt){if(!(K instanceof mt))throw new TypeError("Cannot call a class as a function")})(this,K),this.config=mt,this.sensor=null,this.fusionSensor=null,this._out=new Float32Array(4),this.api=null,this.errors=[],this._sensorQ=new ke,this._outQ=new ke,this._onSensorRead=this._onSensorRead.bind(this),this._onSensorError=this._onSensorError.bind(this),this.init()}return pt(K,[{key:"init",value:function(){var mt=null;try{(mt=new RelativeOrientationSensor({frequency:60,referenceFrame:"screen"})).addEventListener("error",this._onSensorError)}catch(It){this.errors.push(It),"SecurityError"===It.name?(console.error("Cannot construct sensors due to the Feature Policy"),console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.'),this.useDeviceMotion()):"ReferenceError"===It.name?this.useDeviceMotion():console.error(It)}mt&&(this.api="sensor",this.sensor=mt,this.sensor.addEventListener("reading",this._onSensorRead),this.sensor.start())}},{key:"useDeviceMotion",value:function(){this.api="devicemotion",this.fusionSensor=new wn(this.config.K_FILTER,this.config.PREDICTION_TIME_S,this.config.YAW_ONLY,this.config.DEBUG),this.sensor&&(this.sensor.removeEventListener("reading",this._onSensorRead),this.sensor.removeEventListener("error",this._onSensorError),this.sensor=null)}},{key:"getOrientation",value:function(){if(this.fusionSensor)return this.fusionSensor.getOrientation();if(!this.sensor||!this.sensor.quaternion)return this._out[0]=this._out[1]=this._out[2]=0,this._out[3]=1,this._out;var mt=this.sensor.quaternion;this._sensorQ.set(mt[0],mt[1],mt[2],mt[3]);var It=this._outQ;return It.copy(ai),It.multiply(this._sensorQ),this.config.YAW_ONLY&&(It.x=It.z=0,It.normalize()),this._out[0]=It.x,this._out[1]=It.y,this._out[2]=It.z,this._out[3]=It.w,this._out}},{key:"_onSensorError",value:function(mt){this.errors.push(mt.error),"NotAllowedError"===mt.error.name?console.error("Permission to access sensor was denied"):"NotReadableError"===mt.error.name?console.error("Sensor could not be read"):console.error(mt.error),this.useDeviceMotion()}},{key:"_onSensorRead",value:function(){}}]),K}();function jr(){this.loadIcon_();var K=document.createElement("div");(Xt=K.style).position="fixed",Xt.top=0,Xt.right=0,Xt.bottom=0,Xt.left=0,Xt.backgroundColor="gray",Xt.fontFamily="sans-serif",Xt.zIndex=1e6;var mt=document.createElement("img");mt.src=this.icon,(Xt=mt.style).marginLeft="25%",Xt.marginTop="25%",Xt.width="50%",K.appendChild(mt);var It=document.createElement("div");(Xt=It.style).textAlign="center",Xt.fontSize="16px",Xt.lineHeight="24px",Xt.margin="24px 25%",Xt.width="50%",It.innerHTML="Place your phone into your Cardboard viewer.",K.appendChild(It);var Mt=document.createElement("div");(Xt=Mt.style).backgroundColor="#CFD8DC",Xt.position="fixed",Xt.bottom=0,Xt.width="100%",Xt.height="48px",Xt.padding="14px 24px",Xt.boxSizing="border-box",Xt.color="#656A6B",K.appendChild(Mt);var Gt=document.createElement("div");Gt.style.float="left",Gt.innerHTML="No Cardboard viewer?";var Xt,Me=document.createElement("a");Me.href="https://www.google.com/get/cardboard/get-cardboard/",Me.innerHTML="get one",Me.target="_blank",(Xt=Me.style).float="right",Xt.fontWeight=600,Xt.textTransform="uppercase",Xt.borderLeft="1px solid gray",Xt.paddingLeft="24px",Xt.textDecoration="none",Xt.color="#656A6B",Mt.appendChild(Gt),Mt.appendChild(Me),this.overlay=K,this.text=It,this.hide()}jr.prototype.show=function(K){K||this.overlay.parentElement?K&&(this.overlay.parentElement&&this.overlay.parentElement!=K&&this.overlay.parentElement.removeChild(this.overlay),K.appendChild(this.overlay)):document.body.appendChild(this.overlay),this.overlay.style.display="block";var mt=this.overlay.querySelector("img").style;vn()?(mt.width="20%",mt.marginLeft="40%",mt.marginTop="3%"):(mt.width="50%",mt.marginLeft="25%",mt.marginTop="25%")},jr.prototype.hide=function(){this.overlay.style.display="none"},jr.prototype.showTemporarily=function(K,mt){this.show(mt),this.timer=setTimeout(this.hide.bind(this),K)},jr.prototype.disableShowTemporarily=function(){clearTimeout(this.timer)},jr.prototype.update=function(){this.disableShowTemporarily(),!vn()&&ha()?this.show():this.hide()},jr.prototype.loadIcon_=function(){this.icon=function(K,mt){return"data:"+K+","+encodeURIComponent(mt)}("image/svg+xml","<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>")};var de="CardboardV1",go="WEBVR_CARDBOARD_VIEWER";function Bi(K){try{this.selectedKey=localStorage.getItem(go)}catch(mt){console.error("Failed to load viewer profile: %s",mt)}this.selectedKey||(this.selectedKey=K||de),this.dialog=this.createDialog_(Sn.Viewers),this.root=null,this.onChangeCallbacks_=[]}Bi.prototype.show=function(K){this.root=K,K.appendChild(this.dialog),this.dialog.querySelector("#"+this.selectedKey).checked=!0,this.dialog.style.display="block"},Bi.prototype.hide=function(){this.root&&this.root.contains(this.dialog)&&this.root.removeChild(this.dialog),this.dialog.style.display="none"},Bi.prototype.getCurrentViewer=function(){return Sn.Viewers[this.selectedKey]},Bi.prototype.getSelectedKey_=function(){var K=this.dialog.querySelector("input[name=field]:checked");return K?K.id:null},Bi.prototype.onChange=function(K){this.onChangeCallbacks_.push(K)},Bi.prototype.fireOnChange_=function(K){for(var mt=0;mt<this.onChangeCallbacks_.length;mt++)this.onChangeCallbacks_[mt](K)},Bi.prototype.onSave_=function(){if(this.selectedKey=this.getSelectedKey_(),this.selectedKey&&Sn.Viewers[this.selectedKey]){this.fireOnChange_(Sn.Viewers[this.selectedKey]);try{localStorage.setItem(go,this.selectedKey)}catch(K){console.error("Failed to save viewer profile: %s",K)}this.hide()}else console.error("ViewerSelector.onSave_: this should never happen!")},Bi.prototype.createDialog_=function(K){var mt=document.createElement("div");mt.classList.add("webvr-polyfill-viewer-selector"),mt.style.display="none";var It=document.createElement("div");(Xt=It.style).position="fixed",Xt.left=0,Xt.top=0,Xt.width="100%",Xt.height="100%",Xt.background="rgba(0, 0, 0, 0.3)",It.addEventListener("click",this.hide.bind(this));var Gt=document.createElement("div"),Xt=Gt.style;for(var Me in Xt.boxSizing="border-box",Xt.position="fixed",Xt.top="24px",Xt.left="50%",Xt.marginLeft="-140px",Xt.width="280px",Xt.padding="24px",Xt.overflow="hidden",Xt.background="#fafafa",Xt.fontFamily="'Roboto', sans-serif",Xt.boxShadow="0px 5px 20px #666",Gt.appendChild(this.createH1_("Select your viewer")),K)Gt.appendChild(this.createChoice_(Me,K[Me].label));return Gt.appendChild(this.createButton_("Save",this.onSave_.bind(this))),mt.appendChild(It),mt.appendChild(Gt),mt},Bi.prototype.createH1_=function(K){var mt=document.createElement("h1"),It=mt.style;return It.color="black",It.fontSize="20px",It.fontWeight="bold",It.marginTop=0,It.marginBottom="24px",mt.innerHTML=K,mt},Bi.prototype.createChoice_=function(K,mt){var It=document.createElement("div");It.style.marginTop="8px",It.style.color="black";var Mt=document.createElement("input");Mt.style.fontSize="30px",Mt.setAttribute("id",K),Mt.setAttribute("type","radio"),Mt.setAttribute("value",K),Mt.setAttribute("name","field");var Gt=document.createElement("label");return Gt.style.marginLeft="4px",Gt.setAttribute("for",K),Gt.innerHTML=mt,It.appendChild(Mt),It.appendChild(Gt),It},Bi.prototype.createButton_=function(K,mt){var It=document.createElement("button");It.innerHTML=K;var Mt=It.style;return Mt.float="right",Mt.textTransform="uppercase",Mt.color="#1094f7",Mt.fontSize="14px",Mt.letterSpacing=0,Mt.border=0,Mt.background="none",Mt.marginTop="16px",It.addEventListener("click",mt),It};var pa=function da(K,mt){return K(mt={exports:{}},mt.exports),mt.exports}(function(K,mt){K.exports=function(It){var Mt={};function Gt(Xt){if(Mt[Xt])return Mt[Xt].exports;var Me=Mt[Xt]={i:Xt,l:!1,exports:{}};return It[Xt].call(Me.exports,Me,Me.exports,Gt),Me.l=!0,Me.exports}return Gt.m=It,Gt.c=Mt,Gt.d=function(Xt,Me,sn){Gt.o(Xt,Me)||Object.defineProperty(Xt,Me,{configurable:!1,enumerable:!0,get:sn})},Gt.n=function(Xt){var Me=Xt&&Xt.__esModule?function(){return Xt.default}:function(){return Xt};return Gt.d(Me,"a",Me),Me},Gt.o=function(Xt,Me){return Object.prototype.hasOwnProperty.call(Xt,Me)},Gt.p="",Gt(Gt.s=0)}([function(It,Mt,Gt){var Xt=function(){function Be(Pn,Xn){for(var dr=0;dr<Xn.length;dr++){var Ar=Xn[dr];Ar.enumerable=Ar.enumerable||!1,Ar.configurable=!0,"value"in Ar&&(Ar.writable=!0),Object.defineProperty(Pn,Ar.key,Ar)}}return function(Pn,Xn,dr){return Xn&&Be(Pn.prototype,Xn),dr&&Be(Pn,dr),Pn}}();var sn=Gt(1),un=typeof navigator<"u"&&parseFloat((""+(/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent)||[0,""])[1]).replace("undefined","3_2").replace("_",".").replace("_",""))<10&&!window.MSStream,Ie=function(){function Be(){(function Me(Be,Pn){if(!(Be instanceof Pn))throw new TypeError("Cannot call a class as a function")})(this,Be),un?this.noSleepTimer=null:(this.noSleepVideo=document.createElement("video"),this.noSleepVideo.setAttribute("playsinline",""),this.noSleepVideo.setAttribute("src",sn),this.noSleepVideo.addEventListener("timeupdate",function(Pn){this.noSleepVideo.currentTime>.5&&(this.noSleepVideo.currentTime=Math.random())}.bind(this)))}return Xt(Be,[{key:"enable",value:function(){un?(this.disable(),this.noSleepTimer=window.setInterval(function(){window.location.href="/",window.setTimeout(window.stop,0)},15e3)):this.noSleepVideo.play()}},{key:"disable",value:function(){un?this.noSleepTimer&&(window.clearInterval(this.noSleepTimer),this.noSleepTimer=null):this.noSleepVideo.pause()}}]),Be}();It.exports=Ie},function(It,Mt,Gt){It.exports="data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA="}])}),Ss=function Ta(K){return K&&K.__esModule&&Object.prototype.hasOwnProperty.call(K,"default")?K.default:K}(pa),Xs=1e3,Ms=[0,0,.5,1],_a=[.5,0,.5,1],Pa=window.requestAnimationFrame,Ys=window.cancelAnimationFrame;function Ka(K){Object.defineProperties(this,{hasPosition:{writable:!1,enumerable:!0,value:K.hasPosition},hasExternalDisplay:{writable:!1,enumerable:!0,value:K.hasExternalDisplay},canPresent:{writable:!1,enumerable:!0,value:K.canPresent},maxLayers:{writable:!1,enumerable:!0,value:K.maxLayers},hasOrientation:{enumerable:!0,get:function(){return se("VRDisplayCapabilities.prototype.hasOrientation","VRDisplay.prototype.getFrameData"),K.hasOrientation}}})}function oi(K){var mt=!("wakelock"in(K=K||{}))||K.wakelock;this.isPolyfilled=!0,this.displayId=Xs++,this.displayName="",this.depthNear=.01,this.depthFar=1e4,this.isPresenting=!1,Object.defineProperty(this,"isConnected",{get:function(){return se("VRDisplay.prototype.isConnected","VRDisplayCapabilities.prototype.hasExternalDisplay"),!1}}),this.capabilities=new Ka({hasPosition:!1,hasOrientation:!1,hasExternalDisplay:!1,canPresent:!1,maxLayers:1}),this.stageParameters=null,this.waitingForPresent_=!1,this.layer_=null,this.originalParent_=null,this.fullscreenElement_=null,this.fullscreenWrapper_=null,this.fullscreenElementCachedStyle_=null,this.fullscreenEventTarget_=null,this.fullscreenChangeHandler_=null,this.fullscreenErrorHandler_=null,mt&&ha()&&(this.wakelock_=new Ss)}oi.prototype.getFrameData=function(K){return Ya(K,this._getPose(),this)},oi.prototype.getPose=function(){return se("VRDisplay.prototype.getPose","VRDisplay.prototype.getFrameData"),this._getPose()},oi.prototype.resetPose=function(){return se("VRDisplay.prototype.resetPose"),this._resetPose()},oi.prototype.getImmediatePose=function(){return se("VRDisplay.prototype.getImmediatePose","VRDisplay.prototype.getFrameData"),this._getPose()},oi.prototype.requestAnimationFrame=function(K){return Pa(K)},oi.prototype.cancelAnimationFrame=function(K){return Ys(K)},oi.prototype.wrapForFullscreen=function(K){if(xt())return K;if(!this.fullscreenWrapper_){this.fullscreenWrapper_=document.createElement("div");var mt=["height: "+Math.min(screen.height,screen.width)+"px !important","top: 0 !important","left: 0 !important","right: 0 !important","border: 0","margin: 0","padding: 0","z-index: 999999 !important","position: fixed"];this.fullscreenWrapper_.setAttribute("style",mt.join("; ")+";"),this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper")}if(this.fullscreenElement_==K)return this.fullscreenWrapper_;if(this.fullscreenElement_&&(this.originalParent_?this.originalParent_.appendChild(this.fullscreenElement_):this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_)),this.fullscreenElement_=K,this.originalParent_=K.parentElement,this.originalParent_||document.body.appendChild(K),!this.fullscreenWrapper_.parentElement){var It=this.fullscreenElement_.parentElement;It.insertBefore(this.fullscreenWrapper_,this.fullscreenElement_),It.removeChild(this.fullscreenElement_)}this.fullscreenWrapper_.insertBefore(this.fullscreenElement_,this.fullscreenWrapper_.firstChild),this.fullscreenElementCachedStyle_=this.fullscreenElement_.getAttribute("style");var Mt=this;return function Gt(){if(Mt.fullscreenElement_){var Xt=["position: absolute","top: 0","left: 0","width: "+Math.max(screen.width,screen.height)+"px","height: "+Math.min(screen.height,screen.width)+"px","border: 0","margin: 0","padding: 0"];Mt.fullscreenElement_.setAttribute("style",Xt.join("; ")+";")}}(),this.fullscreenWrapper_},oi.prototype.removeFullscreenWrapper=function(){if(this.fullscreenElement_){var K=this.fullscreenElement_;this.fullscreenElementCachedStyle_?K.setAttribute("style",this.fullscreenElementCachedStyle_):K.removeAttribute("style"),this.fullscreenElement_=null,this.fullscreenElementCachedStyle_=null;var mt=this.fullscreenWrapper_.parentElement;return this.fullscreenWrapper_.removeChild(K),this.originalParent_===mt?mt.insertBefore(K,this.fullscreenWrapper_):this.originalParent_&&this.originalParent_.appendChild(K),mt.removeChild(this.fullscreenWrapper_),K}},oi.prototype.requestPresent=function(K){var mt=this.isPresenting,It=this;return K instanceof Array||(se("VRDisplay.prototype.requestPresent with non-array argument","an array of VRLayers as the first argument"),K=[K]),new Promise(function(Mt,Gt){if(It.capabilities.canPresent)if(0==K.length||K.length>It.capabilities.maxLayers)Gt(new Error("Invalid number of layers."));else{var Xt=K[0];if(Xt.source){var Me=Xt.leftBounds||Ms,sn=Xt.rightBounds||_a;if(mt){var un=It.layer_;un.source!==Xt.source&&(un.source=Xt.source);for(var Ie=0;Ie<4;Ie++)un.leftBounds[Ie]=Me[Ie],un.rightBounds[Ie]=sn[Ie];return It.wrapForFullscreen(It.layer_.source),It.updatePresent_(),void Mt()}if(It.layer_={predistorted:Xt.predistorted,source:Xt.source,leftBounds:Me.slice(0),rightBounds:sn.slice(0)},It.waitingForPresent_=!1,It.layer_&&It.layer_.source){var Be=It.wrapForFullscreen(It.layer_.source);It.addFullscreenListeners_(Be,function(){var dr=document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.msFullscreenElement;It.isPresenting=Be===dr,It.isPresenting?(screen.orientation&&screen.orientation.lock&&screen.orientation.lock("landscape-primary").catch(function(Ar){console.error("screen.orientation.lock() failed due to",Ar.message)}),It.waitingForPresent_=!1,It.beginPresent_(),Mt()):(screen.orientation&&screen.orientation.unlock&&screen.orientation.unlock(),It.removeFullscreenWrapper(),It.disableWakeLock(),It.endPresent_(),It.removeFullscreenListeners_()),It.fireVRDisplayPresentChange_()},function(){It.waitingForPresent_&&(It.removeFullscreenWrapper(),It.removeFullscreenListeners_(),It.disableWakeLock(),It.waitingForPresent_=!1,It.isPresenting=!1,Gt(new Error("Unable to present.")))}),function(K){if(Rt())return!1;if(K.requestFullscreen)K.requestFullscreen();else if(K.webkitRequestFullscreen)K.webkitRequestFullscreen();else if(K.mozRequestFullScreen)K.mozRequestFullScreen();else{if(!K.msRequestFullscreen)return!1;K.msRequestFullscreen()}return!0}(Be)?(It.enableWakeLock(),It.waitingForPresent_=!0):(xt()||Rt())&&(It.enableWakeLock(),It.isPresenting=!0,It.beginPresent_(),It.fireVRDisplayPresentChange_(),Mt())}It.waitingForPresent_||xt()||(Ti(),Gt(new Error("Unable to present.")))}else Mt()}else Gt(new Error("VRDisplay is not capable of presenting."))})},oi.prototype.exitPresent=function(){var K=this.isPresenting,mt=this;return this.isPresenting=!1,this.layer_=null,this.disableWakeLock(),new Promise(function(It,Mt){K?(!Ti()&&xt()&&(mt.endPresent_(),mt.fireVRDisplayPresentChange_()),Rt()&&(mt.removeFullscreenWrapper(),mt.removeFullscreenListeners_(),mt.endPresent_(),mt.fireVRDisplayPresentChange_()),It()):Mt(new Error("Was not presenting to VRDisplay."))})},oi.prototype.getLayers=function(){return this.layer_?[this.layer_]:[]},oi.prototype.fireVRDisplayPresentChange_=function(){var K=new CustomEvent("vrdisplaypresentchange",{detail:{display:this}});window.dispatchEvent(K)},oi.prototype.fireVRDisplayConnect_=function(){var K=new CustomEvent("vrdisplayconnect",{detail:{display:this}});window.dispatchEvent(K)},oi.prototype.addFullscreenListeners_=function(K,mt,It){this.removeFullscreenListeners_(),this.fullscreenEventTarget_=K,this.fullscreenChangeHandler_=mt,this.fullscreenErrorHandler_=It,mt&&(document.fullscreenEnabled?K.addEventListener("fullscreenchange",mt,!1):document.webkitFullscreenEnabled?K.addEventListener("webkitfullscreenchange",mt,!1):document.mozFullScreenEnabled?document.addEventListener("mozfullscreenchange",mt,!1):document.msFullscreenEnabled&&K.addEventListener("msfullscreenchange",mt,!1)),It&&(document.fullscreenEnabled?K.addEventListener("fullscreenerror",It,!1):document.webkitFullscreenEnabled?K.addEventListener("webkitfullscreenerror",It,!1):document.mozFullScreenEnabled?document.addEventListener("mozfullscreenerror",It,!1):document.msFullscreenEnabled&&K.addEventListener("msfullscreenerror",It,!1))},oi.prototype.removeFullscreenListeners_=function(){if(this.fullscreenEventTarget_){var K=this.fullscreenEventTarget_;if(this.fullscreenChangeHandler_){var mt=this.fullscreenChangeHandler_;K.removeEventListener("fullscreenchange",mt,!1),K.removeEventListener("webkitfullscreenchange",mt,!1),document.removeEventListener("mozfullscreenchange",mt,!1),K.removeEventListener("msfullscreenchange",mt,!1)}if(this.fullscreenErrorHandler_){var It=this.fullscreenErrorHandler_;K.removeEventListener("fullscreenerror",It,!1),K.removeEventListener("webkitfullscreenerror",It,!1),document.removeEventListener("mozfullscreenerror",It,!1),K.removeEventListener("msfullscreenerror",It,!1)}this.fullscreenEventTarget_=null,this.fullscreenChangeHandler_=null,this.fullscreenErrorHandler_=null}},oi.prototype.enableWakeLock=function(){this.wakelock_&&this.wakelock_.enable()},oi.prototype.disableWakeLock=function(){this.wakelock_&&this.wakelock_.disable()},oi.prototype.beginPresent_=function(){},oi.prototype.endPresent_=function(){},oi.prototype.submitFrame=function(K){},oi.prototype.getEyeParameters=function(K){return null};var Ol={ADDITIONAL_VIEWERS:[],DEFAULT_VIEWER:"",MOBILE_WAKE_LOCK:!0,DEBUG:!1,DPDB_URL:"https://dpdb.webvr.rocks/dpdb.json",K_FILTER:.98,PREDICTION_TIME_S:.04,CARDBOARD_UI_DISABLED:!1,ROTATE_INSTRUCTIONS_DISABLED:!1,YAW_ONLY:!1,BUFFER_SCALE:.5,DIRTY_SUBMIT_FRAME_BINDINGS:!1},Go_LEFT="left",Go_RIGHT="right";function Li(K){var mt=js({},Ol);K=js(mt,K||{}),oi.call(this,{wakelock:K.MOBILE_WAKE_LOCK}),this.config=K,this.displayName="Cardboard VRDisplay",this.capabilities=new Ka({hasPosition:!1,hasOrientation:!0,hasExternalDisplay:!1,canPresent:!0,maxLayers:1}),this.stageParameters=null,this.bufferScale_=this.config.BUFFER_SCALE,this.poseSensor_=new ci(this.config),this.distorter_=null,this.cardboardUI_=null,this.dpdb_=new Kn(this.config.DPDB_URL,this.onDeviceParamsUpdated_.bind(this)),this.deviceInfo_=new Sn(this.dpdb_.getDeviceParams(),K.ADDITIONAL_VIEWERS),this.viewerSelector_=new Bi(K.DEFAULT_VIEWER),this.viewerSelector_.onChange(this.onViewerChanged_.bind(this)),this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer()),this.config.ROTATE_INSTRUCTIONS_DISABLED||(this.rotateInstructions_=new jr),xt()&&window.addEventListener("resize",this.onResize_.bind(this))}return(Li.prototype=Object.create(oi.prototype))._getPose=function(){return{position:null,orientation:this.poseSensor_.getOrientation(),linearVelocity:null,linearAcceleration:null,angularVelocity:null,angularAcceleration:null}},Li.prototype._resetPose=function(){this.poseSensor_.resetPose&&this.poseSensor_.resetPose()},Li.prototype._getFieldOfView=function(K){var mt;if(K==Go_LEFT)mt=this.deviceInfo_.getFieldOfViewLeftEye();else{if(K!=Go_RIGHT)return console.error("Invalid eye provided: %s",K),null;mt=this.deviceInfo_.getFieldOfViewRightEye()}return mt},Li.prototype._getEyeOffset=function(K){var mt;if(K==Go_LEFT)mt=[.5*-this.deviceInfo_.viewer.interLensDistance,0,0];else{if(K!=Go_RIGHT)return console.error("Invalid eye provided: %s",K),null;mt=[.5*this.deviceInfo_.viewer.interLensDistance,0,0]}return mt},Li.prototype.getEyeParameters=function(K){var mt=this._getEyeOffset(K),It=this._getFieldOfView(K),Mt={offset:mt,renderWidth:.5*this.deviceInfo_.device.width*this.bufferScale_,renderHeight:this.deviceInfo_.device.height*this.bufferScale_};return Object.defineProperty(Mt,"fieldOfView",{enumerable:!0,get:function(){return se("VRFieldOfView","VRFrameData's projection matrices"),It}}),Mt},Li.prototype.onDeviceParamsUpdated_=function(K){this.config.DEBUG&&console.log("DPDB reported that device params were updated."),this.deviceInfo_.updateDeviceParams(K),this.distorter_&&this.distorter_.updateDeviceInfo(this.deviceInfo_)},Li.prototype.updateBounds_=function(){this.layer_&&this.distorter_&&(this.layer_.leftBounds||this.layer_.rightBounds)&&this.distorter_.setTextureBounds(this.layer_.leftBounds,this.layer_.rightBounds)},Li.prototype.beginPresent_=function(){var K=this.layer_.source.getContext("webgl");K||(K=this.layer_.source.getContext("experimental-webgl")),K||(K=this.layer_.source.getContext("webgl2")),K&&(this.layer_.predistorted?this.config.CARDBOARD_UI_DISABLED||(K.canvas.width=nr()*this.bufferScale_,K.canvas.height=hr()*this.bufferScale_,this.cardboardUI_=new si(K)):(this.config.CARDBOARD_UI_DISABLED||(this.cardboardUI_=new si(K)),this.distorter_=new Z(K,this.cardboardUI_,this.config.BUFFER_SCALE,this.config.DIRTY_SUBMIT_FRAME_BINDINGS),this.distorter_.updateDeviceInfo(this.deviceInfo_)),this.cardboardUI_&&this.cardboardUI_.listen(function(mt){this.viewerSelector_.show(this.layer_.source.parentElement),mt.stopPropagation(),mt.preventDefault()}.bind(this),function(mt){this.exitPresent(),mt.stopPropagation(),mt.preventDefault()}.bind(this)),this.rotateInstructions_&&(vn()&&ha()?this.rotateInstructions_.showTemporarily(3e3,this.layer_.source.parentElement):this.rotateInstructions_.update()),this.orientationHandler=this.onOrientationChange_.bind(this),window.addEventListener("orientationchange",this.orientationHandler),this.vrdisplaypresentchangeHandler=this.updateBounds_.bind(this),window.addEventListener("vrdisplaypresentchange",this.vrdisplaypresentchangeHandler),this.fireVRDisplayDeviceParamsChange_())},Li.prototype.endPresent_=function(){this.distorter_&&(this.distorter_.destroy(),this.distorter_=null),this.cardboardUI_&&(this.cardboardUI_.destroy(),this.cardboardUI_=null),this.rotateInstructions_&&this.rotateInstructions_.hide(),this.viewerSelector_.hide(),window.removeEventListener("orientationchange",this.orientationHandler),window.removeEventListener("vrdisplaypresentchange",this.vrdisplaypresentchangeHandler)},Li.prototype.updatePresent_=function(){this.endPresent_(),this.beginPresent_()},Li.prototype.submitFrame=function(K){if(this.distorter_)this.updateBounds_(),this.distorter_.submitFrame();else if(this.cardboardUI_&&this.layer_){var mt=this.layer_.source.getContext("webgl");mt||(mt=this.layer_.source.getContext("experimental-webgl")),mt||(mt=this.layer_.source.getContext("webgl2"));var It=mt.canvas;It.width==this.lastWidth&&It.height==this.lastHeight||this.cardboardUI_.onResize(),this.lastWidth=It.width,this.lastHeight=It.height,this.cardboardUI_.render()}},Li.prototype.onOrientationChange_=function(K){this.viewerSelector_.hide(),this.rotateInstructions_&&this.rotateInstructions_.update(),this.onResize_()},Li.prototype.onResize_=function(K){if(this.layer_){var mt=this.layer_.source.getContext("webgl");mt||(mt=this.layer_.source.getContext("experimental-webgl")),mt||(mt=this.layer_.source.getContext("webgl2")),mt.canvas.setAttribute("style",["position: absolute","top: 0","left: 0","width: 100vw","height: 100vh","border: 0","margin: 0","padding: 0px","box-sizing: content-box"].join("; ")+";"),Xa(mt.canvas)}},Li.prototype.onViewerChanged_=function(K){this.deviceInfo_.setViewer(K),this.distorter_&&this.distorter_.updateDeviceInfo(this.deviceInfo_),this.fireVRDisplayDeviceParamsChange_()},Li.prototype.fireVRDisplayDeviceParamsChange_=function(){var K=new CustomEvent("vrdisplaydeviceparamschange",{detail:{vrdisplay:this,deviceInfo:this.deviceInfo_}});window.dispatchEvent(K)},Li.VRFrameData=function Ks(){this.leftProjectionMatrix=new Float32Array(16),this.leftViewMatrix=new Float32Array(16),this.rightProjectionMatrix=new Float32Array(16),this.rightViewMatrix=new Float32Array(16),this.pose=null},Li.VRDisplay=oi,Li}(),($=G.exports)&&$.__esModule&&Object.prototype.hasOwnProperty.call($,"default")?$.default:$),B={ADDITIONAL_VIEWERS:[],DEFAULT_VIEWER:"",PROVIDE_MOBILE_VRDISPLAY:!0,MOBILE_WAKE_LOCK:!0,DEBUG:!1,DPDB_URL:"https://dpdb.webvr.rocks/dpdb.json",K_FILTER:.98,PREDICTION_TIME_S:.04,CARDBOARD_UI_DISABLED:!1,ROTATE_INSTRUCTIONS_DISABLED:!1,YAW_ONLY:!1,BUFFER_SCALE:.5,DIRTY_SUBMIT_FRAME_BINDINGS:!1};function C(F){this.config=_(_({},B),F),this.polyfillDisplays=[],this.enabled=!1,this.hasNative="getVRDisplays"in navigator,this.native={},this.native.getVRDisplays=navigator.getVRDisplays,this.native.VRFrameData=window.VRFrameData,this.native.VRDisplay=window.VRDisplay,(!this.hasNative||this.config.PROVIDE_MOBILE_VRDISPLAY&&O())&&(this.enable(),this.getVRDisplays().then(function(G){G&&G[0]&&G[0].fireVRDisplayConnect_&&G[0].fireVRDisplayConnect_()}))}C.prototype.getPolyfillDisplays=function(){if(this._polyfillDisplaysPopulated)return this.polyfillDisplays;if(O()){var F=new D({ADDITIONAL_VIEWERS:this.config.ADDITIONAL_VIEWERS,DEFAULT_VIEWER:this.config.DEFAULT_VIEWER,MOBILE_WAKE_LOCK:this.config.MOBILE_WAKE_LOCK,DEBUG:this.config.DEBUG,DPDB_URL:this.config.DPDB_URL,CARDBOARD_UI_DISABLED:this.config.CARDBOARD_UI_DISABLED,K_FILTER:this.config.K_FILTER,PREDICTION_TIME_S:this.config.PREDICTION_TIME_S,ROTATE_INSTRUCTIONS_DISABLED:this.config.ROTATE_INSTRUCTIONS_DISABLED,YAW_ONLY:this.config.YAW_ONLY,BUFFER_SCALE:this.config.BUFFER_SCALE,DIRTY_SUBMIT_FRAME_BINDINGS:this.config.DIRTY_SUBMIT_FRAME_BINDINGS});this.polyfillDisplays.push(F)}return this._polyfillDisplaysPopulated=!0,this.polyfillDisplays},C.prototype.enable=function(){if(this.enabled=!0,this.hasNative&&this.native.VRFrameData){var F=this.native.VRFrameData,G=new this.native.VRFrameData,Q=this.native.VRDisplay.prototype.getFrameData;window.VRDisplay.prototype.getFrameData=function(X){X instanceof F?Q.call(this,X):(Q.call(this,G),X.pose=G.pose,N(G.leftProjectionMatrix,X.leftProjectionMatrix),N(G.rightProjectionMatrix,X.rightProjectionMatrix),N(G.leftViewMatrix,X.leftViewMatrix),N(G.rightViewMatrix,X.rightViewMatrix))}}navigator.getVRDisplays=this.getVRDisplays.bind(this),window.VRDisplay=D.VRDisplay,window.VRFrameData=D.VRFrameData},C.prototype.getVRDisplays=function(){var F=this;return this.hasNative?this.native.getVRDisplays.call(navigator).then(function(G){return G.length>0?G:F.getPolyfillDisplays()}):Promise.resolve(this.getPolyfillDisplays())},C.version="0.10.12",C.VRFrameData=D.VRFrameData,C.VRDisplay=D.VRDisplay;var M=Object.freeze({default:C}),k=M&&C||M;return void 0!==U&&U.window&&(U.document||(U.document=U.window.document),U.navigator||(U.navigator=U.window.navigator)),k}()},5406:ot=>{var ht=/\n/,I=/\s/;function U(N,_,E,D){var B=N.indexOf(_,E);return-1===B||B>D?D:B}function $(N){return I.test(N)}function O(N,_,E,D){return{start:_,end:_+Math.min(D,E-_)}}ot.exports=function(N,_){return ot.exports.lines(N,_).map(function(E){return N.substring(E.start,E.end)}).join("\n")},ot.exports.lines=function(N,_){if(0===(_=_||{}).width&&"nowrap"!==_.mode)return[];N=N||"";var E="number"==typeof _.width?_.width:Number.MAX_VALUE,D=Math.max(0,_.start||0),B="number"==typeof _.end?_.end:N.length,C=_.mode,M=_.measure||O;return"pre"===C?function(k,F,G,Q,X){for(var lt=[],rt=G,pt=G;pt<Q&&pt<F.length;pt++){var vt=F.charAt(pt),bt=ht.test(vt);if(bt||pt===Q-1){var ft=k(F,rt,bt?pt:pt+1,X);lt.push(ft),rt=pt+1}}return lt}(M,N,D,B,E):function(k,F,G,Q,X,lt){var rt=[],pt=X;for("nowrap"===lt&&(pt=Number.MAX_VALUE);G<Q&&G<F.length;){for(var vt=U(F,"\n",G,Q);G<vt&&$(F.charAt(G));)G++;var bt=k(F,G,vt,pt),ft=G+(bt.end-bt.start),wt=ft+1;if(ft<vt){for(;ft>G&&!$(F.charAt(ft));)ft--;if(ft===G)wt>G+1&&wt--,ft=wt;else for(wt=ft;ft>G&&$(F.charAt(ft-1));)ft--}if(ft>=G){var et=k(F,G,ft,pt);rt.push(et)}G=wt}return rt}(M,N,D,B,E,C)}},3558:(ot,ht,I)=>{"use strict";var U=I(919),$=I(8847),O=I(3216),N=I(4597);function _(B,C,M){var k=B;return $(C)?(M=C,"string"==typeof B&&(k={uri:B})):k=N(C,{uri:B}),k.callback=M,k}function E(B,C,M){return D(C=_(B,C,M))}function D(B){if(void 0===B.callback)throw new Error("callback argument missing");var C=!1,M=function(Rt,Yt,ve){C||(C=!0,B.callback(Rt,Yt,ve))};function k(){var Rt=void 0;if(Rt=lt.response?lt.response:lt.responseText||function(Yt){try{if("document"===Yt.responseType)return Yt.responseXML;if(""===Yt.responseType&&(!Yt.responseXML||"parsererror"!==Yt.responseXML.documentElement.nodeName))return Yt.responseXML}catch{}return null}(lt),et)try{Rt=JSON.parse(Rt)}catch{}return Rt}function F(Rt){return clearTimeout(rt),Rt instanceof Error||(Rt=new Error(""+(Rt||"Unknown XMLHttpRequest Error"))),Rt.statusCode=0,M(Rt,xt)}function G(){if(!X){var Rt;clearTimeout(rt);var Yt=xt,ve=null;return 0!==(Rt=B.useXDR&&void 0===lt.status?200:1223===lt.status?204:lt.status)?(Yt={body:k(),statusCode:Rt,method:vt,headers:{},url:pt,rawRequest:lt},lt.getAllResponseHeaders&&(Yt.headers=O(lt.getAllResponseHeaders()))):ve=new Error("Internal XMLHttpRequest Error"),M(ve,Yt,Yt.body)}}var Q,X,lt=B.xhr||null;lt||(lt=B.cors||B.useXDR?new E.XDomainRequest:new E.XMLHttpRequest);var rt,pt=lt.url=B.uri||B.url,vt=lt.method=B.method||"GET",bt=B.body||B.data,ft=lt.headers=B.headers||{},wt=!!B.sync,et=!1,xt={body:void 0,headers:{},statusCode:0,method:vt,url:pt,rawRequest:lt};if("json"in B&&!1!==B.json&&(et=!0,ft.accept||ft.Accept||(ft.Accept="application/json"),"GET"!==vt&&"HEAD"!==vt&&(ft["content-type"]||ft["Content-Type"]||(ft["Content-Type"]="application/json"),bt=JSON.stringify(!0===B.json?bt:B.json))),lt.onreadystatechange=function(){4===lt.readyState&&setTimeout(G,0)},lt.onload=G,lt.onerror=F,lt.onprogress=function(){},lt.onabort=function(){X=!0},lt.ontimeout=F,lt.open(vt,pt,!wt,B.username,B.password),wt||(lt.withCredentials=!!B.withCredentials),!wt&&B.timeout>0&&(rt=setTimeout(function(){if(!X){X=!0,lt.abort("timeout");var Rt=new Error("XMLHttpRequest timeout");Rt.code="ETIMEDOUT",F(Rt)}},B.timeout)),lt.setRequestHeader)for(Q in ft)ft.hasOwnProperty(Q)&&lt.setRequestHeader(Q,ft[Q]);else if(B.headers&&!function(Rt){for(var Yt in Rt)if(Rt.hasOwnProperty(Yt))return!1;return!0}(B.headers))throw new Error("Headers cannot be set on an XDomainRequest object");return"responseType"in B&&(lt.responseType=B.responseType),"beforeSend"in B&&"function"==typeof B.beforeSend&&B.beforeSend(lt),lt.send(bt||null),lt}ot.exports=E,ot.exports.default=E,E.XMLHttpRequest=U.XMLHttpRequest||function(){},E.XDomainRequest="withCredentials"in new E.XMLHttpRequest?E.XMLHttpRequest:U.XDomainRequest,function(B,C){for(var M=0;M<B.length;M++)C(B[M])}(["get","put","post","patch","head","delete"],function(B){E["delete"===B?"del":B]=function(C,M,k){return(M=_(C,M,k)).method=B.toUpperCase(),D(M)}})},1896:ot=>{ot.exports=void 0!==self.DOMParser?function(ht){return(new self.DOMParser).parseFromString(ht,"application/xml")}:void 0!==self.ActiveXObject&&new self.ActiveXObject("Microsoft.XMLDOM")?function(ht){var I=new self.ActiveXObject("Microsoft.XMLDOM");return I.async="false",I.loadXML(ht),I}:function(ht){var I=document.createElement("div");return I.innerHTML=ht,I}},4597:ot=>{ot.exports=function(){for(var I={},U=0;U<arguments.length;U++){var $=arguments[U];for(var O in $)ht.call($,O)&&(I[O]=$[O])}return I};var ht=Object.prototype.hasOwnProperty},2784:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7427).debug("components:anchored:warn");ot.exports.Component=U("anchored",{schema:{persistent:{default:!1}},init:function(){var O=this.el.sceneEl.getAttribute("webxr"),N=O.optionalFeatures;-1===N.indexOf("anchors")&&(N.push("anchors"),this.el.sceneEl.setAttribute("webxr",O)),this.auxQuaternion=new THREE.Quaternion,this.onEnterVR=this.onEnterVR.bind(this),this.el.sceneEl.addEventListener("enter-vr",this.onEnterVR)},onEnterVR:function(){this.anchor=void 0,this.requestPersistentAnchorPending=this.data.persistent,this.requestAnchorPending=!this.data.persistent},tick:function(){var O,N,_,E=this.el.sceneEl,D=E.renderer.xr,B=this.el.object3D;(E.is("ar-mode")||E.is("vr-mode"))&&(!this.anchor&&this.requestPersistentAnchorPending&&this.restorePersistentAnchor(),!this.anchor&&this.requestAnchorPending&&this.createAnchor(),this.anchor&&(O=E.frame,N=D.getReferenceSpace(),_=O.getPose(this.anchor.anchorSpace,N),B.matrix.elements=_.transform.matrix,B.matrix.decompose(B.position,B.rotation,B.scale)))},createAnchor:async function(O,N){var _,E,D,B,G,C=this.el.sceneEl,M=C.renderer.xr,k=this.el.object3D;O=O||k.position,N=N||this.auxQuaternion.setFromEuler(k.rotation),(G=C.renderer.xr.getSession())&&G.restorePersistentAnchor?(this.anchor&&this.deleteAnchor(),_=C.frame,E=M.getReferenceSpace(),D=new XRRigidTransform({x:O.x,y:O.y,z:O.z},{x:N.x,y:N.y,z:N.z,w:N.w}),this.requestAnchorPending=!1,B=await _.createAnchor(D,E),this.data.persistent&&(this.el.id?(this.persistentHandle=await B.requestPersistentHandle(),localStorage.setItem(this.el.id,this.persistentHandle)):$("The anchor won't be persisted because the entity has no assigned id.")),C.object3D.attach(this.el.object3D),this.anchor=B):$("This browser doesn't support the WebXR anchors module")},restorePersistentAnchor:async function(){var O,N=this.el.sceneEl.renderer.xr.getSession(),_=N.persistentAnchors;if(this.requestPersistentAnchorPending=!1,!this.el.id)return $("The entity associated to the persistent anchor cannot be retrieved because it doesn't have an assigned id."),void(this.requestAnchorPending=!0);if(_){O=localStorage.getItem(this.el.id);for(var E=0;E<_.length;++E)if(O===_[E]){this.anchor=await N.restorePersistentAnchor(_[E]),this.anchor&&(this.persistentHandle=_[E]);break}this.anchor||(this.requestAnchorPending=!0)}else this.requestPersistentAnchorPending=!0},deleteAnchor:function(){var O,N=this.anchor;N&&(O=this.el.sceneEl.renderer.xr.getSession(),N.delete(),this.el.sceneEl.object3D.add(this.el.object3D),this.persistentHandle&&O.deletePersistentAnchor(this.persistentHandle),this.anchor=void 0)}})},6896:(ot,ht,I)=>{var U=I(4635).A,$=I(8190).components,O=I(8190).registerComponent,N=I(9437),_=I(7427),E=new N.Color,D=new N.Color,B=_.entity.getComponentProperty,C=_.entity.setComponentProperty,M={},k="color",F="rotation",G="components";function Q(ft){ft.x=N.MathUtils.degToRad(ft.x),ft.y=N.MathUtils.degToRad(ft.y),ft.z=N.MathUtils.degToRad(ft.z)}function X(ft,wt,et){var xt;for(xt=0;xt<wt.length;xt++)ft.addEventListener(wt[xt],et)}function lt(ft,wt,et){var xt;for(xt=0;xt<wt.length;xt++)ft.removeEventListener(wt[xt],et)}function rt(ft,wt){var et,xt,Rt;for(xt=vt(wt),Rt=ft,et=0;et<xt.length;et++)Rt=Rt[xt[et]];if(void 0===Rt)throw console.log(ft),new Error("[animation] property ("+wt+") could not be found");return Rt}function pt(ft,wt,et,xt){var Rt,Yt,ve,xe;for(wt.startsWith("object3D.rotation")&&(et=N.MathUtils.degToRad(et)),Yt=vt(wt),xe=ft,Rt=0;Rt<Yt.length-1;Rt++)xe=xe[Yt[Rt]];ve=Yt[Yt.length-1],xt!==k?xe[ve]=et:"r"in xe[ve]?(xe[ve].r=et.r,xe[ve].g=et.g,xe[ve].b=et.b):(xe[ve].x=et.r,xe[ve].y=et.g,xe[ve].z=et.b)}function vt(ft){return ft in M||(M[ft]=ft.split(".")),M[ft]}function bt(ft){return ft.isRawProperty||ft.property.startsWith(G)||ft.property.startsWith("object3D")}ot.exports.Component=O("animation",{schema:{autoplay:{default:!0},delay:{default:0},dir:{default:""},dur:{default:1e3},easing:{default:"easeInQuad"},elasticity:{default:400},enabled:{default:!0},from:{default:""},loop:{default:0,parse:function(ft){return!0===ft||"true"===ft||!1!==ft&&"false"!==ft&&parseInt(ft,10)}},property:{default:""},startEvents:{type:"array"},pauseEvents:{type:"array"},resumeEvents:{type:"array"},round:{default:!1},to:{default:""},type:{default:""},isRawProperty:{default:!1}},multiple:!0,init:function(){var ft=this;this.eventDetail={name:this.attrName},this.time=0,this.animation=null,this.animationIsPlaying=!1,this.onStartEvent=this.onStartEvent.bind(this),this.beginAnimation=this.beginAnimation.bind(this),this.pauseAnimation=this.pauseAnimation.bind(this),this.resumeAnimation=this.resumeAnimation.bind(this),this.fromColor={},this.toColor={},this.targets={},this.targetsArray=[],this.updateConfigForDefault=this.updateConfigForDefault.bind(this),this.updateConfigForRawColor=this.updateConfigForRawColor.bind(this),this.config={complete:function(){ft.animationIsPlaying=!1,ft.el.emit("animationcomplete",ft.eventDetail,!1),ft.id&&ft.el.emit("animationcomplete__"+ft.id,ft.eventDetail,!1)}}},update:function(ft){var wt=this.config,et=this.data;this.animationIsPlaying=!1,this.data.enabled&&et.property&&(wt.autoplay=!1,wt.direction=et.dir,wt.duration=et.dur,wt.easing=et.easing,wt.elasticity=et.elasticity,wt.loop=et.loop,wt.round=et.round,this.createAndStartAnimation())},tick:function(ft,wt){this.animationIsPlaying&&(this.time+=wt,this.animation.tick(this.time))},remove:function(){this.pauseAnimation(),this.removeEventListeners()},pause:function(){this.paused=!0,this.pausedWasPlaying=this.animationIsPlaying,this.pauseAnimation(),this.removeEventListeners()},play:function(){this.paused&&(this.paused=!1,this.addEventListeners(),this.pausedWasPlaying&&(this.resumeAnimation(),this.pausedWasPlaying=!1))},createAndStartAnimation:function(){var ft=this.data;this.updateConfig(),this.animationIsPlaying=!1,this.animation=U(this.config),this.animation.began=!0,this.removeEventListeners(),this.addEventListeners(),!ft.autoplay||ft.startEvents&&ft.startEvents.length||(ft.delay?setTimeout(this.beginAnimation,ft.delay):this.beginAnimation())},beginAnimation:function(){this.updateConfig(),this.animation.began=!0,this.time=0,this.animationIsPlaying=!0,this.stopRelatedAnimations(),this.el.emit("animationbegin",this.eventDetail,!1)},pauseAnimation:function(){this.animationIsPlaying=!1},resumeAnimation:function(){this.animationIsPlaying=!0},onStartEvent:function(){this.data.enabled&&(this.updateConfig(),this.animation&&this.animation.pause(),this.animation=U(this.config),this.data.delay?setTimeout(this.beginAnimation,this.data.delay):this.beginAnimation())},updateConfigForRawColor:function(){var ft,wt,et,xt=this.config,Rt=this.data,Yt=this.el;if(!this.waitComponentInitRawProperty(this.updateConfigForRawColor)){for(wt in ft=""===Rt.from?rt(Yt,Rt.property):Rt.from,this.setColorConfig(ft,Rt.to),ft=this.fromColor,et=this.toColor,this.targetsArray.length=0,this.targetsArray.push(ft),xt.targets=this.targetsArray,et)xt[wt]=et[wt];var ve;xt.update=(ve={},function(xe){var Ge;(Ge=xe.animatables[0].target).r===ve.r&&Ge.g===ve.g&&Ge.b===ve.b||pt(Yt,Rt.property,Ge,Rt.type)})}},updateConfigForDefault:function(){var ft,wt,et,xt,Rt=this.config,Yt=this.data,ve=this.el;this.waitComponentInitRawProperty(this.updateConfigForDefault)||(ft=""===Yt.from?bt(Yt)?rt(ve,Yt.property):B(ve,Yt.property):Yt.from,et=Yt.to,isNaN(ft||et)?(ft=ft&&ft.toString(),et=et&&et.toString()):(ft=parseFloat(ft),et=parseFloat(et)),(wt="true"===Yt.to||"false"===Yt.to||!0===Yt.to||!1===Yt.to)&&(ft="true"===Yt.from||!0===Yt.from?1:0,et="true"===Yt.to||!0===Yt.to?1:0),this.targets.aframeProperty=ft,Rt.targets=this.targets,Rt.aframeProperty=et,Rt.update=function(xe){var Ge;(Ge=xe.animatables[0].target.aframeProperty)!==xt&&(xt=Ge,wt&&(Ge=Ge>=1),bt(Yt)?pt(ve,Yt.property,Ge,Yt.type):C(ve,Yt.property,Ge))})},updateConfigForVector:function(){var ft,wt,et,xt,xe,Rt=this.config,Yt=this.data,ve=this.el;for(ft in wt=""!==Yt.from?_.coordinates.parse(Yt.from):B(ve,Yt.property),et=_.coordinates.parse(Yt.to),Yt.property===F&&(Q(wt),Q(et)),this.targetsArray.length=0,this.targetsArray.push(wt),Rt.targets=this.targetsArray,et)Rt[ft]=et[ft];Rt.update="position"!==Yt.property&&Yt.property!==F&&"scale"!==Yt.property?(xe={},function(Ge){var en=Ge.animatables[0].target;en.x===xe.x&&en.y===xe.y&&en.z===xe.z||(xe.x=en.x,xe.y=en.y,xe.z=en.z,C(ve,Yt.property,en))}):(xt={},function(xe){var Ge=xe.animatables[0].target;Ge.x===xt.x&&Ge.y===xt.y&&Ge.z===xt.z||(xt.x=Ge.x,xt.y=Ge.y,xt.z=Ge.z,ve.object3D[Yt.property].set(Ge.x,Ge.y,Ge.z))})},updateConfig:function(){var ft,wt,xt,Rt,Yt,ve;wt=this.el,Rt=(Yt=this.data.property.split("."))[0],ve=Yt[1],ft=(xt=wt.components[Rt]||$[Rt])?ve&&!xt.schema[ve]?null:ve?xt.schema[ve].type:xt.schema.type:null,bt(this.data)&&this.data.type===k?this.updateConfigForRawColor():"vec2"===ft||"vec3"===ft||"vec4"===ft?this.updateConfigForVector():this.updateConfigForDefault()},waitComponentInitRawProperty:function(ft){var wt,et=this.data,xt=this.el,Rt=this;return""===et.from&&!!et.property.startsWith(G)&&(wt=vt(et.property)[1],!xt.components[wt]&&(xt.addEventListener("componentinitialized",function Yt(ve){ve.detail.name===wt&&(ft(),Rt.animation=U(Rt.config),xt.removeEventListener("componentinitialized",Yt))}),!0))},stopRelatedAnimations:function(){var ft,wt;for(wt in this.el.components)ft=this.el.components[wt],wt!==this.attrName&&"animation"===ft.name&&ft.animationIsPlaying&&ft.data.property===this.data.property&&(ft.animationIsPlaying=!1)},addEventListeners:function(){var ft=this.data,wt=this.el;X(wt,ft.startEvents,this.onStartEvent),X(wt,ft.pauseEvents,this.pauseAnimation),X(wt,ft.resumeEvents,this.resumeAnimation)},removeEventListeners:function(){var ft=this.data,wt=this.el;lt(wt,ft.startEvents,this.onStartEvent),lt(wt,ft.pauseEvents,this.pauseAnimation),lt(wt,ft.resumeEvents,this.resumeAnimation)},setColorConfig:function(ft,wt){E.set(ft),D.set(wt),wt=this.toColor,(ft=this.fromColor).r=E.r,ft.g=E.g,ft.b=E.b,wt.r=D.r,wt.g=D.g,wt.b=D.b}})},4395:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437);ot.exports.Component=U("camera",{schema:{active:{default:!0},far:{default:1e4},fov:{default:80,min:0},near:{default:.005,min:0},spectator:{default:!1},zoom:{default:1,min:0}},init:function(){var O,N=this.el;O=this.camera=new $.PerspectiveCamera,N.setObject3D("camera",O)},update:function(O){var N=this.data,_=this.camera;_.aspect=N.aspect||window.innerWidth/window.innerHeight,_.far=N.far,_.fov=N.fov,_.near=N.near,_.zoom=N.zoom,_.updateProjectionMatrix(),this.updateActiveCamera(O),this.updateSpectatorCamera(O)},updateActiveCamera:function(O){var N=this.data,_=this.el,E=this.system;O&&O.active===N.active||N.spectator||(N.active&&E.activeCameraEl!==_?E.setActiveCamera(_):N.active||E.activeCameraEl!==_||E.disableActiveCamera())},updateSpectatorCamera:function(O){var N=this.data,_=this.el,E=this.system;O&&O.spectator===N.spectator||(N.spectator&&E.spectatorCameraEl!==_?E.setSpectatorCamera(_):N.spectator||E.spectatorCameraEl!==_||E.disableSpectatorCamera())},remove:function(){this.el.removeObject3D("camera")}})},3674:(ot,ht,I)=>{var U,$,O,N,_=I(8190).registerComponent,E=I(7427),D="click",B="mouseup",C="cursor-fusing",M="cursor-hovering",k="cursor-hovered",F={DOWN:["mousedown","touchstart"],UP:["mouseup","touchend"]},G={DOWN:["selectstart"],UP:["selectend"]},Q="a-mouse-cursor-hover";ot.exports.Component=_("cursor",{dependencies:["raycaster"],schema:{downEvents:{default:[]},fuse:{default:E.device.isMobile()},fuseTimeout:{default:1500,min:0},mouseCursorStylesEnabled:{default:!0},upEvents:{default:[]},rayOrigin:{default:"entity",oneOf:["mouse","entity","xrselect"]}},after:["tracked-controls"],multiple:!0,init:function(){var X=this;this.fuseTimeout=void 0,this.cursorDownEl=null,this.intersectedEl=null,this.canvasBounds=document.body.getBoundingClientRect(),this.isCursorDown=!1,this.activeXRInput=null,this.updateCanvasBounds=E.debounce(function(){X.canvasBounds=X.el.sceneEl.canvas.getBoundingClientRect()},500),this.eventDetail={},this.intersectedEventDetail={cursorEl:this.el},this.onCursorDown=this.onCursorDown.bind(this),this.onCursorUp=this.onCursorUp.bind(this),this.onIntersection=this.onIntersection.bind(this),this.onIntersectionCleared=this.onIntersectionCleared.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onEnterVR=this.onEnterVR.bind(this)},update:function(X){this.data.rayOrigin!==X.rayOrigin&&this.updateMouseEventListeners()},tick:function(){var X=this.el.sceneEl.frame,lt=this.activeXRInput;"xrselect"===this.data.rayOrigin&&X&&lt&&this.onMouseMove({frame:X,inputSource:lt,type:"fakeselectevent"})},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},remove:function(){var X=this.el;X.removeState(M),X.removeState(C),clearTimeout(this.fuseTimeout),this.intersectedEl&&this.intersectedEl.removeState(k),this.removeEventListeners()},addEventListeners:function(){var X,lt=this.data,rt=this.el,pt=this;function vt(){X=rt.sceneEl.canvas,lt.downEvents.length||lt.upEvents.length||(F.DOWN.forEach(function(bt){X.addEventListener(bt,pt.onCursorDown,{passive:!1})}),F.UP.forEach(function(bt){X.addEventListener(bt,pt.onCursorUp,{passive:!1})}))}(X=rt.sceneEl.canvas)?vt():rt.sceneEl.addEventListener("render-target-loaded",vt),lt.downEvents.forEach(function(bt){rt.addEventListener(bt,pt.onCursorDown)}),lt.upEvents.forEach(function(bt){rt.addEventListener(bt,pt.onCursorUp)}),rt.addEventListener("raycaster-intersection",this.onIntersection),rt.addEventListener("raycaster-closest-entity-changed",this.onIntersection),rt.addEventListener("raycaster-intersection-cleared",this.onIntersectionCleared),rt.sceneEl.addEventListener("rendererresize",this.updateCanvasBounds),rt.sceneEl.addEventListener("enter-vr",this.onEnterVR),window.addEventListener("resize",this.updateCanvasBounds),window.addEventListener("scroll",this.updateCanvasBounds),this.updateMouseEventListeners()},removeEventListeners:function(){var X,lt=this.data,rt=this.el,pt=this;!(X=rt.sceneEl.canvas)||lt.downEvents.length||lt.upEvents.length||(F.DOWN.forEach(function(vt){X.removeEventListener(vt,pt.onCursorDown)}),F.UP.forEach(function(vt){X.removeEventListener(vt,pt.onCursorUp)})),lt.downEvents.forEach(function(vt){rt.removeEventListener(vt,pt.onCursorDown)}),lt.upEvents.forEach(function(vt){rt.removeEventListener(vt,pt.onCursorUp)}),rt.removeEventListener("raycaster-intersection",this.onIntersection),rt.removeEventListener("raycaster-intersection-cleared",this.onIntersectionCleared),X.removeEventListener("mousemove",this.onMouseMove),X.removeEventListener("touchstart",this.onMouseMove),X.removeEventListener("touchmove",this.onMouseMove),rt.sceneEl.removeEventListener("rendererresize",this.updateCanvasBounds),rt.sceneEl.removeEventListener("enter-vr",this.onEnterVR),window.removeEventListener("resize",this.updateCanvasBounds),window.removeEventListener("scroll",this.updateCanvasBounds)},updateMouseEventListeners:function(){var X,lt=this.el;(X=lt.sceneEl.canvas).removeEventListener("mousemove",this.onMouseMove),X.removeEventListener("touchmove",this.onMouseMove),lt.setAttribute("raycaster","useWorldCoordinates",!1),"mouse"===this.data.rayOrigin&&(X.addEventListener("mousemove",this.onMouseMove),X.addEventListener("touchmove",this.onMouseMove,{passive:!1}),lt.setAttribute("raycaster","useWorldCoordinates",!0),this.updateCanvasBounds())},onMouseMove:(U=new THREE.Vector3,$=new THREE.Vector2,O=new THREE.Vector3,N={origin:O,direction:U},function(X){var lt,rt,pt,vt,bt,ft,wt,et=this.canvasBounds,xt=this.el.sceneEl.camera;xt.parent.updateMatrixWorld(),lt=(rt="touchmove"===X.type||"touchstart"===X.type?X.touches.item(0):X).clientX-et.left,pt=rt.clientY-et.top,$.x=lt/et.width*2-1,$.y=-pt/et.height*2+1,"xrselect"!==this.data.rayOrigin||"selectstart"!==X.type&&"fakeselectevent"!==X.type?"fakeselectout"===X.type?(U.set(0,1,0),O.set(0,9999,0)):xt&&xt.isPerspectiveCamera?(O.setFromMatrixPosition(xt.matrixWorld),U.set($.x,$.y,.5).unproject(xt).sub(O).normalize()):xt&&xt.isOrthographicCamera?(O.set($.x,$.y,(xt.near+xt.far)/(xt.near-xt.far)).unproject(xt),U.set(0,0,-1).transformDirection(xt.matrixWorld)):console.error("AFRAME.Raycaster: Unsupported camera type: "+xt.type):(vt=X.frame,bt=X.inputSource,ft=this.el.renderer.xr.getReferenceSpace(),wt=vt.getPose(bt.targetRaySpace,ft).transform,U.set(0,0,-1),U.applyQuaternion(wt.orientation),O.copy(wt.position)),this.el.setAttribute("raycaster",N),"touchmove"===X.type&&X.preventDefault()}),onCursorDown:function(X){this.isCursorDown=!0,"mouse"===this.data.rayOrigin&&"touchstart"===X.type&&(this.onMouseMove(X),this.el.components.raycaster.checkIntersections(),X.preventDefault()),"xrselect"===this.data.rayOrigin&&"selectstart"===X.type&&(this.activeXRInput=X.inputSource,this.onMouseMove(X),this.el.components.raycaster.checkIntersections(),this.el.components.raycaster.intersectedEls.length&&void 0!==this.el.sceneEl.components["ar-hit-test"]&&this.el.sceneEl.getAttribute("ar-hit-test").enabled&&(this.el.sceneEl.setAttribute("ar-hit-test","enabled",!1),this.reenableARHitTest=!0)),this.twoWayEmit("mousedown",X),this.cursorDownEl=this.intersectedEl},onCursorUp:function(X){if(this.isCursorDown){this.isCursorDown=!1;var lt=this.data;this.twoWayEmit(B,X),!0===this.reenableARHitTest&&(this.el.sceneEl.setAttribute("ar-hit-test","enabled",!0),this.reenableARHitTest=void 0),this.cursorDownEl&&this.cursorDownEl!==this.intersectedEl&&(this.intersectedEventDetail.intersection=null,this.cursorDownEl.emit(B,this.intersectedEventDetail)),lt.fuse&&"mouse"!==lt.rayOrigin&&"xrselect"!==lt.rayOrigin||!this.intersectedEl||this.cursorDownEl!==this.intersectedEl||this.twoWayEmit(D,X),"xrselect"===lt.rayOrigin&&this.activeXRInput===X.inputSource&&this.onMouseMove({type:"fakeselectout"}),this.activeXRInput=null,this.cursorDownEl=null,"touchend"===X.type&&X.preventDefault()}},onIntersection:function(X){var lt,rt,pt,vt;vt=X.detail.intersections[rt=X.detail.els[0]===this.el?1:0],(pt=X.detail.els[rt])&&this.intersectedEl!==pt&&(this.intersectedEl&&(lt=this.el.components.raycaster.getIntersection(this.intersectedEl))&&lt.distance<=vt.distance||(this.clearCurrentIntersection(!0),this.setIntersection(pt,vt)))},onIntersectionCleared:function(X){-1!==X.detail.clearedEls.indexOf(this.intersectedEl)&&this.clearCurrentIntersection()},onEnterVR:function(){this.clearCurrentIntersection(!0);var X=this.el.sceneEl.xrSession,lt=this;X&&"mouse"!==this.data.rayOrigin&&(G.DOWN.forEach(function(rt){X.addEventListener(rt,lt.onCursorDown)}),G.UP.forEach(function(rt){X.addEventListener(rt,lt.onCursorUp)}))},setIntersection:function(X,lt){var rt=this.el,pt=this.data,vt=this;this.intersectedEl!==X&&(this.intersectedEl=X,rt.addState(M),X.addState(k),this.twoWayEmit("mouseenter"),this.data.mouseCursorStylesEnabled&&"mouse"===this.data.rayOrigin&&this.el.sceneEl.canvas.classList.add(Q),0!==pt.fuseTimeout&&pt.fuse&&"xrselect"!==pt.rayOrigin&&"mouse"!==pt.rayOrigin&&(rt.addState(C),this.twoWayEmit("fusing"),this.fuseTimeout=setTimeout(function(){rt.removeState(C),vt.twoWayEmit(D)},pt.fuseTimeout)))},clearCurrentIntersection:function(X){var lt,rt,pt=this.el;this.intersectedEl&&(this.intersectedEl.removeState(k),pt.removeState(M),pt.removeState(C),this.twoWayEmit("mouseleave"),this.data.mouseCursorStylesEnabled&&"mouse"===this.data.rayOrigin&&this.el.sceneEl.canvas.classList.remove(Q),this.intersectedEl=null,clearTimeout(this.fuseTimeout),!0!==X&&0!==(rt=this.el.components.raycaster.intersections).length&&(lt=rt[rt[0].object.el===pt?1:0])&&this.setIntersection(lt.object.el,lt))},twoWayEmit:function(X,lt){var rt,pt=this.el,vt=this.intersectedEl;function bt(ft,wt){lt instanceof MouseEvent?ft.mouseEvent=lt:typeof TouchEvent<"u"&&lt instanceof TouchEvent&&(ft.touchEvent=lt)}rt=this.el.components.raycaster.getIntersection(vt),this.eventDetail.intersectedEl=vt,this.eventDetail.intersection=rt,bt(this.eventDetail),pt.emit(X,this.eventDetail),vt&&(this.intersectedEventDetail.intersection=rt,bt(this.intersectedEventDetail),vt.emit(X,this.intersectedEventDetail))}})},8388:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7960),O=$.checkControllerPresentAndSetup,N=$.emitIfAxesChanged,_=$.onButtonEvent,E="generic";ot.exports.Component=U("generic-tracked-controller-controls",{schema:{hand:{default:""},defaultModel:{default:!0},defaultModelColor:{default:"gray"},orientationOffset:{type:"vec3"},disabled:{default:!1}},after:["tracked-controls"],mapping:{axes:{touchpad:[0,1],thumbstick:[2,3]},buttons:["trigger","squeeze","touchpad","thumbstick"]},bindMethods:function(){this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var D=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(B){_(B.detail.id,"down",D)},this.onButtonUp=function(B){_(B.detail.id,"up",D)},this.onButtonTouchStart=function(B){_(B.detail.id,"touchstart",D)},this.onButtonTouchEnd=function(B){_(B.detail.id,"touchend",D)},this.controllerPresent=!1,this.wasControllerConnected=!1,this.lastControllerCheck=0,this.bindMethods(),this.el.addEventListener("controllerconnected",function(B){B.detail.name!==D.name&&(D.wasControllerConnected=!0,D.removeEventListeners(),D.removeControllersUpdateListener())})},addEventListeners:function(){var D=this.el;D.addEventListener("buttonchanged",this.onButtonChanged),D.addEventListener("buttondown",this.onButtonDown),D.addEventListener("buttonup",this.onButtonUp),D.addEventListener("touchstart",this.onButtonTouchStart),D.addEventListener("touchend",this.onButtonTouchEnd),D.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var D=this.el;D.removeEventListener("buttonchanged",this.onButtonChanged),D.removeEventListener("buttondown",this.onButtonDown),D.removeEventListener("buttonup",this.onButtonUp),D.removeEventListener("touchstart",this.onButtonTouchStart),D.removeEventListener("touchend",this.onButtonTouchEnd),D.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var D=this.data;O(this,E,{hand:D.hand?D.hand:void 0,iterateControllerProfiles:!0})},play:function(){this.wasControllerConnected||(this.checkIfControllerPresent(),this.addControllersUpdateListener())},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var D=this.el,B=this.data;this.el.components["tracked-controls"]?this.removeEventListeners():(D.setAttribute("tracked-controls",{hand:B.hand,idPrefix:E,orientationOffset:B.orientationOffset,iterateControllerProfiles:!0}),this.data.defaultModel&&this.initDefaultModel())},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.wasControllerConnected&&this.checkIfControllerPresent()},onButtonChanged:function(D){var B=this.mapping.buttons[D.detail.id];B&&this.el.emit(B+"changed",D.detail.state)},onAxisMoved:function(D){N(this,this.mapping.axes,D)},initDefaultModel:function(){var D=this.modelEl=document.createElement("a-entity");D.setAttribute("geometry",{primitive:"sphere",radius:.03}),D.setAttribute("material",{color:this.data.color}),this.el.appendChild(D),this.el.emit("controllermodelready",{name:"generic-tracked-controller-controls",model:this.modelEl,rayOrigin:{origin:{x:0,y:0,z:-.01},direction:{x:0,y:0,z:-1}}})}})},9840:(ot,ht,I)=>{var U=I(7045).to,$=I(7045).Ls,O=I(8190).registerComponent,N=I(9437),_=new N.BufferGeometry;ot.exports.Component=O("geometry",{schema:{buffer:{default:!0},primitive:{default:"box",oneOf:$,schemaChange:!0},skipCache:{default:!1}},init:function(){this.geometry=null},update:function(E){var D,B=this.data,C=this.el,M=this.system;this.geometry&&(M.unuseGeometry(E),this.geometry=null),this.geometry=M.getOrCreateGeometry(B),(D=C.getObject3D("mesh"))?D.geometry=this.geometry:((D=new N.Mesh).geometry=this.geometry,this.el.getAttribute("material")||(D.material=new N.MeshStandardMaterial({color:16777215*Math.random(),metalness:0,roughness:.5})),C.setObject3D("mesh",D))},remove:function(){this.system.unuseGeometry(this.data),this.el.getObject3D("mesh").geometry=_,this.geometry=null},updateSchema:function(E){var D=this.oldData&&this.oldData.primitive,B=E.primitive,C=U[B]&&U[B].schema;if(!C)throw new Error("Unknown geometry schema `"+B+"`");D&&D===B||this.extendSchema(C)}})},297:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437),O=I(7427).debug("components:gltf-model:warn");ot.exports.Component=U("gltf-model",{schema:{type:"model"},init:function(){var N=this,_=this.system.getDRACOLoader(),E=this.system.getMeshoptDecoder(),D=this.system.getKTX2Loader();this.model=null,this.loader=new $.GLTFLoader,_&&this.loader.setDRACOLoader(_),this.ready=E?E.then(function(B){N.loader.setMeshoptDecoder(B)}):Promise.resolve(),D&&this.loader.setKTX2Loader(D)},update:function(){var N=this,_=this.el,E=this.data;E&&(this.remove(),this.ready.then(function(){N.loader.load(E,function(D){N.model=D.scene||D.scenes[0],N.model.animations=D.animations,_.setObject3D("mesh",N.model),_.emit("model-loaded",{format:"gltf",model:N.model})},void 0,function(D){O(D&&D.message?D.message:"Failed to load glTF model"),_.emit("model-error",{format:"gltf",src:E})})}))},remove:function(){this.model&&this.el.removeObject3D("mesh")}})},9194:(ot,ht,I)=>{(0,I(8190).registerComponent)("grabbable",{init:function(){this.el.setAttribute("obb-collider","centerModel: true")}})},332:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(1343).AFRAME_CDN_ROOT,O={toonLeft:$+"controllers/hands/leftHand.glb",toonRight:$+"controllers/hands/rightHand.glb",lowPolyLeft:$+"controllers/hands/leftHandLow.glb",lowPolyRight:$+"controllers/hands/rightHandLow.glb",highPolyLeft:$+"controllers/hands/leftHandHigh.glb",highPolyRight:$+"controllers/hands/rightHandHigh.glb"},N="Point",_="Fist",E="Thumb Up",D={};function B(C,M){var k;if(C)return"grip"===(k=D[C])?k+(M?"close":"open"):"point"===k?k+(M?"up":"down"):"pointing"===k||"pistol"===k?k+(M?"start":"end"):void 0}D[_]="grip",D[E]="pistol",D[N]="pointing",ot.exports.Component=U("hand-controls",{schema:{color:{default:"white",type:"color"},hand:{default:"left"},handModelStyle:{default:"lowPoly",oneOf:["lowPoly","highPoly","toon"]}},after:["tracked-controls"],init:function(){var C=this,M=this.el;this.pressedButtons={},this.touchedButtons={},this.loader=new THREE.GLTFLoader,this.loader.setCrossOrigin("anonymous"),this.onGripDown=function(){C.handleButton("grip","down")},this.onGripUp=function(){C.handleButton("grip","up")},this.onTrackpadDown=function(){C.handleButton("trackpad","down")},this.onTrackpadUp=function(){C.handleButton("trackpad","up")},this.onTrackpadTouchStart=function(){C.handleButton("trackpad","touchstart")},this.onTrackpadTouchEnd=function(){C.handleButton("trackpad","touchend")},this.onTriggerDown=function(){C.handleButton("trigger","down")},this.onTriggerUp=function(){C.handleButton("trigger","up")},this.onTriggerTouchStart=function(){C.handleButton("trigger","touchstart")},this.onTriggerTouchEnd=function(){C.handleButton("trigger","touchend")},this.onGripTouchStart=function(){C.handleButton("grip","touchstart")},this.onGripTouchEnd=function(){C.handleButton("grip","touchend")},this.onThumbstickDown=function(){C.handleButton("thumbstick","down")},this.onThumbstickUp=function(){C.handleButton("thumbstick","up")},this.onAorXTouchStart=function(){C.handleButton("AorX","touchstart")},this.onAorXTouchEnd=function(){C.handleButton("AorX","touchend")},this.onBorYTouchStart=function(){C.handleButton("BorY","touchstart")},this.onBorYTouchEnd=function(){C.handleButton("BorY","touchend")},this.onSurfaceTouchStart=function(){C.handleButton("surface","touchstart")},this.onSurfaceTouchEnd=function(){C.handleButton("surface","touchend")},this.onControllerConnected=this.onControllerConnected.bind(this),this.onControllerDisconnected=this.onControllerDisconnected.bind(this),M.addEventListener("controllerconnected",this.onControllerConnected),M.addEventListener("controllerdisconnected",this.onControllerDisconnected),M.object3D.visible=!1},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},tick:function(C,M){var k=this.el.getObject3D("mesh");k&&k.mixer&&k.mixer.update(M/1e3)},onControllerConnected:function(){this.el.object3D.visible=!0},onControllerDisconnected:function(){this.el.object3D.visible=!1},addEventListeners:function(){var C=this.el;C.addEventListener("gripdown",this.onGripDown),C.addEventListener("gripup",this.onGripUp),C.addEventListener("trackpaddown",this.onTrackpadDown),C.addEventListener("trackpadup",this.onTrackpadUp),C.addEventListener("trackpadtouchstart",this.onTrackpadTouchStart),C.addEventListener("trackpadtouchend",this.onTrackpadTouchEnd),C.addEventListener("triggerdown",this.onTriggerDown),C.addEventListener("triggerup",this.onTriggerUp),C.addEventListener("triggertouchstart",this.onTriggerTouchStart),C.addEventListener("triggertouchend",this.onTriggerTouchEnd),C.addEventListener("griptouchstart",this.onGripTouchStart),C.addEventListener("griptouchend",this.onGripTouchEnd),C.addEventListener("thumbstickdown",this.onThumbstickDown),C.addEventListener("thumbstickup",this.onThumbstickUp),C.addEventListener("abuttontouchstart",this.onAorXTouchStart),C.addEventListener("abuttontouchend",this.onAorXTouchEnd),C.addEventListener("bbuttontouchstart",this.onBorYTouchStart),C.addEventListener("bbuttontouchend",this.onBorYTouchEnd),C.addEventListener("xbuttontouchstart",this.onAorXTouchStart),C.addEventListener("xbuttontouchend",this.onAorXTouchEnd),C.addEventListener("ybuttontouchstart",this.onBorYTouchStart),C.addEventListener("ybuttontouchend",this.onBorYTouchEnd),C.addEventListener("surfacetouchstart",this.onSurfaceTouchStart),C.addEventListener("surfacetouchend",this.onSurfaceTouchEnd)},removeEventListeners:function(){var C=this.el;C.removeEventListener("gripdown",this.onGripDown),C.removeEventListener("gripup",this.onGripUp),C.removeEventListener("trackpaddown",this.onTrackpadDown),C.removeEventListener("trackpadup",this.onTrackpadUp),C.removeEventListener("trackpadtouchstart",this.onTrackpadTouchStart),C.removeEventListener("trackpadtouchend",this.onTrackpadTouchEnd),C.removeEventListener("triggerdown",this.onTriggerDown),C.removeEventListener("triggerup",this.onTriggerUp),C.removeEventListener("triggertouchstart",this.onTriggerTouchStart),C.removeEventListener("triggertouchend",this.onTriggerTouchEnd),C.removeEventListener("griptouchstart",this.onGripTouchStart),C.removeEventListener("griptouchend",this.onGripTouchEnd),C.removeEventListener("thumbstickdown",this.onThumbstickDown),C.removeEventListener("thumbstickup",this.onThumbstickUp),C.removeEventListener("abuttontouchstart",this.onAorXTouchStart),C.removeEventListener("abuttontouchend",this.onAorXTouchEnd),C.removeEventListener("bbuttontouchstart",this.onBorYTouchStart),C.removeEventListener("bbuttontouchend",this.onBorYTouchEnd),C.removeEventListener("xbuttontouchstart",this.onAorXTouchStart),C.removeEventListener("xbuttontouchend",this.onAorXTouchEnd),C.removeEventListener("ybuttontouchstart",this.onBorYTouchStart),C.removeEventListener("ybuttontouchend",this.onBorYTouchEnd),C.removeEventListener("surfacetouchstart",this.onSurfaceTouchStart),C.removeEventListener("surfacetouchend",this.onSurfaceTouchEnd)},update:function(C){var M,k=this.el,F=this.data.hand,Q=this.data.color,X=this;if(M={hand:F,model:!1},F!==C){var lt=O[this.data.handModelStyle+F.charAt(0).toUpperCase()+F.slice(1)];this.loader.load(lt,function(rt){var pt=rt.scene.children[0],vt="left"===F?Math.PI/2:-Math.PI/2,bt=k.sceneEl.hasWebXR?-Math.PI/2:0;pt.mixer=new THREE.AnimationMixer(pt),X.clips=rt.animations,k.setObject3D("mesh",pt),pt.traverse(function(ft){ft.isMesh&&(ft.material.color=new THREE.Color(Q))}),pt.position.set(0,0,0),pt.rotation.set(bt,0,vt),k.setAttribute("magicleap-controls",M),k.setAttribute("vive-controls",M),k.setAttribute("oculus-touch-controls",M),k.setAttribute("pico-controls",M),k.setAttribute("windows-motion-controls",M),k.setAttribute("hp-mixed-reality-controls",M)})}},remove:function(){this.el.removeObject3D("mesh")},handleButton:function(C,M){var k,F="down"===M,G="touchstart"===M;if(0===M.indexOf("touch")){if(G===this.touchedButtons[C])return;this.touchedButtons[C]=G}else{if(F===this.pressedButtons[C])return;this.pressedButtons[C]=F}k=this.gesture,this.gesture=this.determineGesture(),this.gesture!==k&&(this.animateGesture(this.gesture,k),this.emitGestureEvents(this.gesture,k))},determineGesture:function(){var C,M,k,F=this.pressedButtons.grip,G=this.pressedButtons.surface||this.touchedButtons.surface,Q=this.pressedButtons.trackpad||this.touchedButtons.trackpad,X=this.pressedButtons.trigger||this.touchedButtons.trigger,lt=this.touchedButtons.AorX||this.touchedButtons.BorY;return(k=(M=this.el.components["tracked-controls"])&&M.controller)&&(k.id&&0===k.id.indexOf("OpenVR ")||k.profiles&&k.profiles[0]&&"htc-vive"===k.profiles[0])?F||X?C=_:Q&&(C=N):F?C=G||lt||Q?X?_:N:X?E:"Point + Thumb":X&&(C="Hold"),C},getClip:function(C){var M,k;for(k=0;k<this.clips.length;k++)if((M=this.clips[k]).name===C)return M},animateGesture:function(C,M){C?this.playAnimation(C||"Open",M,!1):this.playAnimation(M,M,!0)},emitGestureEvents:function(C,M){var k,F=this.el;M!==C&&((k=B(M,!1))&&F.emit(k),(k=B(C,!0))&&F.emit(k))},playAnimation:function(C,M,k){var F,G,Q=this.el.getObject3D("mesh");if(Q){if(F=this.getClip(C),G=Q.mixer.clipAction(F),k)return G.paused=!1,void(G.timeScale=-1);if(G.clampWhenFinished=!0,G.loop=THREE.LoopOnce,G.repetitions=0,G.timeScale=1,G.time=0,G.weight=1,!M)return Q.mixer.stopAllAction(),void G.play();F=this.getClip(M),G.reset(),G.play(),Q.mixer.clipAction(F).crossFadeTo(G,.15,!0)}}})},9686:(ot,ht,I)=>{var U,C,$=I(8190).registerComponent,O=I(4056).P,N=I(7960).checkControllerPresentAndSetup,_=I(1343).AFRAME_CDN_ROOT,E=_+"controllers/oculus-hands/v4/left.glb",D=_+"controllers/oculus-hands/v4/right.glb",B=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"];ot.exports.Component=$("hand-tracking-controls",{schema:{hand:{default:"right",oneOf:["left","right"]},modelStyle:{default:"mesh",oneOf:["dots","mesh"]},modelColor:{default:"white"},modelOpacity:{default:1}},after:["tracked-controls"],bindMethods:function(){this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this)},addEventListeners:function(){this.el.addEventListener("model-loaded",this.onModelLoaded);for(var C=0;C<this.jointEls.length;++C)this.jointEls[C].object3D.visible=!0},removeEventListeners:function(){this.el.removeEventListener("model-loaded",this.onModelLoaded);for(var C=0;C<this.jointEls.length;++C)this.jointEls[C].object3D.visible=!1},init:function(){var C=this.el.sceneEl,M=C.getAttribute("webxr"),k=M.optionalFeatures;-1===k.indexOf("hand-tracking")&&(k.push("hand-tracking"),C.setAttribute("webxr",M)),this.wristObject3D=new THREE.Object3D,this.el.sceneEl.object3D.add(this.wristObject3D),this.onModelLoaded=this.onModelLoaded.bind(this),this.onChildAttached=this.onChildAttached.bind(this),this.jointEls=[],this.controllerPresent=!1,this.isPinched=!1,this.pinchEventDetail={position:new THREE.Vector3,wristRotation:new THREE.Quaternion},this.indexTipPosition=new THREE.Vector3,this.hasPoses=!1,this.jointPoses=new Float32Array(16*B.length),this.jointRadii=new Float32Array(B.length),this.bindMethods(),this.updateReferenceSpace=this.updateReferenceSpace.bind(this),this.el.sceneEl.addEventListener("enter-vr",this.updateReferenceSpace),this.el.sceneEl.addEventListener("exit-vr",this.updateReferenceSpace),this.el.addEventListener("child-attached",this.onChildAttached),this.el.object3D.visible=!1,this.wristObject3D.visible=!1},onChildAttached:function(C){this.addChildEntity(C.detail.el)},update:function(){this.updateModelMaterial()},updateModelMaterial:function(){var C=this.jointEls,k=1!==this.data.modelOpacity;this.skinnedMesh&&(this.skinnedMesh.material.color.set(this.data.modelColor),this.skinnedMesh.material.transparent=k,this.skinnedMesh.material.opacity=this.data.modelOpacity);for(var F=0;F<C.length;F++)C[F].setAttribute("material",{color:this.data.modelColor,transparent:k,opacity:this.data.modelOpacity})},updateReferenceSpace:function(){var C=this,M=this.el.sceneEl.xrSession;if(this.referenceSpace=void 0,M){var k=C.el.sceneEl.systems.webxr.sessionReferenceSpaceType;M.requestReferenceSpace(k).then(function(F){C.referenceSpace=F}).catch(function(F){throw C.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(k,"tracked-controls-webxr uses reference space "+k),F})}},checkIfControllerPresent:function(){var C=this.data;N(this,"",{hand:C.hand?C.hand:void 0,iterateControllerProfiles:!0,handTracking:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},tick:function(){var M=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller,k=this.el.sceneEl.frame,G=this.referenceSpace;M&&k&&G&&this.el.components["tracked-controls-webxr"]&&(this.hasPoses=!1,M.hand&&(this.el.object3D.position.set(0,0,0),this.el.object3D.rotation.set(0,0,0),this.hasPoses=k.fillPoses(M.hand.values(),G,this.jointPoses)&&k.fillJointRadii(M.hand.values(),this.jointRadii),this.updateHandModel(),this.detectGesture(),this.updateWristObject()))},updateWristObject:(U=new THREE.Matrix4,function(){var C=this.wristObject3D;C&&this.hasPoses&&(U.fromArray(this.jointPoses,0),C.position.setFromMatrixPosition(U),C.quaternion.setFromRotationMatrix(U))}),updateHandModel:function(){"dots"===this.data.modelStyle&&this.updateHandDotsModel(),"mesh"===this.data.modelStyle&&this.updateHandMeshModel()},getBone:function(C){for(var M=this.bones,k=0;k<M.length;k++)if(M[k].name===C)return M[k];return null},updateHandMeshModel:(C=new THREE.Matrix4,function(){var M=0,k=this.jointPoses,F=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller;if(F&&this.mesh&&(this.mesh.visible=!1,this.hasPoses))for(var G of F.hand.values()){var Q=this.getBone(G.jointName);null!=Q&&(this.mesh.visible=!0,C.fromArray(k,16*M),Q.position.setFromMatrixPosition(C),Q.quaternion.setFromRotationMatrix(C)),M++}}),updateHandDotsModel:function(){for(var C,M,k=this.jointPoses,F=this.jointRadii,G=this.el.components["tracked-controls"]&&this.el.components["tracked-controls"].controller,Q=0;Q<G.hand.size;Q++)M=(C=this.jointEls[Q]).object3D,C.object3D.visible=this.hasPoses,this.hasPoses&&(M.matrix.fromArray(k,16*Q),M.matrix.decompose(M.position,M.rotation,M.scale),C.setAttribute("scale",{x:F[Q],y:F[Q],z:F[Q]}))},detectGesture:function(){this.detectPinch()},detectPinch:function(){var C=new THREE.Vector3,M=new THREE.Matrix4;return function(){var k=this.indexTipPosition,F=this.pinchEventDetail;if(this.hasPoses){C.setFromMatrixPosition(M.fromArray(this.jointPoses,64)),k.setFromMatrixPosition(M.fromArray(this.jointPoses,144)),F.wristRotation.setFromRotationMatrix(M.fromArray(this.jointPoses,0));var G=k.distanceTo(C);G<.015&&!1===this.isPinched&&(this.isPinched=!0,this.pinchDistance=G,F.position.copy(k).add(C).multiplyScalar(.5),this.el.emit("pinchstarted",F)),G>this.pinchDistance+.1*this.pinchDistance&&!0===this.isPinched&&(this.isPinched=!1,F.position.copy(k).add(C).multiplyScalar(.5),this.el.emit("pinchended",F)),this.isPinched&&(F.position.copy(k).add(C).multiplyScalar(.5),this.el.emit("pinchmoved",F))}}}(),pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var C=this.el;C.setAttribute("tracked-controls",{id:"",hand:this.data.hand,iterateControllerProfiles:!0,handTrackingEnabled:!0}),this.mesh?this.mesh!==C.getObject3D("mesh")&&C.setObject3D("mesh",this.mesh):this.initDefaultModel()},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){var C,M=this.el;this.checkIfControllerPresent(),C=M.components["tracked-controls"]&&M.components["tracked-controls"].controller,this.mesh&&C&&C.hand&&C.hand instanceof XRHand&&M.setObject3D("mesh",this.mesh)},initDefaultModel:function(){var C=this.data;"dots"===C.modelStyle&&this.initDotsModel(),"mesh"===C.modelStyle&&this.initMeshHandModel(),this.el.object3D.visible=!0,this.wristObject3D.visible=!0},initDotsModel:function(){if(0===this.jointEls.length){for(var C=0;C<B.length;++C){var M=this.jointEl=document.createElement("a-entity");M.setAttribute("geometry",{primitive:"sphere",radius:1}),M.object3D.visible=!1,this.el.appendChild(M),this.jointEls.push(M)}this.updateModelMaterial()}},initMeshHandModel:function(){this.el.setAttribute("gltf-model","left"===this.data.hand?E:D)},onModelLoaded:function(){var C=this.mesh=this.el.getObject3D("mesh").children[0],M=this.skinnedMesh=C.getObjectByProperty("type","SkinnedMesh");this.skinnedMesh&&(this.bones=M.skeleton.bones,this.el.removeObject3D("mesh"),C.position.set(0,0,0),C.rotation.set(0,0,0),M.frustumCulled=!1,M.material=new THREE.MeshStandardMaterial,this.updateModelMaterial(),this.setupChildrenEntities(),this.el.setObject3D("mesh",C))},setupChildrenEntities:function(){for(var C=this.el.children,M=0;M<C.length;++M)C[M]instanceof O&&this.addChildEntity(C[M])},addChildEntity:function(C){C instanceof O&&this.wristObject3D.add(C.object3D)}})},5593:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437);U("hand-tracking-grab-controls",{schema:{hand:{default:"right",oneOf:["left","right"]},color:{type:"color",default:"white"},hoverColor:{type:"color",default:"#538df1"},hoverEnabled:{default:!1}},init:function(){var O,N=this.el,_=this.data;O="right"===_.hand?"components.hand-tracking-controls.bones.3":"components.hand-tracking-controls.bones.21",N.setAttribute("hand-tracking-controls",{hand:_.hand}),N.setAttribute("obb-collider",{trackedObject3D:O,size:.04}),this.auxMatrix=new $.Matrix4,this.auxQuaternion=new $.Quaternion,this.auxQuaternion2=new $.Quaternion,this.auxVector=new $.Vector3,this.auxVector2=new $.Vector3,this.grabbingObjectPosition=new $.Vector3,this.grabbedObjectPosition=new $.Vector3,this.grabbedObjectPositionDelta=new $.Vector3,this.grabDeltaPosition=new $.Vector3,this.grabInitialRotation=new $.Quaternion,this.onCollisionStarted=this.onCollisionStarted.bind(this),this.el.addEventListener("obbcollisionstarted",this.onCollisionStarted),this.onCollisionEnded=this.onCollisionEnded.bind(this),this.el.addEventListener("obbcollisionended",this.onCollisionEnded),this.onPinchStarted=this.onPinchStarted.bind(this),this.el.addEventListener("pinchstarted",this.onPinchStarted),this.onPinchEnded=this.onPinchEnded.bind(this),this.el.addEventListener("pinchended",this.onPinchEnded),this.onPinchMoved=this.onPinchMoved.bind(this),this.el.addEventListener("pinchmoved",this.onPinchMoved)},transferEntityOwnership:function(){for(var O,N=this.el.sceneEl.querySelectorAll("[hand-tracking-grab-controls]"),_=0;_<N.length;++_)(O=N[_].components["hand-tracking-grab-controls"])!==this&&this.grabbedEl&&this.grabbedEl===O.grabbedEl&&O.releaseGrabbedEntity();return!1},onCollisionStarted:function(O){var N=O.detail.withEl;this.collidedEl||N.getAttribute("grabbable")&&(this.collidedEl=N,this.grabbingObject3D=O.detail.trackedObject3D,this.data.hoverEnabled&&this.el.setAttribute("hand-tracking-controls","modelColor",this.data.hoverColor))},onCollisionEnded:function(){this.collidedEl=void 0,this.grabbedEl||(this.grabbingObject3D=void 0,this.data.hoverEnabled&&this.el.setAttribute("hand-tracking-controls","modelColor",this.data.color))},onPinchStarted:function(O){this.collidedEl&&(this.pinchPosition=O.detail.position,this.wristRotation=O.detail.wristRotation,this.grabbedEl=this.collidedEl,this.transferEntityOwnership(),this.grab())},onPinchEnded:function(){this.releaseGrabbedEntity()},onPinchMoved:function(O){this.wristRotation=O.detail.wristRotation},releaseGrabbedEntity:function(){var O=this.grabbedEl;O&&(O.object3D.updateMatrixWorld=this.originalUpdateMatrixWorld,O.object3D.matrixAutoUpdate=!0,O.object3D.matrixWorldAutoUpdate=!0,O.object3D.matrixWorld.decompose(this.auxVector,this.auxQuaternion,this.auxVector2),O.object3D.position.copy(this.auxVector),O.object3D.quaternion.copy(this.auxQuaternion),this.el.emit("grabended",{grabbedEl:O}),this.grabbedEl=void 0)},grab:function(){var O,N=this.grabbedEl;O=N.object3D.getWorldPosition(this.grabbedObjectPosition),this.grabDeltaPosition.copy(O).sub(this.pinchPosition),this.grabInitialRotation.copy(this.auxQuaternion.copy(this.wristRotation).invert()),this.originalUpdateMatrixWorld=N.object3D.updateMatrixWorld,N.object3D.updateMatrixWorld=function(){},N.object3D.updateMatrixWorldChildren=function(_){for(var E=this.children,D=0,B=E.length;D<B;D++){var C=E[D];!0!==C.matrixWorldAutoUpdate&&!0!==_||C.updateMatrixWorld(!0)}},N.object3D.matrixAutoUpdate=!1,N.object3D.matrixWorldAutoUpdate=!1,this.el.emit("grabstarted",{grabbedEl:N})},tock:function(){var O,N=this.auxMatrix,_=this.auxQuaternion,E=this.auxQuaternion2,D=this.grabbedEl;D&&((O=D.object3D).getWorldQuaternion(E),O.matrixWorld.identity(),N.identity(),N.makeTranslation(this.pinchPosition),O.matrixWorld.multiply(N),N.identity(),N.makeRotationFromQuaternion(_.copy(this.wristRotation).multiply(this.grabInitialRotation)),O.matrixWorld.multiply(N),N.identity(),N.makeTranslation(this.grabDeltaPosition),O.matrixWorld.multiply(N),N.identity(),N.makeRotationFromQuaternion(E),O.matrixWorld.multiply(N),N.makeScale(D.object3D.scale.x,D.object3D.scale.y,D.object3D.scale.z),O.matrixWorld.multiply(N),O.updateMatrixWorldChildren())}})},5387:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("hide-on-enter-ar",{init:function(){var $=this;this.el.sceneEl.addEventListener("enter-vr",function(){$.el.sceneEl.is("ar-mode")&&($.el.object3D.visible=!1)}),this.el.sceneEl.addEventListener("exit-vr",function(){$.el.object3D.visible=!0})}})},1620:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("hide-on-enter-vr",{init:function(){var $=this;this.el.sceneEl.addEventListener("enter-vr",function(){$.el.sceneEl.is("vr-mode")&&($.el.object3D.visible=!1)}),this.el.sceneEl.addEventListener("exit-vr",function(){$.el.object3D.visible=!0})}})},7538:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437),O=I(7960),N=O.checkControllerPresentAndSetup,_=O.emitIfAxesChanged,E=O.onButtonEvent,D="hp-mixed-reality",B=I(1343).AFRAME_CDN_ROOT+"controllers/hp/mixed-reality/",C={x:0,y:0,z:.06},M={_x:Math.PI/4,_y:0,_z:0,_order:"XYZ"};ot.exports.Component=U("hp-mixed-reality-controls",{schema:{hand:{default:"none"},model:{default:!0},orientationOffset:{type:"vec3"}},mapping:{left:{axes:{touchpad:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton"]},right:{axes:{touchpad:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton"]}},init:function(){var k=this;this.controllerPresent=!1,this.lastControllerCheck=0,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(F){E(F.detail.id,"down",k,k.data.hand)},this.onButtonUp=function(F){E(F.detail.id,"up",k,k.data.hand)},this.onButtonTouchEnd=function(F){E(F.detail.id,"touchend",k,k.data.hand)},this.onButtonTouchStart=function(F){E(F.detail.id,"touchstart",k,k.data.hand)},this.previousButtonValues={},this.bindMethods()},update:function(){var k=this.data;this.controllerIndex="right"===k.hand?0:"left"===k.hand?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var k=this.el;k.addEventListener("buttonchanged",this.onButtonChanged),k.addEventListener("buttondown",this.onButtonDown),k.addEventListener("buttonup",this.onButtonUp),k.addEventListener("touchstart",this.onButtonTouchStart),k.addEventListener("touchend",this.onButtonTouchEnd),k.addEventListener("axismove",this.onAxisMoved),k.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var k=this.el;k.removeEventListener("buttonchanged",this.onButtonChanged),k.removeEventListener("buttondown",this.onButtonDown),k.removeEventListener("buttonup",this.onButtonUp),k.removeEventListener("touchstart",this.onButtonTouchStart),k.removeEventListener("touchend",this.onButtonTouchEnd),k.removeEventListener("axismove",this.onAxisMoved),k.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){N(this,D,{index:this.controllerIndex,hand:this.data.hand})},injectTrackedControls:function(){var F=this.data;this.el.setAttribute("tracked-controls",{idPrefix:D,hand:F.hand,controller:this.controllerIndex,orientationOffset:F.orientationOffset}),this.data.model&&this.el.setAttribute("gltf-model",B+this.data.hand+".glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(k){var G=this.mapping[this.data.hand].buttons[k.detail.id];G&&("trigger"===G&&console.log("analog value of trigger press: "+k.detail.state.value),this.el.emit(G+"changed",k.detail.state))},onModelLoaded:function(k){var F=k.detail.model;this.data.model&&(F.position.copy(C),F.rotation.copy(M),this.el.emit("controllermodelready",{name:"hp-mixed-reality-controls",model:this.data.model,rayOrigin:new $.Vector3(0,0,0)}))},onAxisMoved:function(k){_(this,this.mapping.axes,k)}})},8850:(ot,ht,I)=>{I(6896),I(2784),I(4395),I(3674),I(9840),I(8388),I(297),I(9194),I(9686),I(5593),I(332),I(5387),I(1620),I(7538),I(6219),I(9248),I(8798),I(6298),I(7796),I(7850),I(298),I(3069),I(3176),I(8771),I(6077),I(5744),I(2588),I(7519),I(7394),I(2310),I(4760),I(1072),I(477),I(1603),I(6547),I(4524),I(6466),I(5300),I(7360),I(1507),I(4592),I(6458),I(221),I(3575),I(4005),I(3494),I(6273),I(3239),I(2288),I(6149),I(2130),I(3791),I(2662),I(952),I(1217),I(8346),I(6469)},9248:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7427);U("laser-controls",{schema:{hand:{default:"right"},model:{default:!0},defaultModelColor:{type:"color",default:"grey"}},init:function(){var O=this.config,N=this.data,_=this.el,E=this,D={hand:N.hand,model:N.model};function B(C){var M=O[C.detail.name];if(M){var k=$.extend({showLine:!0},M.raycaster||{});C.detail.rayOrigin&&(k.origin=C.detail.rayOrigin.origin,k.direction=C.detail.rayOrigin.direction,k.showLine=!0),C.detail.rayOrigin||!E.modelReady?_.setAttribute("raycaster",k):_.setAttribute("raycaster","showLine",!0),_.setAttribute("cursor",$.extend({fuse:!1},M.cursor))}}_.setAttribute("hp-mixed-reality-controls",D),_.setAttribute("magicleap-controls",D),_.setAttribute("oculus-go-controls",D),_.setAttribute("oculus-touch-controls",D),_.setAttribute("pico-controls",D),_.setAttribute("valve-index-controls",D),_.setAttribute("vive-controls",D),_.setAttribute("vive-focus-controls",D),_.setAttribute("windows-motion-controls",D),_.setAttribute("generic-tracked-controller-controls",{hand:D.hand}),_.addEventListener("controllerconnected",B),_.addEventListener("controllerdisconnected",function(C){O[C.detail.name]&&_.setAttribute("raycaster","showLine",!1)}),_.addEventListener("controllermodelready",function(C){B(C),E.modelReady=!0})},config:{"generic-tracked-controller-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"hp-mixed-reality-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:0,z:0}}},"magicleap-controls":{cursor:{downEvents:["trackpaddown","triggerdown"],upEvents:["trackpadup","triggerup"]}},"oculus-go-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:5e-4,z:0}}},"oculus-touch-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{origin:{x:0,y:0,z:0}}},"pico-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"valve-index-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"vive-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]}},"vive-focus-controls":{cursor:{downEvents:["trackpaddown","triggerdown"],upEvents:["trackpadup","triggerup"]}},"windows-motion-controls":{cursor:{downEvents:["triggerdown"],upEvents:["triggerup"]},raycaster:{showLine:!1}}}})},6219:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7427).debug("components:layer:warn");ot.exports.Component=U("layer",{schema:{type:{default:"quad",oneOf:["quad","monocubemap","stereocubemap"]},src:{type:"map"},rotateCubemap:{default:!1},width:{default:0},height:{default:0}},init:function(){var O=this.el.sceneEl.renderer.getContext();this.quaternion=new THREE.Quaternion,this.position=new THREE.Vector3,this.bindMethods(),this.needsRedraw=!1,this.frameBuffer=O.createFramebuffer();var N=this.el.sceneEl.getAttribute("webxr"),_=N.requiredFeatures;-1===_.indexOf("layers")&&(_.push("layers"),this.el.sceneEl.setAttribute("webxr",N)),this.el.sceneEl.addEventListener("enter-vr",this.onEnterVR),this.el.sceneEl.addEventListener("exit-vr",this.onExitVR)},bindMethods:function(){this.onRequestedReferenceSpace=this.onRequestedReferenceSpace.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.onExitVR=this.onExitVR.bind(this)},update:function(O){this.data.src!==O.src&&this.updateSrc()},updateSrc:function(){var O=this.data.type;this.texture=void 0,"quad"!==O?"monocubemap"!==O&&"stereocubemap"!==O||this.loadCubeMapImages():this.loadQuadImage()},loadCubeMapImages:function(){var O,N=this.xrGLFactory,_=this.el.sceneEl.frame,E=this.data.src,D=this.data.type;this.visibilityChanged=!1,this.layer&&("monocubemap"!==D&&"stereocubemap"!==D||(this.pendingCubeMapUpdate=!E.complete,this.loadingScreen=!this.loadingScreen,"monocubemap"===D?(O=N.getSubImage(this.layer,_),this.loadCubeMapImage(O.colorTexture,E,0)):(O=N.getSubImage(this.layer,_,"left"),this.loadCubeMapImage(O.colorTexture,E,0),O=N.getSubImage(this.layer,_,"right"),this.loadCubeMapImage(O.colorTexture,E,6))))},loadQuadImage:function(){var O=this.data.src,N=this;this.el.sceneEl.systems.material.loadTexture(O,{src:O},function(_){N.el.sceneEl.renderer.initTexture(_),N.texture=_,"VIDEO"===O.tagName&&setTimeout(function(){N.textureIsVideo=!0},1e3),N.layer&&(N.layer.height=N.data.height/2||N.texture.image.height/1e3,N.layer.width=N.data.width/2||N.texture.image.width/1e3,N.needsRedraw=!0),N.updateQuadPanel()})},preGenerateCubeMapTextures:function(O,N){"monocubemap"===this.data.type?this.generateCubeMapTextures(O,0,N):(this.generateCubeMapTextures(O,0,N),this.generateCubeMapTextures(O,6,N))},generateCubeMapTextures:function(O,N,_){for(var E,B=this.data,C=this.cubeFaceSize,M=Math.min(O.width,O.height),k=[],F=0;F<6;F++){var G=document.createElement("CANVAS");G.width=G.height=C;var Q=G.getContext("2d");B.rotateCubemap&&(2!==F&&3!==F||(Q.save(),Q.translate(C,C),Q.rotate(Math.PI))),Q.drawImage(O,(F+N)*M,0,M,M,0,0,C,C),Q.restore(),_&&_(),k.push(G)}return B.rotateCubemap&&(E=k[0],k[0]=k[1],k[1]=E,E=k[4],k[4]=k[5],k[5]=E),_&&_(),k},loadCubeMapImage:function(O,N,_){var E,D=this.el.sceneEl.renderer.getContext();D.pixelStorei(D.UNPACK_FLIP_Y_WEBGL,!1),D.bindTexture(D.TEXTURE_CUBE_MAP,O),E=!N.complete||this.loadingScreen?this.loadingScreenImages:this.generateCubeMapTextures(N,_);var B=0;E.forEach(function(C,M){D.texSubImage2D(D.TEXTURE_CUBE_MAP_POSITIVE_X+M,0,0,0,D.RGBA,D.UNSIGNED_BYTE,C),B=D.getError()}),0!==B&&console.log("renderingError, WebGL Error Code: "+B),D.bindTexture(D.TEXTURE_CUBE_MAP,null)},tick:function(){this.el.sceneEl.xrSession&&(this.layer||!this.el.sceneEl.is("vr-mode")&&!this.el.sceneEl.is("ar-mode")||this.initLayer(),this.updateTransform(),this.data.src.complete&&(this.pendingCubeMapUpdate||this.loadingScreen||this.visibilityChanged)&&this.loadCubeMapImages(),(this.needsRedraw||this.layer.needsRedraw||this.textureIsVideo)&&("quad"===this.data.type&&this.draw(),this.needsRedraw=!1))},initLayer:function(){var O=this,N=this.data.type;this.el.sceneEl.xrSession.onvisibilitychange=function(_){O.visibilityChanged="hidden"!==_.session.visibilityState},"quad"!==N?"monocubemap"!==N&&"stereocubemap"!==N||this.initCubeMapLayer():this.initQuadLayer()},initQuadLayer:function(){var O=this.el.sceneEl,N=O.renderer.getContext(),_=this.xrGLFactory=new XRWebGLBinding(O.xrSession,N);this.texture&&(this.layer=_.createQuadLayer({space:this.referenceSpace,viewPixelHeight:2048,viewPixelWidth:2048,height:this.data.height/2||this.texture.image.height/1e3,width:this.data.width/2||this.texture.image.width/1e3}),this.initLoadingScreenImages(),O.renderer.xr.addLayer(this.layer))},initCubeMapLayer:function(){var O=this.data.src,N=this.el.sceneEl,_=N.renderer.getContext(),E=_.getParameter(_.MAX_CUBE_MAP_TEXTURE_SIZE),D=this.cubeFaceSize=Math.min(E,Math.min(O.width,O.height)),B=this.xrGLFactory=new XRWebGLBinding(N.xrSession,_);this.layer=B.createCubeLayer({space:this.referenceSpace,viewPixelWidth:D,viewPixelHeight:D,layout:"monocubemap"===this.data.type?"mono":"stereo",isStatic:!1}),this.initLoadingScreenImages(),this.loadCubeMapImages(),N.renderer.xr.addLayer(this.layer)},initLoadingScreenImages:function(){for(var O=this.cubeFaceSize,N=this.loadingScreenImages=[],_=0;_<6;_++){var E=document.createElement("CANVAS");E.width=E.height=O;var D=E.getContext("2d");E.width=E.height=O,D.fillStyle="black",D.fillRect(0,0,O,O),2!==_&&3!==_&&(D.translate(O,0),D.scale(-1,1),D.fillStyle="white",D.font="30px Arial",D.fillText("Loading",O/2,O/2)),N.push(E)}},destroyLayer:function(){this.layer&&(this.el.sceneEl.renderer.xr.removeLayer(this.layer),this.layer.destroy(),this.layer=void 0)},toggleCompositorLayer:function(){this.enableCompositorLayer(!this.layerEnabled)},enableCompositorLayer:function(O){this.layerEnabled=O,this.quadPanelEl.object3D.visible=!this.layerEnabled},updateQuadPanel:function(){var O=this.quadPanelEl;this.quadPanelEl||(O=this.quadPanelEl=document.createElement("a-entity"),this.el.appendChild(O)),O.setAttribute("material",{shader:"flat",src:this.data.src,transparent:!0}),O.setAttribute("geometry",{primitive:"plane",height:this.data.height||this.texture.image.height/1e3,width:this.data.width||this.texture.image.height/1e3})},draw:function(){var B,C,M,k,F,G,Q,X,lt,O=this.el.sceneEl,N=this.el.sceneEl.renderer.getContext(),_=this.xrGLFactory.getSubImage(this.layer,O.frame),E=O.renderer.properties.get(this.texture).__webglTexture,D=N.getParameter(N.FRAMEBUFFER_BINDING);N.viewport(_.viewport.x,_.viewport.y,_.viewport.width,_.viewport.height),N.bindFramebuffer(N.FRAMEBUFFER,this.frameBuffer),N.framebufferTexture2D(N.FRAMEBUFFER,N.COLOR_ATTACHMENT0,N.TEXTURE_2D,_.colorTexture,0),C=E,M=_,k=this.data.src,F=(B=N).createFramebuffer(),G=M.viewport.x,Q=M.viewport.y,X=M.viewport.x+M.viewport.width,lt=M.viewport.y+M.viewport.height,"VIDEO"===k.tagName&&(B.bindTexture(B.TEXTURE_2D,C),B.texSubImage2D(B.TEXTURE_2D,0,0,0,k.width,k.height,B.RGB,B.UNSIGNED_BYTE,k)),B.bindFramebuffer(B.READ_FRAMEBUFFER,F),B.framebufferTexture2D(B.READ_FRAMEBUFFER,B.COLOR_ATTACHMENT0,B.TEXTURE_2D,C,0),B.readBuffer(B.COLOR_ATTACHMENT0),B.blitFramebuffer(0,0,k.width,k.height,G,Q,X,lt,B.COLOR_BUFFER_BIT,B.NEAREST),B.bindFramebuffer(B.READ_FRAMEBUFFER,null),B.deleteFramebuffer(F),N.bindFramebuffer(N.FRAMEBUFFER,D)},updateTransform:function(){var O=this.el,N=this.position,_=this.quaternion;O.object3D.updateMatrixWorld(),N.setFromMatrixPosition(O.object3D.matrixWorld),_.setFromRotationMatrix(O.object3D.matrixWorld),this.layerEnabled||N.set(0,0,1e8),this.layer.transform=new XRRigidTransform(N,_)},onEnterVR:function(){var O=this.el.sceneEl,N=O.xrSession;O.hasWebXR&&XRWebGLBinding&&N?(N.requestReferenceSpace("local-floor").then(this.onRequestedReferenceSpace),this.layerEnabled=!0,this.quadPanelEl&&(this.quadPanelEl.object3D.visible=!1),this.data.src.play&&this.data.src.play()):$("The layer component requires WebXR and the layers API enabled")},onExitVR:function(){this.quadPanelEl&&(this.quadPanelEl.object3D.visible=!0),this.destroyLayer()},onRequestedReferenceSpace:function(O){this.referenceSpace=O}})},8798:(ot,ht,I)=>{var U,$,O,N,_,E,D=I(7427),B=D.diff,C=I(8940),M=I(8190).registerComponent,k=I(9437),F=I(3657),G=k.MathUtils.degToRad,Q=C("components:light:warn"),X=new k.CubeTextureLoader,lt={};ot.exports.Component=M("light",{schema:{angle:{default:60,if:{type:["spot"]}},color:{type:"color",if:{type:["ambient","directional","hemisphere","point","spot"]}},envMap:{default:"",if:{type:["probe"]}},groundColor:{type:"color",if:{type:["hemisphere"]}},decay:{default:1,if:{type:["point","spot"]}},distance:{default:0,min:0,if:{type:["point","spot"]}},intensity:{default:1,min:0,if:{type:["ambient","directional","hemisphere","point","spot","probe"]}},penumbra:{default:0,min:0,max:1,if:{type:["spot"]}},type:{default:"directional",oneOf:["ambient","directional","hemisphere","point","spot","probe"],schemaChange:!0},target:{type:"selector",if:{type:["spot","directional"]}},castShadow:{default:!1,if:{type:["point","spot","directional"]}},shadowBias:{default:0,if:{castShadow:!0}},shadowCameraFar:{default:500,if:{castShadow:!0}},shadowCameraFov:{default:90,if:{castShadow:!0}},shadowCameraNear:{default:.5,if:{castShadow:!0}},shadowCameraTop:{default:5,if:{castShadow:!0}},shadowCameraRight:{default:5,if:{castShadow:!0}},shadowCameraBottom:{default:-5,if:{castShadow:!0}},shadowCameraLeft:{default:-5,if:{castShadow:!0}},shadowCameraVisible:{default:!1,if:{castShadow:!0}},shadowCameraAutomatic:{default:"",if:{type:["directional"]}},shadowMapHeight:{default:512,if:{castShadow:!0}},shadowMapWidth:{default:512,if:{castShadow:!0}},shadowRadius:{default:1,if:{castShadow:!0}}},init:function(){var rt=this.el;this.light=null,this.defaultTarget=null,this.system.registerLight(rt)},update:function(rt){var pt=this.data,vt=B(pt,rt),bt=this.light,ft=this;if(!bt||"type"in vt)this.setLight(this.data),this.updateShadow();else{var wt=!1;Object.keys(vt).forEach(function(et){var xt=pt[et];switch(et){case"color":bt.color.set(xt);break;case"groundColor":bt.groundColor.set(xt);break;case"angle":bt.angle=G(xt);break;case"target":null===xt?"spot"!==pt.type&&"directional"!==pt.type||(bt.target=ft.defaultTarget):xt.hasLoaded?ft.onSetTarget(xt,bt):xt.addEventListener("loaded",ft.onSetTarget.bind(ft,xt,bt));break;case"envMap":ft.updateProbeMap(pt,bt);break;case"castShadow":case"shadowBias":case"shadowCameraFar":case"shadowCameraFov":case"shadowCameraNear":case"shadowCameraTop":case"shadowCameraRight":case"shadowCameraBottom":case"shadowCameraLeft":case"shadowCameraVisible":case"shadowMapHeight":case"shadowMapWidth":case"shadowRadius":wt||(ft.updateShadow(),wt=!0);break;case"shadowCameraAutomatic":ft.shadowCameraAutomaticEls=pt.shadowCameraAutomatic?Array.from(document.querySelectorAll(pt.shadowCameraAutomatic)):[];break;default:bt[et]=xt}})}},tick:(U=new k.Box3,$=new k.Vector3,O=new k.Vector3,N=new k.Matrix4,_=new k.Sphere,E=new k.Vector3,function(){if("directional"===this.data.type&&this.light.shadow&&this.light.shadow.camera instanceof k.OrthographicCamera&&this.shadowCameraAutomaticEls.length){var rt=this.light.shadow.camera;rt.getWorldDirection($),rt.getWorldPosition(O),N.copy(rt.matrixWorld),N.invert(),rt.near=1,rt.left=1e5,rt.right=-1e5,rt.top=-1e5,rt.bottom=1e5,this.shadowCameraAutomaticEls.forEach(function(pt){U.setFromObject(pt.object3D),U.getBoundingSphere(_);var vt=F.distanceOfPointFromPlane(O,$,_.center),bt=F.nearestPointInPlane(O,$,_.center,E).applyMatrix4(N);rt.near=Math.min(-vt-_.radius-1,rt.near),rt.left=Math.min(-_.radius+bt.x,rt.left),rt.right=Math.max(_.radius+bt.x,rt.right),rt.top=Math.max(_.radius+bt.y,rt.top),rt.bottom=Math.min(-_.radius+bt.y,rt.bottom)}),rt.updateProjectionMatrix()}}),setLight:function(rt){var pt=this.el,vt=this.getLight(rt);vt&&(this.light&&pt.removeObject3D("light"),this.light=vt,this.light.el=pt,pt.setObject3D("light",this.light),"spot"!==rt.type&&"directional"!==rt.type&&"hemisphere"!==rt.type||pt.getObject3D("light").translateY(-1),"spot"===rt.type&&(pt.setObject3D("light-target",this.defaultTarget),pt.getObject3D("light-target").position.set(0,0,-1)),this.shadowCameraAutomaticEls=rt.shadowCameraAutomatic?Array.from(document.querySelectorAll(rt.shadowCameraAutomatic)):[])},updateShadow:function(){var rt=this.el,pt=this.data,vt=this.light;vt.castShadow=pt.castShadow;var bt=rt.getObject3D("cameraHelper");if(pt.shadowCameraVisible&&!bt?rt.setObject3D("cameraHelper",new k.CameraHelper(vt.shadow.camera)):!pt.shadowCameraVisible&&bt&&rt.removeObject3D("cameraHelper"),!pt.castShadow)return vt;vt.shadow.bias=pt.shadowBias,vt.shadow.radius=pt.shadowRadius,vt.shadow.mapSize.height=pt.shadowMapHeight,vt.shadow.mapSize.width=pt.shadowMapWidth,vt.shadow.camera.near=pt.shadowCameraNear,vt.shadow.camera.far=pt.shadowCameraFar,vt.shadow.camera instanceof k.OrthographicCamera?(vt.shadow.camera.top=pt.shadowCameraTop,vt.shadow.camera.right=pt.shadowCameraRight,vt.shadow.camera.bottom=pt.shadowCameraBottom,vt.shadow.camera.left=pt.shadowCameraLeft):vt.shadow.camera.fov=pt.shadowCameraFov,vt.shadow.camera.updateProjectionMatrix(),bt&&bt.update()},getLight:function(rt){var pt=rt.angle,vt=new k.Color(rt.color);vt=vt.getHex();var bt=rt.decay,ft=rt.distance,wt=new k.Color(rt.groundColor);wt=wt.getHex();var et=rt.intensity,xt=rt.type,Rt=rt.target,Yt=null;switch(xt.toLowerCase()){case"ambient":return new k.AmbientLight(vt,et);case"directional":return Yt=new k.DirectionalLight(vt,et),this.defaultTarget=Yt.target,Rt&&(Rt.hasLoaded?this.onSetTarget(Rt,Yt):Rt.addEventListener("loaded",this.onSetTarget.bind(this,Rt,Yt))),Yt;case"hemisphere":return new k.HemisphereLight(vt,wt,et);case"point":return new k.PointLight(vt,et,ft,bt);case"spot":return Yt=new k.SpotLight(vt,et,ft,G(pt),rt.penumbra,bt),this.defaultTarget=Yt.target,Rt&&(Rt.hasLoaded?this.onSetTarget(Rt,Yt):Rt.addEventListener("loaded",this.onSetTarget.bind(this,Rt,Yt))),Yt;case"probe":return Yt=new k.LightProbe,this.updateProbeMap(rt,Yt),Yt;default:Q("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.",xt)}},updateProbeMap:function(rt,pt){rt.envMap||pt.copy(new k.LightProbe),lt[rt.envMap]instanceof window.Promise&&lt[rt.envMap].then(function(vt){pt.copy(vt)}),lt[rt.envMap]instanceof k.LightProbe&&pt.copy(lt[rt.envMap]),lt[rt.envMap]=new window.Promise(function(vt){D.srcLoader.validateCubemapSrc(rt.envMap,function(bt){X.load(bt,function(ft){var wt=k.LightProbeGenerator.fromCubeTexture(ft);lt[rt.envMap]=wt,pt.copy(wt)})})})},onSetTarget:function(rt,pt){pt.target=rt.object3D},remove:function(){var rt=this.el;rt.removeObject3D("light"),rt.getObject3D("cameraHelper")&&rt.removeObject3D("cameraHelper")}})},6298:(ot,ht,I)=>{var U=I(8190).registerComponent;function $(O,N){return!(!O||!N)&&O.x===N.x&&O.y===N.y&&O.z===N.z}ot.exports.Component=U("line",{schema:{start:{type:"vec3",default:{x:0,y:0,z:0}},end:{type:"vec3",default:{x:0,y:0,z:0}},color:{type:"color",default:"#74BEC1"},opacity:{type:"number",default:1},visible:{default:!0}},multiple:!0,init:function(){var O,N,_=this.data;N=this.material=new THREE.LineBasicMaterial({color:_.color,opacity:_.opacity,transparent:_.opacity<1,visible:_.visible}),(O=this.geometry=new THREE.BufferGeometry).setAttribute("position",new THREE.BufferAttribute(new Float32Array(6),3)),this.line=new THREE.Line(O,N),this.el.setObject3D(this.attrName,this.line)},update:function(O){var N=this.data,_=this.geometry,E=!1,D=this.material,B=_.attributes.position.array;$(N.start,O.start)||(B[0]=N.start.x,B[1]=N.start.y,B[2]=N.start.z,E=!0),$(N.end,O.end)||(B[3]=N.end.x,B[4]=N.end.y,B[5]=N.end.z,E=!0),E&&(_.attributes.position.needsUpdate=!0,_.computeBoundingSphere()),D.color.setStyle(N.color),D.opacity=N.opacity,D.transparent=N.opacity<1,D.visible=N.visible},remove:function(){this.el.removeObject3D(this.attrName,this.line)}})},7796:(ot,ht,I)=>{var U,$,O,N,_,E,D,B,C=I(8190).registerComponent,M=I(5892).registerShader,k=I(9437);ot.exports.Component=C("link",{schema:{backgroundColor:{default:"red",type:"color"},borderColor:{default:"white",type:"color"},highlighted:{default:!1},highlightedColor:{default:"#24CAFF",type:"color"},href:{default:""},image:{type:"asset"},on:{default:"click"},peekMode:{default:!1},title:{default:""},titleColor:{default:"white",type:"color"},visualAspectEnabled:{default:!1}},init:function(){this.navigate=this.navigate.bind(this),this.previousQuaternion=void 0,this.quaternionClone=new k.Quaternion,this.hiddenEls=[]},update:function(F){var Q,X=this.data,lt=this.el;X.visualAspectEnabled&&(this.initVisualAspect(),Q=X.highlighted?X.highlightedColor:X.borderColor,lt.setAttribute("material","backgroundColor",X.highlighted?X.highlightedColor:X.backgroundColor),lt.setAttribute("material","strokeColor",Q),X.on!==F.on&&this.updateEventListener(),void 0!==F.peekMode&&X.peekMode!==F.peekMode&&this.updatePeekMode(),X.image&&F.image!==X.image&&lt.setAttribute("material","pano","string"==typeof X.image?X.image:X.image.src))},updatePeekMode:function(){var F=this.el,G=this.sphereEl;this.data.peekMode?(this.hideAll(),F.getObject3D("mesh").visible=!1,G.setAttribute("visible",!0)):(this.showAll(),F.getObject3D("mesh").visible=!0,G.setAttribute("visible",!1))},play:function(){this.updateEventListener()},pause:function(){this.removeEventListener()},updateEventListener:function(){var F=this.el;F.isPlaying&&(this.removeEventListener(),F.addEventListener(this.data.on,this.navigate))},removeEventListener:function(){var F=this.data.on;F&&this.el.removeEventListener(F,this.navigate)},initVisualAspect:function(){var F,G,Q,X=this.el;this.data.visualAspectEnabled&&!this.visualAspectInitialized&&(Q=this.textEl=this.textEl||document.createElement("a-entity"),G=this.sphereEl=this.sphereEl||document.createElement("a-entity"),F=this.semiSphereEl=this.semiSphereEl||document.createElement("a-entity"),X.setAttribute("geometry",{primitive:"circle",radius:1,segments:64}),X.setAttribute("material",{shader:"portal",pano:this.data.image,side:"double"}),Q.setAttribute("text",{color:this.data.titleColor,align:"center",font:"kelsonsans",value:this.data.title||this.data.href,width:4}),Q.setAttribute("position","0 1.5 0"),X.appendChild(Q),F.setAttribute("geometry",{primitive:"sphere",radius:1,phiStart:0,segmentsWidth:64,segmentsHeight:64,phiLength:180,thetaStart:0,thetaLength:360}),F.setAttribute("material",{shader:"portal",borderEnabled:0,pano:this.data.image,side:"back"}),F.setAttribute("rotation","0 180 0"),F.setAttribute("position","0 0 0"),F.setAttribute("visible",!1),X.appendChild(F),G.setAttribute("geometry",{primitive:"sphere",radius:10,segmentsWidth:64,segmentsHeight:64}),G.setAttribute("material",{shader:"portal",borderEnabled:0,pano:this.data.image,side:"back"}),G.setAttribute("visible",!1),X.appendChild(G),this.visualAspectInitialized=!0)},navigate:function(){window.location=this.data.href},tick:(_=new k.Vector3,E=new k.Vector3,D=new k.Quaternion,B=new k.Vector3,function(){var F,G,Q=this.el,X=Q.object3D,lt=Q.sceneEl.camera,rt=this.textEl;if(this.data.visualAspectEnabled)if(X.updateMatrixWorld(),lt.parent.updateMatrixWorld(),lt.updateMatrixWorld(),X.matrix.decompose(E,D,B),E.setFromMatrixPosition(X.matrixWorld),_.setFromMatrixPosition(lt.matrixWorld),(G=E.distanceTo(_))>20)this.previousQuaternion||(this.quaternionClone.copy(D),this.previousQuaternion=this.quaternionClone),X.lookAt(_);else{if(F=this.calculateCameraPortalOrientation(),G<.5){if(!0===this.semiSphereEl.getAttribute("visible"))return;rt.setAttribute("text","width",1.5),F<=0?(rt.setAttribute("position","0 0 0.75"),rt.setAttribute("rotation","0 180 0"),this.semiSphereEl.setAttribute("rotation","0 0 0")):(rt.setAttribute("position","0 0 -0.75"),rt.setAttribute("rotation","0 0 0"),this.semiSphereEl.setAttribute("rotation","0 180 0")),Q.getObject3D("mesh").visible=!1,this.semiSphereEl.setAttribute("visible",!0),this.peekCameraPortalOrientation=F}else rt.setAttribute("rotation",F<=0?"0 180 0":"0 0 0"),rt.setAttribute("text","width",5),rt.setAttribute("position","0 1.5 0"),Q.getObject3D("mesh").visible=!0,this.semiSphereEl.setAttribute("visible",!1),this.peekCameraPortalOrientation=void 0;this.previousQuaternion&&(X.quaternion.copy(this.previousQuaternion),this.previousQuaternion=void 0)}}),hideAll:function(){var F=this.el,G=this.hiddenEls,Q=this;G.length>0||F.sceneEl.object3D.traverse(function(X){X&&X.el&&X.el.hasAttribute("link-controls")||X.el&&X!==F.sceneEl.object3D&&X.el!==F&&X.el!==Q.sphereEl&&X.el!==F.sceneEl.cameraEl&&!1!==X.el.getAttribute("visible")&&X.el!==Q.textEl&&X.el!==Q.semiSphereEl&&(X.el.setAttribute("visible",!1),G.push(X.el))})},showAll:function(){this.hiddenEls.forEach(function(F){F.setAttribute("visible",!0)}),this.hiddenEls=[]},calculateCameraPortalOrientation:(U=new k.Matrix4,$=new k.Vector3,O=new k.Vector3(0,0,1),N=new k.Vector3(0,0,0),function(){var F=this.el,G=F.sceneEl.camera;return $.set(0,0,0),O.set(0,0,1),N.set(0,0,0),F.object3D.matrixWorld.extractRotation(U),O.applyMatrix4(U),F.object3D.updateMatrixWorld(),F.object3D.localToWorld(N),G.parent.parent.updateMatrixWorld(),G.parent.updateMatrixWorld(),G.updateMatrixWorld(),G.localToWorld($),$.sub(N).normalize(),O.normalize(),Math.sign(O.dot($))}),remove:function(){this.removeEventListener()}}),M("portal",{schema:{borderEnabled:{default:1,type:"int",is:"uniform"},backgroundColor:{default:"red",type:"color",is:"uniform"},pano:{type:"map",is:"uniform"},strokeColor:{default:"white",type:"color",is:"uniform"}},vertexShader:["vec3 portalPosition;","varying vec3 vWorldPosition;","varying float vDistanceToCenter;","varying float vDistance;","void main() {","vDistanceToCenter = clamp(length(position - vec3(0.0, 0.0, 0.0)), 0.0, 1.0);","portalPosition = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz;","vDistance = length(portalPosition - cameraPosition);","vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),fragmentShader:["#define RECIPROCAL_PI2 0.15915494","uniform sampler2D pano;","uniform vec3 strokeColor;","uniform vec3 backgroundColor;","uniform float borderEnabled;","varying float vDistanceToCenter;","varying float vDistance;","varying vec3 vWorldPosition;","void main() {","vec3 direction = normalize(vWorldPosition - cameraPosition);","vec2 sampleUV;","float borderThickness = clamp(exp(-vDistance / 50.0), 0.6, 0.95);","sampleUV.y = clamp(direction.y * 0.5  + 0.5, 0.0, 1.0);","sampleUV.x = atan(direction.z, -direction.x) * -RECIPROCAL_PI2 + 0.5;","if (vDistanceToCenter > borderThickness && borderEnabled == 1.0) {","gl_FragColor = vec4(strokeColor, 1.0);","} else {","gl_FragColor = mix(texture2D(pano, sampleUV), vec4(backgroundColor, 1.0), clamp(pow((vDistance / 15.0), 2.0), 0.0, 1.0));","}","}"].join("\n")})},7850:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437),O=I(7427),N=Math.PI/2;ot.exports.Component=U("look-controls",{dependencies:["position","rotation"],schema:{enabled:{default:!0},magicWindowTrackingEnabled:{default:!0},pointerLockEnabled:{default:!1},reverseMouseDrag:{default:!1},reverseTouchDrag:{default:!1},touchEnabled:{default:!0},mouseEnabled:{default:!0}},init:function(){this.deltaYaw=0,this.previousHMDPosition=new $.Vector3,this.hmdQuaternion=new $.Quaternion,this.magicWindowAbsoluteEuler=new $.Euler,this.magicWindowDeltaEuler=new $.Euler,this.position=new $.Vector3,this.magicWindowObject=new $.Object3D,this.rotation={},this.deltaRotation={},this.savedPose=null,this.pointerLocked=!1,this.setupMouseControls(),this.bindMethods(),this.previousMouseEvent={},this.setupMagicWindowControls(),this.savedPose={position:new $.Vector3,rotation:new $.Euler},(this.el.sceneEl.is("vr-mode")||this.el.sceneEl.is("ar-mode"))&&this.onEnterVR()},setupMagicWindowControls:function(){var _,E=this.data;(O.device.isMobile()||O.device.isMobileDeviceRequestingDesktopSite())&&(_=this.magicWindowControls=new $.DeviceOrientationControls(this.magicWindowObject),typeof DeviceOrientationEvent<"u"&&DeviceOrientationEvent.requestPermission&&(_.enabled=!1,this.el.sceneEl.components["device-orientation-permission-ui"].permissionGranted?_.enabled=E.magicWindowTrackingEnabled:this.el.sceneEl.addEventListener("deviceorientationpermissiongranted",function(){_.enabled=E.magicWindowTrackingEnabled})))},update:function(_){var E=this.data;E.enabled!==_.enabled&&this.updateGrabCursor(E.enabled),_&&!E.magicWindowTrackingEnabled&&_.magicWindowTrackingEnabled&&(this.magicWindowAbsoluteEuler.set(0,0,0),this.magicWindowDeltaEuler.set(0,0,0)),this.magicWindowControls&&(this.magicWindowControls.enabled=E.magicWindowTrackingEnabled),_&&!E.pointerLockEnabled!==_.pointerLockEnabled&&(this.removeEventListeners(),this.addEventListeners(),this.pointerLocked&&this.exitPointerLock())},tick:function(_){this.data.enabled&&this.updateOrientation()},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners(),this.pointerLocked&&this.exitPointerLock()},remove:function(){this.removeEventListeners(),this.pointerLocked&&this.exitPointerLock()},bindMethods:function(){this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onEnterVR=this.onEnterVR.bind(this),this.onExitVR=this.onExitVR.bind(this),this.onPointerLockChange=this.onPointerLockChange.bind(this),this.onPointerLockError=this.onPointerLockError.bind(this)},setupMouseControls:function(){this.mouseDown=!1,this.pitchObject=new $.Object3D,this.yawObject=new $.Object3D,this.yawObject.position.y=10,this.yawObject.add(this.pitchObject)},addEventListeners:function(){var _=this.el.sceneEl,E=_.canvas;E?(E.addEventListener("mousedown",this.onMouseDown,!1),window.addEventListener("mousemove",this.onMouseMove,!1),window.addEventListener("mouseup",this.onMouseUp,!1),E.addEventListener("touchstart",this.onTouchStart,{passive:!0}),window.addEventListener("touchmove",this.onTouchMove,{passive:!0}),window.addEventListener("touchend",this.onTouchEnd,{passive:!0}),_.addEventListener("enter-vr",this.onEnterVR),_.addEventListener("exit-vr",this.onExitVR),this.data.pointerLockEnabled&&(document.addEventListener("pointerlockchange",this.onPointerLockChange,!1),document.addEventListener("mozpointerlockchange",this.onPointerLockChange,!1),document.addEventListener("pointerlockerror",this.onPointerLockError,!1))):_.addEventListener("render-target-loaded",this.addEventListeners.bind(this))},removeEventListeners:function(){var _=this.el.sceneEl,E=_&&_.canvas;E&&(E.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mouseup",this.onMouseUp),E.removeEventListener("touchstart",this.onTouchStart),window.removeEventListener("touchmove",this.onTouchMove),window.removeEventListener("touchend",this.onTouchEnd),_.removeEventListener("enter-vr",this.onEnterVR),_.removeEventListener("exit-vr",this.onExitVR),document.removeEventListener("pointerlockchange",this.onPointerLockChange,!1),document.removeEventListener("mozpointerlockchange",this.onPointerLockChange,!1),document.removeEventListener("pointerlockerror",this.onPointerLockError,!1))},updateOrientation:function(){var _=this.el.object3D,E=this.pitchObject,D=this.yawObject,B=this.el.sceneEl;(B.is("vr-mode")||B.is("ar-mode"))&&B.checkHeadsetConnected()||(this.updateMagicWindowOrientation(),_.rotation.x=this.magicWindowDeltaEuler.x+E.rotation.x,_.rotation.y=this.magicWindowDeltaEuler.y+D.rotation.y,_.rotation.z=this.magicWindowDeltaEuler.z)},updateMagicWindowOrientation:function(){var _=this.magicWindowAbsoluteEuler,E=this.magicWindowDeltaEuler;this.magicWindowControls&&this.magicWindowControls.enabled&&(this.magicWindowControls.update(),_.setFromQuaternion(this.magicWindowObject.quaternion,"YXZ"),this.previousMagicWindowYaw||0===_.y||(this.previousMagicWindowYaw=_.y),this.previousMagicWindowYaw&&(E.x=_.x,E.y+=_.y-this.previousMagicWindowYaw,E.z=_.z,this.previousMagicWindowYaw=_.y))},onMouseMove:function(_){var E,D,B,C=this.pitchObject,M=this.previousMouseEvent,k=this.yawObject;this.data.enabled&&(this.mouseDown||this.pointerLocked)&&(this.pointerLocked?(D=_.movementX||_.mozMovementX||0,B=_.movementY||_.mozMovementY||0):(D=_.screenX-M.screenX,B=_.screenY-M.screenY),this.previousMouseEvent.screenX=_.screenX,this.previousMouseEvent.screenY=_.screenY,k.rotation.y+=.002*D*(E=this.data.reverseMouseDrag?1:-1),C.rotation.x+=.002*B*E,C.rotation.x=Math.max(-N,Math.min(N,C.rotation.x)))},onMouseDown:function(_){var E=this.el.sceneEl;if(this.data.enabled&&this.data.mouseEnabled&&(!E.is("vr-mode")&&!E.is("ar-mode")||!E.checkHeadsetConnected())&&0===_.button){var D=E&&E.canvas;this.mouseDown=!0,this.previousMouseEvent.screenX=_.screenX,this.previousMouseEvent.screenY=_.screenY,this.showGrabbingCursor(),this.data.pointerLockEnabled&&!this.pointerLocked&&(D.requestPointerLock?D.requestPointerLock():D.mozRequestPointerLock&&D.mozRequestPointerLock())}},showGrabbingCursor:function(){this.el.sceneEl.canvas.style.cursor="grabbing"},hideGrabbingCursor:function(){this.el.sceneEl.canvas.style.cursor=""},onMouseUp:function(){this.mouseDown=!1,this.hideGrabbingCursor()},onTouchStart:function(_){1!==_.touches.length||!this.data.touchEnabled||this.el.sceneEl.is("vr-mode")||this.el.sceneEl.is("ar-mode")||(this.touchStart={x:_.touches[0].pageX,y:_.touches[0].pageY},this.touchStarted=!0)},onTouchMove:function(_){var D;this.touchStarted&&this.data.touchEnabled&&(D=2*Math.PI*(_.touches[0].pageX-this.touchStart.x)/this.el.sceneEl.canvas.clientWidth,this.yawObject.rotation.y-=.5*D*(this.data.reverseTouchDrag?1:-1),this.touchStart={x:_.touches[0].pageX,y:_.touches[0].pageY})},onTouchEnd:function(){this.touchStarted=!1},onEnterVR:function(){var _=this.el.sceneEl;_.checkHeadsetConnected()&&(this.saveCameraPose(),this.el.object3D.position.set(0,0,0),this.el.object3D.rotation.set(0,0,0),_.hasWebXR&&(this.el.object3D.matrixAutoUpdate=!1,this.el.object3D.updateMatrix()))},onExitVR:function(){this.el.sceneEl.checkHeadsetConnected()&&(this.restoreCameraPose(),this.previousHMDPosition.set(0,0,0),this.el.object3D.matrixAutoUpdate=!0)},onPointerLockChange:function(){this.pointerLocked=!(!document.pointerLockElement&&!document.mozPointerLockElement)},onPointerLockError:function(){this.pointerLocked=!1},exitPointerLock:function(){document.exitPointerLock(),this.pointerLocked=!1},updateGrabCursor:function(_){var E=this.el.sceneEl;function D(){E.canvas.classList.add("a-grab-cursor")}function B(){E.canvas.classList.remove("a-grab-cursor")}E.canvas?_?D():B():E.addEventListener("render-target-loaded",_?D:B)},saveCameraPose:function(){var _=this.el;this.savedPose.position.copy(_.object3D.position),this.savedPose.rotation.copy(_.object3D.rotation),this.hasSavedPose=!0},restoreCameraPose:function(){var _=this.el,E=this.savedPose;this.hasSavedPose&&(_.object3D.position.copy(E.position),_.object3D.rotation.copy(E.rotation),this.hasSavedPose=!1)}})},298:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7960),O=$.checkControllerPresentAndSetup,N=$.emitIfAxesChanged,_=$.onButtonEvent,E="magicleap-one",D=I(1343).AFRAME_CDN_ROOT+"controllers/magicleap/magicleap-one-controller.glb";ot.exports.Component=U("magicleap-controls",{schema:{hand:{default:"none"},model:{default:!0},orientationOffset:{type:"vec3"}},mapping:{axes:{touchpad:[0,1]},buttons:["trigger","grip","touchpad","menu"]},init:function(){var B=this;this.controllerPresent=!1,this.lastControllerCheck=0,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(C){_(C.detail.id,"down",B)},this.onButtonUp=function(C){_(C.detail.id,"up",B)},this.onButtonTouchEnd=function(C){_(C.detail.id,"touchend",B)},this.onButtonTouchStart=function(C){_(C.detail.id,"touchstart",B)},this.previousButtonValues={},this.bindMethods()},update:function(){var B=this.data;this.controllerIndex="right"===B.hand?0:"left"===B.hand?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var B=this.el;B.addEventListener("buttonchanged",this.onButtonChanged),B.addEventListener("buttondown",this.onButtonDown),B.addEventListener("buttonup",this.onButtonUp),B.addEventListener("touchstart",this.onButtonTouchStart),B.addEventListener("touchend",this.onButtonTouchEnd),B.addEventListener("axismove",this.onAxisMoved),B.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var B=this.el;B.removeEventListener("buttonchanged",this.onButtonChanged),B.removeEventListener("buttondown",this.onButtonDown),B.removeEventListener("buttonup",this.onButtonUp),B.removeEventListener("touchstart",this.onButtonTouchStart),B.removeEventListener("touchend",this.onButtonTouchEnd),B.removeEventListener("axismove",this.onAxisMoved),B.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){O(this,E,{index:this.controllerIndex,hand:this.data.hand})},injectTrackedControls:function(){var C=this.data;this.el.setAttribute("tracked-controls",{idPrefix:E,hand:C.hand,controller:this.controllerIndex,orientationOffset:C.orientationOffset}),this.data.model&&this.el.setAttribute("gltf-model",D)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(B){var M=this.mapping.buttons[B.detail.id];M&&("trigger"===M&&console.log("analog value of trigger press: "+B.detail.state.value),this.el.emit(M+"changed",B.detail.state))},onModelLoaded:function(B){B.detail.model.scale.set(.01,.01,.01)},onAxisMoved:function(B){N(this,this.mapping.axes,B)},updateModel:function(B,C){},setButtonColor:function(B,C){}})},3069:(ot,ht,I)=>{var U=I(7427),$=I(8190),O=I(9437),N=I(5892),_=U.debug("components:material:error"),D=N.shaders;function C(M,k){M.dispose(),k.unregisterMaterial(M),Object.keys(M).filter(function(F){return M[F]&&M[F].isTexture}).forEach(function(F){M[F].dispose()})}ot.exports.Component=(0,$.registerComponent)("material",{schema:{alphaTest:{default:0,min:0,max:1},depthTest:{default:!0},depthWrite:{default:!0},flatShading:{default:!1},npot:{default:!1},offset:{type:"vec2",default:{x:0,y:0}},opacity:{default:1,min:0,max:1},repeat:{type:"vec2",default:{x:1,y:1}},shader:{default:"standard",oneOf:N.shaderNames,schemaChange:!0},side:{default:"front",oneOf:["front","back","double"]},transparent:{default:!1},vertexColorsEnabled:{default:!1},visible:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"]},dithering:{default:!0},anisotropy:{default:0,min:0}},init:function(){this.material=null},update:function(M){var k=this.data;this.shader&&k.shader===M.shader||this.updateShader(k.shader),this.shader.update(this.data),this.updateMaterial(M)},updateSchema:function(M){var k,F,G,Q;k=this.oldData&&this.oldData.shader,(G=D[Q=(F=M&&M.shader)||k]&&D[Q].schema)||_("Unknown shader schema "+Q),k&&F===k||(this.extendSchema(G),this.updateBehavior())},updateBehavior:function(){var M,k,F=this.el.sceneEl,G=this.schema,Q=this;function X(lt,rt){var pt;for(pt in k)k[pt]=lt;Q.shader.update(k)}for(M in this.tick=void 0,k={},G)"time"===G[M].type&&(this.tick=X,k[M]=!0);F&&(this.tick?F.addBehavior(this):F.removeBehavior(this))},updateShader:function(M){var k,F=this.data,G=D[M]&&D[M].Shader;if(!G)throw new Error("Unknown shader "+M);(k=this.shader=new G).el=this.el,k.init(F),this.setMaterial(k.material),this.updateSchema(F)},updateMaterial:function(M){var k,F=this.data,G=this.material;for(k in G.alphaTest=F.alphaTest,G.depthTest=!1!==F.depthTest,G.depthWrite=!1!==F.depthWrite,G.opacity=F.opacity,G.flatShading=F.flatShading,G.side=function(Q){switch(Q){case"back":return O.BackSide;case"double":return O.DoubleSide;default:return O.FrontSide}}(F.side),G.transparent=!1!==F.transparent||F.opacity<1,G.vertexColors=F.vertexColorsEnabled,G.visible=F.visible,G.blending=function(Q){switch(Q){case"none":return O.NoBlending;case"additive":return O.AdditiveBlending;case"subtractive":return O.SubtractiveBlending;case"multiply":return O.MultiplyBlending;default:return O.NormalBlending}}(F.blending),G.dithering=F.dithering,M)break;!k||M.alphaTest===F.alphaTest&&M.side===F.side&&M.vertexColorsEnabled===F.vertexColorsEnabled||(G.needsUpdate=!0)},remove:function(){var M=new O.MeshBasicMaterial,k=this.material,F=this.el.getObject3D("mesh");F&&(F.material=M),C(k,this.system)},setMaterial:function(M){var k,F=this.el,G=this.system;this.material&&C(this.material,G),this.material=M,G.registerMaterial(M),(k=F.getObject3D("mesh"))?k.material=M:F.addEventListener("object3dset",function Q(X){"mesh"===X.detail.type&&X.target===F&&(F.getObject3D("mesh").material=M,F.removeEventListener("object3dset",Q))})}})},3176:(ot,ht,I)=>{var U,$,O,N,_,B,C,M,k,E=I(8190).registerComponent,D=I(9437);E("obb-collider",{schema:{size:{default:0},trackedObject3D:{default:""},minimumColliderDimension:{default:.02},centerModel:{default:!1}},init:function(){this.previousScale=(new D.Vector3).copy(this.el.object3D.scale),this.auxEuler=new D.Euler,this.boundingBox=new D.Box3,this.boundingBoxSize=new D.Vector3,this.updateCollider=this.updateCollider.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.updateBoundingBox=this.updateBoundingBox.bind(this),this.el.addEventListener("model-loaded",this.onModelLoaded),this.updateCollider(),this.system.addCollider(this.el)},remove:function(){this.system.removeCollider(this.el)},update:function(){this.data.trackedObject3D&&(this.trackedObject3DPath=this.data.trackedObject3D.split("."))},onModelLoaded:function(){this.data.centerModel&&this.centerModel(),this.updateCollider()},centerModel:function(){var B,C=this.el,M=C.components["gltf-model"]&&C.components["gltf-model"].model;M&&(this.el.removeObject3D("mesh"),B=(new D.Box3).setFromObject(M).getCenter(new D.Vector3),M.position.x+=M.position.x-B.x,M.position.y+=M.position.y-B.y,M.position.z+=M.position.z-B.z,this.el.setObject3D("mesh",M))},updateCollider:function(){var B=this.el,C=this.boundingBoxSize,M=this.aabb=this.aabb||new D.OBB;this.obb=this.obb||new D.OBB,B.hasLoaded?(this.updateBoundingBox(),M.halfSize.copy(C).multiplyScalar(.5),this.el.sceneEl.systems["obb-collider"].data.showColliders&&this.showCollider()):B.addEventListener("loaded",this.updateCollider)},showCollider:function(){this.updateColliderMesh(),this.renderColliderMesh.visible=!0},updateColliderMesh:function(){var B=this.renderColliderMesh,C=this.boundingBoxSize;B?(B.geometry.dispose(),B.geometry=new D.BoxGeometry(C.x,C.y,C.z)):this.initColliderMesh()},hideCollider:function(){this.renderColliderMesh&&(this.renderColliderMesh.visible=!1)},initColliderMesh:function(){var B,C,M;C=this.renderColliderGeometry=new D.BoxGeometry((B=this.boundingBoxSize).x,B.y,B.z),(M=this.renderColliderMesh=new D.Mesh(C,new D.MeshLambertMaterial({color:65280,side:D.DoubleSide}))).matrixAutoUpdate=!1,M.matrixWorldAutoUpdate=!1,M.updateMatrixWorld=function(){},this.el.sceneEl.object3D.add(M)},updateBoundingBox:(U=new D.Vector3,$=new D.Vector3,O=new D.Quaternion,N=new D.Quaternion,_=new D.Matrix4,function(){var B=this.auxEuler,C=this.boundingBox,M=this.data.size,k=this.trackedObject3D||this.el.object3D,F=this.boundingBoxSize,G=this.data.minimumColliderDimension;if(M)return this.boundingBoxSize.x=M,this.boundingBoxSize.y=M,void(this.boundingBoxSize.z=M);B.copy(k.rotation),k.rotation.set(0,0,0),k.parent.matrixWorld.decompose(U,O,$),_.compose(U,N,$),k.parent.matrixWorld.copy(_),C.setFromObject(k,!0),C.getSize(F),F.x=F.x<G?G:F.x,F.y=F.y<G?G:F.y,F.z=F.z<G?G:F.z,k.parent.matrixWorld.compose(U,O,$),this.el.object3D.rotation.copy(B)}),checkTrackedObject:function(){var B,C=this.trackedObject3DPath;if(C&&C.length&&!this.trackedObject3D){B=this.el;for(var M=0;M<C.length&&(B=B[C[M]]);M++);B&&(this.trackedObject3D=B,this.updateCollider())}return this.trackedObject3D},tick:(B=new D.Vector3,C=new D.Vector3,M=new D.Quaternion,k=new D.Matrix4,function(){var F=this.obb,G=this.renderColliderMesh,Q=this.checkTrackedObject()||this.el.object3D;Q&&(Q.updateMatrix(),Q.updateMatrixWorld(!0),Q.matrixWorld.decompose(B,M,C),(Math.abs(C.x-this.previousScale.x)>1e-4||Math.abs(C.y-this.previousScale.y)>1e-4||Math.abs(C.z-this.previousScale.z)>1e-4)&&this.updateCollider(),this.previousScale.copy(C),C.set(1,1,1),k.compose(B,M,C),G&&G.matrixWorld.copy(k),F.copy(this.aabb),F.applyMatrix4(k))})})},8771:(ot,ht,I)=>{var U=I(8940),$=I(8190).registerComponent,O=I(9437),N=U("components:obj-model:warn");ot.exports.Component=$("obj-model",{schema:{mtl:{type:"model"},obj:{type:"model"}},init:function(){var _=this;this.model=null,this.objLoader=new O.OBJLoader,this.mtlLoader=new O.MTLLoader(this.objLoader.manager),this.mtlLoader.crossOrigin="",this.el.addEventListener("componentinitialized",function(E){_.model&&"material"===E.detail.name&&_.applyMaterial()})},update:function(){var _=this.data;_.obj&&(this.resetMesh(),this.loadObj(_.obj,_.mtl))},remove:function(){this.resetMesh()},resetMesh:function(){this.model&&this.el.removeObject3D("mesh")},loadObj:function(_,E){var D=this,B=this.el,C=this.mtlLoader,M=this.objLoader,k=this.el.sceneEl.systems.renderer,F=E.substr(0,E.lastIndexOf("/")+1);if(E)return B.hasAttribute("material")&&N("Material component properties are ignored when a .MTL is provided"),C.setResourcePath(F),void C.load(E,function(G){G.preload(),M.setMaterials(G),M.load(_,function(Q){D.model=Q,D.model.traverse(function(X){if(X.isMesh){var lt=X.material;lt.map&&k.applyColorCorrection(lt.map),lt.emissiveMap&&k.applyColorCorrection(lt.emissiveMap)}}),B.setObject3D("mesh",Q),B.emit("model-loaded",{format:"obj",model:Q})})});M.load(_,function(G){D.model=G,D.applyMaterial(),B.setObject3D("mesh",G),B.emit("model-loaded",{format:"obj",model:G})})},applyMaterial:function(){var _=this.el.components.material;_&&this.model.traverse(function(E){E instanceof O.Mesh&&(E.material=_.material)})}})},6077:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7960),O=$.checkControllerPresentAndSetup,N=$.emitIfAxesChanged,_=$.onButtonEvent,E=I(7427).device.isWebXRAvailable,D=I(1343).AFRAME_CDN_ROOT+"controllers/oculus/go/oculus-go-controller.gltf",B=E?"oculus-go":"Oculus Go";ot.exports.Component=U("oculus-go-controls",{schema:{hand:{default:""},buttonColor:{type:"color",default:"#FFFFFF"},buttonTouchedColor:{type:"color",default:"#BBBBBB"},buttonHighlightColor:{type:"color",default:"#7A7A7A"},model:{default:!0},orientationOffset:{type:"vec3"},armModel:{default:!0}},mapping:E?{axes:{touchpad:[0,1]},buttons:["trigger","none","touchpad"]}:{axes:{trackpad:[0,1]},buttons:["trackpad","trigger"]},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var M=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(k){_(k.detail.id,"down",M)},this.onButtonUp=function(k){_(k.detail.id,"up",M)},this.onButtonTouchStart=function(k){_(k.detail.id,"touchstart",M)},this.onButtonTouchEnd=function(k){_(k.detail.id,"touchend",M)},this.controllerPresent=!1,this.lastControllerCheck=0,this.bindMethods()},addEventListeners:function(){var M=this.el;M.addEventListener("buttonchanged",this.onButtonChanged),M.addEventListener("buttondown",this.onButtonDown),M.addEventListener("buttonup",this.onButtonUp),M.addEventListener("touchstart",this.onButtonTouchStart),M.addEventListener("touchend",this.onButtonTouchEnd),M.addEventListener("model-loaded",this.onModelLoaded),M.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var M=this.el;M.removeEventListener("buttonchanged",this.onButtonChanged),M.removeEventListener("buttondown",this.onButtonDown),M.removeEventListener("buttonup",this.onButtonUp),M.removeEventListener("touchstart",this.onButtonTouchStart),M.removeEventListener("touchend",this.onButtonTouchEnd),M.removeEventListener("model-loaded",this.onModelLoaded),M.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){O(this,B,this.data.hand?{hand:this.data.hand}:{})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var k=this.data;this.el.setAttribute("tracked-controls",{armModel:k.armModel,hand:k.hand,idPrefix:B,orientationOffset:k.orientationOffset}),this.data.model&&this.el.setAttribute("gltf-model",D)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelLoaded:function(M){var k,F=M.detail.model;M.target===this.el&&this.data.model&&((k=this.buttonMeshes={}).trigger=F.getObjectByName("oculus_go_button_trigger"),k.trackpad=F.getObjectByName("oculus_go_touchpad"),k.touchpad=F.getObjectByName("oculus_go_touchpad"))},onButtonChanged:function(M){var k=this.mapping.buttons[M.detail.id];k&&this.el.emit(k+"changed",M.detail.state)},onAxisMoved:function(M){N(this,this.mapping.axes,M)},updateModel:function(M,k){this.data.model&&this.updateButtonModel(M,k)},updateButtonModel:function(M,k){var F=this.buttonMeshes;if(F&&F[M]){var G;switch(k){case"down":G=this.data.buttonHighlightColor;break;case"touchstart":G=this.data.buttonTouchedColor;break;default:G=this.data.buttonColor}F[M].material.color.set(G)}}})},5744:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437),O=I(7960),N=O.checkControllerPresentAndSetup,_=O.emitIfAxesChanged,E=O.onButtonEvent,D=I(7427).device.isWebXRAvailable,B="oculus-touch",C=D?B:"Oculus Touch",M=I(1343).AFRAME_CDN_ROOT,k=M+"controllers/oculus/oculus-touch-controller-",F=M+"controllers/meta/",G={left:{modelUrl:k+"left.gltf",rayOrigin:{origin:{x:.008,y:-.01,z:0},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new $.Vector3(-.005,.003,-.055),modelPivotRotation:new $.Euler(0,0,0)},right:{modelUrl:k+"right.gltf",rayOrigin:{origin:{x:-.008,y:-.01,z:0},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new $.Vector3(.005,.003,-.055),modelPivotRotation:new $.Euler(0,0,0)}},Q={left:{modelUrl:k+"left.gltf",rayOrigin:{origin:{x:.002,y:-.005,z:-.03},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new $.Vector3(-.005,.036,-.037),modelPivotRotation:new $.Euler(Math.PI/4.5,0,0)},right:{modelUrl:k+"right.gltf",rayOrigin:{origin:{x:-.002,y:-.005,z:-.03},direction:{x:0,y:-.8,z:-1}},modelPivotOffset:new $.Vector3(.005,.036,-.037),modelPivotRotation:new $.Euler(Math.PI/4.5,0,0)}},X="oculus-touch",lt={"oculus-touch":D?Q:G,"oculus-touch-v2":{left:{modelUrl:k+"gen2-left.gltf",rayOrigin:{origin:{x:-.006,y:-.03,z:-.04},direction:{x:0,y:-.9,z:-1}},modelPivotOffset:new $.Vector3(0,-.007,-.021),modelPivotRotation:new $.Euler(-Math.PI/4,0,0)},right:{modelUrl:k+"gen2-right.gltf",rayOrigin:{origin:{x:.006,y:-.03,z:-.04},direction:{x:0,y:-.9,z:-1}},modelPivotOffset:new $.Vector3(0,-.007,-.021),modelPivotRotation:new $.Euler(-Math.PI/4,0,0)}},"oculus-touch-v3":{left:{modelUrl:k+"v3-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new $.Vector3(0,0,0),modelPivotRotation:new $.Euler(0,0,0)},right:{modelUrl:k+"v3-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new $.Vector3(0,0,0),modelPivotRotation:new $.Euler(0,0,0)}},"meta-quest-touch-pro":{left:{modelUrl:F+"quest-touch-pro-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new $.Vector3(0,0,0),modelPivotRotation:new $.Euler(0,0,0)},right:{modelUrl:F+"quest-touch-pro-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new $.Vector3(0,0,0),modelPivotRotation:new $.Euler(0,0,0)}},"meta-quest-touch-plus":{left:{modelUrl:F+"quest-touch-plus-left.glb",rayOrigin:{origin:{x:.0065,y:-.0186,z:-.05},direction:{x:.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new $.Vector3(0,0,0),modelPivotRotation:new $.Euler(0,0,0)},right:{modelUrl:F+"quest-touch-plus-right.glb",rayOrigin:{origin:{x:-.0065,y:-.0186,z:-.05},direction:{x:-.12394785839500175,y:-.5944043672340157,z:-.7945567170519814}},modelPivotOffset:new $.Vector3(0,0,0),modelPivotRotation:new $.Euler(0,0,0)}}};function pt(vt){vt.traverse(function(bt){var ft;"Mesh"===bt.type&&(ft=bt.material.clone(),vt.originalColor=bt.material.color,bt.material.dispose(),bt.material=ft)})}ot.exports.Component=U("oculus-touch-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#999"},buttonTouchColor:{type:"color",default:"#8AB"},buttonHighlightColor:{type:"color",default:"#2DF"},model:{default:!0},controllerType:{default:"auto",oneOf:["auto","oculus-touch","oculus-touch-v2","oculus-touch-v3"]},orientationOffset:{type:"vec3",default:{x:43,y:0,z:0}}},after:["tracked-controls"],mapping:D?{left:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","xbutton","ybutton","surface"]},right:{axes:{thumbstick:[2,3]},buttons:["trigger","grip","none","thumbstick","abutton","bbutton","surface"]}}:{left:{axes:{thumbstick:[0,1]},buttons:["thumbstick","trigger","grip","xbutton","ybutton","surface"]},right:{axes:{thumbstick:[0,1]},buttons:["thumbstick","trigger","grip","abutton","bbutton","surface"]}},bindMethods:function(){this.onButtonChanged=this.onButtonChanged.bind(this),this.onThumbstickMoved=this.onThumbstickMoved.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var vt=this;this.onButtonDown=function(bt){E(bt.detail.id,"down",vt,vt.data.hand)},this.onButtonUp=function(bt){E(bt.detail.id,"up",vt,vt.data.hand)},this.onButtonTouchStart=function(bt){E(bt.detail.id,"touchstart",vt,vt.data.hand)},this.onButtonTouchEnd=function(bt){E(bt.detail.id,"touchend",vt,vt.data.hand)},this.controllerPresent=!1,this.lastControllerCheck=0,this.previousButtonValues={},this.bindMethods(),this.triggerEuler=new $.Euler},addEventListeners:function(){var vt=this.el;vt.addEventListener("buttonchanged",this.onButtonChanged),vt.addEventListener("buttondown",this.onButtonDown),vt.addEventListener("buttonup",this.onButtonUp),vt.addEventListener("touchstart",this.onButtonTouchStart),vt.addEventListener("touchend",this.onButtonTouchEnd),vt.addEventListener("axismove",this.onAxisMoved),vt.addEventListener("model-loaded",this.onModelLoaded),vt.addEventListener("thumbstickmoved",this.onThumbstickMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var vt=this.el;vt.removeEventListener("buttonchanged",this.onButtonChanged),vt.removeEventListener("buttondown",this.onButtonDown),vt.removeEventListener("buttonup",this.onButtonUp),vt.removeEventListener("touchstart",this.onButtonTouchStart),vt.removeEventListener("touchend",this.onButtonTouchEnd),vt.removeEventListener("axismove",this.onAxisMoved),vt.removeEventListener("model-loaded",this.onModelLoaded),vt.removeEventListener("thumbstickmoved",this.onThumbstickMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){N(this,C,{hand:this.data.hand,iterateControllerProfiles:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},loadModel:function(vt){var bt,ft=this.data;if(ft.model)if(this.controllerObject3D)this.el.setObject3D("mesh",this.controllerObject3D);else{if(this.displayModel=lt[ft.controllerType]||lt[X],"auto"===ft.controllerType){var wt=this.el.sceneEl.systems["tracked-controls-webvr"];if(wt&&wt.vrDisplay)/^Oculus Quest$/.test(wt.vrDisplay.displayName)&&(this.displayModel=lt["oculus-touch-v2"]);else{bt=X;for(var xt=Object.keys(lt),Rt=0;Rt<vt.profiles.length;Rt++)if(-1!==xt.indexOf(vt.profiles[Rt])){bt=vt.profiles[Rt];break}this.displayModel=lt[bt]}}var Yt=this.displayModel[ft.hand].modelUrl;this.isTouchV3orPROorPlus=this.displayModel===lt["oculus-touch-v3"]||this.displayModel===lt["meta-quest-touch-pro"]||this.displayModel===lt["meta-quest-touch-plus"],this.el.setAttribute("gltf-model",Yt)}},injectTrackedControls:function(vt){var bt=this.data;this.el.setAttribute("tracked-controls",{id:D?B:"right"===bt.hand?"Oculus Touch (Right)":"Oculus Touch (Left)",hand:bt.hand,orientationOffset:bt.orientationOffset,handTrackingEnabled:!1,iterateControllerProfiles:!0,space:"gripSpace"}),this.loadModel(vt)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(vt){var bt=this.mapping[this.data.hand].buttons[vt.detail.id];if(bt){if(this.isTouchV3orPROorPlus)this.onButtonChangedV3orPROorPlus(vt);else{var ft,wt=this.buttonMeshes;"trigger"!==bt&&"grip"!==bt||(ft=vt.detail.state.value),wt&&("trigger"===bt&&wt.trigger&&(wt.trigger.rotation.x=this.originalXRotationTrigger-ft*(Math.PI/26)),"grip"===bt&&wt.grip&&(wt.grip.position.x=this.originalXPositionGrip+.004*(ft*="left"===this.data.hand?-1:1)))}this.el.emit(bt+"changed",vt.detail.state)}},onButtonChangedV3orPROorPlus:function(vt){var bt,ft=this.mapping[this.data.hand].buttons[vt.detail.id],wt=this.buttonObjects;wt&&wt[ft]&&(wt[ft].quaternion.slerpQuaternions(this.buttonRanges[ft].min.quaternion,this.buttonRanges[ft].max.quaternion,bt=vt.detail.state.value),wt[ft].position.lerpVectors(this.buttonRanges[ft].min.position,this.buttonRanges[ft].max.position,bt))},onModelLoaded:function(vt){if(vt.target===this.el&&this.data.model){if(this.isTouchV3orPROorPlus)this.onTouchV3orPROorPlusModelLoaded(vt);else{var bt,ft=this.controllerObject3D=vt.detail.model;(bt=this.buttonMeshes={}).grip=ft.getObjectByName("buttonHand"),this.originalXPositionGrip=bt.grip&&bt.grip.position.x,bt.trigger=ft.getObjectByName("buttonTrigger"),this.originalXRotationTrigger=bt.trigger&&bt.trigger.rotation.x,bt.thumbstick=ft.getObjectByName("stick"),bt.xbutton=ft.getObjectByName("buttonX"),bt.abutton=ft.getObjectByName("buttonA"),bt.ybutton=ft.getObjectByName("buttonY"),bt.bbutton=ft.getObjectByName("buttonB")}for(var wt in this.buttonMeshes)this.buttonMeshes[wt]&&pt(this.buttonMeshes[wt]);this.applyOffset(vt.detail.model),this.el.emit("controllermodelready",{name:"oculus-touch-controls",model:this.data.model,rayOrigin:this.displayModel[this.data.hand].rayOrigin})}},applyOffset:function(vt){vt.position.copy(this.displayModel[this.data.hand].modelPivotOffset),vt.rotation.copy(this.displayModel[this.data.hand].modelPivotRotation)},onTouchV3orPROorPlusModelLoaded:function(vt){var bt=this.controllerObject3D=vt.detail.model,ft=this.buttonObjects={},wt=this.buttonMeshes={},et=this.buttonRanges={};wt.grip=bt.getObjectByName("squeeze"),ft.grip=bt.getObjectByName("xr_standard_squeeze_pressed_value"),et.grip={min:bt.getObjectByName("xr_standard_squeeze_pressed_min"),max:bt.getObjectByName("xr_standard_squeeze_pressed_max")},ft.grip.minX=ft.grip.position.x,wt.thumbstick=bt.getObjectByName("thumbstick"),ft.thumbstick=bt.getObjectByName("xr_standard_thumbstick_pressed_value"),et.thumbstick={min:bt.getObjectByName("xr_standard_thumbstick_pressed_min"),max:bt.getObjectByName("xr_standard_thumbstick_pressed_max")},ft.thumbstickXAxis=bt.getObjectByName("xr_standard_thumbstick_xaxis_pressed_value"),et.thumbstickXAxis={min:bt.getObjectByName("xr_standard_thumbstick_xaxis_pressed_min"),max:bt.getObjectByName("xr_standard_thumbstick_xaxis_pressed_max")},ft.thumbstickYAxis=bt.getObjectByName("xr_standard_thumbstick_yaxis_pressed_value"),et.thumbstickYAxis={min:bt.getObjectByName("xr_standard_thumbstick_yaxis_pressed_min"),max:bt.getObjectByName("xr_standard_thumbstick_yaxis_pressed_max")},wt.trigger=bt.getObjectByName("trigger"),ft.trigger=bt.getObjectByName("xr_standard_trigger_pressed_value"),et.trigger={min:bt.getObjectByName("xr_standard_trigger_pressed_min"),max:bt.getObjectByName("xr_standard_trigger_pressed_max")},et.trigger.diff={x:Math.abs(et.trigger.max.rotation.x)-Math.abs(et.trigger.min.rotation.x),y:Math.abs(et.trigger.max.rotation.y)-Math.abs(et.trigger.min.rotation.y),z:Math.abs(et.trigger.max.rotation.z)-Math.abs(et.trigger.min.rotation.z)};var xt="left"===this.data.hand?"x":"a",Rt="left"===this.data.hand?"y":"b",Yt=xt+"button",ve=Rt+"button";wt[Yt]=bt.getObjectByName(xt+"_button"),ft[Yt]=bt.getObjectByName(xt+"_button_pressed_value"),et[Yt]={min:bt.getObjectByName(xt+"_button_pressed_min"),max:bt.getObjectByName(xt+"_button_pressed_max")},wt[ve]=bt.getObjectByName(Rt+"_button"),ft[ve]=bt.getObjectByName(Rt+"_button_pressed_value"),et[ve]={min:bt.getObjectByName(Rt+"_button_pressed_min"),max:bt.getObjectByName(Rt+"_button_pressed_max")}},onAxisMoved:function(vt){_(this,this.mapping[this.data.hand].axes,vt)},onThumbstickMoved:function(vt){if(this.buttonMeshes&&this.buttonMeshes.thumbstick)if(this.isTouchV3orPROorPlus)this.updateThumbstickTouchV3orPROorPlus(vt);else for(var bt in vt.detail)this.buttonObjects.thumbstick.rotation[this.axisMap[bt]]=this.buttonRanges.thumbstick.originalRotation[this.axisMap[bt]]-Math.PI/8*vt.detail[bt]*("y"===bt||"right"===this.data.hand?-1:1)},axisMap:{y:"x",x:"z"},updateThumbstickTouchV3orPROorPlus:function(vt){this.buttonObjects.thumbstickXAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickXAxis.min.quaternion,this.buttonRanges.thumbstickXAxis.max.quaternion,(vt.detail.x+1)/2),this.buttonObjects.thumbstickYAxis.quaternion.slerpQuaternions(this.buttonRanges.thumbstickYAxis.min.quaternion,this.buttonRanges.thumbstickYAxis.max.quaternion,(vt.detail.y+1)/2)},updateModel:function(vt,bt){this.data.model&&this.updateButtonModel(vt,bt)},updateButtonModel:function(vt,bt){var wt=this.buttonMeshes;wt&&wt[vt]&&wt[vt].material.color.set("up"===bt||"touchend"===bt?wt[vt].originalColor||this.data.buttonColor:"touchstart"===bt?this.data.buttonTouchColor:this.data.buttonHighlightColor)}})},2588:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437),O=I(7960),N=O.checkControllerPresentAndSetup,_=O.emitIfAxesChanged,E=O.onButtonEvent,D="pico-4",B=I(1343).AFRAME_CDN_ROOT+"controllers/pico/pico4/";ot.exports.Component=U("pico-controls",{schema:{hand:{default:"none"},model:{default:!0},orientationOffset:{type:"vec3"}},mapping:{left:{axes:{touchpad:[2,3]},buttons:["trigger","squeeze","none","thumbstick","xbutton","ybutton"]},right:{axes:{touchpad:[2,3]},buttons:["trigger","squeeze","none","thumbstick","abutton","bbutton"]}},init:function(){var C=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(M){E(M.detail.id,"down",C,C.data.hand)},this.onButtonUp=function(M){E(M.detail.id,"up",C,C.data.hand)},this.onButtonTouchEnd=function(M){E(M.detail.id,"touchend",C,C.data.hand)},this.onButtonTouchStart=function(M){E(M.detail.id,"touchstart",C,C.data.hand)},this.bindMethods()},update:function(){var C=this.data;this.controllerIndex="right"===C.hand?0:"left"===C.hand?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var C=this.el;C.addEventListener("buttonchanged",this.onButtonChanged),C.addEventListener("buttondown",this.onButtonDown),C.addEventListener("buttonup",this.onButtonUp),C.addEventListener("touchstart",this.onButtonTouchStart),C.addEventListener("touchend",this.onButtonTouchEnd),C.addEventListener("axismove",this.onAxisMoved),C.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var C=this.el;C.removeEventListener("buttonchanged",this.onButtonChanged),C.removeEventListener("buttondown",this.onButtonDown),C.removeEventListener("buttonup",this.onButtonUp),C.removeEventListener("touchstart",this.onButtonTouchStart),C.removeEventListener("touchend",this.onButtonTouchEnd),C.removeEventListener("axismove",this.onAxisMoved),C.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){N(this,D,{index:this.controllerIndex,hand:this.data.hand})},injectTrackedControls:function(){var M=this.data;this.el.setAttribute("tracked-controls",{idPrefix:D,hand:M.hand,controller:this.controllerIndex,orientationOffset:M.orientationOffset}),this.data.model&&this.el.setAttribute("gltf-model",B+this.data.hand+".glb")},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(C){var k=this.mapping[this.data.hand].buttons[C.detail.id];k&&("trigger"===k&&console.log("analog value of trigger press: "+C.detail.state.value),this.el.emit(k+"changed",C.detail.state))},onModelLoaded:function(C){C.target===this.el&&this.data.model&&this.el.emit("controllermodelready",{name:"pico-controls",model:this.data.model,rayOrigin:new $.Vector3(0,0,0)})},onAxisMoved:function(C){_(this,this.mapping.axes,C)}})},7519:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("position",{schema:{type:"vec3"},update:function(){var O=this.data;this.el.object3D.position.set(O.x,O.y,O.z)},remove:function(){this.el.object3D.position.set(0,0,0)}})},7394:(ot,ht,I)=>{var U,$,O=I(8190).registerComponent,N=I(9437),_=I(7427).debug("components:raycaster:warn"),E=/^[\w\s-.,[\]#]*$/,D={childList:!0,attributes:!0,subtree:!0},B="raycaster-intersected-cleared",C="raycaster-intersection-cleared";function M(k,F){var G;for(k.length=F.length,G=0;G<F.length;G++)k[G]=F[G]}ot.exports.Component=O("raycaster",{schema:{autoRefresh:{default:!0},direction:{type:"vec3",default:{x:0,y:0,z:-1}},enabled:{default:!0},far:{default:1e3},interval:{default:0},near:{default:0},objects:{default:""},origin:{type:"vec3"},showLine:{default:!1},lineColor:{default:"white"},lineOpacity:{default:1},useWorldCoordinates:{default:!1}},multiple:!0,init:function(){this.clearedIntersectedEls=[],this.unitLineEndVec3=new N.Vector3,this.intersectedEls=[],this.intersections=[],this.newIntersectedEls=[],this.newIntersections=[],this.objects=[],this.prevCheckTime=void 0,this.prevIntersectedEls=[],this.rawIntersections=[],this.raycaster=new N.Raycaster,this.updateOriginDirection(),this.setDirty=this.setDirty.bind(this),this.updateLine=this.updateLine.bind(this),this.observer=new MutationObserver(this.setDirty),this.dirty=!0,this.lineEndVec3=new N.Vector3,this.otherLineEndVec3=new N.Vector3,this.lineData={end:this.lineEndVec3},this.getIntersection=this.getIntersection.bind(this),this.intersectedDetail={el:this.el,getIntersection:this.getIntersection},this.intersectedClearedDetail={el:this.el},this.intersectionClearedDetail={clearedEls:this.clearedIntersectedEls},this.intersectionDetail={}},update:function(k){var F=this.data,G=this.el,Q=this.raycaster;Q.far=F.far,Q.near=F.near,!F.showLine||F.far===k.far&&F.origin===k.origin&&F.direction===k.direction&&k.showLine||(this.unitLineEndVec3.copy(F.direction).normalize(),this.drawLine()),!F.showLine&&k.showLine&&G.removeAttribute("line"),F.objects===k.objects||E.test(F.objects)||_('[raycaster] Selector "'+F.objects+'" may not update automatically with DOM changes.'),F.objects||_('[raycaster] For performance, please define raycaster.objects when using raycaster or cursor components to whitelist which entities to intersect with. e.g., raycaster="objects: [data-raycastable]".'),F.autoRefresh!==k.autoRefresh&&G.isPlaying&&(F.autoRefresh?this.addEventListeners():this.removeEventListeners()),k.enabled&&!F.enabled&&this.clearAllIntersections(),this.setDirty()},play:function(){this.addEventListeners()},pause:function(){this.removeEventListeners()},remove:function(){this.data.showLine&&this.el.removeAttribute("line"),this.clearAllIntersections()},addEventListeners:function(){this.data.autoRefresh&&(this.observer.observe(this.el.sceneEl,D),this.el.sceneEl.addEventListener("object3dset",this.setDirty),this.el.sceneEl.addEventListener("object3dremove",this.setDirty))},removeEventListeners:function(){this.observer.disconnect(),this.el.sceneEl.removeEventListener("object3dset",this.setDirty),this.el.sceneEl.removeEventListener("object3dremove",this.setDirty)},setDirty:function(){this.dirty=!0},refreshObjects:function(){var k,F=this.data;k=this.el.sceneEl.querySelectorAll(F.objects?F.objects:"*"),this.objects=this.flattenObject3DMaps(k),this.dirty=!1},tock:function(k){var F=this.data,G=this.prevCheckTime;F.enabled&&(G&&k-G<F.interval||(this.prevCheckTime=k,this.checkIntersections()))},checkIntersections:function(){var k,F,G=this.clearedIntersectedEls,Q=this.el,X=this.data,lt=this.intersectedEls,rt=this.intersections,pt=this.newIntersectedEls,vt=this.newIntersections,bt=this.prevIntersectedEls,ft=this.rawIntersections;for(this.dirty&&this.refreshObjects(),M(this.prevIntersectedEls,this.intersectedEls),this.updateOriginDirection(),ft.length=0,this.raycaster.intersectObjects(this.objects,!0,ft),rt.length=0,lt.length=0,k=0;k<ft.length;k++)F=ft[k],X.showLine&&F.object===Q.getObject3D("line")||F.object.el&&(rt.push(F),lt.push(F.object.el));for(vt.length=0,pt.length=0,k=0;k<rt.length;k++)-1===bt.indexOf(rt[k].object.el)&&(vt.push(rt[k]),pt.push(rt[k].object.el));for(G.length=0,k=0;k<bt.length;k++)-1===lt.indexOf(bt[k])&&(bt[k].emit(B,this.intersectedClearedDetail),G.push(bt[k]));for(G.length&&Q.emit(C,this.intersectionClearedDetail),k=0;k<pt.length;k++)pt[k].emit("raycaster-intersected",this.intersectedDetail);vt.length&&(this.intersectionDetail.els=pt,this.intersectionDetail.intersections=vt,Q.emit("raycaster-intersection",this.intersectionDetail)),(0===bt.length&&rt.length>0||bt.length>0&&0===rt.length||bt.length&&rt.length&&bt[0]!==rt[0].object.el)&&(this.intersectionDetail.els=this.intersectedEls,this.intersectionDetail.intersections=rt,Q.emit("raycaster-closest-entity-changed",this.intersectionDetail)),X.showLine&&setTimeout(this.updateLine)},updateLine:function(){var k,G=this.intersections;G.length&&(k=G[0].object.el===this.el&&G[1]?G[1].distance:G[0].distance),this.drawLine(k)},getIntersection:function(k){var F,G;for(F=0;F<this.intersections.length;F++)if((G=this.intersections[F]).object.el===k)return G;return null},updateOriginDirection:(U=new N.Vector3,$=new N.Vector3,function(){var k=this.el,F=this.data;F.useWorldCoordinates?this.raycaster.set(F.origin,F.direction):(k.object3D.updateMatrixWorld(),$.setFromMatrixPosition(k.object3D.matrixWorld),0===F.origin.x&&0===F.origin.y&&0===F.origin.z||($=k.object3D.localToWorld($.copy(F.origin))),U.copy(F.direction).transformDirection(k.object3D.matrixWorld).normalize(),this.raycaster.set($,U))}),drawLine:function(k){var F,G=this.data,Q=this.el;F=this.lineData.end===this.lineEndVec3?this.otherLineEndVec3:this.lineEndVec3,void 0===k&&(k=G.far===1/0?1e3:G.far),this.lineData.start=G.origin,this.lineData.end=F.copy(this.unitLineEndVec3).multiplyScalar(k).add(G.origin),this.lineData.color=G.lineColor,this.lineData.opacity=G.lineOpacity,Q.setAttribute("line",this.lineData)},flattenObject3DMaps:function(k){var F,G,Q=this.objects,X=this.el.sceneEl.object3D;function lt(pt){return pt.parent?lt(pt.parent):pt===X}for(Q.length=0,G=0;G<k.length;G++){var rt=k[G];if(rt.isEntity&&rt.object3D&&lt(rt.object3D))for(F in rt.object3DMap)Q.push(rt.getObject3D(F))}return Q},clearAllIntersections:function(){var k;for(k=0;k<this.intersectedEls.length;k++)this.intersectedEls[k].emit(B,this.intersectedClearedDetail);M(this.clearedIntersectedEls,this.intersectedEls),this.intersectedEls.length=0,this.intersections.length=0,this.el.emit(C,this.intersectionClearedDetail)}})},2310:(ot,ht,I)=>{var U=I(9437).MathUtils.degToRad,$=I(8190).registerComponent;ot.exports.Component=$("rotation",{schema:{type:"vec3"},update:function(){var O=this.data;this.el.object3D.rotation.set(U(O.x),U(O.y),U(O.z),"YXZ")},remove:function(){this.el.object3D.rotation.set(0,0,0)}})},4760:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("scale",{schema:{type:"vec3",default:{x:1,y:1,z:1}},update:function(){var $=this.data;this.el.object3D.scale.set($.x,$.y,$.z)},remove:function(){this.el.object3D.scale.set(1,1,1)}})},3575:(ot,ht,I)=>{var U,$,O,N=I(8190).registerComponent,_=I(9437),E=(U=new _.Quaternion,$=new _.Vector3,function(C,M,k){M.position.copy(C.transform.position),M.quaternion.copy(C.transform.orientation),$.copy(k),U.copy(C.transform.orientation),$.applyQuaternion(U),M.position.sub($)});function D(C,M){this.renderer=C,this.xrHitTestSource=null,C.xr.addEventListener("sessionend",function(){this.xrHitTestSource=null}.bind(this)),C.xr.addEventListener("sessionstart",function(){this.sessionStart(M)}.bind(this)),this.renderer.xr.isPresenting&&this.sessionStart(M)}function B(C){console.warn(C.message),console.warn('Cannot requestHitTestSource Are you missing: webxr="optionalFeatures: hit-test;" from <a-scene>?')}E.tempFakePose={transform:{orientation:new _.Quaternion,position:new _.Vector3}},D.prototype.previousFrameAnchors=new Set,D.prototype.anchorToObject3D=new Map,D.prototype.sessionStart=function(C){this.session=this.renderer.xr.getSession(),"requestHitTestSource"in this.session?C.space?this.session.requestHitTestSource(C).then(function(M){this.xrHitTestSource=M}.bind(this)).catch(B):C.profile&&this.session.requestHitTestSourceForTransientInput(C).then(function(M){this.xrHitTestSource=M,this.transient=!0}.bind(this)).catch(B):B({message:"No requestHitTestSource on the session."})},D.prototype.anchorFromLastHitTestResult=function(C,M){var k=this.lastHitTest;if(k){var F={object3D:C,offset:M};Array.from(this.anchorToObject3D.entries()).forEach(function(G){var X=G[0];G[1].object3D===C&&(this.anchorToObject3D.delete(X),X.delete())}.bind(this)),k.createAnchor&&k.createAnchor().then(function(G){this.anchorToObject3D.set(G,F)}.bind(this)).catch(function(G){console.warn(G.message),console.warn('Cannot create anchor, are you missing: webxr="optionalFeatures: anchors;" from <a-scene>?')})}},D.prototype.doHit=function(C){if(this.renderer.xr.isPresenting){var M,k,F=this.renderer.xr.getReferenceSpace(),G=C.getViewerPose(F);return this.xrHitTestSource&&G?this.transient?(M=C.getHitTestResultsForTransientInput(this.xrHitTestSource)).length>0&&(k=M[0].results).length>0&&(this.lastHitTest=k[0],k[0].getPose(F)):(M=C.getHitTestResults(this.xrHitTestSource)).length>0&&(this.lastHitTest=M[0],M[0].getPose(F)):void 0}},D.updateAnchorPoses=function(C,M){var k=C.trackedAnchors||D.prototype.previousFrameAnchors;D.prototype.previousFrameAnchors.forEach(function(F){k.has(F)||D.prototype.anchorToObject3D.delete(F)}),k.forEach(function(F){var G,Q;try{G=C.getPose(F.anchorSpace,M)}catch{}if(G){if(!(Q=D.prototype.anchorToObject3D.get(F)))return;E(G,Q.object3D,Q.offset)}})},ot.exports.Component=N("ar-hit-test",{schema:{target:{type:"selector"},enabled:{default:!0},src:{default:"data:image/webp;base64,UklGRkQHAABXRUJQVlA4WAoAAAAQAAAA/wEA/wEAQUxQSL0DAAARDzD/ERGCjrY9sYYFfgo6aa1kJ7K0w9Lo3AadLSVeFxevQwj5kuM8RfR/Atw/C0+ozB/oUBrloFZs6ElSW88j1KA4yExNWQaqRZquIDF0JYmlq0hAuUDTFu66tng3teW7pa3cQf1V1edvur54M/Slm6Wv3Gx9zw0MXlQLntcsBN6wkHjTQuYtC4W3LTw8mGRVG57TbAROtxHfZNhInGkjc5aNwtk2Hg6Mvki14k+NkZzCwQgCxalcAv3kddRTPI1DcUrXId1FLf1uHpzaQz4tquhZVLlKesbVpqKeTj0n0F5PpXDlFN9UqmhalL/ImuZFo6KmToWLoKlddMprqlS8cKovBvHo2kTiFV2LN4msaxKZl3QNiair8xYRdDWivIvXVXmbcMqJ51UebZuFXxZt6xd4laxtciqRtA3Cv0nU1t+kEUFbI8JvCa+tvkm3FDlO/W+OR99+kWEp/YYo+tYfTVnf/K8cE/F///3vv//993eeL+a+uvjawLcX3xjYvJotBFY3kVjTRGFtE+BU2AiMbiQyhpHMWEYeBozAH5qNBYRDB5KBCaTDBKKBAZTDBoKBDjwHAN5ABeCJBsAZcAAC0YHHxAYSMYBiYgGZWEA2MYFCbCCZGAAIANFEB+AnYgMQTDQAYSJ2AN5EBZAm4gDgTDgAeSIu4DGygTIRN1CMLOCZiACykQlg4jsAycgA8AO+BxCNdJyDkcbwRirDGXGnx8w+FDPrkM3MQ9JQZMYhiiwV/RDMtIM3U1/DmXHUo+IR2kSR2ToWkQ1NIn2qf2J8LCqJKiDUiSADHY3whirhdHgZ94HKaR97PhE+twEUJUFoAcgyTct8hfSxSkShASDKdMJ/ritKHwgyQ0sD4D/miCxU5SbhOOUDTnZpccCjYP/i0bZ/8bAgtVGEoGapWIQXyzKVKLwgNJFk2rtMIgoNRJlOZF7SNSSyUEeQmbxBFKEmtYjEe8S8zOZ1AkJVCmS88FJOtF40Ksg4oUaFiygk3C8qlTVNyl8UTevCUdAE2t14PfVqU1FPp57TopKeQZWromddTQp6QOfTOEQt/ZDuipZ11w/wOiqO8dRORcc6BQEkDQMClaHcn5wV9yLbxsNZNgpn2sicYSNxuo34Js1G4FQbnuNsOPa28PCWhcKbFjJvWEi8ZiHwqgXPcxbc5db33Cx95WboSzddX7yp+vyN0+eul7ZyN7Xlu64t3jVt4c5pc4JLV5EYupJE0xUknC4nOjVlmaYpyLit53HCQ0+ScnqceNcS5dzUkd0/CwMAVlA4IGADAAAQXwCdASoAAgACP8ne6Wy/tjCpqJ/IA/A5CWlu4XYBG/Pz8AfwD8APz//f3v8E1fuHZnxKYACtfuHZnxKYACrYTb5mOslhxu843ecbvON3nG7zjd3a0VCn7G1MABVxwH/Xd25gAK1+4dmfEpe2+PHhQaj75++riG6FuYACtfuHZnxKYACRrK3q9xO8Ss3uWKnMhs/rDF1hi6wxdYYusMXWGI5QRcCFDZog5OgqNlse1NDuz/UoFa/cOzPiUwAEsAOK4/nu5eZHK2tlXxJfNYlMABWv3Dsz4bvNJ5YA/LtxJ38SmAArX7h2Z8Sk5vdZUYv7mZPiUwAFa/cOzPh21s5OgZxf1mfEpemRyFr/rM+JS9noA/LtxJ38SmAAlUJIotzAASn6TjdhK+D3Dsz4dyvB7h2Z8O2tnJ0DOL+sz4lL2nKLT4lL/+iSLOocxq639w7M34MNZdm55uJ8v8ra2cpVZnxKTq2F3PN/cNksAfl24k7+JTAASqrD37h2Z7b1W+VtbOUqsz4lJ1bC7nm/uGyWAPy7cSd/EpgAJVVh79w7M9t6rfK2tnKVWZ8Sk6thdzzf3DZLAH5duJO/iUwAEqqw9+4dme29VvlbWzlKrM+JSdWwu55v7hslgD8u3EnfxKYACVVYe/cOzPbeq3ytrZylVme0kYJ8557FLerqFrzIbPrrf3DZLAH5duJO/iUvaVMS9BoaF4p7pSDFTP1XMyfElelrM0DOL+sz4eBJ13nV1OppBGPuKb4YzXQgq9uH19uS/0+JS9t9fr6ZUlQBelDG6GMgq97otb5QMPJwtKyBTbFp8Sl7b6/X0ykkawEOsgdiE6Fi0vb/Eve6xkwsmug0Z4nGNHQO8839bpTsjpz7SWIJxKagvd1QWMa6FYT1KEw3j4XDT6vJ9Xk+nyfT5Pq8n1eEmk5dinMM/9Fcfz4Z3Dsz3KD2dw7LxBRxKrqUUGQPH/7zxr1KIfNpLEJ0MZB2ITM/0Z2EFoh12NlXnEcpYcbvON3nG7zjd5xu84vfcNIAAP7+y8ceyzbVxkakPYY4lcr72fqOnDwipv+yxC71wAADBrjKnAAAAAAAAAAAAAAw7oNGHttqWONcoFN/2WIDc2pa6WVFtFYROlsaMaTXdcOjXHz93+YxAglKa4AAAAA=",type:"map"},type:{default:"footprint",oneOf:["footprint","map"]},footprintDepth:{default:.1},mapSize:{type:"vec2",default:{x:.5,y:.5}}},sceneOnly:!0,init:function(){this.hitTest=null,this.imageDataArray=new Uint8ClampedArray(1048576),this.imageData=new ImageData(this.imageDataArray,512,512),this.textureCache=new Map,this.orthoCam=new _.OrthographicCamera,this.orthoCam.layers.set(21),this.textureTarget=new _.WebGLRenderTarget(512,512,{}),this.basicMaterial=new _.MeshBasicMaterial({color:0,side:_.DoubleSide}),this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.context.imageSmoothingEnabled=!1,this.canvas.width=512,this.canvas.height=512,this.canvasTexture=new _.CanvasTexture(this.canvas,{alpha:!0}),this.canvasTexture.flipY=!1;var C=this.el.getAttribute("webxr"),M=C.optionalFeatures;M.includes("hit-test")&&M.includes("anchors")||(M.push("hit-test"),M.push("anchors"),this.el.setAttribute("webxr",C)),this.el.sceneEl.renderer.xr.addEventListener("sessionend",function(){this.hitTest=null}.bind(this)),this.el.sceneEl.renderer.xr.addEventListener("sessionstart",function(){if(this.el.is("ar-mode")){var k=this.el.sceneEl.renderer,F=this.session=k.xr.getSession();this.hasPosedOnce=!1,this.bboxMesh.visible=!1,O||(O=new Map),F.requestReferenceSpace("viewer").then(function(X){this.hitTest=new D(k,{space:X}),O.set(X,this.hitTest),this.el.emit("ar-hit-test-start")}.bind(this));var G="generic-touchscreen",Q=new D(k,{profile:G});F.addEventListener("selectstart",function(X){if(!0===this.data.enabled){var lt=X.inputSource;this.bboxMesh.visible=!0,!0===this.hasPosedOnce&&(this.el.emit("ar-hit-test-select-start",{inputSource:lt,position:this.bboxMesh.position,orientation:this.bboxMesh.quaternion}),lt.profiles[0]===G?this.hitTest=Q:(this.hitTest=O.get(lt)||new D(k,{space:lt.targetRaySpace}),O.set(lt,this.hitTest)))}}.bind(this)),F.addEventListener("selectend",function(X){if(this.hitTest&&!0===this.data.enabled){var lt,rt=X.inputSource;!0===this.hasPosedOnce&&(this.bboxMesh.visible=!1,this.data.target&&(lt=this.data.target.object3D)&&(E.tempFakePose.transform.position.copy(this.bboxMesh.position),E.tempFakePose.transform.orientation.copy(this.bboxMesh.quaternion),E(E.tempFakePose,lt,this.bboxOffset),lt.visible=!0,this.hitTest.anchorFromLastHitTestResult(lt,this.bboxOffset)),this.el.emit("ar-hit-test-select",{inputSource:rt,position:this.bboxMesh.position,orientation:this.bboxMesh.quaternion})),this.hitTest=null}else this.hitTest=null}.bind(this))}}.bind(this)),this.bboxOffset=new _.Vector3,this.update=this.update.bind(this),this.makeBBox()},update:function(){!1===this.data.enabled&&(this.hitTest=null,this.bboxMesh.visible=!1),this.data.target&&(this.data.target.object3D?(this.data.target.addEventListener("model-loaded",this.update),this.data.target.object3D.layers.enable(21),this.data.target.object3D.traverse(function(C){C.layers.enable(21)})):this.data.target.addEventListener("loaded",this.update,{once:!0})),this.bboxNeedsUpdate=!0},makeBBox:function(){var C=new _.PlaneGeometry(1,1),M=new _.MeshBasicMaterial({transparent:!0,color:16777215});C.rotateX(-Math.PI/2),C.rotateY(-Math.PI/2),this.bbox=new _.Box3,this.bboxMesh=new _.Mesh(C,M),this.el.setObject3D("ar-hit-test",this.bboxMesh),this.bboxMesh.visible=!1},updateFootprint:function(){var C,M,k,F=this.el.sceneEl.renderer,G=F.xr.enabled;this.bboxMesh.material.map=this.canvasTexture,this.bboxMesh.material.needsUpdate=!0,this.orthoCam.rotation.set(-Math.PI/2,0,-Math.PI/2),this.orthoCam.position.copy(this.bboxMesh.position),this.orthoCam.position.y-=this.bboxMesh.scale.y/2,this.orthoCam.near=.1,this.orthoCam.far=this.orthoCam.near+this.data.footprintDepth*this.bboxMesh.scale.y,this.orthoCam.position.y+=this.orthoCam.far,this.orthoCam.right=this.bboxMesh.scale.z/2,this.orthoCam.left=-this.bboxMesh.scale.z/2,this.orthoCam.top=this.bboxMesh.scale.x/2,this.orthoCam.bottom=-this.bboxMesh.scale.x/2,this.orthoCam.updateProjectionMatrix(),M=F.getRenderTarget(),F.setRenderTarget(this.textureTarget),F.xr.enabled=!1,k=this.el.object3D.background,this.el.object3D.overrideMaterial=this.basicMaterial,this.el.object3D.background=null,F.render(this.el.object3D,this.orthoCam),this.el.object3D.background=k,this.el.object3D.overrideMaterial=null,F.xr.enabled=G,F.setRenderTarget(M),F.readRenderTargetPixels(this.textureTarget,0,0,512,512,this.imageDataArray),this.context.putImageData(this.imageData,0,0),this.context.shadowColor="white",this.context.shadowBlur=10,this.context.drawImage(this.canvas,0,0),C=this.context.getImageData(0,0,512,512);for(var Q=0;Q<262144;Q++)0!==C.data[4*Q+3]&&255!==C.data[4*Q+3]&&(C.data[4*Q+3]=128);this.context.putImageData(C,0,0),this.canvasTexture.needsUpdate=!0},tick:function(){var C,M,k=this.el.sceneEl.frame;k&&D.updateAnchorPoses(k,this.el.sceneEl.renderer.xr.getReferenceSpace()),this.bboxNeedsUpdate&&(this.bboxNeedsUpdate=!1,this.data.target&&"map"!==this.data.type||(this.textureCache.has(this.data.src)?M=this.textureCache.get(this.data.src):(M=(new _.TextureLoader).load(this.data.src),this.textureCache.set(this.data.src,M)),this.bboxMesh.material.map=M,this.bboxMesh.material.needsUpdate=!0),this.data.target&&this.data.target.object3D?(this.bbox.setFromObject(this.data.target.object3D),this.bbox.getCenter(this.bboxMesh.position),this.bbox.getSize(this.bboxMesh.scale),"footprint"===this.data.type&&(this.bboxMesh.scale.x*=1.04,this.bboxMesh.scale.z*=1.04,this.updateFootprint()),this.bboxMesh.position.y-=this.bboxMesh.scale.y/2,this.bboxOffset.copy(this.bboxMesh.position),this.bboxOffset.sub(this.data.target.object3D.position)):this.bboxMesh.scale.set(this.data.mapSize.x,1,this.data.mapSize.y)),this.hitTest&&(C=this.hitTest.doHit(k))&&(!0!==this.hasPosedOnce&&(this.hasPosedOnce=!0,this.el.emit("ar-hit-test-achieved")),this.bboxMesh.visible=!0,this.bboxMesh.position.copy(C.transform.position),this.bboxMesh.quaternion.copy(C.transform.orientation))}})},4005:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("background",{schema:{color:{type:"color",default:"black"},transparent:{default:!1}},sceneOnly:!0,update:function(){var $=this.data;this.el.object3D.background=$.transparent?null:new THREE.Color($.color)},remove:function(){this.el.object3D.background=null}})},3494:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("debug",{schema:{default:!0},sceneOnly:!0})},6273:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(1343),O="a-dialog-buttons-container",N="a-dialog-button";function _(E,D){var B,C,M,k;return(B=document.createElement("div")).classList.add("a-modal"),B.setAttribute($.AFRAME_INJECTED,""),(C=document.createElement("div")).className="a-dialog",C.setAttribute($.AFRAME_INJECTED,""),B.appendChild(C),(M=document.createElement("div")).classList.add("a-dialog-text-container"),C.appendChild(M),(k=document.createElement("div")).classList.add("a-dialog-text"),k.innerHTML=E,M.appendChild(k),C.appendChild(D),B}ot.exports.Component=U("device-orientation-permission-ui",{schema:{enabled:{default:!0},deviceMotionMessage:{default:"This immersive website requires access to your device motion sensors."},httpsMessage:{default:"Access this site over HTTPS to enter VR mode and grant access to the device sensors."},denyButtonText:{default:"Deny"},allowButtonText:{default:"Allow"},cancelButtonText:{default:"Cancel"}},sceneOnly:!0,init:function(){var E=this;this.data.enabled&&(window.isSecureContext||this.showHTTPAlert(),typeof DeviceOrientationEvent<"u"&&DeviceOrientationEvent.requestPermission?(this.onDeviceMotionDialogAllowClicked=this.onDeviceMotionDialogAllowClicked.bind(this),this.onDeviceMotionDialogDenyClicked=this.onDeviceMotionDialogDenyClicked.bind(this),DeviceOrientationEvent.requestPermission().then(function(){E.el.emit("deviceorientationpermissiongranted"),E.permissionGranted=!0}).catch(function(){var D,B,C,M,k,F,G,Q;E.devicePermissionDialogEl=(D=E.data.denyButtonText,B=E.data.allowButtonText,C=E.data.deviceMotionMessage,M=E.onDeviceMotionDialogAllowClicked,k=E.onDeviceMotionDialogDenyClicked,(F=document.createElement("div")).classList.add(O),(G=document.createElement("button")).classList.add(N,"a-dialog-deny-button"),G.setAttribute($.AFRAME_INJECTED,""),G.innerHTML=D,F.appendChild(G),(Q=document.createElement("button")).classList.add(N,"a-dialog-allow-button"),Q.setAttribute($.AFRAME_INJECTED,""),Q.innerHTML=B,F.appendChild(Q),Q.addEventListener("click",function(X){X.stopPropagation(),M()}),G.addEventListener("click",function(X){X.stopPropagation(),k()}),_(C,F)),E.el.appendChild(E.devicePermissionDialogEl)})):this.permissionGranted=!0)},remove:function(){this.devicePermissionDialogEl&&this.el.removeChild(this.devicePermissionDialogEl)},onDeviceMotionDialogDenyClicked:function(){this.remove()},showHTTPAlert:function(){var E,D,B,C,M,k=this,F=(E=k.data.cancelButtonText,D=k.data.httpsMessage,B=function(){k.el.removeChild(F)},(C=document.createElement("div")).classList.add(O),(M=document.createElement("button")).classList.add(N,"a-dialog-ok-button"),M.setAttribute($.AFRAME_INJECTED,""),M.innerHTML=E,C.appendChild(M),M.addEventListener("click",function(G){G.stopPropagation(),B()}),_(D,C));this.el.appendChild(F)},onDeviceMotionDialogAllowClicked:function(){var E=this;this.el.emit("deviceorientationpermissionrequested"),DeviceOrientationEvent.requestPermission().then(function(D){"granted"===D?(E.el.emit("deviceorientationpermissiongranted"),E.permissionGranted=!0):E.el.emit("deviceorientationpermissionrejected"),E.remove()}).catch(console.error)}})},3239:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("embedded",{dependencies:["xr-mode-ui"],schema:{default:!0},sceneOnly:!0,update:function(){var $=this.el,O=$.querySelector(".a-enter-vr");!0===this.data?(O&&O.classList.add("embedded"),$.removeFullScreenStyles()):(O&&O.classList.remove("embedded"),$.addFullScreenStyles())}})},6149:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437);I(8940)("components:fog:warn"),ot.exports.Component=U("fog",{schema:{color:{type:"color",default:"#000"},density:{default:25e-5},far:{default:1e3,min:0},near:{default:1,min:0},type:{default:"linear",oneOf:["linear","exponential"]}},sceneOnly:!0,update:function(){var E,D,O=this.data,N=this.el,_=this.el.object3D.fog;_&&O.type===_.name?Object.keys(this.schema).forEach(function(E){var D=O[E];"color"===E&&(D=new $.Color(D)),_[E]=D}):N.object3D.fog=((D="exponential"===(E=O).type?new $.FogExp2(E.color,E.density):new $.Fog(E.color,E.near,E.far)).name=E.type,D)},remove:function(){this.el.object3D.fog&&(this.el.object3D.fog=null)}})},2288:(ot,ht,I)=>{var U,$=I(1343).AFRAME_INJECTED,O=I(8330),N=I(8190).registerComponent,_=I(7427),E="https://unpkg.com/aframe-inspector@"+((U=O.version.split("."))[2]="x",U.join(".")+"/dist/aframe-inspector.min.js");ot.exports.Component=N("inspector",{schema:{url:{default:E}},sceneOnly:!0,init:function(){this.firstPlay=!0,this.onKeydown=this.onKeydown.bind(this),this.onMessage=this.onMessage.bind(this),this.initOverlay(),window.addEventListener("keydown",this.onKeydown),window.addEventListener("message",this.onMessage)},play:function(){var D;this.firstPlay&&"false"!==(D=_.getUrlParameter("inspector"))&&D&&(this.openInspector(),this.firstPlay=!1)},initOverlay:function(){this.loadingMessageEl=document.createElement("div"),this.loadingMessageEl.classList.add("a-inspector-loader"),this.loadingMessageEl.innerHTML='Loading Inspector<span class="dots"><span>.</span><span>.</span><span>.</span></span>'},remove:function(){this.removeEventListeners()},onKeydown:function(D){73===D.keyCode&&(D.ctrlKey&&D.altKey||D.getModifierState("AltGraph"))&&this.openInspector()},showLoader:function(){document.body.appendChild(this.loadingMessageEl)},hideLoader:function(){document.body.removeChild(this.loadingMessageEl)},onMessage:function(D){"INJECT_AFRAME_INSPECTOR"===D.data&&this.openInspector()},openInspector:function(D){var B,C=this;AFRAME.INSPECTOR||AFRAME.inspectorInjected?AFRAME.INSPECTOR.open(D):(this.showLoader(),(B=document.createElement("script")).src=this.data.url,B.setAttribute("data-name","aframe-inspector"),B.setAttribute($,""),B.onload=function(){AFRAME.INSPECTOR.open(D),C.hideLoader(),C.removeEventListeners()},B.onerror=function(){C.loadingMessageEl.innerHTML="Error loading Inspector"},document.head.appendChild(B),AFRAME.inspectorInjected=!0)},removeEventListeners:function(){window.removeEventListener("keydown",this.onKeydown),window.removeEventListener("message",this.onMessage)}})},2130:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7427).shouldCaptureKeyEvent;ot.exports.Component=U("keyboard-shortcuts",{schema:{enterVR:{default:!0},exitVR:{default:!0}},sceneOnly:!0,init:function(){this.onKeyup=this.onKeyup.bind(this)},update:function(O){this.enterVREnabled=this.data.enterVR},play:function(){window.addEventListener("keyup",this.onKeyup,!1)},pause:function(){window.removeEventListener("keyup",this.onKeyup)},onKeyup:function(O){var N=this.el;$(O)&&(this.enterVREnabled&&70===O.keyCode&&N.enterVR(),this.enterVREnabled&&27===O.keyCode&&N.exitVR())}})},3791:(ot,ht,I)=>{var U=I(8940),$=I(8190).registerComponent,O=U("components:pool:warn");ot.exports.Component=$("pool",{schema:{container:{default:""},mixin:{default:""},size:{default:0},dynamic:{default:!1}},sceneOnly:!0,multiple:!0,initPool:function(){var N;for(this.availableEls=[],this.usedEls=[],this.data.mixin||O("No mixin provided for pool component."),this.data.container&&(this.container=document.querySelector(this.data.container),this.container||O("Container "+this.data.container+" not found.")),this.container=this.container||this.el,N=0;N<this.data.size;++N)this.createEntity()},update:function(N){var _=this.data;N.mixin===_.mixin&&N.size===_.size||this.initPool()},createEntity:function(){var N;(N=document.createElement("a-entity")).play=this.wrapPlay(N.play),N.setAttribute("mixin",this.data.mixin),N.object3D.visible=!1,N.pause(),this.container.appendChild(N),this.availableEls.push(N);var _=this.usedEls;N.addEventListener("loaded",function(){-1===_.indexOf(N)&&(N.object3DParent=N.object3D.parent,N.object3D.parent.remove(N.object3D))})},wrapPlay:function(N){var _=this.usedEls;return function(){-1!==_.indexOf(this)&&N.call(this)}},requestEntity:function(){var N;if(0===this.availableEls.length){if(!1===this.data.dynamic)return void O("Requested entity from empty pool: "+this.attrName);O("Requested entity from empty pool. This pool is dynamic and will resize automatically. You might want to increase its initial size: "+this.attrName),this.createEntity()}return N=this.availableEls.shift(),this.usedEls.push(N),N.object3DParent&&(N.object3DParent.add(N.object3D),this.updateRaycasters()),N.object3D.visible=!0,N},returnEntity:function(N){var _=this.usedEls.indexOf(N);if(-1!==_)return this.usedEls.splice(_,1),this.availableEls.push(N),N.object3DParent=N.object3D.parent,N.object3D.parent.remove(N.object3D),this.updateRaycasters(),N.object3D.visible=!1,N.pause(),N;O("The returned entity was not previously pooled from "+this.attrName)},updateRaycasters:function(){document.querySelectorAll("[raycaster]").forEach(function(N){N.components.raycaster.setDirty()})}})},2662:(ot,ht,I)=>{var U,$=I(8190).registerComponent,O=I(9437);ot.exports.Component=$("real-world-meshing",{schema:{filterLabels:{type:"array"},meshesEnabled:{default:!0},meshMixin:{default:!0},planesEnabled:{default:!0},planeMixin:{default:""}},sceneOnly:!0,init:function(){var N=this.el.getAttribute("webxr"),_=N.requiredFeatures;-1===_.indexOf("mesh-detection")&&(_.push("mesh-detection"),this.el.setAttribute("webxr",N)),-1===_.indexOf("plane-detection")&&(_.push("plane-detection"),this.el.setAttribute("webxr",N)),this.meshEntities=[],this.initWorldMeshEntity=this.initWorldMeshEntity.bind(this)},tick:function(){this.el.is("ar-mode")&&(this.detectMeshes(),this.updateMeshes())},detectMeshes:function(){var N,_,E,D=this.data,C=this.meshEntities,M=!1,k=[],F=this.data.filterLabels;N=(E=this.el.frame).detectedMeshes,_=E.detectedPlanes;for(var G=0;G<C.length;G++)C[G].present=!1;if(D.meshesEnabled)for(var Q of N.values())if(!F.length||-1!==F.indexOf(Q.semanticLabel)){for(G=0;G<C.length;G++)if(Q===C[G].mesh){M=!0,C[G].present=!0,C[G].lastChangedTime<Q.lastChangedTime&&this.updateMeshGeometry(C[G].el,Q),C[G].lastChangedTime=Q.lastChangedTime;break}M||k.push(Q),M=!1}if(D.planesEnabled)for(Q of _.values())if(!F.length||-1!==F.indexOf(Q.semanticLabel)){for(G=0;G<C.length;G++)if(Q===C[G].mesh){M=!0,C[G].present=!0,C[G].lastChangedTime<Q.lastChangedTime&&this.updateMeshGeometry(C[G].el,Q),C[G].lastChangedTime=Q.lastChangedTime;break}M||k.push(Q),M=!1}this.deleteMeshes(),this.createNewMeshes(k)},updateMeshes:(U=new O.Matrix4,function(){for(var N,_,D=this.el,B=D.frame,C=this.meshEntities,M=D.renderer.xr.getReferenceSpace(),k=0;k<C.length;k++)N=B.getPose(C[k].mesh.meshSpace||C[k].mesh.planeSpace,M),(_=C[k].el).hasLoaded&&(U.fromArray(N.transform.matrix),U.decompose(_.object3D.position,_.object3D.quaternion,_.object3D.scale))}),deleteMeshes:function(){for(var N=this.meshEntities,_=[],E=0;E<N.length;E++)N[E].present?_.push(N[E]):this.el.removeChild(N[E]);this.meshEntities=_},createNewMeshes:function(N){for(var _,E=0;E<N.length;E++)_=document.createElement("a-entity"),this.meshEntities.push({mesh:N[E],el:_}),_.addEventListener("loaded",this.initWorldMeshEntity),this.el.appendChild(_)},initMeshGeometry:function(N){var _,E,D;if(N instanceof XRPlane){E=new O.Shape,D=N.polygon;for(var B=0;B<D.length;++B)0===B?E.moveTo(D[B].x,D[B].z):E.lineTo(D[B].x,D[B].z);return(_=new O.ShapeGeometry(E)).rotateX(Math.PI/2),_}return(_=new O.BufferGeometry).setAttribute("position",new O.BufferAttribute(N.vertices,3)),_.setIndex(new O.BufferAttribute(N.indices,1)),_},initWorldMeshEntity:function(N){for(var _,E,D,B=N.target,C=this.meshEntities,M=0;M<C.length;M++)if(C[M].el===B){D=C[M];break}_=this.initMeshGeometry(D.mesh),E=new O.Mesh(_,new O.MeshBasicMaterial({color:16777215*Math.random(),side:O.DoubleSide})),B.setObject3D("mesh",E),D.mesh instanceof XRPlane&&this.data.planeMixin?B.setAttribute("mixin",this.data.planeMixin):this.data.meshMixin&&B.setAttribute("mixin",this.data.meshMixin),B.setAttribute("data-world-mesh",D.mesh.semanticLabel)},updateMeshGeometry:function(N,_){var E=N.getObject3D("mesh");E.geometry.dispose(),E.geometry=this.initMeshGeometry(_)}})},952:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("reflection",{schema:{directionalLight:{type:"selector"}},sceneOnly:!0,init:function(){var $=this;this.cubeRenderTarget=new THREE.WebGLCubeRenderTarget(16),this.cubeCamera=new THREE.CubeCamera(.1,1e3,this.cubeRenderTarget),this.lightingEstimationTexture=new THREE.WebGLCubeRenderTarget(16).texture,this.needsVREnvironmentUpdate=!0;var O=this.el.getAttribute("webxr"),N=O.optionalFeatures;N.includes("light-estimation")||(N.push("light-estimation"),this.el.setAttribute("webxr",O)),this.el.addEventListener("enter-vr",function(){$.el.is("ar-mode")&&$.el.renderer.xr.getSession().requestLightProbe&&$.startLightProbe()}),this.el.addEventListener("exit-vr",function(){$.xrLightProbe&&$.stopLightProbe()}),this.el.object3D.environment=this.cubeRenderTarget.texture},stopLightProbe:function(){this.xrLightProbe=null,this.probeLight&&(this.probeLight.components.light.light.intensity=0),this.needsVREnvironmentUpdate=!0,this.el.object3D.environment=this.cubeRenderTarget.texture},startLightProbe:function(){this.needsLightProbeUpdate=!0},setupLightProbe:function(){var $=this.el.renderer,O=$.xr.getSession(),N=this,_=$.getContext();if(!this.probeLight){var E=document.createElement("a-light");E.setAttribute("type","probe"),E.setAttribute("intensity",0),this.el.appendChild(E),this.probeLight=E}switch(O.preferredReflectionFormat){case"srgba8":_.getExtension("EXT_sRGB");break;case"rgba16f":_.getExtension("OES_texture_half_float")}this.glBinding=new XRWebGLBinding(O,_),_.getExtension("EXT_sRGB"),_.getExtension("OES_texture_half_float"),O.requestLightProbe().then(function(D){N.xrLightProbe=D,D.addEventListener("reflectionchange",N.updateXRCubeMap.bind(N))}).catch(function(D){console.warn("Lighting estimation not supported: "+D.message),console.warn('Are you missing: webxr="optionalFeatures: light-estimation;" from <a-scene>?')})},updateXRCubeMap:function(){var $=this.el.renderer,O=this.glBinding.getReflectionCubeMap(this.xrLightProbe);O&&($.properties.get(this.lightingEstimationTexture).__webglTexture=O,this.lightingEstimationTexture.needsPMREMUpdate=!0,this.el.object3D.environment=this.lightingEstimationTexture)},tick:function(){var E,D,B,C,M,$=this.el.object3D,O=this.el.renderer,N=this.el.frame;if(N&&this.xrLightProbe){var _=N.getLightEstimate(this.xrLightProbe);_&&(E=_,D=this.probeLight.components.light.light,B=this.data.directionalLight&&this.data.directionalLight.components.light.light,C=this.data.directionalLight&&this.data.directionalLight.object3D.position,M=Math.max(E.primaryLightIntensity.x,Math.max(E.primaryLightIntensity.y,E.primaryLightIntensity.z)),D.sh.fromArray(E.sphericalHarmonicsCoefficients),D.intensity=1,B&&(B.color.setRGB(E.primaryLightIntensity.x/M,E.primaryLightIntensity.y/M,E.primaryLightIntensity.z/M),B.intensity=M,C.copy(E.primaryLightDirection)))}this.needsVREnvironmentUpdate&&($.environment=null,this.needsVREnvironmentUpdate=!1,this.cubeCamera.position.set(0,1.6,0),this.cubeCamera.update(O,$),$.environment=this.cubeRenderTarget.texture),this.needsLightProbeUpdate&&N&&(this.setupLightProbe(),this.needsLightProbeUpdate=!1)},remove:function(){this.el.object3D.environment=null,this.probeLight&&this.el.removeChild(this.probeLight)}})},1217:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437),O=["attribute vec3 position;","attribute vec2 uv;","uniform mat4 projectionMatrix;","uniform mat4 modelViewMatrix;","varying vec2 vUv;","void main()  {","  vUv = vec2( 1.- uv.x, uv.y );","  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),N=["precision mediump float;","uniform samplerCube map;","varying vec2 vUv;","#define M_PI 3.141592653589793238462643383279","void main() {","  vec2 uv = vUv;","  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;","  float latitude = uv.y * M_PI;","  vec3 dir = vec3(","    - sin( longitude ) * sin( latitude ),","    cos( latitude ),","    - cos( longitude ) * sin( latitude )","  );","  normalize( dir );","  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );","}"].join("\n");ot.exports.Component=U("screenshot",{schema:{width:{default:4096},height:{default:2048},camera:{type:"selector"}},sceneOnly:!0,setup:function(){var _=this.el;if(!this.canvas){var E=_.renderer.getContext();E&&(this.cubeMapSize=E.getParameter(E.MAX_CUBE_MAP_TEXTURE_SIZE),this.material=new $.RawShaderMaterial({uniforms:{map:{type:"t",value:null}},vertexShader:O,fragmentShader:N,side:$.DoubleSide}),this.quad=new $.Mesh(new $.PlaneGeometry(1,1),this.material),this.quad.visible=!1,this.camera=new $.OrthographicCamera(-.5,.5,.5,-.5,-1e4,1e4),this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),_.object3D.add(this.quad),this.onKeyDown=this.onKeyDown.bind(this))}},getRenderTarget:function(_,E){return new $.WebGLRenderTarget(_,E,{colorSpace:this.el.sceneEl.renderer.outputColorSpace,minFilter:$.LinearFilter,magFilter:$.LinearFilter,wrapS:$.ClampToEdgeWrapping,wrapT:$.ClampToEdgeWrapping,format:$.RGBAFormat,type:$.UnsignedByteType})},resize:function(_,E){this.quad.scale.set(_,E,1),this.camera.left=-1*_/2,this.camera.right=_/2,this.camera.top=E/2,this.camera.bottom=-1*E/2,this.camera.updateProjectionMatrix(),this.canvas.width=_,this.canvas.height=E},play:function(){window.addEventListener("keydown",this.onKeyDown)},onKeyDown:function(_){this.data&&83===_.keyCode&&_.ctrlKey&&_.altKey&&this.capture(_.shiftKey?"equirectangular":"perspective")},setCapture:function(_){var E,D,B,C,M=this.el;return"perspective"===_?(this.quad.visible=!1,D=this.data.camera&&this.data.camera.components.camera.camera||M.camera,E={width:this.data.width,height:this.data.height}):(D=this.camera,C=new $.WebGLCubeRenderTarget(Math.min(this.cubeMapSize,2048),{format:$.RGBFormat,generateMipmaps:!0,minFilter:$.LinearMipmapLinearFilter,colorSpace:$.SRGBColorSpace}),B=new $.CubeCamera(M.camera.near,M.camera.far,C),M.camera.getWorldPosition(B.position),M.camera.getWorldQuaternion(B.quaternion),B.update(M.renderer,M.object3D),this.quad.material.uniforms.map.value=B.renderTarget.texture,E={width:this.data.width,height:this.data.height},this.quad.visible=!0),{camera:D,size:E,projection:_}},capture:function(_){var E,D=this.el.renderer.xr.enabled,B=this.el.renderer;this.setup(),B.xr.enabled=!1,E=this.setCapture(_),this.renderCapture(E.camera,E.size,E.projection),this.saveCapture(),B.xr.enabled=D},getCanvas:function(_){var E=this.el.renderer.xr.enabled,D=this.el.renderer;this.setup();var B=this.setCapture(_);return D.xr.enabled=!1,this.renderCapture(B.camera,B.size,B.projection),D.xr.enabled=E,this.canvas},renderCapture:function(_,E,D){var B,C,M,k=this.el.renderer.autoClear,F=this.el,G=F.renderer;C=this.getRenderTarget(E.width,E.height),M=new Uint8Array(4*E.width*E.height),this.resize(E.width,E.height),G.autoClear=!0,G.clear(),G.setRenderTarget(C),G.render(F.object3D,_),G.autoClear=k,G.readRenderTargetPixels(C,0,0,E.width,E.height,M),G.setRenderTarget(null),"perspective"===D&&(M=this.flipPixelsVertically(M,E.width,E.height)),B=new ImageData(new Uint8ClampedArray(M),E.width,E.height),this.quad.visible=!1,this.ctx.putImageData(B,0,0)},flipPixelsVertically:function(_,E,D){for(var B=_.slice(0),C=0;C<E;++C)for(var M=0;M<D;++M)B[4*C+M*E*4]=_[4*C+(D-M)*E*4],B[4*C+1+M*E*4]=_[4*C+1+(D-M)*E*4],B[4*C+2+M*E*4]=_[4*C+2+(D-M)*E*4],B[4*C+3+M*E*4]=_[4*C+3+(D-M)*E*4];return B},saveCapture:function(){this.canvas.toBlob(function(_){var E="screenshot-"+document.title.toLowerCase()+"-"+Date.now()+".png",D=document.createElement("a"),B=URL.createObjectURL(_);D.href=B,D.setAttribute("download",E),D.innerHTML="downloading...",D.style.display="none",document.body.appendChild(D),setTimeout(function(){D.click(),document.body.removeChild(D)},1)},"image/png")}})},8346:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(282),O=I(7427);I(3729),I(8132);var N=window.aframeStats,_="a-hidden",E=window.threeStats;ot.exports.Component=U("stats",{schema:{default:!0},sceneOnly:!0,init:function(){var B,C,M,D=this.el;"false"!==O.getUrlParameter("stats")&&(this.stats=(C=new E((B=D).renderer),M=new N(B),new $({css:[],values:{fps:{caption:"fps",below:30}},groups:[{caption:"Framerate",values:["fps","raf"]}],plugins:B.isMobile?[]:[C,M]})),this.statsEl=document.querySelector(".rs-base"),this.hideBound=this.hide.bind(this),this.showBound=this.show.bind(this),D.addEventListener("enter-vr",this.hideBound),D.addEventListener("exit-vr",this.showBound))},update:function(){if(this.stats)return this.data?this.show():this.hide()},remove:function(){this.el.removeEventListener("enter-vr",this.hideBound),this.el.removeEventListener("exit-vr",this.showBound),this.statsEl&&this.statsEl.parentNode.removeChild(this.statsEl)},tick:function(){var D=this.stats;D&&(D("rAF").tick(),D("FPS").frame(),D().update())},hide:function(){this.statsEl.classList.add(_)},show:function(){this.statsEl.classList.remove(_)}})},6469:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(1343),O=I(7427),N="a-hidden";function _(E){E.addEventListener("touchstart",function(){E.classList.remove("resethover")},{passive:!0}),E.addEventListener("touchend",function(){E.classList.add("resethover")},{passive:!0})}ot.exports.Component=U("xr-mode-ui",{dependencies:["canvas"],schema:{enabled:{default:!0},cardboardModeEnabled:{default:!1},enterVRButton:{default:""},enterVREnabled:{default:!0},enterARButton:{default:""},enterAREnabled:{default:!0},XRMode:{default:"vr",oneOf:["vr","ar","xr"]}},sceneOnly:!0,init:function(){var E=this,D=this.el;"false"!==O.getUrlParameter("ui")&&(this.insideLoader=!1,this.enterVREl=null,this.enterAREl=null,this.orientationModalEl=null,this.bindMethods(),D.addEventListener("enter-vr",this.updateEnterInterfaces),D.addEventListener("exit-vr",this.updateEnterInterfaces),D.addEventListener("update-vr-devices",this.updateEnterInterfaces),window.addEventListener("message",function(B){"loaderReady"===B.data.type&&(E.insideLoader=!0,E.remove())}),window.addEventListener("orientationchange",this.toggleOrientationModalIfNeeded))},bindMethods:function(){this.onEnterVRButtonClick=this.onEnterVRButtonClick.bind(this),this.onEnterARButtonClick=this.onEnterARButtonClick.bind(this),this.onModalClick=this.onModalClick.bind(this),this.toggleOrientationModalIfNeeded=this.toggleOrientationModalIfNeeded.bind(this),this.updateEnterInterfaces=this.updateEnterInterfaces.bind(this)},onModalClick:function(){this.el.exitVR()},onEnterVRButtonClick:function(){this.el.enterVR()},onEnterARButtonClick:function(){this.el.enterAR()},update:function(){var E,D,B,k,F,G,Q,C=this.data,M=this.el;if(!C.enabled||this.insideLoader||"false"===O.getUrlParameter("ui"))return this.remove();this.enterVREl||this.enterAREl||this.orientationModalEl||(this.enterVREl||!C.enterVREnabled||"xr"!==C.XRMode&&"vr"!==C.XRMode||(C.enterVRButton?(this.enterVREl=document.querySelector(C.enterVRButton),this.enterVREl.addEventListener("click",this.onEnterVRButtonClick)):(this.enterVREl=(E=this.onEnterVRButtonClick,(B=document.createElement("div")).classList.add("a-enter-vr"),B.setAttribute($.AFRAME_INJECTED,""),(D=document.createElement("button")).className="a-enter-vr-button",D.setAttribute("title","Enter VR mode with a headset or fullscreen without"),D.setAttribute($.AFRAME_INJECTED,""),O.device.isMobile()&&_(D),B.appendChild(D),D.addEventListener("click",function(k){E(),k.stopPropagation()}),B),M.appendChild(this.enterVREl))),this.enterAREl||!C.enterAREnabled||"xr"!==C.XRMode&&"ar"!==C.XRMode||(C.enterARButton?(this.enterAREl=document.querySelector(C.enterARButton),this.enterAREl.addEventListener("click",this.onEnterARButtonClick)):(this.enterAREl=(k=this.onEnterARButtonClick,F="xr"===C.XRMode,(Q=document.createElement("div")).classList.add("a-enter-ar"),F&&Q.classList.add("xr"),Q.setAttribute($.AFRAME_INJECTED,""),(G=document.createElement("button")).className="a-enter-ar-button",G.setAttribute("title","Enter AR mode with a headset or handheld device."),G.setAttribute($.AFRAME_INJECTED,""),O.device.isMobile()&&_(G),Q.appendChild(G),G.addEventListener("click",function(X){k(),X.stopPropagation()}),Q),M.appendChild(this.enterAREl))),this.orientationModalEl=function(k){var F=document.createElement("div");F.className="a-orientation-modal",F.classList.add(N),F.setAttribute($.AFRAME_INJECTED,"");var G=document.createElement("button");return G.setAttribute($.AFRAME_INJECTED,""),G.innerHTML="Exit VR",G.addEventListener("click",k),F.appendChild(G),F}(this.onModalClick),M.appendChild(this.orientationModalEl),this.updateEnterInterfaces())},remove:function(){[this.enterVREl,this.enterAREl,this.orientationModalEl].forEach(function(E){E&&E.parentNode&&E.parentNode.removeChild(E)}),this.enterVREl=void 0,this.enterAREl=void 0,this.orientationModalEl=void 0},updateEnterInterfaces:function(){this.toggleEnterVRButtonIfNeeded(),this.toggleEnterARButtonIfNeeded(),this.toggleOrientationModalIfNeeded()},toggleEnterVRButtonIfNeeded:function(){var E=this.el;this.enterVREl&&(E.is("vr-mode")||(E.isMobile||O.device.isMobileDeviceRequestingDesktopSite())&&!this.data.cardboardModeEnabled&&!O.device.checkVRSupport()?this.enterVREl.classList.add(N):(O.device.checkVRSupport()||this.enterVREl.classList.add("fullscreen"),this.enterVREl.classList.remove(N),E.enterVR(!1,!0)))},toggleEnterARButtonIfNeeded:function(){var E=this.el;this.enterAREl&&(E.is("vr-mode")||!O.device.checkARSupport()?this.enterAREl.classList.add(N):(this.enterAREl.classList.remove(N),E.enterVR(!0,!0)))},toggleOrientationModalIfNeeded:function(){var E=this.el,D=this.orientationModalEl;D&&E.isMobile&&(!O.device.isLandscape()&&E.is("vr-mode")?D.classList.remove(N):D.classList.add(N))}})},1072:(ot,ht,I)=>{var U=I(8190),$=I(9437);ot.exports.Component=(0,U.registerComponent)("shadow",{schema:{cast:{default:!0},receive:{default:!0}},init:function(){this.onMeshChanged=this.update.bind(this),this.el.addEventListener("object3dset",this.onMeshChanged),this.system.setShadowMapEnabled(!0)},update:function(){var N=this.data;this.updateDescendants(N.cast,N.receive)},remove:function(){this.el.removeEventListener("object3dset",this.onMeshChanged),this.updateDescendants(!1,!1)},updateDescendants:function(N,_){var E=this.el.sceneEl;this.el.object3D.traverse(function(D){if(D instanceof $.Mesh&&(D.castShadow=N,D.receiveShadow=_,E.hasLoaded&&D.material))for(var B=Array.isArray(D.material)?D.material:[D.material],C=0;C<B.length;C++)B[C].needsUpdate=!0})}})},477:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(8940),O=I(9437),N=$("components:sound:warn");ot.exports.Component=U("sound",{schema:{autoplay:{default:!1},distanceModel:{default:"inverse",oneOf:["linear","inverse","exponential"]},loop:{default:!1},loopStart:{default:0},loopEnd:{default:0},maxDistance:{default:1e4},on:{default:""},poolSize:{default:1},positional:{default:!0},refDistance:{default:1},rolloffFactor:{default:1},src:{type:"audio"},volume:{default:1}},multiple:!0,init:function(){var _=this;this.listener=null,this.audioLoader=new O.AudioLoader,this.pool=new O.Group,this.loaded=!1,this.mustPlay=!1,this.playSoundBound=function(){_.playSound()}},update:function(_){var E,D,B=this.data,C=B.src!==_.src;if(C){if(!B.src)return;this.setupSound()}for(E=0;E<this.pool.children.length;E++)D=this.pool.children[E],B.positional&&(D.setDistanceModel(B.distanceModel),D.setMaxDistance(B.maxDistance),D.setRefDistance(B.refDistance),D.setRolloffFactor(B.rolloffFactor)),D.setLoop(B.loop),D.setLoopStart(B.loopStart),D.setLoopEnd(0!==B.loopStart&&0===B.loopEnd?D.buffer.duration:B.loopEnd),D.setVolume(B.volume),D.isPaused=!1;if(B.on!==_.on&&this.updateEventListener(_.on),C){var M=this;this.loaded=!1,this.audioLoader.load(B.src,function(k){for(E=0;E<M.pool.children.length;E++)(D=M.pool.children[E]).setBuffer(k);M.loaded=!0,O.Cache.remove(B.src),(M.data.autoplay||M.mustPlay)&&M.playSound(M.processSound),M.el.emit("sound-loaded",M.evtDetail,!1)})}},pause:function(){this.stopSound(),this.removeEventListener()},play:function(){this.data.autoplay&&this.playSound(),this.updateEventListener()},remove:function(){var _;this.removeEventListener(),this.el.getObject3D(this.attrName)&&this.el.removeObject3D(this.attrName);try{for(_=0;_<this.pool.children.length;_++)this.pool.children[_].disconnect()}catch{N("Audio source not properly disconnected")}},updateEventListener:function(_){var E=this.el;_&&E.removeEventListener(_,this.playSoundBound),E.addEventListener(this.data.on,this.playSoundBound)},removeEventListener:function(){this.el.removeEventListener(this.data.on,this.playSoundBound)},setupSound:function(){var _,E,D=this.el,B=D.sceneEl,C=this;this.pool.children.length>0&&(this.stopSound(),D.removeObject3D("sound"));var M=this.listener=B.audioListener||new O.AudioListener;for(B.audioListener=M,B.camera&&B.camera.add(M),B.addEventListener("camera-set-active",function(k){k.detail.cameraEl.getObject3D("camera").add(M)}),this.pool=new O.Group,_=0;_<this.data.poolSize;_++)E=this.data.positional?new O.PositionalAudio(M):new O.Audio(M),this.pool.add(E);for(D.setObject3D(this.attrName,this.pool),_=0;_<this.pool.children.length;_++)(E=this.pool.children[_]).onEnded=function(){this.isPlaying=!1,C.el.emit("sound-ended",C.evtDetail,!1)}},pauseSound:function(){var _,E;for(this.isPlaying=!1,_=0;_<this.pool.children.length;_++)(E=this.pool.children[_]).source&&E.source.buffer&&E.isPlaying&&!E.isPaused&&(E.isPaused=!0,E.pause())},playSound:function(_){var E,D,B;if(!this.loaded)return N("Sound not loaded yet. It will be played once it finished loading"),this.mustPlay=!0,void(this.processSound=_);for(E=!1,this.isPlaying=!0,D=0;D<this.pool.children.length;D++)(B=this.pool.children[D]).isPlaying||!B.buffer||E||(_&&_(B),B.play(),B.isPaused=!1,E=!0);E?(this.mustPlay=!1,this.processSound=void 0):N("All the sounds are playing. If you need to play more sounds simultaneously consider increasing the size of pool with the `poolSize` attribute.",this.el)},stopSound:function(){var _,E;for(this.isPlaying=!1,_=0;_<this.pool.children.length;_++){if(!(E=this.pool.children[_]).source||!E.source.buffer)return;E.stop()}}})},1603:(ot,ht,I)=>{var U=I(4433),$=I(5751),O=I(8190).registerComponent,N=I(5892),_=I(9437),E=I(7427),D=E.debug("components:text:error"),B=N.shaders,C=E.debug("components:text:warn"),M=I(1343).AFRAME_CDN_ROOT+"fonts/",k={aileronsemibold:M+"Aileron-Semibold.fnt",dejavu:M+"DejaVu-sdf.fnt",exo2bold:M+"Exo2Bold.fnt",exo2semibold:M+"Exo2SemiBold.fnt",kelsonsans:M+"KelsonSans.fnt",monoid:M+"Monoid.fnt",mozillavr:M+"mozillavr.fnt",roboto:M+"Roboto-msdf.json",sourcecodepro:M+"SourceCodePro.fnt"},F=["roboto"],G="roboto";ot.exports.FONTS=k;var Q,X,lt,rt,pt=new function(){var et=this.cache={};this.get=function(xt,Rt){return xt in et||(et[xt]=Rt()),et[xt]}},vt={},bt={},ft=/^\w+:/;function wt(et,xt,Rt){return et||(.5+xt)*Rt}ot.exports.Component=O("text",{multiple:!0,schema:{align:{type:"string",default:"left",oneOf:["left","right","center"]},alphaTest:{default:.5},anchor:{default:"center",oneOf:["left","right","center","align"]},baseline:{default:"center",oneOf:["top","center","bottom"]},color:{type:"color",default:"#FFF"},font:{type:"string",default:G},fontImage:{type:"string"},height:{type:"number"},letterSpacing:{type:"number",default:0},lineHeight:{type:"number"},negate:{type:"boolean",default:!0},opacity:{type:"number",default:1},shader:{default:"sdf",oneOf:B},side:{default:"front",oneOf:["front","back","double"]},tabSize:{default:4},transparent:{default:!0},value:{type:"string"},whiteSpace:{default:"normal",oneOf:["normal","pre","nowrap"]},width:{type:"number"},wrapCount:{type:"number",default:40},wrapPixels:{type:"number"},xOffset:{type:"number",default:0},yOffset:{type:"number",default:0},zOffset:{type:"number",default:.001}},init:function(){this.shaderData={},this.geometry=U(),this.createOrUpdateMaterial(),this.explicitGeoDimensionsChecked=!1},update:function(et){var xt=this.data,Rt=this.currentFont;bt[xt.font]?this.texture=bt[xt.font]:(this.texture=bt[xt.font]=new _.Texture,this.texture.anisotropy=16),this.createOrUpdateMaterial(),et.font===xt.font?Rt&&(this.updateGeometry(this.geometry,Rt),this.updateLayout()):this.updateFont()},remove:function(){this.geometry.dispose(),this.geometry=null,this.el.removeObject3D(this.attrName),this.material.dispose(),this.material=null,this.texture.dispose(),this.texture=null,this.shaderObject&&delete this.shaderObject},createOrUpdateMaterial:function(){var et,xt,Rt,Ge,nn,vn,_n,Yt=this.data,ve=this.material,xe=this.shaderData;if(Rt=Yt.shader,-1!==F.indexOf(Yt.font)||Yt.font.indexOf("-msdf.")>=0?Rt="msdf":Yt.font in k&&-1===F.indexOf(Yt.font)&&(Rt="sdf"),et=(this.shaderObject&&this.shaderObject.name)!==Rt,xe.alphaTest=Yt.alphaTest,xe.color=Yt.color,xe.map=this.texture,xe.opacity=Yt.opacity,xe.side=function(Ge){switch(Ge){case"back":return _.FrontSide;case"double":return _.DoubleSide;default:return _.BackSide}}(Yt.side),xe.transparent=Yt.transparent,xe.negate=Yt.negate,!et)return this.shaderObject.update(xe),ve.transparent=xe.transparent,void(ve.side=xe.side);Ge=this.el,nn=xe,(_n=new B[Rt].Shader).el=Ge,_n.init(nn),_n.update(nn),(vn=_n.material).transparent=nn.transparent,this.material=(xt={material:vn,shader:_n}).material,this.shaderObject=xt.shader,this.material.side=xe.side,this.mesh&&(this.mesh.material=this.material)},updateFont:function(){var et,xt=this.data,Rt=this.el,Yt=this.geometry,ve=this;xt.font||C("No font specified. Using the default font."),this.mesh&&(this.mesh.visible=!1),et=this.lookupFont(xt.font||G)||xt.font,pt.get(et,function(){return xe=et,Ge=xt.yOffset,new Promise(function(en,nn){$(xe,function(vn,_n){if(vn)return D("Error loading font",xe),void nn(vn);xe.indexOf("/Roboto-msdf.json")>=0&&(Ge=30),Ge&&_n.chars.map(function(nr){nr.yoffset+=Ge}),en(_n)})});var xe,Ge}).then(function(xe){var Ge,en,nn,vn,_n;if(1!==xe.pages.length)throw new Error("Currently only single-page bitmap fonts are supported.");vt[et]||(xe.widthFactor=vt[xe]=(nn=0,vn=0,_n=0,(en=xe).chars.map(function(nr){nn+=nr.xadvance,nr.id>=48&&nr.id<=57&&(_n++,vn+=nr.xadvance)}),_n?vn/_n:nn/en.chars.length)),ve.currentFont=xe,Ge=ve.getFontImageSrc(),pt.get(Ge,function(){return en=Ge,new Promise(function(nn,vn){(new _.ImageLoader).load(en,function(_n){nn(_n)},void 0,function(){D("Error loading font image",en),vn(null)})});var en}).then(function(en){var nn=ve.texture;nn&&(nn.image=en,nn.needsUpdate=!0,bt[xt.font]=nn,ve.texture=nn,ve.initMesh(),ve.currentFont=xe,ve.updateGeometry(Yt,xe),ve.updateLayout(),ve.mesh.visible=!0,Rt.emit("textfontset",{font:xt.font,fontObj:xe}))}).catch(function(en){D(en.message),D(en.stack)})}).catch(function(xe){D(xe.message),D(xe.stack)})},initMesh:function(){this.mesh||(this.mesh=new _.Mesh(this.geometry,this.material),this.el.setObject3D(this.attrName,this.mesh))},getFontImageSrc:function(){if(this.data.fontImage)return this.data.fontImage;var et=this.lookupFont(this.data.font||G)||this.data.font,xt=this.currentFont.pages[0];return xt.match(ft)&&0!==xt.indexOf("http")?et.replace(/(\.fnt)|(\.json)/,".png"):_.LoaderUtils.extractUrlBase(et)+xt},updateLayout:function(){var et,xt,Rt,Yt,ve,xe,Ge,en,nn,vn=this.el,_n=this.data,nr=this.geometry,hr=this.mesh;if(hr&&nr.layout){if(Rt=vn.getAttribute("geometry"),Yt=(xe=(Ge=_n.width||Rt&&Rt.width||1)/wt(_n.wrapPixels,_n.wrapCount,this.currentFont.widthFactor))*((ve=nr.layout).height+ve.descender),Rt&&"plane"===Rt.primitive&&(this.explicitGeoDimensionsChecked||(this.explicitGeoDimensionsChecked=!0,this.hasExplicitGeoWidth=!!Rt.width,this.hasExplicitGeoHeight=!!Rt.height),this.hasExplicitGeoWidth||vn.setAttribute("geometry","width",Ge),this.hasExplicitGeoHeight||vn.setAttribute("geometry","height",Yt)),"left"===(et="align"===_n.anchor?_n.align:_n.anchor))en=0;else if("right"===et)en=-1*ve.width;else{if("center"!==et)throw new TypeError("Invalid text.anchor property value",et);en=-1*ve.width/2}if("bottom"===(xt=_n.baseline))nn=0;else if("top"===xt)nn=-1*ve.height+ve.ascender;else{if("center"!==xt)throw new TypeError("Invalid text.baseline property value",xt);nn=-1*ve.height/2}hr.position.x=en*xe+_n.xOffset,hr.position.y=nn*xe,hr.position.z=_n.zOffset,hr.scale.set(xe,-1*xe,xe)}},lookupFont:function(et){return k[et]},updateGeometry:(Q={},X={},lt=/\\n/g,rt=/\\t/g,function(et,xt){var Rt=this.data;X.font=xt,X.lineHeight=Rt.lineHeight&&isFinite(Rt.lineHeight)?Rt.lineHeight:xt.common.lineHeight,X.text=Rt.value.toString().replace(lt,"\n").replace(rt,"\t"),X.width=wt(Rt.wrapPixels,Rt.wrapCount,xt.widthFactor),et.update(E.extend(Q,Rt,X))})})},4524:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7960),O=I(1343).DEFAULT_CAMERA_HEIGHT,N=I(9437),_=I(1343).DEFAULT_HANDEDNESS,E={touches:[]};ot.exports.Component=U("tracked-controls-webvr",{schema:{autoHide:{default:!0},controller:{default:0},id:{type:"string",default:""},hand:{type:"string",default:""},idPrefix:{type:"string",default:""},orientationOffset:{type:"vec3"},armModel:{default:!1},headElement:{type:"selector"}},init:function(){this.axis=this.el.components["tracked-controls"].axis=[0,0,0],this.buttonStates=this.el.components["tracked-controls"].buttonStates={},this.changedAxes=[],this.targetControllerNumber=this.data.controller,this.axisMoveEventDetail={axis:this.axis,changed:this.changedAxes},this.deltaControllerPosition=new N.Vector3,this.controllerQuaternion=new N.Quaternion,this.controllerEuler=new N.Euler,this.updateGamepad(),this.buttonEventDetails={}},tick:function(D,B){var C=this.el.getObject3D("mesh");C&&C.update&&C.update(B/1e3),this.updateGamepad(),this.updatePose(),this.updateButtons()},defaultUserHeight:function(){return O},getHeadElement:function(){return this.data.headElement||this.el.sceneEl.camera.el},updateGamepad:function(){var D=this.data,B=$.findMatchingControllerWebVR(this.system.controllers,D.id,D.idPrefix,D.hand,D.controller);this.controller=B,this.el.components["tracked-controls"].controller=B,this.data.autoHide&&(this.el.object3D.visible=!!this.controller)},applyArmModel:function(D){var B,C,M,k,F=this.controller,G=this.controllerEuler,Q=this.controllerQuaternion,X=this.deltaControllerPosition;C=this.getHeadElement().object3D,k=this.defaultUserHeight(),M=F.pose,B=(F?F.hand:void 0)||_,D.copy(C.position),X.set(.175*("left"===B?-1:"right"===B?1:0),-.3,-.03),X.multiplyScalar(k),X.applyAxisAngle(C.up,C.rotation.y),D.add(X),X.set(0,0,-.175),X.multiplyScalar(k),M.orientation?Q.fromArray(M.orientation):Q.copy(C.quaternion),G.setFromQuaternion(Q),G.set(G.x,G.y,0),X.applyEuler(G),D.add(X)},updatePose:function(){var D,B,C=this.controller,M=this.data,k=this.el.object3D,F=this.system.vrDisplay;C&&((D=C.pose).position?k.position.fromArray(D.position):M.armModel&&this.applyArmModel(k.position),D.orientation&&k.quaternion.fromArray(D.orientation),F&&D.position&&(B=this.el.sceneEl.renderer.xr.getStandingMatrix(),k.matrix.compose(k.position,k.quaternion,k.scale),k.matrix.multiplyMatrices(B,k.matrix),k.matrix.decompose(k.position,k.quaternion,k.scale)),k.rotateX(this.data.orientationOffset.x*N.MathUtils.DEG2RAD),k.rotateY(this.data.orientationOffset.y*N.MathUtils.DEG2RAD),k.rotateZ(this.data.orientationOffset.z*N.MathUtils.DEG2RAD))},updateButtons:function(){var B,C=this.controller;if(C){for(B=0;B<C.buttons.length;++B)this.buttonStates[B]||(this.buttonStates[B]={pressed:!1,touched:!1,value:0}),this.buttonEventDetails[B]||(this.buttonEventDetails[B]={id:B,state:this.buttonStates[B]}),this.handleButton(B,C.buttons[B]);this.handleAxes()}},handleButton:function(D,B){return!!(this.handlePress(D,B)|this.handleTouch(D,B)|this.handleValue(D,B))&&(this.el.emit("buttonchanged",this.buttonEventDetails[D],!1),!0)},handleAxes:function(){var D,B=!1,C=this.controller.axes,M=this.axis,k=this.changedAxes;for(this.changedAxes.splice(0,this.changedAxes.length),D=0;D<C.length;++D)k.push(M[D]!==C[D]),k[D]&&(B=!0);if(!B)return!1;for(this.axis.splice(0,this.axis.length),D=0;D<C.length;D++)this.axis.push(C[D]);return this.el.emit("axismove",this.axisMoveEventDetail,!1),!0},handlePress:function(D,B){var M=this.buttonStates[D];return B.pressed!==M.pressed&&(this.el.emit(B.pressed?"buttondown":"buttonup",this.buttonEventDetails[D],!1),M.pressed=B.pressed,!0)},handleTouch:function(D,B){var M=this.buttonStates[D];return B.touched!==M.touched&&(this.el.emit(B.touched?"touchstart":"touchend",this.buttonEventDetails[D],!1,E),M.touched=B.touched,!0)},handleValue:function(D,B){var C=this.buttonStates[D];return B.value!==C.value&&(C.value=B.value,!0)}})},6466:(ot,ht,I)=>{var U=I(7960),$=I(8190).registerComponent;ot.exports.Component=$("tracked-controls-webxr",{schema:{id:{type:"string",default:""},hand:{type:"string",default:""},handTrackingEnabled:{default:!1},index:{type:"int",default:-1},iterateControllerProfiles:{default:!1},space:{type:"string",oneOf:["targetRaySpace","gripSpace"],default:"gripSpace"}},init:function(){this.updateController=this.updateController.bind(this),this.buttonEventDetails={},this.buttonStates=this.el.components["tracked-controls"].buttonStates={},this.axis=this.el.components["tracked-controls"].axis=[0,0,0],this.changedAxes=[],this.axisMoveEventDetail={axis:this.axis,changed:this.changedAxes}},update:function(){this.updateController()},play:function(){var O=this.el.sceneEl;this.updateController(),O.addEventListener("controllersupdated",this.updateController)},pause:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.updateController)},isControllerPresent:function(O){return!(!this.controller||this.controller.gamepad||"none"!==O.inputSource.handedness&&O.inputSource.handedness!==this.data.hand)},updateController:function(){this.controller=U.findMatchingControllerWebXR(this.system.controllers,this.data.id,this.data.hand,this.data.index,this.data.iterateControllerProfiles,this.data.handTrackingEnabled),this.el.components["tracked-controls"].controller=this.controller,this.data.autoHide&&(this.el.object3D.visible=!!this.controller)},tick:function(){var O=this.el.sceneEl,N=this.controller;N&&O.frame&&this.system.referenceSpace&&(N.hand||(this.pose=O.frame.getPose(N[this.data.space],this.system.referenceSpace),this.updatePose(),this.updateButtons()))},updatePose:function(){var O=this.el.object3D,N=this.pose;N&&(O.matrix.elements=N.transform.matrix,O.matrix.decompose(O.position,O.rotation,O.scale))},updateButtons:function(){var N,_,E=this.controller;if(E&&E.gamepad){for(_=E.gamepad,N=0;N<_.buttons.length;++N)this.buttonStates[N]||(this.buttonStates[N]={pressed:!1,touched:!1,value:0}),this.buttonEventDetails[N]||(this.buttonEventDetails[N]={id:N,state:this.buttonStates[N]}),this.handleButton(N,_.buttons[N]);this.handleAxes()}},handleButton:function(O,N){return!!(this.handlePress(O,N)|this.handleTouch(O,N)|this.handleValue(O,N))&&(this.el.emit("buttonchanged",this.buttonEventDetails[O],!1),!0)},handleAxes:function(){var O,N=!1,_=this.controller.gamepad.axes,E=this.axis,D=this.changedAxes;for(this.changedAxes.splice(0,this.changedAxes.length),O=0;O<_.length;++O)D.push(E[O]!==_[O]),D[O]&&(N=!0);if(!N)return!1;for(this.axis.splice(0,this.axis.length),O=0;O<_.length;O++)this.axis.push(_[O]);return this.el.emit("axismove",this.axisMoveEventDetail,!1),!0},handlePress:function(O,N){var E=this.buttonStates[O];return N.pressed!==E.pressed&&(this.el.emit(N.pressed?"buttondown":"buttonup",this.buttonEventDetails[O],!1),E.pressed=N.pressed,!0)},handleTouch:function(O,N){var E=this.buttonStates[O];return N.touched!==E.touched&&(this.el.emit(N.touched?"touchstart":"touchend",this.buttonEventDetails[O],!1),E.touched=N.touched,!0)},handleValue:function(O,N){var _=this.buttonStates[O];return N.value!==_.value&&(_.value=N.value,!0)}})},6547:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("tracked-controls",{schema:{autoHide:{default:!0},controller:{default:-1},id:{type:"string",default:""},hand:{type:"string",default:""},idPrefix:{type:"string",default:""},handTrackingEnabled:{default:!1},orientationOffset:{type:"vec3"},armModel:{default:!1},headElement:{type:"selector"},iterateControllerProfiles:{default:!1},space:{type:"string",oneOf:["targetRaySpace","gripSpace"],default:"targetRaySpace"}},after:["tracked-controls-webvr","tracked-controls-webxr"],update:function(){var $=this.data,O=this.el;O.sceneEl.hasWebXR?O.setAttribute("tracked-controls-webxr",{id:$.id,hand:$.hand,index:$.controller,iterateControllerProfiles:$.iterateControllerProfiles,handTrackingEnabled:$.handTrackingEnabled,space:$.space}):O.setAttribute("tracked-controls-webvr",$)}})},7360:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437),O=I(7960),N=O.checkControllerPresentAndSetup,_=O.emitIfAxesChanged,E=O.onButtonEvent,D=I(1343).AFRAME_CDN_ROOT+"controllers/valve/index/valve-index-",B={left:D+"left.glb",right:D+"right.glb"},C="valve",M=I(7427).device.isWebXRAvailable,k={left:{_x:Math.PI/3,_y:0,_z:0,_order:"XYZ"},right:{_x:Math.PI/3,_y:0,_z:0,_order:"XYZ"}},F=M?k:{left:{_x:.692295102620542,_y:-.0627618864318427,_z:-.06265893149611756,_order:"XYZ"},right:{_x:.6484021229942998,_y:-.032563619881892894,_z:-.1327973171917482,_order:"XYZ"}},G=M?{left:{x:0,y:-.05,z:.06},right:{x:0,y:-.05,z:.06}}:{left:{x:-.00023692678902063457,y:.04724540367838371,z:-.061959880395271096},right:{x:.002471558599671131,y:.055765208987076195,z:-.061068168708348844}};ot.exports.Component=U("valve-index-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#FAFAFA"},buttonHighlightColor:{type:"color",default:"#22D1EE"},model:{default:!0},orientationOffset:{type:"vec3"}},after:["tracked-controls"],mapping:{axes:{trackpad:[0,1],thumbstick:[2,3]},buttons:["trigger","grip","trackpad","thumbstick","abutton"]},init:function(){var Q=this;this.controllerPresent=!1,this.lastControllerCheck=0,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(X){E(X.detail.id,"down",Q)},this.onButtonUp=function(X){E(X.detail.id,"up",Q)},this.onButtonTouchEnd=function(X){E(X.detail.id,"touchend",Q)},this.onButtonTouchStart=function(X){E(X.detail.id,"touchstart",Q)},this.previousButtonValues={},this.bindMethods()},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var Q=this.el;Q.addEventListener("buttonchanged",this.onButtonChanged),Q.addEventListener("buttondown",this.onButtonDown),Q.addEventListener("buttonup",this.onButtonUp),Q.addEventListener("touchend",this.onButtonTouchEnd),Q.addEventListener("touchstart",this.onButtonTouchStart),Q.addEventListener("model-loaded",this.onModelLoaded),Q.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var Q=this.el;Q.removeEventListener("buttonchanged",this.onButtonChanged),Q.removeEventListener("buttondown",this.onButtonDown),Q.removeEventListener("buttonup",this.onButtonUp),Q.removeEventListener("touchend",this.onButtonTouchEnd),Q.removeEventListener("touchstart",this.onButtonTouchStart),Q.removeEventListener("model-loaded",this.onModelLoaded),Q.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){var Q=this.data;N(this,C,{index:"right"===Q.hand?0:"left"===Q.hand?1:2,iterateControllerProfiles:!0,hand:Q.hand})},injectTrackedControls:function(){var X=this.data;this.el.setAttribute("tracked-controls",{idPrefix:C,controller:"right"===X.hand?1:"left"===X.hand?0:2,hand:X.hand,orientationOffset:X.orientationOffset}),this.loadModel()},loadModel:function(){var Q=this.data;Q.model&&this.el.setAttribute("gltf-model",""+B[Q.hand])},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(Q){var lt=this.mapping.buttons[Q.detail.id],rt=this.buttonMeshes;lt&&("trigger"===lt&&rt&&rt.trigger&&(rt.trigger.rotation.x=this.triggerOriginalRotationX-Q.detail.state.value*(Math.PI/40)),this.el.emit(lt+"changed",Q.detail.state))},onModelLoaded:function(Q){var X,lt=Q.detail.model,rt=this;Q.target===this.el&&this.data.model&&((X=this.buttonMeshes={}).grip={left:lt.getObjectByName("leftgrip"),right:lt.getObjectByName("rightgrip")},X.menu=lt.getObjectByName("menubutton"),X.system=lt.getObjectByName("systembutton"),X.trackpad=lt.getObjectByName("touchpad"),X.trigger=lt.getObjectByName("trigger"),this.triggerOriginalRotationX=X.trigger.rotation.x,Object.keys(X).forEach(function(pt){rt.setButtonColor(pt,rt.data.buttonColor)}),lt.position.copy(G[this.data.hand]),lt.rotation.copy(F[this.data.hand]),this.el.emit("controllermodelready",{name:"valve-index-controls",model:this.data.model,rayOrigin:new $.Vector3(0,0,0)}))},onAxisMoved:function(Q){_(this,this.mapping.axes,Q)},updateModel:function(Q,X){this.data.model&&(-1!==X.indexOf("touch")||this.setButtonColor(Q,"up"===X?this.data.buttonColor:this.data.buttonHighlightColor))},setButtonColor:function(Q,X){}})},5300:(ot,ht,I)=>{var U=I(8190).registerComponent;ot.exports.Component=U("visible",{schema:{default:!0},update:function(){this.el.object3D.visible=this.data}})},1507:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7960),O=$.checkControllerPresentAndSetup,N=$.emitIfAxesChanged,_=$.onButtonEvent,E=I(1343).AFRAME_CDN_ROOT,D=E+"controllers/vive/vr_controller_vive.obj",B=E+"controllers/vive/vr_controller_vive.mtl",C=I(7427).device.isWebXRAvailable,M=C?"htc-vive":"OpenVR ";ot.exports.Component=U("vive-controls",{schema:{hand:{default:"left"},buttonColor:{type:"color",default:"#FAFAFA"},buttonHighlightColor:{type:"color",default:"#22D1EE"},model:{default:!0},orientationOffset:{type:"vec3"}},after:["tracked-controls"],mapping:C?{axes:{touchpad:[0,1]},buttons:["trigger","grip","touchpad","none"]}:{axes:{trackpad:[0,1]},buttons:["trackpad","trigger","grip","menu","system"]},init:function(){var F=this;this.controllerPresent=!1,this.lastControllerCheck=0,this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(G){_(G.detail.id,"down",F)},this.onButtonUp=function(G){_(G.detail.id,"up",F)},this.onButtonTouchEnd=function(G){_(G.detail.id,"touchend",F)},this.onButtonTouchStart=function(G){_(G.detail.id,"touchstart",F)},this.previousButtonValues={},this.bindMethods()},update:function(){var F=this.data;this.controllerIndex="right"===F.hand?0:"left"===F.hand?1:2},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},addEventListeners:function(){var F=this.el;F.addEventListener("buttonchanged",this.onButtonChanged),F.addEventListener("buttondown",this.onButtonDown),F.addEventListener("buttonup",this.onButtonUp),F.addEventListener("touchend",this.onButtonTouchEnd),F.addEventListener("touchstart",this.onButtonTouchStart),F.addEventListener("model-loaded",this.onModelLoaded),F.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0},removeEventListeners:function(){var F=this.el;F.removeEventListener("buttonchanged",this.onButtonChanged),F.removeEventListener("buttondown",this.onButtonDown),F.removeEventListener("buttonup",this.onButtonUp),F.removeEventListener("touchend",this.onButtonTouchEnd),F.removeEventListener("touchstart",this.onButtonTouchStart),F.removeEventListener("model-loaded",this.onModelLoaded),F.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1},checkIfControllerPresent:function(){O(this,M,{index:this.controllerIndex,hand:this.data.hand})},injectTrackedControls:function(){var G=this.data;this.el.setAttribute("tracked-controls",{idPrefix:M,hand:G.hand,controller:this.controllerIndex,orientationOffset:G.orientationOffset}),this.data.model&&this.el.setAttribute("obj-model",{obj:D,mtl:B})},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onButtonChanged:function(F){var Q=this.mapping.buttons[F.detail.id],X=this.buttonMeshes;Q&&("trigger"===Q&&X&&X.trigger&&(X.trigger.rotation.x=-F.detail.state.value*(Math.PI/12)),this.el.emit(Q+"changed",F.detail.state))},onModelLoaded:function(F){var G,Q=F.detail.model,X=this;F.target===this.el&&this.data.model&&((G=this.buttonMeshes={}).grip={left:Q.getObjectByName("leftgrip"),right:Q.getObjectByName("rightgrip")},G.menu=Q.getObjectByName("menubutton"),G.system=Q.getObjectByName("systembutton"),G.trackpad=Q.getObjectByName("touchpad"),G.touchpad=Q.getObjectByName("touchpad"),G.trigger=Q.getObjectByName("trigger"),Object.keys(G).forEach(function(lt){X.setButtonColor(lt,X.data.buttonColor)}),Q.position.set(0,-.015,.04))},onAxisMoved:function(F){N(this,this.mapping.axes,F)},updateModel:function(F,G){this.data.model&&(-1!==G.indexOf("touch")||this.setButtonColor(F,"up"===G?this.data.buttonColor:this.data.buttonHighlightColor))},setButtonColor:function(F,G){var Q=this.buttonMeshes;if(Q)return"grip"===F?(Q.grip.left.material.color.set(G),void Q.grip.right.material.color.set(G)):void Q[F].material.color.set(G)}})},4592:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(7960),O=$.checkControllerPresentAndSetup,N=$.emitIfAxesChanged,_=$.onButtonEvent,E=I(1343).AFRAME_CDN_ROOT+"controllers/vive/focus-controller/focus-controller.gltf",D=I(7427).device.isWebXRAvailable,B=D?"htc-vive-focus":"HTC Vive Focus ";ot.exports.Component=U("vive-focus-controls",{schema:{hand:{default:""},buttonTouchedColor:{type:"color",default:"#BBBBBB"},buttonHighlightColor:{type:"color",default:"#7A7A7A"},model:{default:!0},orientationOffset:{type:"vec3"},armModel:{default:!0}},after:["tracked-controls"],mapping:D?{axes:{touchpad:[0,1]},buttons:["trigger","none","touchpad","none","menu"]}:{axes:{trackpad:[0,1]},buttons:["trackpad","trigger"]},bindMethods:function(){this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.removeControllersUpdateListener=this.removeControllersUpdateListener.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var M=this;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(k){_(k.detail.id,"down",M)},this.onButtonUp=function(k){_(k.detail.id,"up",M)},this.onButtonTouchStart=function(k){_(k.detail.id,"touchstart",M)},this.onButtonTouchEnd=function(k){_(k.detail.id,"touchend",M)},this.controllerPresent=!1,this.lastControllerCheck=0,this.bindMethods()},addEventListeners:function(){var M=this.el;M.addEventListener("buttonchanged",this.onButtonChanged),M.addEventListener("buttondown",this.onButtonDown),M.addEventListener("buttonup",this.onButtonUp),M.addEventListener("touchstart",this.onButtonTouchStart),M.addEventListener("touchend",this.onButtonTouchEnd),M.addEventListener("model-loaded",this.onModelLoaded),M.addEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!0,this.addControllersUpdateListener()},removeEventListeners:function(){var M=this.el;M.removeEventListener("buttonchanged",this.onButtonChanged),M.removeEventListener("buttondown",this.onButtonDown),M.removeEventListener("buttonup",this.onButtonUp),M.removeEventListener("touchstart",this.onButtonTouchStart),M.removeEventListener("touchend",this.onButtonTouchEnd),M.removeEventListener("model-loaded",this.onModelLoaded),M.removeEventListener("axismove",this.onAxisMoved),this.controllerEventsActive=!1,this.removeControllersUpdateListener()},checkIfControllerPresent:function(){O(this,B,this.data.hand?{hand:this.data.hand}:{})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},injectTrackedControls:function(){var k=this.data;this.el.setAttribute("tracked-controls",{armModel:k.armModel,idPrefix:B,orientationOffset:k.orientationOffset}),this.data.model&&this.el.setAttribute("gltf-model",E)},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelLoaded:function(M){var k,F=M.detail.model;M.target===this.el&&this.data.model&&((k=this.buttonMeshes={}).trigger=F.getObjectByName("BumperKey"),k.triggerPressed=F.getObjectByName("BumperKey_Press"),k.triggerPressed&&(k.triggerPressed.visible=!1),k.trackpad=F.getObjectByName("TouchPad"),k.trackpadPressed=F.getObjectByName("TouchPad_Press"),k.trackpadPressed&&(k.trackpadPressed.visible=!1))},onButtonChanged:function(M){var k=this.mapping.buttons[M.detail.id];k&&this.el.emit(k+"changed",M.detail.state)},onAxisMoved:function(M){N(this,this.mapping.axes,M)},updateModel:function(M,k){this.data.model&&this.updateButtonModel(M,k)},updateButtonModel:function(M,k){var F=this.buttonMeshes,G=M+"Pressed";if(F&&F[M]&&F[G]){var Q;switch(k){case"down":Q=this.data.buttonHighlightColor;break;case"touchstart":Q=this.data.buttonTouchedColor}Q&&F[G].material.color.set(Q),F[G].visible=!!Q,F[M].visible=!Q}}})},6458:(ot,ht,I)=>{var U,$,O=I(1343).keyboardevent.KEYCODE_TO_CODE,N=I(8190).registerComponent,_=I(9437),E=I(7427).shouldCaptureKeyEvent,D=1e-5,B=["KeyW","KeyA","KeyS","KeyD","ArrowUp","ArrowLeft","ArrowRight","ArrowDown"];ot.exports.Component=N("wasd-controls",{schema:{acceleration:{default:65},adAxis:{default:"x",oneOf:["x","y","z"]},adEnabled:{default:!0},adInverted:{default:!1},enabled:{default:!0},fly:{default:!1},wsAxis:{default:"z",oneOf:["x","y","z"]},wsEnabled:{default:!0},wsInverted:{default:!1}},after:["look-controls"],init:function(){this.keys={},this.easing=1.1,this.velocity=new _.Vector3,this.onBlur=this.onBlur.bind(this),this.onContextMenu=this.onContextMenu.bind(this),this.onFocus=this.onFocus.bind(this),this.onKeyDown=this.onKeyDown.bind(this),this.onKeyUp=this.onKeyUp.bind(this),this.onVisibilityChange=this.onVisibilityChange.bind(this),this.attachVisibilityEventListeners()},tick:function(C,M){var k=this.data,F=this.el,G=this.velocity;(G[k.adAxis]||G[k.wsAxis]||!function(Q){var X;for(X in Q)return!1;return!0}(this.keys))&&(this.updateVelocity(M/=1e3),(G[k.adAxis]||G[k.wsAxis])&&F.object3D.position.add(this.getMovementVector(M)))},update:function(C){C.adAxis!==this.data.adAxis&&(this.velocity[C.adAxis]=0),C.wsAxis!==this.data.wsAxis&&(this.velocity[C.wsAxis]=0)},remove:function(){this.removeKeyEventListeners(),this.removeVisibilityEventListeners()},play:function(){this.attachKeyEventListeners()},pause:function(){this.keys={},this.removeKeyEventListeners()},updateVelocity:function(C){var M,k,F,G,Q,X=this.data,lt=this.keys,rt=this.velocity;if(k=X.adAxis,G=X.wsAxis,C>.2)return rt[k]=0,void(rt[G]=0);var pt=Math.pow(1/this.easing,60*C);0!==rt[k]&&(rt[k]=rt[k]*pt),0!==rt[G]&&(rt[G]=rt[G]*pt),Math.abs(rt[k])<D&&(rt[k]=0),Math.abs(rt[G])<D&&(rt[G]=0),X.enabled&&(M=X.acceleration,X.adEnabled&&(F=X.adInverted?-1:1,(lt.KeyA||lt.ArrowLeft)&&(rt[k]-=F*M*C),(lt.KeyD||lt.ArrowRight)&&(rt[k]+=F*M*C)),X.wsEnabled&&(Q=X.wsInverted?-1:1,(lt.KeyW||lt.ArrowUp)&&(rt[G]-=Q*M*C),(lt.KeyS||lt.ArrowDown)&&(rt[G]+=Q*M*C)))},getMovementVector:(U=new _.Vector3(0,0,0),$=new _.Euler(0,0,0,"YXZ"),function(C){var k=this.el.getAttribute("rotation");return U.copy(this.velocity),U.multiplyScalar(C),k&&($.set(_.MathUtils.degToRad(this.data.fly?k.x:0),_.MathUtils.degToRad(k.y),0),U.applyEuler($)),U}),attachVisibilityEventListeners:function(){window.oncontextmenu=this.onContextMenu,window.addEventListener("blur",this.onBlur),window.addEventListener("focus",this.onFocus),document.addEventListener("visibilitychange",this.onVisibilityChange)},removeVisibilityEventListeners:function(){window.removeEventListener("blur",this.onBlur),window.removeEventListener("focus",this.onFocus),document.removeEventListener("visibilitychange",this.onVisibilityChange)},attachKeyEventListeners:function(){window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp)},removeKeyEventListeners:function(){window.removeEventListener("keydown",this.onKeyDown),window.removeEventListener("keyup",this.onKeyUp)},onContextMenu:function(){for(var C=Object.keys(this.keys),M=0;M<C.length;M++)delete this.keys[C[M]]},onBlur:function(){this.pause()},onFocus:function(){this.play()},onVisibilityChange:function(){document.hidden?this.onBlur():this.onFocus()},onKeyDown:function(C){var M;E(C)&&-1!==B.indexOf(M=C.code||O[C.keyCode])&&(this.keys[M]=!0)},onKeyUp:function(C){delete this.keys[C.code||O[C.keyCode]]}})},221:(ot,ht,I)=>{var U,rt,$=I(8190).registerComponent,O=I(7960),N=O.checkControllerPresentAndSetup,_=O.emitIfAxesChanged,E=O.onButtonEvent,D=I(7427),B=D.debug("components:windows-motion-controls:debug"),C=D.debug("components:windows-motion-controls:warn"),M=I(1343).DEFAULT_HANDEDNESS,k=I(1343).AFRAME_CDN_ROOT+"controllers/microsoft/",F={left:"left.glb",right:"right.glb",default:"universal.glb"},G=I(7427).device.isWebXRAvailable,Q=/([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/,X=G?"windows-mixed-reality":"Spatial Controller (Spatial Interaction Source) ";ot.exports.Component=$("windows-motion-controls",{schema:{hand:{default:M},pair:{default:0},model:{default:!0},hideDisconnected:{default:!0}},after:["tracked-controls"],mapping:G?{axes:{touchpad:[0,1],thumbstick:[2,3]},buttons:["trigger","squeeze","touchpad","thumbstick","menu"],axisMeshNames:["TOUCHPAD_TOUCH_X","TOUCHPAD_TOUCH_X","THUMBSTICK_X","THUMBSTICK_Y"],buttonMeshNames:{trigger:"SELECT",menu:"MENU",squeeze:"GRASP",thumbstick:"THUMBSTICK_PRESS",touchpad:"TOUCHPAD_PRESS"},pointingPoseMeshName:"POINTING_POSE"}:{axes:{thumbstick:[0,1],trackpad:[2,3]},buttons:["thumbstick","trigger","grip","menu","trackpad"],axisMeshNames:["THUMBSTICK_X","THUMBSTICK_Y","TOUCHPAD_TOUCH_X","TOUCHPAD_TOUCH_Y"],buttonMeshNames:{trigger:"SELECT",menu:"MENU",grip:"GRASP",thumbstick:"THUMBSTICK_PRESS",trackpad:"TOUCHPAD_PRESS"},pointingPoseMeshName:"POINTING_POSE"},bindMethods:function(){this.onModelError=this.onModelError.bind(this),this.onModelLoaded=this.onModelLoaded.bind(this),this.onControllersUpdate=this.onControllersUpdate.bind(this),this.checkIfControllerPresent=this.checkIfControllerPresent.bind(this),this.onAxisMoved=this.onAxisMoved.bind(this)},init:function(){var rt=this,pt=this.el;this.onButtonChanged=this.onButtonChanged.bind(this),this.onButtonDown=function(vt){E(vt.detail.id,"down",rt)},this.onButtonUp=function(vt){E(vt.detail.id,"up",rt)},this.onButtonTouchStart=function(vt){E(vt.detail.id,"touchstart",rt)},this.onButtonTouchEnd=function(vt){E(vt.detail.id,"touchend",rt)},this.onControllerConnected=function(){rt.setModelVisibility(!0)},this.onControllerDisconnected=function(){rt.setModelVisibility(!1)},this.controllerPresent=!1,this.lastControllerCheck=0,this.previousButtonValues={},this.bindMethods(),this.loadedMeshInfo={buttonMeshes:null,axisMeshes:null},this.rayOrigin={origin:new THREE.Vector3,direction:new THREE.Vector3(0,0,-1),createdFromMesh:!1},pt.addEventListener("controllerconnected",this.onControllerConnected),pt.addEventListener("controllerdisconnected",this.onControllerDisconnected)},addEventListeners:function(){var rt=this.el;rt.addEventListener("buttonchanged",this.onButtonChanged),rt.addEventListener("buttondown",this.onButtonDown),rt.addEventListener("buttonup",this.onButtonUp),rt.addEventListener("touchstart",this.onButtonTouchStart),rt.addEventListener("touchend",this.onButtonTouchEnd),rt.addEventListener("axismove",this.onAxisMoved),rt.addEventListener("model-error",this.onModelError),rt.addEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!0},removeEventListeners:function(){var rt=this.el;rt.removeEventListener("buttonchanged",this.onButtonChanged),rt.removeEventListener("buttondown",this.onButtonDown),rt.removeEventListener("buttonup",this.onButtonUp),rt.removeEventListener("touchstart",this.onButtonTouchStart),rt.removeEventListener("touchend",this.onButtonTouchEnd),rt.removeEventListener("axismove",this.onAxisMoved),rt.removeEventListener("model-error",this.onModelError),rt.removeEventListener("model-loaded",this.onModelLoaded),this.controllerEventsActive=!1},checkIfControllerPresent:function(){N(this,X,{hand:this.data.hand,index:this.data.pair,iterateControllerProfiles:!0})},play:function(){this.checkIfControllerPresent(),this.addControllersUpdateListener()},pause:function(){this.removeEventListeners(),this.removeControllersUpdateListener()},updateControllerModel:function(){if(this.data.model&&!this.rayOrigin.createdFromMesh){var rt=this.createControllerModelUrl();this.loadModel(rt)}else this.modelReady()},createControllerModelUrl:function(rt){var pt=this.el.components["tracked-controls"],vt=pt?pt.controller:null,bt="default",ft=this.data.hand;if(vt&&!window.hasNativeWebXRImplementation&&(ft=vt.hand,!rt)){var wt=vt.id.match(Q);bt=wt&&wt[0]||bt}return k+bt+"/"+(F[ft]||F.default)},injectTrackedControls:function(){var rt=this.data;this.el.setAttribute("tracked-controls",{idPrefix:X,controller:rt.pair,hand:rt.hand,armModel:!1}),this.updateControllerModel()},addControllersUpdateListener:function(){this.el.sceneEl.addEventListener("controllersupdated",this.onControllersUpdate,!1)},removeControllersUpdateListener:function(){this.el.sceneEl.removeEventListener("controllersupdated",this.onControllersUpdate,!1)},onControllersUpdate:function(){this.checkIfControllerPresent()},onModelError:function(rt){var pt=this.createControllerModelUrl(!0);rt.detail.src!==pt?(C("Failed to load controller model for device, attempting to load default."),this.loadModel(pt)):C("Failed to load default controller model.")},loadModel:function(rt){this.el.setAttribute("gltf-model","url("+rt+")")},onModelLoaded:function(rt){var pt,vt,bt,ft,wt=this.controllerModel=rt.detail.model,et=this.loadedMeshInfo;if(rt.target===this.el){if(B("Processing model"),et.buttonMeshes={},et.axisMeshes={},wt){for(pt=0;pt<this.mapping.buttons.length;pt++)(vt=this.mapping.buttonMeshNames[this.mapping.buttons[pt]])?(bt=wt.getObjectByName(vt))?(ft={index:pt,value:xt(bt,"VALUE"),pressed:xt(bt,"PRESSED"),unpressed:xt(bt,"UNPRESSED")}).value&&ft.pressed&&ft.unpressed?et.buttonMeshes[this.mapping.buttons[pt]]=ft:C("Missing button submesh under mesh with name: "+vt+"(VALUE: "+!!ft.value+", PRESSED: "+!!ft.pressed+", UNPRESSED:"+!!ft.unpressed+")"):C("Missing button mesh with name: "+vt):B("Skipping unknown button at index: "+pt+" with mapped name: "+this.mapping.buttons[pt]);for(pt=0;pt<this.mapping.axisMeshNames.length;pt++)(vt=this.mapping.axisMeshNames[pt])?(bt=wt.getObjectByName(vt))?(ft={index:pt,value:xt(bt,"VALUE"),min:xt(bt,"MIN"),max:xt(bt,"MAX")}).value&&ft.min&&ft.max?et.axisMeshes[pt]=ft:C("Missing axis submesh under mesh with name: "+vt+"(VALUE: "+!!ft.value+", MIN: "+!!ft.min+", MAX:"+!!ft.max+")"):C("Missing axis mesh with name: "+vt):B("Skipping unknown axis at index: "+pt);this.calculateRayOriginFromMesh(wt),this.setModelVisibility()}B("Model load complete.")}function xt(Rt,Yt){for(var ve=0,xe=Rt.children.length;ve<xe;ve++){var Ge=Rt.children[ve];if(Ge&&Ge.name===Yt)return Ge}}},calculateRayOriginFromMesh:(U=new THREE.Quaternion,function(rt){var pt;if(this.rayOrigin.origin.set(0,0,0),this.rayOrigin.direction.set(0,0,-1),this.rayOrigin.createdFromMesh=!0,pt=rt.getObjectByName(this.mapping.pointingPoseMeshName)){var vt=rt.parent;vt&&(rt.parent=null,rt.updateMatrixWorld(!0),rt.parent=vt),pt.getWorldPosition(this.rayOrigin.origin),pt.getWorldQuaternion(U),this.rayOrigin.direction.applyQuaternion(U),vt&&rt.updateMatrixWorld(!0)}else B("Mesh does not contain pointing origin data, defaulting to none.");this.modelReady()}),lerpAxisTransform:(rt=new THREE.Quaternion,function(pt,vt){var bt=this.loadedMeshInfo.axisMeshes[pt];if(bt){var ft=bt.min,wt=bt.max,et=bt.value,xt=.5*vt+.5;et.setRotationFromQuaternion(rt.copy(ft.quaternion).slerp(wt.quaternion,xt)),et.position.lerpVectors(ft.position,wt.position,xt)}}),lerpButtonTransform:function(){var rt=new THREE.Quaternion;return function(pt,vt){var bt=this.loadedMeshInfo.buttonMeshes[pt];if(bt){var ft=bt.unpressed,wt=bt.pressed,et=bt.value;et.setRotationFromQuaternion(rt.copy(ft.quaternion).slerp(wt.quaternion,vt)),et.position.lerpVectors(ft.position,wt.position,vt)}}}(),modelReady:function(){this.el.emit("controllermodelready",{name:"windows-motion-controls",model:this.data.model,rayOrigin:this.rayOrigin})},onButtonChanged:function(rt){var pt=this.mapping.buttons[rt.detail.id];pt&&(this.loadedMeshInfo&&this.loadedMeshInfo.buttonMeshes&&this.lerpButtonTransform(pt,rt.detail.state.value),this.el.emit(pt+"changed",rt.detail.state))},onAxisMoved:function(rt){var pt=this.mapping.axisMeshNames.length;if(this.loadedMeshInfo&&this.loadedMeshInfo.axisMeshes)for(var vt=0;vt<pt;vt++)this.lerpAxisTransform(vt,rt.detail.axis[vt]||0);_(this,this.mapping.axes,rt)},setModelVisibility:function(rt){var pt=this.el.getObject3D("mesh");this.controllerPresent&&(this.modelVisible=rt=void 0!==rt?rt:this.modelVisible,pt&&(pt.visible=rt))}})},1343:(ot,ht,I)=>{ot.exports={AFRAME_CDN_ROOT:window.AFRAME_CDN_ROOT||"https://cdn.aframe.io/",AFRAME_INJECTED:"aframe-injected",DEFAULT_CAMERA_HEIGHT:1.6,DEFAULT_HANDEDNESS:"right",keyboardevent:I(5440)}},5440:ot=>{ot.exports={KEYCODE_TO_CODE:{38:"ArrowUp",37:"ArrowLeft",40:"ArrowDown",39:"ArrowRight",87:"KeyW",65:"KeyA",83:"KeyS",68:"KeyD"}}},842:(ot,ht,I)=>{var U=I(2203).a,$=I(8940),O=I(9437),N=new O.FileLoader,_=$("core:a-assets:warn");function E(M){if(M.hasAttribute("autoplay")||"auto"===M.getAttribute("preload"))return new Promise(function(k,F){if(4===M.readyState)return k();if(M.error)return F();function G(){for(var Q=0,X=0;X<M.buffered.length;X++)Q+=M.buffered.end(X)-M.buffered.start(X);Q>=M.duration&&("VIDEO"===M.tagName&&O.Cache.add(M.getAttribute("src"),M),k())}M.addEventListener("loadeddata",G,!1),M.addEventListener("progress",G,!1),M.addEventListener("error",F,!1)})}function D(M){var F,G,Q,X,k=(F=M).hasAttribute("crossorigin")||null!==(G=F.getAttribute("src"))&&(-1===G.indexOf("://")||(X=(Q=G).indexOf("://")>-1?Q.split("/")[2]:Q.split("/")[0]).substring(0,X.indexOf(":"))===window.location.host)?F:(_('Cross-origin element (e.g., <img>) was requested without `crossorigin` set. A-Frame will re-request the asset with `crossorigin` attribute set. Please set `crossorigin` on the element (e.g., <img crossorigin="anonymous">)',G),F.crossOrigin="anonymous",F.cloneNode(!0));return k.tagName&&"video"===k.tagName.toLowerCase()&&(k.setAttribute("playsinline",""),k.setAttribute("webkit-playsinline","")),k!==M&&(M.parentNode.appendChild(k),M.parentNode.removeChild(M)),k}function B(M){var k=C(M),F=k.lastIndexOf(".");return F>=0&&".glb"===k.slice(F,M.search(/\?|#|$/))?"arraybuffer":"text"}function C(M){var k=document.createElement("a");k.href=M;var F=k.search.replace(/^\?/,""),G=M.replace(F,"").replace("?","");return G.substring(G.lastIndexOf("/")+1)}customElements.define("a-assets",class extends U{constructor(){super(),this.isAssets=!0,this.fileLoader=N,this.timeout=null}doConnectedCallback(){var M,k,F,G,Q,X,lt=this,rt=[];if(super.doConnectedCallback(),!this.parentNode.isScene)throw new Error("<a-assets> must be a child of a <a-scene>.");for(Q=this.querySelectorAll("img"),M=0;M<Q.length;M++)G=D(Q[M]),rt.push(new Promise(function(pt,vt){O.Cache.add(Q[M].getAttribute("src"),G),G.complete?pt():(G.onload=pt,G.onerror=vt)}));for(F=this.querySelectorAll("audio, video"),M=0;M<F.length;M++)(k=D(F[M])).src||k.srcObject||_("Audio/video asset has neither `src` nor `srcObject` attributes."),rt.push(E(k));this.getChildren().forEach(function(pt){pt.isAssetItem&&pt.hasAttribute("src")&&rt.push(new Promise(function(vt,bt){if(pt.hasLoaded)return vt();pt.addEventListener("loaded",vt),pt.addEventListener("error",bt)}))}),Promise.allSettled(rt).then(function(){null!==lt.timeout&&lt.load()}),X=parseInt(this.getAttribute("timeout"),10)||3e3,this.timeout=setTimeout(function(){lt.hasLoaded||(_("Asset loading timed out in",X,"ms"),lt.timeout=null,lt.emit("timeout"),lt.load())},X)}disconnectedCallback(){super.disconnectedCallback(),this.timeout&&clearTimeout(this.timeout)}load(){super.load.call(this,null,function(){return!1})}}),customElements.define("a-asset-item",class extends U{constructor(){super(),this.data=null,this.isAssetItem=!0}connectedCallback(){var M=this,k=this.getAttribute("src");N.setResponseType(this.getAttribute("response-type")||B(k)),N.load(k,function(F){M.data=F,U.prototype.load.call(M)},function(F){M.emit("progress",{loadedBytes:F.loaded,totalBytes:F.total,xhr:F})},function(F){M.emit("error",{xhr:F})})}}),ot.exports.inferResponseType=B,ot.exports.getFileNameFromURL=C},6178:(ot,ht,I)=>{var U=I(8940)("core:cubemap:warn");class $ extends HTMLElement{constructor(N){return super(N)}onReadyStateChange(){"complete"===document.readyState&&this.doConnectedCallback()}connectedCallback(){"complete"===document.readyState?$.prototype.doConnectedCallback.call(this):document.addEventListener("readystatechange",this.onReadyStateChange.bind(this))}doConnectedCallback(){this.srcs=this.validate()}validate(){var N,_=this.querySelectorAll("[src]"),E=[];if(6===_.length){for(N=0;N<_.length;N++)E.push("IMG"===_[N].tagName?_[N]:_[N].getAttribute("src"));return E}U("<a-cubemap> did not contain exactly six elements each with a `src` attribute.")}}customElements.define("a-cubemap",$)},4056:(ot,ht,I)=>{var U=I(2203).a,$=I(8190).components,O=I(9437),N=I(7427),_=N.debug("core:a-entity:debug"),E=N.debug("core:a-entity:warn"),D="__",B=["position","rotation","scale","visible"],C={once:!0};class M extends U{constructor(){super(),this.components={},this.initializingComponents={},this.componentsToUpdate={},this.isEntity=!0,this.isPlaying=!1,this.object3D=new O.Group,this.object3D.rotation.order="YXZ",this.object3D.el=this,this.object3DMap={},this.parentEl=null,this.rotationObj={},this.states=[]}attributeChangedCallback(Q,X,lt){var rt=this.components[Q];super.attributeChangedCallback(),rt&&rt.justInitialized&&""===lt?delete rt.justInitialized:(rt||null!==lt)&&this.setEntityAttribute(Q,X,lt)}doConnectedCallback(){var Q,X,lt=this;super.doConnectedCallback(),X=this.sceneEl,this.addToParent(),this.isScene||(X?!(Q=X.querySelector("a-assets"))||Q.hasLoaded?this.load():Q.addEventListener("loaded",function(){lt.load()}):this.load())}disconnectedCallback(){var Q;if(this.parentEl){for(Q in this.components)this.removeComponent(Q,!1);this.isScene||(this.removeFromParent(),super.disconnectedCallback(),this.object3D.el=null)}}getObject3D(Q){return this.object3DMap[Q]}setObject3D(Q,X){var lt,rt=this;if(!(X instanceof O.Object3D))throw new Error("`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D.");(lt=this.getObject3D(Q))&&this.object3D.remove(lt),X.el=this,X.children.length&&X.traverse(function(pt){pt.el=rt}),this.object3D.add(X),this.object3DMap[Q]=X,this.emit("object3dset",{object:X,type:Q})}removeObject3D(Q){var X=this.getObject3D(Q);X?(this.object3D.remove(X),delete this.object3DMap[Q],this.emit("object3dremove",{type:Q})):E("Tried to remove `Object3D` of type:",Q,"which was not defined.")}getOrCreateObject3D(Q,X){var lt=this.getObject3D(Q);return!lt&&X&&(lt=new X,this.setObject3D(Q,lt)),E("`getOrCreateObject3D` has been deprecated. Use `setObject3D()` and `object3dset` event instead."),lt}add(Q){if(!Q.object3D)throw new Error("Trying to add an element that doesn't have an `object3D`");this.object3D.add(Q.object3D),this.emit("child-attached",{el:Q})}addToParent(){var Q=this.parentEl=this.parentNode;Q&&Q.add&&!this.attachedToParent&&(Q.add(this),this.attachedToParent=!0)}removeFromParent(){var Q=this.parentEl;this.parentEl.remove(this),this.attachedToParent=!1,this.parentEl=null,Q.emit("child-detached",{el:this})}load(){var Q=this;!this.hasLoaded&&this.parentEl&&super.load.call(this,function(){Q.parentEl&&(Q.updateComponents(),(Q.isScene||Q.parentEl.isPlaying)&&Q.play())})}remove(Q){Q?this.object3D.remove(Q.object3D):this.parentNode.removeChild(this)}getChildEntities(){for(var Q=this.children,X=[],lt=0;lt<Q.length;lt++){var rt=Q[lt];rt instanceof M&&X.push(rt)}return X}initComponent(Q,X,lt){var rt,pt,vt,bt;bt=(vt=N.split(Q,D))[0],pt=vt.length>2?vt.slice(1).join("__"):vt[1],$[bt]&&(k(this,Q)||void 0!==X||lt)&&(Q in this.components||(this.initComponentDependencies(bt),rt=new $[bt].Component(this,X,pt),this.isPlaying&&rt.play(),this.hasAttribute(Q)||(rt.justInitialized=!0,window.HTMLElement.prototype.setAttribute.call(this,Q,"")),_("Component initialized: %s",Q)))}initComponentDependencies(Q){var X,lt;if($[Q]&&(X=$[Q].dependencies))for(lt=0;lt<X.length;lt++)this.initComponent(X[lt],window.HTMLElement.prototype.getAttribute.call(this,X[lt])||void 0,!0)}removeComponent(Q,X){var lt;(lt=this.components[Q])&&(lt.initialized?(lt.pause(),lt.remove(),X&&(lt.destroy(),delete this.components[Q],this.hasAttribute(Q)&&window.HTMLElement.prototype.removeAttribute.call(this,Q)),this.emit("componentremoved",lt.evtDetail,!1)):this.addEventListener("componentinitialized",function rt(pt){pt.detail.name===Q&&(this.removeComponent(Q,X),this.removeEventListener("componentinitialized",rt))}))}updateComponents(){var Q,X,lt,rt,pt,vt,bt=this.componentsToUpdate;if(this.hasLoaded||this.isLoading){for(lt=0;lt<this.mixinEls.length;lt++)for(rt in this.mixinEls[lt].componentCache)F(rt)&&(bt[rt]=!0);if(this.getExtraComponents)for(rt in X=this.getExtraComponents())F(rt)&&(bt[rt]=!0);for(lt=0;lt<this.attributes.length;++lt)-1===B.indexOf(rt=this.attributes[lt].name)&&F(rt)&&(bt[rt]=!0);for(lt=0;lt<B.length;lt++)this.hasAttribute(rt=B[lt])&&this.updateComponent(rt,this.getDOMAttribute(rt));for(rt in bt)pt=this.getDOMAttribute(rt),Q=(vt=X&&X[rt])?vt.constructor===Object?N.extend(vt,N.styleParser.parse(pt||{})):pt||vt:pt,this.updateComponent(rt,Q),delete bt[rt]}}updateComponent(Q,X,lt){var rt=this.components[Q];if(rt)return null!==X||k(this,Q)?void rt.updateProperties(X,lt):void this.removeComponent(Q,!0);this.initComponent(Q,X,!1)}removeAttribute(Q,X){var lt=this.components[Q];lt&&void 0===X&&this.removeComponent(Q,!0),lt&&void 0!==X?lt.resetProperty(X):("mixin"===Q&&this.mixinUpdate(""),window.HTMLElement.prototype.removeAttribute.call(this,Q))}play(){var Q,X,lt;if(!this.isPlaying&&(this.hasLoaded||this.isLoading)){for(lt in this.isPlaying=!0,this.components)this.components[lt].play();for(Q=this.getChildEntities(),X=0;X<Q.length;X++)Q[X].play();this.emit("play")}}pause(){var Q,X,lt;if(this.isPlaying){for(lt in this.isPlaying=!1,this.components)this.components[lt].pause();for(Q=this.getChildEntities(),X=0;X<Q.length;X++)Q[X].pause();this.emit("pause")}}setEntityAttribute(Q,X,lt){if($[Q]||this.components[Q])this.updateComponent(Q,lt);else if("mixin"===Q){if(lt===this.computedMixinStr)return;this.mixinUpdate(lt,X)}}mixinUpdate(Q,X,lt){var rt,pt,vt,bt,ft=M.componentsUpdated,wt=this;if(lt||(X=X||this.getAttribute("mixin")),this.hasLoaded){for(vt=this.updateMixins(Q,X),ft.length=0,bt=0;bt<this.mixinEls.length;bt++)for(rt in this.mixinEls[bt].componentCache)-1===ft.indexOf(rt)&&(this.components[rt]?this.components[rt].handleMixinUpdate():this.initComponent(rt,null),ft.push(rt));for(bt=0;bt<vt.oldMixinIds.length;bt++)if(pt=document.getElementById(vt.oldMixinIds[bt]))for(rt in pt.componentCache)-1===ft.indexOf(rt)&&this.components[rt]&&(this.getDOMAttribute(rt)?this.components[rt].handleMixinUpdate():this.removeComponent(rt,!0))}else this.addEventListener("loaded-private",function(){wt.mixinUpdate(Q,X,!0)},C)}setAttribute(Q,X,lt){var rt,pt,vt,bt,ft,wt=M.singlePropUpdate;if(vt=(bt=Q.indexOf(D))>0?Q.substring(0,bt):Q,!$[vt])return"mixin"===Q&&this.mixinUpdate(X),void super.setAttribute.call(this,Q,X);if(!this.components[Q]&&this.hasAttribute(Q)&&this.updateComponent(Q,window.HTMLElement.prototype.getAttribute.call(this,Q)),void 0!==lt&&"string"==typeof X&&X.length>0&&"string"==typeof N.styleParser.parse(X)){for(ft in wt)delete wt[ft];(rt=wt)[X]=lt,pt=!1}else rt=X,pt=!0===lt;this.updateComponent(Q,rt,pt),this.sceneEl&&this.sceneEl.getAttribute("debug")&&this.components[Q].flushToDOM()}flushToDOM(Q){var X,lt,rt,pt=this.components,vt=this.children;for(rt in pt)pt[rt].flushToDOM();if(Q)for(lt=0;lt<vt.length;++lt)(X=vt[lt]).flushToDOM&&X.flushToDOM(Q)}getAttribute(Q){var X,lt,rt,pt;return"position"===Q?this.object3D.position:"rotation"===Q?((pt=this.rotationObj).x=(lt=O.MathUtils.radToDeg)((rt=this.object3D.rotation).x),pt.y=lt(rt.y),pt.z=lt(rt.z),pt):"scale"===Q?this.object3D.scale:"visible"===Q?this.object3D.visible:(X=this.components[Q])?X.data:window.HTMLElement.prototype.getAttribute.call(this,Q)}getDOMAttribute(Q){var X=this.components[Q];return X?X.attrValue:window.HTMLElement.prototype.getAttribute.call(this,Q)}addState(Q){this.is(Q)||(this.states.push(Q),this.emit("stateadded",Q))}removeState(Q){var X=this.states.indexOf(Q);-1!==X&&(this.states.splice(X,1),this.emit("stateremoved",Q))}is(Q){return-1!==this.states.indexOf(Q)}inspect(){this.sceneEl.components.inspector.openInspector(this)}destroy(){var Q;if(this.parentNode)E("Entity can only be destroyed if detached from scenegraph.");else for(Q in this.components)this.components[Q].destroy()}}function k(G,Q){return!(!G.components[Q]||!G.components[Q].attrValue)||function(X,lt){var rt,pt=!1;for(rt=0;rt<lt.length&&!(pt=lt[rt].hasAttribute(X));++rt);return pt}(Q,G.mixinEls)}function F(G){return-1!==G.indexOf(D)&&(G=N.split(G,D)[0]),!!$[G]}M.componentsUpdated=[],M.singlePropUpdate={},customElements.define("a-entity",M),ot.exports.P=M},5890:(ot,ht,I)=>{var U=I(2203).a,$=I(8190).components,O=I(7427),N=O.styleParser;customElements.define("a-mixin",class extends U{constructor(){super(),this.componentCache={},this.rawAttributeCache={},this.isMixin=!0}doConnectedCallback(){super.doConnectedCallback(),this.sceneEl=this.closestScene(),this.id=this.getAttribute("id"),this.cacheAttributes(),this.updateEntities(),this.load()}attributeChangedCallback(_,E,D){super.attributeChangedCallback(),this.cacheAttribute(_,D),this.updateEntities()}setAttribute(_,E){window.HTMLElement.prototype.setAttribute.call(this,_,E),this.cacheAttribute(_,E)}cacheAttribute(_,E){var D,B;B=O.split(_,"__")[0],D=$[B],void 0===E&&(E=window.HTMLElement.prototype.getAttribute.call(this,_)),this.rawAttributeCache[_]=E,D&&(this.componentCache[_]=this.parseComponentAttrValue(D,E))}parseComponentAttrValue(_,E){var D;return"string"!=typeof E?E:(_.isSingleProperty?"string"==typeof(D=_.schema.parse(E))&&(D=E):D=N.parse(E),D)}getAttribute(_){return this.componentCache[_]||window.HTMLElement.prototype.getAttribute.call(this,_)}cacheAttributes(){var E,D=this.attributes;for(E=0;E<D.length;E++)this.cacheAttribute(D[E].name)}updateEntities(){var _,E,D;if(this.sceneEl)for(E=this.sceneEl.querySelectorAll("[mixin~="+this.id+"]"),D=0;D<E.length;D++)(_=E[D]).hasLoaded&&!_.isMixin&&_.mixinUpdate(this.id)}})},2203:(ot,ht,I)=>{var U=I(7427),$=I(2849),O=U.debug("core:a-node:warn"),N={"a-scene":!0,"a-assets":!0,"a-assets-items":!0,"a-cubemap":!0,"a-mixin":!0,"a-node":!0,"a-entity":!0};function _(D){return D.tagName.toLowerCase()in N||D.isNode}class E extends HTMLElement{constructor(){super(),this.computedMixinStr="",this.hasLoaded=!1,this.isNode=!0,this.mixinEls=[]}connectedCallback(){$.canInitializeElements?this.doConnectedCallback():document.addEventListener("aframeready",this.connectedCallback.bind(this))}doConnectedCallback(){var B;this.sceneEl=this.closestScene(),this.sceneEl||O("You are attempting to attach <"+this.tagName+"> outside of an A-Frame scene. Append this element to `<a-scene>` instead."),this.hasLoaded=!1,this.emit("nodeready",void 0,!1),this.isMixin||(B=this.getAttribute("mixin"))&&this.updateMixins(B)}attributeChangedCallback(B,C,M){M!==this.computedMixinStr&&("mixin"!==B||this.isMixin||this.updateMixins(M,C))}closestScene(){for(var B=this;B&&!B.isScene;)B=B.parentElement;return B}closest(B){for(var C=this.matches||this.mozMatchesSelector||this.msMatchesSelector||this.oMatchesSelector||this.webkitMatchesSelector,M=this;M&&!C.call(M,B);)M=M.parentElement;return M}disconnectedCallback(){this.hasLoaded=!1}load(B,C){var M,k=this;this.hasLoaded||(C=C||_,M=this.getChildren().filter(C).map(function(F){return new Promise(function(G,Q){if(F.hasLoaded)return G();F.addEventListener("loaded",G),F.addEventListener("error",Q)})}),Promise.allSettled(M).then(function(F){F.forEach(function(G){"rejected"===G.status&&O("Rendering scene with errors on node: ",G.reason.target)}),k.isLoading=!0,k.setupMutationObserver(),B&&B(),k.isLoading=!1,k.hasLoaded=!0,k.emit("loaded-private",void 0,!1),k.emit("loaded",void 0,!1)}))}setupMutationObserver(){var B=this;new MutationObserver(function(C){var M;for(M=0;M<C.length;M++)if("attributes"===C[M].type){var k=C[M].attributeName,F=window.HTMLElement.prototype.getAttribute.call(B,k);B.attributeChangedCallback(k,C[M].oldValue,F)}}).observe(this,{attributes:!0,attributeOldValue:!0})}getChildren(){return Array.prototype.slice.call(this.children,0)}updateMixins(B,C){var M,k,F,G=E.newMixinIdArray,Q=E.oldMixinIdArray,X=E.mixinIds;for(G.length=0,Q.length=0,k=B?U.split(B.trim(),/\s+/):G,F=C?U.split(C.trim(),/\s+/):Q,X.newMixinIds=k,X.oldMixinIds=F,M=0;M<F.length;M++)-1===k.indexOf(F[M])&&this.unregisterMixin(F[M]);for(this.computedMixinStr="",this.mixinEls.length=0,M=0;M<k.length;M++)this.registerMixin(k[M]);return this.computedMixinStr&&(this.computedMixinStr=this.computedMixinStr.trim(),window.HTMLElement.prototype.setAttribute.call(this,"mixin",this.computedMixinStr)),0===k.length&&window.HTMLElement.prototype.removeAttribute.call(this,"mixin"),X}registerMixin(B){var C,M,k,F=document.getElementById(B);if(F){if(k=F.getAttribute("mixin"))for(C=U.split(k.trim(),/\s+/),M=0;M<C.length;M++)this.registerMixin(C[M]);this.computedMixinStr=this.computedMixinStr+" "+F.id,this.mixinEls.push(F)}else O("No mixin was found with id `%s`",B)}setAttribute(B,C){"mixin"===B&&this.updateMixins(C),window.HTMLElement.prototype.setAttribute.call(this,B,C)}unregisterMixin(B){var C,M=this.mixinEls;for(C=0;C<M.length;++C)if(B===M[C].id){M.splice(C,1);break}}emit(B,C,M,k){var F=E.evtData;void 0===M&&(M=!0),F.bubbles=!!M,F.detail=C,k&&(F=U.extend({},k,F)),this.dispatchEvent(new CustomEvent(B,F))}}E.evtData={},E.newMixinIdArray=[],E.oldMixinIdArray=[],E.mixinIds={},customElements.define("a-node",E),ot.exports.a=E,ot.exports.$=N},8190:(ot,ht,I)=>{var U=I(7282),$=I(8313),O=I(1876),N=I(7427),_=ot.exports.components={},E=U.parseProperty,D=U.process,B=U.isSingleProperty,C=U.stringifyProperties,M=U.stringifyProperty,k=N.styleParser,F=N.debug("core:component:warn"),G=document.currentScript,Q=new RegExp("[A-Z]+"),X={},lt=Object.freeze({}),rt=[],pt={get:function(et,xt){return et.getComputedPropertyValue(xt)},set:function(et,xt,Rt){return xt in et.schema?et.recomputeProperty(xt,Rt):void 0!==Rt&&et.handleUnknownProperty(xt,Rt),!0}},vt=ot.exports.Component=function(et,xt,Rt){var Yt=this;if(this.sceneOnly&&!et.isScene)throw new Error("Component `"+this.name+"` can only be applied to <a-scene>");if(Rt&&!this.multiple)throw new Error("Trying to initialize multiple components of type `"+this.name+"`. There can only be one component of this type per entity.");this.el=et,this.id=Rt,this.attrName=this.name+(Rt?"__"+Rt:""),this.evtDetail={id:this.id,name:this.name},this.initialized=!1,this.el.components[this.attrName]=this,this.objectPool=X[this.name];var ve=this.events;this.events={},function(xe,Ge){var en;for(en in Ge)xe.events[en]=Ge[en].bind(xe)}(this,ve),this.attrValue=void 0,this.isObjectBased?(this.data=this.objectPool.use(),N.objectPool.removeUnusedKeys(this.data,this.schema),this.oldData=this.objectPool.use(),N.objectPool.removeUnusedKeys(this.oldData,this.schema),this.attrValueProxy=new Proxy(this,pt)):(this.data=void 0,this.oldData=void 0,this.attrValueProxy=void 0),this.deferUnknownPropertyWarnings=!!this.updateSchema,this.silenceUnknownPropertyWarnings=!1,this.throttledEmitComponentChanged=N.throttleLeadingAndTrailing(function(){et.emit("componentchanged",Yt.evtDetail,!1)},200),this.updateProperties(xt,!0)};if(vt.prototype={schema:{},init:function(){},events:{},update:function(et){},updateSchema:void 0,tick:void 0,tock:void 0,play:function(){},pause:function(){},remove:function(){},stringify:function(et){var xt=this.schema;return"string"==typeof et?et:this.isSingleProperty?M(et,xt):(et=C(et,xt),k.stringify(et))},flushToDOM:function(et){var xt=et?this.data:this.attrValue;null!=xt&&window.HTMLElement.prototype.setAttribute.call(this.el,this.attrName,this.stringify(xt))},updateProperties:function(et,xt){var Rt=this.el;this.updateData(et,xt),(Rt.hasLoaded||Rt.isLoading)&&(this.initialized?this.callUpdateHandler():this.initComponent())},initComponent:function(){var et,xt=this.el;xt.initializingComponents[this.name]||(xt.initializingComponents[this.name]=!0,this.init(),this.initialized=!0,delete xt.initializingComponents[this.name],et=this.isObjectBased?lt:void 0,this.dataChanged=!1,this.storeOldData(),this.update(et),xt.isPlaying&&this.play(),xt.emit("componentinitialized",this.evtDetail,!1))},updateData:function(et,xt){this.isSingleProperty?this.recomputeProperty(void 0,et):(xt?(N.objectPool.clearObject(this.attrValue),this.recomputeData(et),this.schemaChangeRequired=!!this.updateSchema):"string"==typeof et?k.parse(et,this.attrValueProxy):N.extend(this.attrValueProxy,et),this.updateSchemaIfNeeded(et))},updateSchemaIfNeeded:function(et){if(this.schemaChangeRequired&&this.updateSchema)rt.length=0,this.updateSchema(this.data),N.objectPool.removeUnusedKeys(this.data,this.schema),this.silenceUnknownPropertyWarnings=!0,this.recomputeData(et),this.silenceUnknownPropertyWarnings=!1,this.schemaChangeRequired=!1;else{for(var xt=0;xt<rt.length;xt++)F("Unknown property `"+rt[xt]+"` for component `"+this.name+"`.");rt.length=0}},callUpdateHandler:function(){if(this.isPositionRotationScale||this.dataChanged){this.dataChanged=!1;var et=this.oldData;this.oldDataInUse=!0,this.update(et),et!==this.oldData&&this.objectPool.recycle(et),this.oldDataInUse=!1,this.storeOldData(),this.throttledEmitComponentChanged()}},handleMixinUpdate:function(){this.recomputeData(),this.updateSchemaIfNeeded(),this.callUpdateHandler()},resetProperty:function(et){(this.isSingleProperty||et in this.schema)&&(et?this.attrValue[et]=void 0:(this.isObjectBased&&this.objectPool.recycle(this.attrValue),this.attrValue=void 0),this.recomputeProperty(et,void 0),this.updateSchemaIfNeeded(),this.callUpdateHandler())},extendSchema:function(et){var xt;xt=N.extend({},_[this.name].schema),N.extend(xt,et),this.schema=D(xt),this.el.emit("schemachanged",this.evtDetail)},getComputedPropertyValue:function(et){var xt=this.el.mixinEls,Rt=this.attrValue&&et?this.attrValue[et]:this.attrValue;if(void 0!==Rt)return Rt;for(var Yt=xt.length-1;Yt>=0;Yt--){var ve=xt[Yt].getAttribute(this.attrName);if(null!==ve&&(!et||et in ve))return et?ve[et]:ve}return et?this.schema[et].default:this.schema.default},recomputeProperty:function(et,xt){var Rt=et?this.schema[et]:this.schema;if(null!=xt){void 0===this.attrValue&&this.isObjectBased&&(this.attrValue=this.objectPool.use());var Yt=et?this.attrValue[et]:this.attrValue;"string"==typeof(Yt=Rt.isCacheable?E(xt,Rt,Yt):xt)&&(Yt=""===xt?void 0:xt),et?this.attrValue[et]=Yt:this.attrValue=Yt}this.oldDataInUse&&(this.oldData=this.objectPool.use(),N.objectPool.removeUnusedKeys(this.oldData,this.schema),this.storeOldData(),this.oldDataInUse=!1);var ve=et?this.oldData[et]:this.oldData,xe=et?this.data[et]:this.data,Ge=E(this.getComputedPropertyValue(et),Rt,xe);return"array"!==Rt.type||et||(Ge=N.clone(Ge)),Rt.equals(Ge,ve)||(this.dataChanged=!0,Rt.schemaChange&&(this.schemaChangeRequired=!0)),et?this.data[et]=Ge:this.data=Ge,Ge},handleUnknownProperty:function(et,xt){void 0===this.attrValue&&(this.attrValue=this.objectPool.use()),this.attrValue[et]=xt,this.silenceUnknownPropertyWarnings||(this.deferUnknownPropertyWarnings?rt.push(et):this.silenceUnknownPropertyWarnings||F("Unknown property `"+et+"` for component `"+this.name+"`."))},storeOldData:function(){var et;if(this.isObjectBased)if(this.isSingleProperty)this.oldData=E(this.data,this.schema,this.oldData);else for(et in this.schema)void 0!==this.data[et]&&(this.oldData[et]=this.data[et]&&"object"==typeof this.data[et]?E(this.data[et],this.schema[et],this.oldData[et]):this.data[et]);else this.oldData=this.data},recomputeData:function(et){var xt;if(this.isSingleProperty)this.recomputeProperty(void 0,et);else{if(et&&"object"==typeof et)for(xt in this.schema)this.attrValueProxy[xt]=et[xt];else for(xt in this.schema)this.attrValueProxy[xt]=void 0;for(xt in"string"==typeof et&&k.parse(et,this.attrValueProxy),this.attrValue)void 0!==this.attrValue[xt]&&-1!==rt.indexOf(xt)&&(xt in this.schema||F("Unknown property `"+xt+"` for component `"+this.name+"`."))}},eventsAttach:function(){var et;for(et in this.eventsDetach(),this.events)this.el.addEventListener(et,this.events[et])},eventsDetach:function(){var et;for(et in this.events)this.el.removeEventListener(et,this.events[et])},destroy:function(){this.objectPool.recycle(this.attrValue),this.objectPool.recycle(this.data),this.objectPool.recycle(this.oldData),this.attrValue=this.data=this.oldData=this.attrValueProxy=void 0}},window.debug)var bt=ot.exports.registrationOrderWarnings={};function ft(et){return et.tick||et.tock}function wt(et){return et&&et.constructor===Object&&!(et instanceof window.HTMLElement)}ot.exports.registerComponent=function(et,xt){var Rt,Yt,ve,xe,Ge,en={};if(document.currentScript&&document.currentScript!==G&&$.forEach(function(vn){vn.hasLoaded||document.currentScript.compareDocumentPosition(vn)!==Node.DOCUMENT_POSITION_FOLLOWING&&(F("The component `"+et+"` was registered in a <script> tag after the scene. Component <script> tags in an HTML file should be declared *before* the scene such that the component is available to entities during scene initialization."),window.debug&&(bt[et]=!0))}),!0===Q.test(et)&&F("The component name `"+et+"` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `"+et.toLowerCase()+"`"),-1!==et.indexOf("__"))throw new Error("The component name `"+et+"` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple components of the same type");if(Object.keys(xt).forEach(function(vn){en[vn]={value:xt[vn],writable:!0}}),_[et])throw new Error("The component `"+et+"` has been already registered. Check that you are not loading two versions of the same component or two different components of the same name.");((Rt=function(vn,_n,nr){vt.call(this,vn,_n,nr)}).prototype=Object.create(vt.prototype,en)).name=et,Rt.prototype.isPositionRotationScale="position"===et||"rotation"===et||"scale"===et,Rt.prototype.constructor=Rt,Rt.prototype.system=O&&O.systems[et],Rt.prototype.play=(xe=Rt.prototype.play,function(){var vn=this.el.sceneEl;this.initialized&&this.el.isPlaying&&!this.isPlaying&&(xe.call(this),this.isPlaying=!0,this.eventsAttach(),ft(this)&&vn.addBehavior(this))}),Rt.prototype.pause=(Ge=Rt.prototype.pause,function(){var vn=this.el.sceneEl;this.isPlaying&&(Ge.call(this),this.isPlaying=!1,this.eventsDetach(),ft(this)&&vn.removeBehavior(this))}),Yt=N.extend(D(Rt.prototype.schema,Rt.prototype.name)),Rt.prototype.isSingleProperty=ve=B(Rt.prototype.schema),Rt.prototype.isObjectBased=!ve||ve&&(wt(Yt.default)||wt(E(void 0,Yt))),X[et]=N.objectPool.createPool(),_[et]={Component:Rt,dependencies:Rt.prototype.dependencies,before:Rt.prototype.before,after:Rt.prototype.after,isSingleProperty:Rt.prototype.isSingleProperty,isObjectBased:Rt.prototype.isObjectBased,multiple:Rt.prototype.multiple,sceneOnly:Rt.prototype.sceneOnly,name:et,schema:Yt,stringify:Rt.prototype.stringify};for(var nn=0;nn<$.length;nn++)$[nn].emit("componentregistered",{name:et},!1);return Rt}},7045:(ot,ht,I)=>{var U=I(7282).process,$=ot.exports.to={},O=ot.exports.Ls=[],N=I(9437),_=function(){};_.prototype={schema:{},init:function(E){return this.geometry=new N.BufferGeometry,this.geometry},update:function(E){}},ot.exports.Az=function(E,D){var B,C={};if(Object.keys(D).forEach(function(M){C[M]={value:D[M],writable:!0}}),$[E])throw new Error("The geometry `"+E+"` has been already registered");return((B=function(){_.call(this)}).prototype=Object.create(_.prototype,C)).name=E,B.prototype.constructor=B,$[E]={Geometry:B,schema:U(B.prototype.schema)},O.push(E),B}},1551:(ot,ht,I)=>{var U=I(676),$=I(8878)("core:propertyTypes:warn"),O=ot.exports.propertyTypes={},N=/[,> .[\]:]/,_=/url\((.+)\)/;function E(X,lt,rt,pt,vt,bt){if(X in O)throw new Error("Property type "+X+" is already registered.");O[X]={default:lt,parse:rt||C,stringify:pt||M,equals:vt||k,isCacheable:!1!==bt}}function D(X,lt){if(!Array.isArray(X)||!Array.isArray(lt))return X===lt;if(X.length!==lt.length)return!1;for(var rt=0;rt<X.length;rt++)if(X[rt]!==lt[rt])return!1;return!0}function B(X){var lt,rt;return"string"!=typeof X?X:(rt=X.match(_))?rt[1]:"#"===X.charAt(0)?(lt=document.getElementById(X.substring(1)))?"CANVAS"===lt.tagName||"VIDEO"===lt.tagName||"IMG"===lt.tagName?lt:lt.getAttribute("src"):void $('"'+X+'" asset not found.'):X}function C(X){return X}function M(X){return null===X?"null":X.toString()}function k(X,lt){return X===lt}function F(X){return parseInt(X,10)}function G(X,lt,rt){return U.parse(X,lt,rt)}function Q(X,lt){return null===X||"object"==typeof X&&Object.keys(X).length===lt&&!("number"!=typeof X.x||"number"!=typeof X.y||lt>2&&"number"!=typeof X.z||lt>3&&"number"!=typeof X.w)}E("audio","",B),E("array",[],function(X){return Array.isArray(X)?X:X&&"string"==typeof X?X.split(",").map(function(lt){return lt.trim()}):[]},function(X){return X.join(", ")},D),E("asset","",B),E("boolean",!1,function(X){return"false"!==X&&!1!==X}),E("color","#FFF"),E("int",0,F),E("number",0,function(X){return parseFloat(X,10)}),E("map","",B),E("model","",B),E("selector",null,function(X){return X?"string"!=typeof X?X:"#"!==X[0]||N.test(X)?document.querySelector(X):document.getElementById(X.substring(1)):null},function(X){return X.getAttribute?"#"+X.getAttribute("id"):M(X)},k,!1),E("selectorAll",null,function(X){return X?"string"!=typeof X?X:Array.prototype.slice.call(document.querySelectorAll(X),0):null},function(X){return X instanceof Array?X.map(function(lt){return"#"+lt.getAttribute("id")}).join(", "):M(X)},D,!1),E("src","",function(X){return $("`src` property type is deprecated. Use `asset` instead."),B(X)}),E("string",""),E("time",0,F),E("vec2",{x:0,y:0},G,U.stringify,U.equals),E("vec3",{x:0,y:0,z:0},G,U.stringify,U.equals),E("vec4",{x:0,y:0,z:0,w:1},G,U.stringify,U.equals),ot.exports.registerPropertyType=E,ot.exports.isValidDefaultValue=function(X,lt){return("audio"!==X||"string"==typeof lt)&&!("array"===X&&!Array.isArray(lt))&&("asset"!==X||"string"==typeof lt)&&("boolean"!==X||"boolean"==typeof lt)&&("color"!==X||"string"==typeof lt)&&("int"!==X||"number"==typeof lt)&&("number"!==X||"number"==typeof lt)&&("map"!==X||"string"==typeof lt)&&("model"!==X||"string"==typeof lt)&&("selector"!==X||"string"==typeof lt||null===lt)&&("selectorAll"!==X||"string"==typeof lt||null===lt)&&("src"!==X||"string"==typeof lt)&&("string"!==X||"string"==typeof lt)&&("time"!==X||"number"==typeof lt)&&("vec2"===X?Q(lt,2):"vec3"===X?Q(lt,3):"vec4"!==X||Q(lt,4))},ot.exports.isValidDefaultCoordinate=Q},2849:ot=>{function ht(){ot.exports.canInitializeElements||(ot.exports.canInitializeElements=!0,setTimeout(function(){document.dispatchEvent(new CustomEvent("aframeready"))}))}ot.exports.canInitializeElements=!1,ot.exports.waitForDocumentReadyState=function(){"complete"!==document.readyState?document.addEventListener("readystatechange",function I(){"complete"===document.readyState&&(document.removeEventListener("readystatechange",I),ht())}):ht()},ot.exports.emitReady=ht},5076:(ot,ht,I)=>{var U=I(8316).W,$=I(6147),O=I(9762),N=I(8313),_=I(1876).systems,E=I(8190).components,D=I(9437),B=I(7427),C=B.debug("core:a-scene:warn"),M=I(4056).P,k=I(2203).a,F=I(8371),G=B.device.isIOS(),Q=B.device.isMobile(),X=B.device.isWebXRAvailable;G&&I(1957);class lt extends M{constructor(){var ft;super(),(ft=this).clock=new D.Clock,ft.isIOS=G,ft.isMobile=Q,ft.hasWebXR=X,ft.isAR=!1,ft.isScene=!0,ft.object3D=new D.Scene,ft.object3D.onAfterRender=function(wt,et,xt){ft.isPlaying&&ft.tock(ft.time,ft.delta,xt)},ft.resize=ft.resize.bind(ft),ft.render=ft.render.bind(ft),ft.systems={},ft.systemNames=[],ft.time=ft.delta=0,ft.usedOfferSession=!1,ft.componentOrder=[],ft.behaviors={},ft.hasLoaded=!1,ft.isPlaying=!1,ft.originalHTML=ft.innerHTML}addFullScreenStyles(){document.documentElement.classList.add("a-fullscreen")}removeFullScreenStyles(){document.documentElement.classList.remove("a-fullscreen")}doConnectedCallback(){var ft=this,wt=this.hasAttribute("embedded");this.setAttribute("inspector",""),this.setAttribute("keyboard-shortcuts",""),this.setAttribute("screenshot",""),this.setAttribute("xr-mode-ui",""),this.setAttribute("device-orientation-permission-ui",""),super.doConnectedCallback(),function(et){var xt;function Rt(){document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||et.exitVR(),document.activeElement.blur(),document.body.focus()}(xt=document.createElement("canvas")).classList.add("a-canvas"),xt.dataset.aframeCanvas=!0,et.appendChild(xt),document.addEventListener("fullscreenchange",Rt),document.addEventListener("mozfullscreenchange",Rt),document.addEventListener("webkitfullscreenchange",Rt),document.addEventListener("MSFullscreenChange",Rt),xt.addEventListener("touchmove",function(Yt){Yt.preventDefault()},{passive:!1}),et.canvas=xt,et.emit("render-target-loaded",{target:xt}),setTimeout(et.resize.bind(et),0)}(this),this.setupRenderer(),O.setup(this,vt),this.resize(),wt||this.addFullScreenStyles(),F(this),U(this),$(this),this.onVRPresentChangeBound=this.onVRPresentChange.bind(this),window.addEventListener("vrdisplaypresentchange",this.onVRPresentChangeBound),this.enterVRBound=function(){ft.enterVR()},this.exitVRBound=function(){ft.exitVR()},this.exitVRTrueBound=function(){ft.exitVR(!0)},this.pointerRestrictedBound=function(){ft.pointerRestricted()},this.pointerUnrestrictedBound=function(){ft.pointerUnrestricted()},ft.hasWebXR||(window.addEventListener("vrdisplaydeactivate",this.exitVRBound),window.addEventListener("vrdisplaydisconnect",this.exitVRTrueBound),window.addEventListener("vrdisplaypointerrestricted",this.pointerRestrictedBound),window.addEventListener("vrdisplaypointerunrestricted",this.pointerUnrestrictedBound)),window.addEventListener("sessionend",this.resize),this.addEventListener("cameraready",function(){ft.attachedCallbackPostCamera()}),this.initSystems(),this.componentOrder=rt(E,this.componentOrder),this.addEventListener("componentregistered",function(){ft.componentOrder=rt(E,ft.componentOrder)}),this.hasWebXR&&navigator.xr&&navigator.xr.addEventListener&&navigator.xr.addEventListener("sessiongranted",function(){ft.enterVR()})}attachedCallbackPostCamera(){var ft=this;window.addEventListener("load",void 0),window.addEventListener("resize",function(){ft.isIOS?setTimeout(ft.resize,100):ft.resize()}),this.play(),N.push(this)}initSystems(){var ft;for(ft in this.initSystem("camera"),_)"camera"!==ft&&this.initSystem(ft)}initSystem(ft){this.systems[ft]||(this.systems[ft]=new _[ft](this),this.systemNames.push(ft))}disconnectedCallback(){var ft=N.indexOf(this);super.disconnectedCallback(),N.splice(ft,1),window.removeEventListener("vrdisplaypresentchange",this.onVRPresentChangeBound),window.removeEventListener("vrdisplayactivate",this.enterVRBound),window.removeEventListener("vrdisplaydeactivate",this.exitVRBound),window.removeEventListener("vrdisplayconnect",this.enterVRBound),window.removeEventListener("vrdisplaydisconnect",this.exitVRTrueBound),window.removeEventListener("vrdisplaypointerrestricted",this.pointerRestrictedBound),window.removeEventListener("vrdisplaypointerunrestricted",this.pointerUnrestrictedBound),window.removeEventListener("sessionend",this.resize),this.renderer.dispose()}addBehavior(ft){var wt,et,xt=this.behaviors[ft.name];for(et in xt||(xt=this.behaviors[ft.name]={tick:{inUse:!1,array:[],markedForRemoval:[]},tock:{inUse:!1,array:[],markedForRemoval:[]}}),xt)if(ft[et]){if((wt=xt[et]).inUse){var Rt=wt.markedForRemoval.indexOf(ft);-1!==Rt&&wt.markedForRemoval.splice(Rt,1)}-1===wt.array.indexOf(ft)&&wt.array.push(ft)}}getPointerLockElement(){return document.pointerLockElement}checkHeadsetConnected(){return B.device.checkHeadsetConnected()}enterAR(){var ft;if(!this.hasWebXR)throw ft="Failed to enter AR mode, WebXR not supported.",new Error(ft);if(!B.device.checkARSupport())throw ft="Failed to enter AR, WebXR immersive-ar mode not supported in your browser or device.",new Error(ft);return this.enterVR(!0)}enterVR(ft,wt){var et,xt,Rt=this,Yt=Rt.renderer.xr;if(wt&&(!navigator.xr||!navigator.xr.offerSession))return Promise.resolve("OfferSession is not supported.");if(Rt.usedOfferSession&&wt)return Promise.resolve("OfferSession was already called.");if(this.is("vr-mode"))return Promise.resolve("Already in VR.");if(this.checkHeadsetConnected()||this.isMobile){var ve=Rt.getAttribute("renderer");if(Yt.enabled=!0,this.hasWebXR){this.xrSession&&this.xrSession.removeEventListener("end",this.exitVRBound),Yt.setReferenceSpaceType(this.sceneEl.systems.webxr.sessionReferenceSpaceType);var Ge=ft?"immersive-ar":"immersive-vr";return xt=this.sceneEl.systems.webxr.sessionConfiguration,new Promise(function(vn,_n){var nr=wt?navigator.xr.offerSession.bind(navigator.xr):navigator.xr.requestSession.bind(navigator.xr);Rt.usedOfferSession|=wt,nr(Ge,xt).then(function(hr){wt&&(Rt.usedOfferSession=!1),Yt.layersEnabled=-1!==xt.requiredFeatures.indexOf("layers"),Yt.setSession(hr).then(function(){Yt.setFoveation(ve.foveationLevel),Rt.xrSession=hr,Rt.systems.renderer.setWebXRFrameRate(hr),hr.addEventListener("end",Rt.exitVRBound),nn(vn)})},function(hr){_n(new Error("Failed to enter "+("immersive-ar"===Ge?"AR":"VR")+" mode (`requestSession`)",{cause:hr}))})})}return et=B.device.getVRDisplay(),Yt.setDevice(et),et.isPresenting&&!window.hasNativeWebVRImplementation?(nn(),Promise.resolve()):et.requestPresent([{source:this.canvas,attributes:{highRefreshRate:ve.highRefreshRate}}]).then(nn,function(vn){throw Rt.removeState("vr-mode"),vn&&vn.message?new Error("Failed to enter VR mode (`requestPresent`): "+vn.message):new Error("Failed to enter VR mode (`requestPresent`).")})}return nn(),Promise.resolve();function nn(vn){var _n,nr;window.hasNativeWebVRImplementation&&!window.hasNativeWebXRImplementation&&(_n=new CustomEvent("vrdisplaypresentchange",{detail:{display:B.device.getVRDisplay()}}),window.dispatchEvent(_n)),Rt.addState(ft?"ar-mode":"vr-mode"),Rt.emit("enter-vr",{target:Rt}),!Rt.hasWebXR&&Rt.isMobile&&screen.orientation&&screen.orientation.lock&&screen.orientation.lock("landscape"),Rt.addFullScreenStyles(),Rt.isMobile||Rt.checkHeadsetConnected()||((nr=Rt.canvas).requestFullscreen||nr.webkitRequestFullscreen||nr.mozRequestFullScreen||nr.msRequestFullscreen).apply(nr,[{navigationUI:"hide"}]),Rt.resize(),vn&&vn()}}exitVR(){var ft,wt=this,et=this.renderer.xr;if(!this.is("vr-mode")&&!this.is("ar-mode"))return Promise.resolve("Not in immersive mode.");if(this.checkHeadsetConnected()||this.isMobile){if(et.enabled=!1,ft=B.device.getVRDisplay(),this.hasWebXR)this.xrSession.removeEventListener("end",this.exitVRBound),this.xrSession.end().then(function(){},function(){}),this.xrSession=void 0;else if(ft.isPresenting)return ft.exitPresent().then(xt,function(Rt){throw Rt&&Rt.message?new Error("Failed to exit VR mode (`exitPresent`): "+Rt.message):new Error("Failed to exit VR mode (`exitPresent`).")})}else(document.fullscreenElement||document.webkitFullscreenElement||document.mozFullScreenElement)&&(document.exitFullscreen?document.exitFullscreen():document.mozCancelFullScreen?document.mozCancelFullScreen():document.webkitExitFullscreen&&document.webkitExitFullscreen());return xt(),Promise.resolve();function xt(){wt.removeState("vr-mode"),wt.removeState("ar-mode"),wt.isMobile&&screen.orientation&&screen.orientation.unlock&&screen.orientation.unlock(),wt.hasAttribute("embedded")&&wt.removeFullScreenStyles(),wt.resize(),wt.isIOS&&B.forceCanvasResizeSafariMobile(wt.canvas),wt.renderer.setPixelRatio(window.devicePixelRatio),wt.emit("exit-vr",{target:wt})}}pointerRestricted(){if(this.canvas){var ft=this.getPointerLockElement();ft&&ft!==this.canvas&&document.exitPointerLock&&document.exitPointerLock(),this.canvas.requestPointerLock&&this.canvas.requestPointerLock()}}pointerUnrestricted(){var ft=this.getPointerLockElement();ft&&ft===this.canvas&&document.exitPointerLock&&document.exitPointerLock()}onVRPresentChange(ft){var wt=ft.display||ft.detail.display;wt&&wt.isPresenting?this.enterVR():this.exitVR()}getAttribute(ft){var wt=this.systems[ft];return wt?wt.data:M.prototype.getAttribute.call(this,ft)}getDOMAttribute(ft){var wt=this.systems[ft];return wt?wt.data:M.prototype.getDOMAttribute.call(this,ft)}setAttribute(ft,wt,et){if(_[ft]){k.prototype.setAttribute.call(this,ft,wt);var xt=this.systems[ft];xt&&xt.updateProperties(wt)}else M.prototype.setAttribute.call(this,ft,wt,et)}removeBehavior(ft){var wt,et,xt,Rt=this.behaviors[ft.name];for(et in Rt)ft[et]&&-1!==(xt=(wt=Rt[et]).array.indexOf(ft))&&(wt.inUse?-1===wt.markedForRemoval.indexOf(ft)&&wt.markedForRemoval.push(ft):(wt.array[xt]=wt.array[wt.array.length-1],wt.array.pop()))}resize(){var ft,wt,et=this.camera,xt=this.canvas;ft=this.renderer.xr.enabled&&this.renderer.xr.isPresenting,!et||!xt||this.is("vr-mode")&&(this.isMobile||ft)||(wt=vt(xt,this.getAttribute("embedded")&&!this.is("vr-mode"),this.maxCanvasSize,this.is("vr-mode")),et.aspect=wt.width/wt.height,et.updateProjectionMatrix(),this.renderer.setSize(wt.width,wt.height,!1),this.emit("rendererresize",null,!1))}setupRenderer(){var ft,wt,et,xt,Rt=this;xt={alpha:!0,antialias:!Q,canvas:this.canvas,logarithmicDepthBuffer:!1,powerPreference:"high-performance"},this.maxCanvasSize={height:-1,width:-1},this.hasAttribute("renderer")&&(et=this.getAttribute("renderer"),(wt=B.styleParser.parse(et)).precision&&(xt.precision=wt.precision+"p"),wt.antialias&&"auto"!==wt.antialias&&(xt.antialias="true"===wt.antialias),wt.logarithmicDepthBuffer&&"auto"!==wt.logarithmicDepthBuffer&&(xt.logarithmicDepthBuffer="true"===wt.logarithmicDepthBuffer),wt.alpha&&(xt.alpha="true"===wt.alpha),wt.stencil&&(xt.stencil="true"===wt.stencil),wt.multiviewStereo&&(xt.multiviewStereo="true"===wt.multiviewStereo),this.maxCanvasSize={width:wt.maxCanvasWidth?parseInt(wt.maxCanvasWidth):this.maxCanvasSize.width,height:wt.maxCanvasHeight?parseInt(wt.maxCanvasHeight):this.maxCanvasSize.height}),(ft=this.renderer=new D.WebGLRenderer(xt)).setPixelRatio(window.devicePixelRatio),this.camera&&ft.xr.setPoseTarget(this.camera.el.object3D),this.addEventListener("camera-set-active",function(){ft.xr.setPoseTarget(Rt.camera.el.object3D)})}play(){var ft=this,wt=this;this.renderStarted?M.prototype.play.call(this):(this.addEventListener("loaded",function(){var et,xt=this.renderer,Rt=this.renderer.xr;M.prototype.play.call(this),wt.renderStarted||(wt.resize(),wt.renderer&&(window.performance&&window.performance.mark("render-started"),O.remove(),(et=B.device.getVRDisplay())&&et.isPresenting&&(Rt.setDevice(et),Rt.enabled=!0,wt.enterVR()),xt.setAnimationLoop(this.render),wt.renderStarted=!0,wt.emit("renderstart")))}),setTimeout(function(){M.prototype.load.call(ft)}))}updateComponent(ft){ft in _||M.prototype.updateComponent.apply(this,arguments)}tick(ft,wt){var et,xt=this.systems;for(this.callComponentBehaviors("tick",ft,wt),et=0;et<this.systemNames.length;et++)xt[this.systemNames[et]].tick&&xt[this.systemNames[et]].tick(ft,wt)}tock(ft,wt,et){var xt,Rt=this.systems;for(this.callComponentBehaviors("tock",ft,wt),xt=0;xt<this.systemNames.length;xt++)Rt[this.systemNames[xt]].tock&&Rt[this.systemNames[xt]].tock(ft,wt,et)}render(ft,wt){var et=this.renderer;this.frame=wt,this.delta=1e3*this.clock.getDelta(),this.time=1e3*this.clock.elapsedTime,this.isPlaying&&this.tick(this.time,this.delta);var xt=null;this.is("ar-mode")&&(xt=this.object3D.background,this.object3D.background=null),et.render(this.object3D,this.camera),xt&&(this.object3D.background=xt)}callComponentBehaviors(ft,wt,et){for(var xt,Rt=0;Rt<this.componentOrder.length;Rt++){var Yt=this.behaviors[this.componentOrder[Rt]];if(Yt){var ve=Yt[ft];for(ve.inUse=!0,xt=0;xt<ve.array.length;xt++)ve.array[xt].isPlaying&&ve.array[xt][ft](wt,et);for(ve.inUse=!1,xt=0;xt<ve.markedForRemoval.length;xt++)this.removeBehavior(ve.markedForRemoval[xt]);ve.markedForRemoval.length=0}}}}function rt(bt,ft){var wt,et,xt={},Rt=ft||[];for(et in Rt.length=0,bt){var Yt=bt[et];if(void 0!==Yt){var ve=Yt.before?Yt.before.slice(0):[],xe=Yt.after?Yt.after.slice(0):[];xt[et]={before:ve,after:xe,visited:!1,done:!1}}}for(et in xt)for(wt=0;wt<xt[et].before.length;wt++){var Ge=xt[et].before[wt];Ge in xt?xt[Ge].after.push(et):C("Invalid ordering constraint, no component named `"+Ge+"` referenced by `"+et+"`")}function en(nn){if(nn in xt&&!xt[nn].done)if(xt[nn].visited)C("Cycle detected, ignoring one or more before/after constraints. The resulting order might be incorrect");else{xt[nn].visited=!0;for(var vn=0;vn<xt[nn].after.length;vn++){var _n=xt[nn].after[vn];_n in xt||C("Invalid before/after constraint, no component named `"+_n+"` referenced in `"+nn+"`"),en(_n)}xt[nn].done=!0,Rt.push(nn)}}for(et in xt)xt[et].done||en(et);return Rt}function pt(bt,ft){var wt,et=window.devicePixelRatio;return!ft||-1===ft.width&&-1===ft.height||bt.width*et<ft.width&&bt.height*et<ft.height||(wt=bt.width/bt.height,bt.width*et>ft.width&&-1!==ft.width&&(bt.width=Math.round(ft.width/et),bt.height=Math.round(ft.width/wt/et)),bt.height*et>ft.height&&-1!==ft.height&&(bt.height=Math.round(ft.height/et),bt.width=Math.round(ft.height*wt/et))),bt}function vt(bt,ft,wt,et){return bt.parentElement?ft?pt({height:bt.parentElement.offsetHeight,width:bt.parentElement.offsetWidth},wt):(Yt={height:document.body.offsetHeight,width:document.body.offsetWidth},et?Yt:pt(Yt,wt)):{height:0,width:0};var Yt}customElements.define("a-scene",lt),ot.exports.aQ=lt},9762:(ot,ht,I)=>{var U,$,O,N=I(7427).styleParser,_="loading-screen";function E(D){var B=U.hasAttribute("embedded"),C=O(U.canvas,B,U.maxCanvasSize,U.is("vr-mode"));D.aspect=C.width/C.height,D.updateProjectionMatrix(),U.renderer.setSize(C.width,C.height,!1)}ot.exports.setup=function(D,B){O=B;var C,M,k,F,G,Q,X,lt,rt,pt,vt=(U=D).hasAttribute(_)?N.parse(U.getAttribute(_)):void 0,bt=vt&&vt.dotsColor||"white",ft=vt&&vt.backgroundColor||"#24CAFF";(void 0===vt||"true"===vt.enabled||void 0===vt.enabled)&&(C=new THREE.Scene,M=new THREE.SphereGeometry(.2,36,18,0,2*Math.PI,0,Math.PI),k=new THREE.MeshBasicMaterial({color:bt}),F=new THREE.Mesh(M,k),G=F.clone(),Q=F.clone(),X=new THREE.PerspectiveCamera(80,window.innerWidth/window.innerHeight,5e-4,1e4),lt=new THREE.Clock,rt=0,pt=function(){U.renderer.render(C,X),rt=lt.getElapsedTime()%4,F.visible=rt>=1,G.visible=rt>=2,Q.visible=rt>=3},C.background=new THREE.Color(ft),C.add(X),F.position.set(-1,0,-15),G.position.set(0,0,-15),Q.position.set(1,0,-15),X.add(F),X.add(G),X.add(Q),($=document.createElement("div")).className="a-loader-title",$.innerHTML=document.title,$.style.display="none",U.appendChild($),setTimeout(function(){U.hasLoaded||(E(X),$.style.display="block",window.addEventListener("resize",function(){E(X)}),U.renderer.setAnimationLoop(pt))},200))},ot.exports.remove=function(){window.removeEventListener("resize",E),$&&($.style.display="none")}},8316:(ot,ht,I)=>{var U,$=I(1343),O=I(7427).extend,N=[E({name:"viewport",content:"width=device-width,initial-scale=1,maximum-scale=1,shrink-to-fit=no,user-scalable=no,minimal-ui,viewport-fit=cover"}),E({name:"mobile-web-app-capable",content:"yes"}),E({name:"theme-color",content:"black"})],_=[E({name:"apple-mobile-web-app-capable",content:"yes"}),E({name:"apple-mobile-web-app-status-bar-style",content:"black"}),(U={rel:"apple-touch-icon",href:"https://aframe.io/images/aframe-logo-152.png"},{tagName:"link",attributes:U,exists:function(){return document.querySelector('link[rel="'+U.rel+'"]')}})];function E(D){return{tagName:"meta",attributes:D,exists:function(){return document.querySelector('meta[name="'+D.name+'"]')}}}ot.exports.W=function(D){var B,C=document.head,M=C.querySelector("script"),k=[];return N.forEach(F),D.isIOS&&_.forEach(F),k;function F(G){G&&!G.exists()&&(B=function(Q){if(Q&&Q.tagName){var X=document.createElement(Q.tagName);return X.setAttribute($.AFRAME_INJECTED,""),O(X,Q.attributes)}}(G))&&(M?M.parentNode.insertBefore(B,M):C.appendChild(B),k.push(B))}}},8371:(ot,ht,I)=>{var U=I(7427).isIframed;function $(O){if(O.data&&"vr"===O.data.type)switch(O.data.data){case"enter":this.enterVR();break;case"exit":this.exitVR()}}ot.exports=function(O){U()&&window.addEventListener("message",$.bind(O))}},8313:ot=>{ot.exports=[]},6147:(ot,ht,I)=>{var U=I(5928);ot.exports=function($){if($.isMobile){var O=$.wakelock=new U;$.addEventListener("enter-vr",function(){O.request()}),$.addEventListener("exit-vr",function(){O.release()})}}},7282:(ot,ht,I)=>{var U,$=I(7427),O=I(1551),_=O.isValidDefaultValue,E=O.propertyTypes,D=(0,$.debug)("core:schema:warn");function B(F){return"type"in F?"string"==typeof F.type:"default"in F}function C(F,G){var Q,X,lt=F.default,rt=F.type;return F.type?"bool"===F.type?rt="boolean":"float"===F.type&&(rt="number"):rt=void 0===lt||"boolean"!=typeof lt&&"number"!=typeof lt?Array.isArray(lt)?"array":"string":typeof lt,(X=E[rt])||D("Unknown property type for component `"+G+"`: "+rt),Q=!!F.parse,F.parse=F.parse||X.parse,F.stringify=F.stringify||X.stringify,F.equals=F.equals||X.equals,F.isCacheable=!0===F.isCacheable||X.isCacheable,F.type=rt,"default"in F?Q||_(rt,lt)||D("Default value `"+lt+"` does not match type `"+rt+"` in component `"+G+"`"):F.default=X.default,F}function M(F,G,Q){return null!=F&&""!==F||(F=G.default,Array.isArray(F)&&(F=F.slice())),G.parse(F,G.default,Q)}function k(F,G){return"object"!=typeof F?F:G&&null!==F?G.stringify(F):JSON.stringify(F)}ot.exports.isSingleProperty=B,ot.exports.process=function(F,G){var Q;if(B(F))return C(F,G);for(Q in F)F[Q]=C(F[Q],G);return F},ot.exports.processPropertyDefinition=C,ot.exports.parseProperties=(U=[],function(F,G,Q,X,lt){var rt,pt,vt;for(pt in U.length=0,Q?F:G)Q&&void 0===F[pt]||U.push(pt);if(null===F||"object"!=typeof F)return F;for(pt in F)void 0===F[pt]||G[pt]||lt||D("Unknown property `"+pt+"` for component/system `"+X+"`.");for(rt=0;rt<U.length;rt++){if(vt=G[pt=U[rt]],!G[pt])return;F[pt]=M(F[pt],vt)}return F}),ot.exports.parseProperty=M,ot.exports.stringifyProperties=function(F,G){var Q,X,lt,rt,pt={};for(Q in F)X=G[Q],"object"==typeof(rt=lt=F[Q])&&(rt=k(lt,X),X||D("Unknown component property: "+Q)),pt[Q]=rt;return pt},ot.exports.stringifyProperty=k},5892:(ot,ht,I)=>{var U=I(7282).process,$=ot.exports.shaders={},O=ot.exports.shaderNames=[],N=I(9437),_=I(7427),E={array:"v3",color:"v3",int:"i",number:"f",map:"t",time:"f",vec2:"v2",vec3:"v3",vec4:"v4"},D=ot.exports.Shader=function(){};D.prototype={schema:{},vertexShader:"void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",fragmentShader:"void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",init:function(B){return this.uniforms=this.initUniforms(),this.material=new(this.raw?N.RawShaderMaterial:N.ShaderMaterial)({uniforms:this.uniforms,glslVersion:this.raw||this.glsl3?N.GLSL3:null,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader}),this.material},initUniforms:function(){var B,M=this.schema,k={};for(B in M)"uniform"===M[B].is&&(k[B]={type:E[M[B].type],value:void 0});return k},update:function(B){var C,M,k=this.schema,F=this.uniforms;for(C in B)if(k[C]&&"uniform"===k[C].is)if("map"!==k[C].type)F[C].value=this.parseValue(k[C].type,B[C]),F[C].needsUpdate=!0;else{if(!F[C]||F[C].value===B[C])continue;this.setMapOnTextureLoad(F,C,M="_texture_"+C),_.material.updateMapMaterialFromData(M,C,this,B)}},parseValue:function(B,C){var M;switch(B){case"vec2":return new N.Vector2(C.x,C.y);case"vec3":return new N.Vector3(C.x,C.y,C.z);case"vec4":return new N.Vector4(C.x,C.y,C.z,C.w);case"color":return M=new N.Color(C),new N.Vector3(M.r,M.g,M.b);default:return C}},setMapOnTextureLoad:function(B,C,M){var k=this;this.el.addEventListener("materialtextureloaded",function(){B[C].value=k.material[M],B[C].needsUpdate=!0})}},ot.exports.registerShader=function(B,C){var M,k={};if(Object.keys(C).forEach(function(F){k[F]={value:C[F],writable:!0}}),$[B])throw new Error("The shader "+B+" has already been registered");return((M=function(){D.call(this)}).prototype=Object.create(D.prototype,k)).name=B,M.prototype.constructor=M,$[B]={Shader:M,schema:U(M.prototype.schema)},O.push(B),M}},1876:(ot,ht,I)=>{var U=I(8190),$=I(7282),O=I(7427),N=I(2849),_=$.parseProperties,E=$.parseProperty,D=$.process,B=$.isSingleProperty,C=O.styleParser,M=ot.exports.systems={},k=ot.exports.System=function(F){var G=U&&U.components[this.name];this.el=F,this.sceneEl=F,G&&(G.Component.prototype.system=this),this.buildData(),this.init(),this.update({})};k.prototype={schema:{},init:function(){},update:function(F){},updateProperties:function(F){var G=this.data;Object.keys($).length&&(this.buildData(F),this.update(G))},buildData:function(F){var G=this.schema;Object.keys(G).length&&(F=F||window.HTMLElement.prototype.getAttribute.call(this.sceneEl,this.name),this.data=B(G)?E(F,G):_(C.parse(F)||{},G,!1,this.name))},tick:void 0,tock:void 0,play:function(){},pause:function(){}},ot.exports.registerSystem=function(F,G){var Q,X,lt={},rt=O.findAllScenes(document);if(Object.keys(G).forEach(function(pt){lt[pt]={value:G[pt],writable:!0}}),M[F])throw new Error("The system `"+F+"` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");if(((X=function(pt){k.call(this,pt)}).prototype=Object.create(k.prototype,lt)).name=F,X.prototype.constructor=X,X.prototype.schema=O.extend(D(X.prototype.schema)),M[F]=X,N.canInitializeElements)for(Q=0;Q<rt.length;Q++)rt[Q].initSystem(F)}},258:(ot,ht,I)=>{I(4530)},4530:(ot,ht,I)=>{var U=I(8190).registerComponent,$=I(9437),O=new $.Vector3,N=new $.Vector3;U("pivot",{dependencies:["position"],schema:{type:"vec3"},init:function(){var _=this.data,E=this.el,D=E.object3D.parent,B=E.object3D,C=new $.Group;O.copy(B.position),N.copy(B.rotation),D.remove(B),C.add(B),D.add(C),E.object3D=C,B.position.set(-1*_.x,-1*_.y,-1*_.z),C.position.set(_.x+O.x,_.y+O.y,_.z+O.z),C.rotation.copy(B.rotation),B.rotation.set(0,0,0)}})},1028:(ot,ht,I)=>{var U=I(8190).components,$=I(5892).shaders,O=I(7427),N={};function _(E){var D=E.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();"fog"===E&&(D="material-fog"),"visible"===E&&(D="material-visible"),N[D]="material."+E}Object.keys(U.material.schema).forEach(_),Object.keys($.standard.schema).forEach(_),ot.exports=function(){return{defaultComponents:{material:{}},mappings:O.extend({},N)}}},196:(ot,ht,I)=>{I(5702),I(9099),I(1907),I(3200),I(3120),I(9357),I(7161),I(9172),I(9012),I(4814),I(542),I(2414),I(1199),I(6672)},5920:(ot,ht,I)=>{var U=I(2203).$,$=I(4056).P,O=I(8190).components,N=I(7427),_=N.debug,E=N.entity.setComponentProperty,D=_("extras:primitives:debug"),B=_("extras:primitives:warn"),C=_("extras:primitives:error"),M=ot.exports.primitives={};function k(F,G,Q){var X=N.entity.getComponentPropertyPath(F);X.constructor===Array?(Q[X[0]]=Q[X[0]]||{},Q[X[0]][X[1]]=G.trim()):Q[X]=G.trim()}ot.exports.registerPrimitive=function(F,G){if(F=F.toLowerCase(),!U[F]){U[F]=!0,D("Registering <%s>",F),G.defaultAttributes&&B("The 'defaultAttributes' object is deprecated. Use 'defaultComponents' instead.");var Q=G.mappings||{},X=class extends ${constructor(){super(),this.defaultComponentsFromPrimitive=G.defaultComponents||G.defaultAttributes||{},this.deprecated=G.deprecated||null,this.deprecatedMappings=G.deprecatedMappings||{},this.mappings=Q,G.deprecated&&console.warn(G.deprecated),this.resolveMappingCollisions()}resolveMappingCollisions(){var lt=this.mappings,rt=this;Object.keys(lt).forEach(function(pt){var vt;pt!==pt.toLowerCase()&&B("Mapping keys should be specified in lower case. The mapping key "+pt+" may not be recognized"),O[pt]&&(vt=lt[pt].replace(".","-"),lt[vt]=lt[pt],delete lt[pt],console.warn("The primitive "+rt.tagName.toLowerCase()+" has a mapping collision. The attribute "+pt+" has the same name as a registered component and has been renamed to "+vt))})}getExtraComponents(){var lt,rt,pt,vt,bt,ft=this;for(rt=N.clone(this.defaultComponentsFromPrimitive),(bt=this.getAttribute("mixin"))&&(bt=N.split(bt.trim(),/\s+/)).forEach(function(Rt){var Yt,ve,xe=document.getElementById(Rt);if(xe){var Ge=xe.rawAttributeCache,en=xe.componentCache;for(var nn in Ge){if(vt=ft.mappings[nn])return void k(vt,Ge[nn],rt);nn in en&&(rt[nn]=(ve=en[nn],wt(Yt=rt[nn])?et(ve):wt(ve)?et(Yt):xt(Yt)&&xt(ve)?N.extendDeep(Yt,ve):et(ve)))}}}),pt=0;pt<this.attributes.length;pt++)(vt=this.mappings[(lt=this.attributes[pt]).name])&&k(vt,lt.value,rt);return rt;function wt(Rt){return void 0===Rt}function et(Rt){return xt(Rt)?N.extendDeep({},Rt):Rt}function xt(Rt){return null!==Rt&&Rt.constructor===Object}}attributeChangedCallback(lt,rt,pt){var vt=this.mappings[lt];lt in this.deprecatedMappings&&console.warn(this.deprecatedMappings[lt]),lt&&vt?E(this,vt,pt):super.attributeChangedCallback(lt,rt,pt)}};return customElements.define(F,X),X.mappings=Q,M[F]=X,X}C("Trying to register primitive "+F+" that has been already previously registered")},ot.exports.definePrimitive=function(F,G,Q){Q=Q||{},Object.keys(G).map(function(X){var lt,rt;lt=X,rt=Q,Object.keys(O[lt].schema).map(function(vt){var bt=vt.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();void 0!==rt[bt]&&(bt=lt+"-"+vt),rt[bt]=lt+"."+vt})}),ot.exports.registerPrimitive(F,N.extendDeep({},null,{defaultComponents:G,mappings:Q}))}},5702:(ot,ht,I)=>{(0,I(5920).registerPrimitive)("a-camera",{defaultComponents:{camera:{},"look-controls":{},"wasd-controls":{},position:{x:0,y:1.6,z:0}},mappings:{active:"camera.active",far:"camera.far",fov:"camera.fov","look-controls-enabled":"look-controls.enabled",near:"camera.near","pointer-lock-enabled":"look-controls.pointerLockEnabled","wasd-controls-enabled":"wasd-controls.enabled","reverse-mouse-drag":"look-controls.reverseMouseDrag",zoom:"camera.zoom"}})},9099:(ot,ht,I)=>{var U=I(1028);(0,I(5920).registerPrimitive)("a-cursor",I(7427).extendDeep({},U(),{defaultComponents:{cursor:{},geometry:{primitive:"ring",radiusOuter:.016,radiusInner:.01,segmentsTheta:32},material:{color:"#000",shader:"flat",opacity:.8},position:{x:0,y:0,z:-1}},mappings:{far:"raycaster.far",fuse:"cursor.fuse","fuse-timeout":"cursor.fuseTimeout",interval:"raycaster.interval",objects:"raycaster.objects"}}))},1907:(ot,ht,I)=>{var U=I(1028);(0,I(5920).registerPrimitive)("a-curvedimage",I(7427).extendDeep({},U(),{defaultComponents:{geometry:{height:1,primitive:"cylinder",radius:2,segmentsRadial:48,thetaLength:270,openEnded:!0,thetaStart:0},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0,repeat:"-1 1"}},mappings:{height:"geometry.height","open-ended":"geometry.openEnded",radius:"geometry.radius",segments:"geometry.segmentsRadial",start:"geometry.thetaStart","theta-length":"geometry.thetaLength","theta-start":"geometry.thetaStart",width:"geometry.thetaLength"}}))},3200:(ot,ht,I)=>{(0,I(5920).registerPrimitive)("a-gltf-model",{mappings:{src:"gltf-model"}})},3120:(ot,ht,I)=>{var U=I(1028);(0,I(5920).registerPrimitive)("a-image",I(7427).extendDeep({},U(),{defaultComponents:{geometry:{primitive:"plane"},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0}},mappings:{height:"geometry.height",width:"geometry.width"}}))},9357:(ot,ht,I)=>{(0,I(5920).registerPrimitive)("a-light",{defaultComponents:{light:{}},mappings:{angle:"light.angle",color:"light.color","ground-color":"light.groundColor",decay:"light.decay",distance:"light.distance",intensity:"light.intensity",penumbra:"light.penumbra",type:"light.type",target:"light.target",envmap:"light.envMap","shadow-camera-automatic":"light.shadowCameraAutomatic"}})},7161:(ot,ht,I)=>{(0,I(5920).registerPrimitive)("a-link",{defaultComponents:{link:{visualAspectEnabled:!0}},mappings:{href:"link.href",image:"link.image",title:"link.title"}})},9172:(ot,ht,I)=>{var U=I(1028)();(0,I(5920).registerPrimitive)("a-obj-model",I(7427).extendDeep({},U,{defaultComponents:{"obj-model":{}},mappings:{src:"obj-model.obj",mtl:"obj-model.mtl"}}))},9012:(ot,ht,I)=>{var U=I(1028),$=I(5920).registerPrimitive,O=I(7427),N=I(6672);$("a-sky",O.extendDeep({},U(),{defaultComponents:{geometry:{primitive:"sphere",radius:500,segmentsWidth:64,segmentsHeight:32},material:{color:"#FFF",side:"back",shader:"flat",npot:!0},scale:"-1 1 1"},mappings:O.extendDeep({},N["a-sphere"].mappings)}))},4814:(ot,ht,I)=>{(0,I(5920).registerPrimitive)("a-sound",{defaultComponents:{sound:{}},mappings:{src:"sound.src",on:"sound.on",autoplay:"sound.autoplay",loop:"sound.loop",volume:"sound.volume"}})},542:(ot,ht,I)=>{(0,I(5920).definePrimitive)("a-text",{text:{anchor:"align",width:5}})},2414:(ot,ht,I)=>{var U=I(1028);(0,I(5920).registerPrimitive)("a-video",I(7427).extendDeep({},U(),{defaultComponents:{geometry:{primitive:"plane"},material:{color:"#FFF",shader:"flat",side:"double",transparent:!0}},mappings:{height:"geometry.height",width:"geometry.width"}}))},1199:(ot,ht,I)=>{var U=I(1028);(0,I(5920).registerPrimitive)("a-videosphere",I(7427).extendDeep({},U(),{defaultComponents:{geometry:{primitive:"sphere",radius:500,segmentsWidth:64,segmentsHeight:32},material:{color:"#FFF",shader:"flat",side:"back",npot:!0},scale:"-1 1 1"},mappings:{radius:"geometry.radius","segments-height":"geometry.segmentsHeight","segments-width":"geometry.segmentsWidth"}}))},6672:(ot,ht,I)=>{var U=I(1028),$=I(7045).to,O=I(7045).Ls,N=I(5920).registerPrimitive,_=I(7427),E=ot.exports={};function D(B){return B.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}O.forEach(function(B){var C=$[B],M=D(B),k={};Object.keys(C.schema).forEach(function(Q){k[D(Q)]="geometry."+Q});var F="a-"+M,G=N(F,_.extendDeep({},U(),{defaultComponents:{geometry:{primitive:B}},mappings:k}));E[F]=G})},5459:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437);U("box",{schema:{depth:{default:1,min:0},height:{default:1,min:0},width:{default:1,min:0},segmentsHeight:{default:1,min:1,max:20,type:"int"},segmentsWidth:{default:1,min:1,max:20,type:"int"},segmentsDepth:{default:1,min:1,max:20,type:"int"}},init:function(O){this.geometry=new $.BoxGeometry(O.width,O.height,O.depth,O.segmentsWidth,O.segmentsHeight,O.segmentsDepth)}})},2328:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437),O=$.MathUtils.degToRad;U("circle",{schema:{radius:{default:1,min:0},segments:{default:32,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(N){this.geometry=new $.CircleGeometry(N.radius,N.segments,O(N.thetaStart),O(N.thetaLength))}})},4907:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437),O=$.MathUtils.degToRad;U("cone",{schema:{height:{default:1,min:0},openEnded:{default:!1},radiusBottom:{default:1,min:0},radiusTop:{default:.01,min:0},segmentsHeight:{default:18,min:1,type:"int"},segmentsRadial:{default:36,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(N){this.geometry=new $.CylinderGeometry(N.radiusTop,N.radiusBottom,N.height,N.segmentsRadial,N.segmentsHeight,N.openEnded,O(N.thetaStart),O(N.thetaLength))}})},6362:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437),O=$.MathUtils.degToRad;U("cylinder",{schema:{height:{default:1,min:0},openEnded:{default:!1},radius:{default:1,min:0},segmentsHeight:{default:18,min:1,type:"int"},segmentsRadial:{default:36,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(N){this.geometry=new $.CylinderGeometry(N.radius,N.radius,N.height,N.segmentsRadial,N.segmentsHeight,N.openEnded,O(N.thetaStart),O(N.thetaLength))}})},3934:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437);U("dodecahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(O){this.geometry=new $.DodecahedronGeometry(O.radius,O.detail)}})},4763:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437);U("icosahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(O){this.geometry=new $.IcosahedronGeometry(O.radius,O.detail)}})},6394:(ot,ht,I)=>{I(5459),I(2328),I(4907),I(6362),I(3934),I(4763),I(7049),I(6184),I(4110),I(7313),I(1394),I(6103),I(5553),I(7020)},7049:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437);U("octahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(O){this.geometry=new $.OctahedronGeometry(O.radius,O.detail)}})},6184:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437);U("plane",{schema:{height:{default:1,min:0},width:{default:1,min:0},segmentsHeight:{default:1,min:1,max:20,type:"int"},segmentsWidth:{default:1,min:1,max:20,type:"int"}},init:function(O){this.geometry=new $.PlaneGeometry(O.width,O.height,O.segmentsWidth,O.segmentsHeight)}})},4110:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437),O=$.MathUtils.degToRad;U("ring",{schema:{radiusInner:{default:.8,min:0},radiusOuter:{default:1.2,min:0},segmentsPhi:{default:10,min:1,type:"int"},segmentsTheta:{default:32,min:3,type:"int"},thetaLength:{default:360,min:0},thetaStart:{default:0}},init:function(N){this.geometry=new $.RingGeometry(N.radiusInner,N.radiusOuter,N.segmentsTheta,N.segmentsPhi,O(N.thetaStart),O(N.thetaLength))}})},7313:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437),O=$.MathUtils.degToRad;U("sphere",{schema:{radius:{default:1,min:0},phiLength:{default:360},phiStart:{default:0,min:0},thetaLength:{default:180,min:0},thetaStart:{default:0},segmentsHeight:{default:18,min:2,type:"int"},segmentsWidth:{default:36,min:3,type:"int"}},init:function(N){this.geometry=new $.SphereGeometry(N.radius,N.segmentsWidth,N.segmentsHeight,O(N.phiStart),O(N.phiLength),O(N.thetaStart),O(N.thetaLength))}})},1394:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437);U("tetrahedron",{schema:{detail:{default:0,min:0,max:5,type:"int"},radius:{default:1,min:0}},init:function(O){this.geometry=new $.TetrahedronGeometry(O.radius,O.detail)}})},6103:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437),O=$.MathUtils.degToRad;U("torus",{schema:{arc:{default:360},radius:{default:1,min:0},radiusTubular:{default:.2,min:0},segmentsRadial:{default:36,min:2,type:"int"},segmentsTubular:{default:32,min:3,type:"int"}},init:function(N){this.geometry=new $.TorusGeometry(N.radius,2*N.radiusTubular,N.segmentsRadial,N.segmentsTubular,O(N.arc))}})},5553:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437);U("torusKnot",{schema:{p:{default:2,min:1},q:{default:3,min:1},radius:{default:1,min:0},radiusTubular:{default:.2,min:0},segmentsRadial:{default:8,min:3,type:"int"},segmentsTubular:{default:100,min:3,type:"int"}},init:function(O){this.geometry=new $.TorusKnotGeometry(O.radius,2*O.radiusTubular,O.segmentsTubular,O.segmentsRadial,O.p,O.q)}})},7020:(ot,ht,I)=>{var U=I(7045).Az,$=I(9437),O=new $.Quaternion,N=new $.Vector3(0,0,1),_=new $.Vector2,E=new $.Vector2,D=new $.Vector2;U("triangle",{schema:{vertexA:{type:"vec3",default:{x:0,y:.5,z:0}},vertexB:{type:"vec3",default:{x:-.5,y:-.5,z:0}},vertexC:{type:"vec3",default:{x:.5,y:-.5,z:0}}},init:function(B){var C,M,k,F,G,Q,lt,rt;(k=new $.Triangle).a.set(B.vertexA.x,B.vertexA.y,B.vertexA.z),k.b.set(B.vertexB.x,B.vertexB.y,B.vertexB.z),k.c.set(B.vertexC.x,B.vertexC.y,B.vertexC.z),M=k.getNormal(new $.Vector3),O.setFromUnitVectors(M,N),F=k.a.clone().applyQuaternion(O),G=k.b.clone().applyQuaternion(O),Q=k.c.clone().applyQuaternion(O),_.set(Math.min(F.x,G.x,Q.x),Math.min(F.y,G.y,Q.y)),E.set(Math.max(F.x,G.x,Q.x),Math.max(F.y,G.y,Q.y)),D.set(0,0).subVectors(E,_),F=(new $.Vector2).subVectors(F,_).divide(D),G=(new $.Vector2).subVectors(G,_).divide(D),Q=(new $.Vector2).subVectors(Q,_).divide(D),C=this.geometry=new $.BufferGeometry,lt=[M.x,M.y,M.z,M.x,M.y,M.z,M.x,M.y,M.z],rt=[F.x,F.y,G.x,G.y,Q.x,Q.y],C.setAttribute("position",new $.Float32BufferAttribute([k.a.x,k.a.y,k.a.z,k.b.x,k.b.y,k.b.z,k.c.x,k.c.y,k.c.z],3)),C.setAttribute("normal",new $.Float32BufferAttribute(lt,3)),C.setAttribute("uv",new $.Float32BufferAttribute(rt,2))}})},4497:(ot,ht,I)=>{if(window.hasNativeWebVRImplementation=!!window.navigator.getVRDisplays||!!window.navigator.getVRDevices,window.hasNativeWebXRImplementation=void 0!==navigator.xr,!window.hasNativeWebXRImplementation&&!window.hasNativeWebVRImplementation){var U=I(4500)(window.navigator.userAgent)?1/window.devicePixelRatio:1,$=I(9835),O={BUFFER_SCALE:U,CARDBOARD_UI_DISABLED:!0,ROTATE_INSTRUCTIONS_DISABLED:!0,MOBILE_WAKE_LOCK:!!window.cordova};window.webvrpolyfill=new $(O)}var N=I(7427),_=N.debug,E=_("A-Frame:error"),D=_("A-Frame:warn");window.document.currentScript&&window.document.currentScript.parentNode!==window.document.head&&!window.debug&&D("Put the A-Frame <script> tag in the <head> of the HTML *before* the scene to ensure everything for A-Frame is properly registered before they are used from HTML."),window.cordova||"file:"!==window.location.protocol||E("This HTML file is currently being served via the file:// protocol. Assets, textures, and models WILL NOT WORK due to cross-origin policy! Please use a local or hosted server: https://aframe.io/docs/1.4.0/introduction/installation.html#use-a-local-server."),N.device.isBrowserEnvironment&&(I(7180),I(9379));var B=I(5076).aQ,C=I(8190).components,M=I(8190).registerComponent,k=I(7045).Az,F=I(5920).registerPrimitive,G=I(5892).registerShader,Q=I(1876).registerSystem,X=I(5892).shaders,lt=I(1876).systems,rt=window.THREE=I(9437),pt=I(2849),vt=I(8330);I(8850),I(6394),I(344),I(3072);var bt=I(2203).a,ft=I(4056).P;I(842),I(6178),I(5890),I(258),I(196),console.log("A-Frame Version: 1.6.0 (Date 2024-05-23, Commit #0e2163bd)"),console.log("THREE Version (https://github.com/supermedium/three.js):",rt.REVISION),console.log("WebVR Polyfill Version:",vt.dependencies["webvr-polyfill"]),window.AFRAME_ASYNC||pt.waitForDocumentReadyState(),ot.exports=window.AFRAME={AComponent:I(8190).Component,AEntity:ft,ANode:bt,ANIME:I(4635).A,AScene:B,components:C,coreComponents:Object.keys(C),geometries:I(7045).to,registerComponent:M,registerGeometry:k,registerPrimitive:F,registerShader:G,registerSystem:Q,primitives:{getMeshMixin:I(1028),primitives:I(5920).primitives},scenes:I(8313),schema:I(7282),shaders:X,systems:lt,emitReady:pt.emitReady,THREE:rt,utils:N,version:vt.version}},8132:ot=>{window.aframeStats=function(ht){var I=null,U=ht;return{update:function(){var $;I("te").set(($=U.querySelectorAll("*"),Array.prototype.slice.call($).filter(function(O){return O.isEntity}),$.length)),window.performance.getEntriesByName&&I("lt").set(window.performance.getEntriesByName("render-started")[0].startTime.toFixed(0))},start:function(){},end:function(){},attach:function($){I=$},values:{te:{caption:"Entities"},lt:{caption:"Load Time"}},groups:[{caption:"A-Frame",values:["te","lt"]}],fractions:[]}},ot.exports={aframeStats:window.aframeStats}},9437:(ot,ht,I)=>{var U=I(9611).A;I.g.THREE=U,I(7469),U.Cache&&(U.Cache.enabled=!0),ot.exports=U},2621:(ot,ht,I)=>{var U=I(5892).registerShader,$=I(9437),O=I(7427);function N(_,E){return E.color.set(_.color),E.fog=_.fog,E.wireframe=_.wireframe,E.toneMapped=_.toneMapped,E.wireframeLinewidth=_.wireframeLinewidth,E}ot.exports.Shader=U("flat",{schema:{color:{type:"color"},fog:{default:!0},height:{default:256},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},src:{type:"map"},width:{default:512},wireframe:{default:!1},wireframeLinewidth:{default:2},toneMapped:{default:!0}},init:function(_){this.materialData={color:new $.Color},N(_,this.materialData),this.material=new $.MeshBasicMaterial(this.materialData)},update:function(_){this.updateMaterial(_),O.material.updateMap(this,_)},updateMaterial:function(_){var E;for(E in N(_,this.materialData),this.materialData)this.material[E]=this.materialData[E]}})},344:(ot,ht,I)=>{I(2621),I(9583),I(8318),I(6419),I(1152),I(7002)},1152:(ot,ht,I)=>{var U=I(5892).registerShader,$=I(9437),O=["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","out vec2 vUV;","void main(void) {","  vUV = uv;","  #include <begin_vertex>","  #include <project_vertex>","  #include <logdepthbuf_vertex>","  #include <fog_vertex>","}"].join("\n"),N=["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform bool negate;","uniform float alphaTest;","uniform float opacity;","uniform sampler2D map;","uniform vec3 color;","in vec2 vUV;","float median(float r, float g, float b) {","  return max(min(r, g), min(max(r, g), b));","}","#define BIG_ENOUGH 0.001","#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)","void main() {","  vec3 sampleColor = texture(map, vUV).rgb;","  if (negate) { sampleColor = 1.0 - sampleColor; }","  float sigDist = median(sampleColor.r, sampleColor.g, sampleColor.b) - 0.5;","  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);","  float dscale = 0.353505;","  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));","  float isBigEnough = max(abs(duv.x), abs(duv.y));","  // Do modified alpha test.","  if (isBigEnough > BIG_ENOUGH) {","    float ratio = BIG_ENOUGH / isBigEnough;","    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);","  }","  // Do modified alpha test.","  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }","  gl_FragColor = vec4(color.xyz, alpha * opacity);","  #include <logdepthbuf_fragment>","  #include <tonemapping_fragment>","  #include <colorspace_fragment>","  #include <fog_fragment>","}"].join("\n");ot.exports.Shader=U("msdf",{schema:{alphaTest:{type:"number",is:"uniform",default:.5},color:{type:"color",is:"uniform",default:"white"},map:{type:"map",is:"uniform"},negate:{type:"boolean",is:"uniform",default:!0},opacity:{type:"number",is:"uniform",default:1}},vertexShader:O,fragmentShader:N,init:function(){return this.uniforms=$.UniformsUtils.merge([$.UniformsLib.fog,this.initUniforms()]),this.material=new $.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,fog:!0}),this.material}})},8318:(ot,ht,I)=>{var U=I(5892).registerShader,$=I(9437),O=I(7427);function N(_,E){switch(E.color.set(_.color),E.specular.set(_.specular),E.emissive.set(_.emissive),E.emissiveIntensity=_.emissiveIntensity,E.fog=_.fog,E.transparent=_.transparent,E.wireframe=_.wireframe,E.wireframeLinewidth=_.wireframeLinewidth,E.shininess=_.shininess,E.flatShading=_.flatShading,E.wireframe=_.wireframe,E.wireframeLinewidth=_.wireframeLinewidth,E.reflectivity=_.reflectivity,E.refractionRatio=_.refractionRatio,_.combine){case"mix":E.combine=$.MixOperation;break;case"multiply":E.combine=$.MultiplyOperation;break;case"add":E.combine=$.AddOperation}return _.normalMap&&(E.normalScale=_.normalScale),_.ambientOcclusionMap&&(E.aoMapIntensity=_.ambientOcclusionMapIntensity),_.bumpMap&&(E.bumpScale=_.bumpMapScale),_.displacementMap&&(E.displacementScale=_.displacementScale,E.displacementBias=_.displacementBias),E}ot.exports.Shader=U("phong",{schema:{color:{type:"color"},emissive:{type:"color",default:"black"},emissiveIntensity:{default:1},specular:{type:"color",default:"#111111"},transparent:{default:!1},fog:{default:!0},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},src:{type:"map"},envMap:{default:""},sphericalEnvMap:{type:"map"},shininess:{default:30},flatShading:{default:!1},wireframe:{default:!1},wireframeLinewidth:{default:2},combine:{oneOF:["multiply","mix","add"],default:"mix"},reflectivity:{default:.9},refractionRatio:{default:.98},refract:{default:!1},normalMap:{type:"map"},normalScale:{type:"vec2",default:{x:1,y:1}},normalTextureOffset:{type:"vec2"},normalTextureRepeat:{type:"vec2",default:{x:1,y:1}},ambientOcclusionMap:{type:"map"},ambientOcclusionMapIntensity:{default:1},displacementMap:{type:"map"},displacementScale:{default:1},displacementBias:{default:.5},displacementTextureOffset:{type:"vec2"},displacementTextureRepeat:{type:"vec2",default:{x:1,y:1}},bumpMap:{type:"map"},bumpMapScale:{default:1},bumpTextureOffset:{type:"vec2"},bumpTextureRepeat:{type:"vec2",default:{x:1,y:1}}},init:function(_){this.materialData={color:new $.Color,specular:new $.Color,emissive:new $.Color},N(_,this.materialData),this.material=new $.MeshPhongMaterial(this.materialData);var E=this.el.sceneEl;Object.defineProperty(this.material,"envMap",{get:function(){return this._envMap||E.object3D.environment},set:function(D){this._envMap=D}})},update:function(_){this.updateMaterial(_),O.material.updateMap(this,_),O.material.updateDistortionMap("normal",this,_),O.material.updateDistortionMap("displacement",this,_),O.material.updateDistortionMap("ambientOcclusion",this,_),O.material.updateDistortionMap("bump",this,_),O.material.updateEnvMap(this,_)},updateMaterial:function(_){var E;for(E in N(_,this.materialData),this.materialData)this.material[E]=this.materialData[E]}})},6419:(ot,ht,I)=>{var U=I(5892).registerShader,$=I(9437),O=["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","out vec2 vUV;","void main(void) {","  vUV = uv;","  #include <begin_vertex>","  #include <project_vertex>","  #include <logdepthbuf_vertex>","  #include <fog_vertex>","}"].join("\n"),N=["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform float alphaTest;","uniform float opacity;","uniform sampler2D map;","uniform vec3 color;","in vec2 vUV;","float contour(float width, float value) {","  return smoothstep(0.5 - value, 0.5 + value, width);","}","#define BIG_ENOUGH 0.001","#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)","void main() {","  vec2 uv = vUV;","  vec4 texColor = texture(map, uv);","  float dist = texColor.a;","  float width = fwidth(dist);","  float alpha = contour(dist, width);","  float dscale = 0.353505;","  vec2 duv = dscale * (dFdx(uv) + dFdy(uv));","  float isBigEnough = max(abs(duv.x), abs(duv.y));","  if (isBigEnough > BIG_ENOUGH) {","    float ratio = BIG_ENOUGH / isBigEnough;","    alpha = ratio * alpha + (1.0 - ratio) * dist;","  }","  if (isBigEnough <= BIG_ENOUGH) {","    vec4 box = vec4 (uv - duv, uv + duv);","    alpha = (alpha + 0.5 * (","      contour(texture(map, box.xy).a, width)","      + contour(texture(map, box.zw).a, width)","      + contour(texture(map, box.xw).a, width)","      + contour(texture(map, box.zy).a, width)","    )) / 3.0;","  }","  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }","  gl_FragColor = vec4(color, opacity * alpha);","  #include <logdepthbuf_fragment>","  #include <tonemapping_fragment>","  #include <colorspace_fragment>","  #include <fog_fragment>","}"].join("\n");ot.exports.Shader=U("sdf",{schema:{alphaTest:{type:"number",is:"uniform",default:.5},color:{type:"color",is:"uniform",default:"white"},map:{type:"map",is:"uniform"},opacity:{type:"number",is:"uniform",default:1}},vertexShader:O,fragmentShader:N,init:function(){return this.uniforms=$.UniformsUtils.merge([$.UniformsLib.fog,this.initUniforms()]),this.material=new $.ShaderMaterial({uniforms:this.uniforms,vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,fog:!0}),this.material}})},7002:(ot,ht,I)=>{var U=I(5892).registerShader,$=I(9437);ot.exports.Shader=U("shadow",{schema:{opacity:{default:.5},transparent:{default:!0},alphaToCoverage:{default:!0}},init:function(O){this.material=new $.ShadowMaterial},update:function(O){this.material.opacity=O.opacity,this.material.alphaToCoverage=O.alphaToCoverage,this.material.transparent=O.transparent}})},9583:(ot,ht,I)=>{var U=I(5892).registerShader,$=I(9437),O=I(7427);function N(_,E){return E.color.set(_.color),E.emissive.set(_.emissive),E.emissiveIntensity=_.emissiveIntensity,E.fog=_.fog,E.metalness=_.metalness,E.roughness=_.roughness,E.wireframe=_.wireframe,E.wireframeLinewidth=_.wireframeLinewidth,_.normalMap&&(E.normalScale=_.normalScale),_.ambientOcclusionMap&&(E.aoMapIntensity=_.ambientOcclusionMapIntensity),_.displacementMap&&(E.displacementScale=_.displacementScale,E.displacementBias=_.displacementBias),E}ot.exports.Shader=U("standard",{schema:{ambientOcclusionMap:{type:"map"},ambientOcclusionMapIntensity:{default:1},ambientOcclusionTextureOffset:{type:"vec2"},ambientOcclusionTextureRepeat:{type:"vec2",default:{x:1,y:1}},color:{type:"color"},displacementMap:{type:"map"},displacementScale:{default:1},displacementBias:{default:.5},displacementTextureOffset:{type:"vec2"},displacementTextureRepeat:{type:"vec2",default:{x:1,y:1}},emissive:{type:"color",default:"#000"},emissiveIntensity:{default:1},envMap:{default:""},fog:{default:!0},height:{default:256},metalness:{default:0,min:0,max:1},metalnessMap:{type:"map"},metalnessTextureOffset:{type:"vec2"},metalnessTextureRepeat:{type:"vec2",default:{x:1,y:1}},normalMap:{type:"map"},normalScale:{type:"vec2",default:{x:1,y:1}},normalTextureOffset:{type:"vec2"},normalTextureRepeat:{type:"vec2",default:{x:1,y:1}},offset:{type:"vec2",default:{x:0,y:0}},repeat:{type:"vec2",default:{x:1,y:1}},roughness:{default:.5,min:0,max:1},roughnessMap:{type:"map"},roughnessTextureOffset:{type:"vec2"},roughnessTextureRepeat:{type:"vec2",default:{x:1,y:1}},sphericalEnvMap:{type:"map"},src:{type:"map"},width:{default:512},wireframe:{default:!1},wireframeLinewidth:{default:2}},init:function(_){this.materialData={color:new $.Color,emissive:new $.Color},N(_,this.materialData),this.material=new $.MeshStandardMaterial(this.materialData)},update:function(_){this.updateMaterial(_),O.material.updateMap(this,_),O.material.updateDistortionMap("normal",this,_),O.material.updateDistortionMap("displacement",this,_),O.material.updateDistortionMap("ambientOcclusion",this,_),O.material.updateDistortionMap("metalness",this,_),O.material.updateDistortionMap("roughness",this,_),O.material.updateEnvMap(this,_)},updateMaterial:function(_){var E,D=this.material;for(E in N(_,this.materialData),this.materialData)D[E]=this.materialData[E]}})},409:(ot,ht,I)=>{var U=I(1343),$=I(1876).registerSystem,O="data-aframe-default-camera";ot.exports.System=$("camera",{init:function(){this.activeCameraEl=null,this.render=this.render.bind(this),this.unwrapRender=this.unwrapRender.bind(this),this.wrapRender=this.wrapRender.bind(this),this.initialCameraFound=!1,this.numUserCameras=0,this.numUserCamerasChecked=0,this.setupInitialCamera()},setupInitialCamera:function(){var N,_,E=this.sceneEl,D=this;if(!E.camera||E.camera.el.getAttribute("camera").spectator)if((N=E.querySelectorAll("a-camera, :not(a-mixin)[camera]")).length)for(this.numUserCameras=N.length,_=0;_<N.length;_++)N[_].addEventListener("object3dset",function(B){"camera"===B.detail.type&&D.checkUserCamera(this)}),N[_].isNode?N[_].load():N[_].addEventListener("nodeready",function(){this.load()});else this.createDefaultCamera();else E.emit("cameraready",{cameraEl:E.camera.el})},checkUserCamera:function(N){var _,E=this.el.sceneEl;this.numUserCamerasChecked++,this.initialCameraFound||((_=N.getAttribute("camera")).active&&!_.spectator?(this.initialCameraFound=!0,E.camera=N.getObject3D("camera"),E.emit("cameraready",{cameraEl:N})):this.numUserCamerasChecked===this.numUserCameras&&this.createDefaultCamera())},createDefaultCamera:function(){var N,_=this.sceneEl;(N=document.createElement("a-entity")).setAttribute("camera",{active:!0}),N.setAttribute("position",{x:0,y:U.DEFAULT_CAMERA_HEIGHT,z:0}),N.setAttribute("wasd-controls",""),N.setAttribute("look-controls",""),N.setAttribute(U.AFRAME_INJECTED,""),N.addEventListener("object3dset",function(E){"camera"===E.detail.type&&(_.camera=E.detail.object,_.emit("cameraready",{cameraEl:N}))}),_.appendChild(N)},disableActiveCamera:function(){var N;(N=this.sceneEl.querySelectorAll(":not(a-mixin)[camera]"))[N.length-1].setAttribute("camera","active",!0)},setActiveCamera:function(N){var _,E,D,B,F,G,C=this.activeCameraEl,M=this.sceneEl;if((B=N.getObject3D("camera"))&&N!==this.activeCameraEl){var k=M.querySelector("["+O+"]");for(N!==(k&&k.querySelector(":not(a-mixin)[camera]"))&&(G=void 0,(F=M).camera&&(G=F.querySelector("["+O+"]"))&&F.removeChild(G)),this.activeCameraEl=N,this.activeCameraEl.play(),M.camera=B,C&&C.setAttribute("camera","active",!1),E=M.querySelectorAll(":not(a-mixin)[camera]"),D=0;D<E.length;D++)(_=E[D]).isEntity&&N!==_&&(_.setAttribute("camera","active",!1),_.pause());M.emit("camera-set-active",{cameraEl:N})}},setSpectatorCamera:function(N){var _,E=this.spectatorCameraEl,D=this.sceneEl;N.getObject3D("camera")&&N!==this.spectatorCameraEl&&(E&&E.setAttribute("camera","spectator",!1),_=this.spectatorCameraEl=N,D.addEventListener("enter-vr",this.wrapRender),D.addEventListener("exit-vr",this.unwrapRender),_.setAttribute("camera","active",!1),_.play(),D.emit("camera-set-spectator",{cameraEl:N}))},disableSpectatorCamera:function(){this.spectatorCameraEl=void 0},wrapRender:function(){this.spectatorCameraEl&&!this.originalRender&&(this.originalRender=this.sceneEl.renderer.render,this.sceneEl.renderer.render=this.render)},unwrapRender:function(){this.originalRender&&(this.sceneEl.renderer.render=this.originalRender,this.originalRender=void 0)},render:function(N,_){var E,D,B=this.sceneEl;E=B.renderer.xr.enabled,this.originalRender.call(B.renderer,N,_),this.spectatorCameraEl&&!B.isMobile&&E&&(D=this.spectatorCameraEl.components.camera.camera,B.renderer.xr.enabled=!1,this.originalRender.call(B.renderer,N,D),B.renderer.xr.enabled=E)}})},810:(ot,ht,I)=>{var U=I(7045).to,$=I(1876).registerSystem;function O(N){var _=N.primitive,E=U[_]&&U[_].Geometry,D=new E;if(!E)throw new Error("Unknown geometry `"+_+"`");return D.init(N),D.geometry}ot.exports.System=$("geometry",{init:function(){this.cache={},this.cacheCount={}},clearCache:function(){this.cache={},this.cacheCount={}},getOrCreateGeometry:function(N){var _,E,B,C,D=this.cache;return N.skipCache?O(N):(_=D[E=this.hash(N)],(B=this.cacheCount)[C=E]=void 0===B[C]?1:B[C]+1,_||(_=O(N),D[E]=_,_))},unuseGeometry:function(N){var _,E=this.cache,D=this.cacheCount;N.skipCache||E[_=this.hash(N)]&&(D[_]--,D[_]>0||(E[_].dispose(),delete E[_],delete D[_]))},hash:function(N){return JSON.stringify(N)}})},4211:(ot,ht,I)=>{var U=I(1876).registerSystem,$=I(9437);ot.exports.System=U("gltf-model",{schema:{dracoDecoderPath:{default:"https://www.gstatic.com/draco/versioned/decoders/1.5.6/"},basisTranscoderPath:{default:""},meshoptDecoderPath:{default:""}},init:function(){this.update()},update:function(){var O,N=this.data.dracoDecoderPath,_=this.data.basisTranscoderPath,E=this.data.meshoptDecoderPath;!this.dracoLoader&&N&&(this.dracoLoader=new $.DRACOLoader,this.dracoLoader.setDecoderPath(N)),!this.ktx2Loader&&_&&(this.ktx2Loader=new $.KTX2Loader,this.ktx2Loader.setTranscoderPath(_).detectSupport(this.el.renderer)),!this.meshoptDecoder&&E&&(this.meshoptDecoder=(O=E,new Promise(function(D,B){var C=document.createElement("script");document.body.appendChild(C),C.onload=D,C.onerror=B,C.async=!0,C.src=O})).then(function(){return window.MeshoptDecoder.ready}).then(function(){return window.MeshoptDecoder}))},getDRACOLoader:function(){return this.dracoLoader},getKTX2Loader:function(){return this.ktx2Loader},getMeshoptDecoder:function(){return this.meshoptDecoder}})},3072:(ot,ht,I)=>{I(409),I(810),I(4211),I(6540),I(1855),I(2382),I(6769),I(5426),I(5078),I(3448),I(6696)},6540:(ot,ht,I)=>{var U=I(1876).registerSystem,$=I(1343),O="data-aframe-default-light";ot.exports.System=U("light",{schema:{defaultLightsEnabled:{default:!0}},init:function(){this.defaultLights=!1,this.userDefinedLights=!1,this.sceneEl.addEventListener("loaded",this.setupDefaultLights.bind(this))},registerLight:function(N){N.hasAttribute(O)||(this.removeDefaultLights(),this.userDefinedLights=!0)},removeDefaultLights:function(){var N,_=this.sceneEl;if(this.defaultLights){N=document.querySelectorAll("["+O+"]");for(var E=0;E<N.length;E++)_.removeChild(N[E]);this.defaultLights=!1}},setupDefaultLights:function(){var N,_,E=this.sceneEl;this.userDefinedLights||this.defaultLights||!this.data.defaultLightsEnabled||((N=document.createElement("a-entity")).setAttribute("light",{color:"#BBB",type:"ambient"}),N.setAttribute(O,""),N.setAttribute($.AFRAME_INJECTED,""),E.appendChild(N),(_=document.createElement("a-entity")).setAttribute("light",{color:"#FFF",intensity:.6,castShadow:!0}),_.setAttribute("position",{x:-.5,y:1,z:1}),_.setAttribute(O,""),_.setAttribute($.AFRAME_INJECTED,""),E.appendChild(_),this.defaultLights=!0)}})},1855:(ot,ht,I)=>{var U=I(1876).registerSystem,$=I(9437),O=I(7427),N=I(8066).setTextureProperties,_=I(8066).createCompatibleTexture,E=O.debug,D=E("components:texture:error"),B=E("components:texture:warn"),C=new $.ImageLoader;ot.exports.System=U("material",{init:function(){this.materials={},this.sourceCache={}},clearTextureSourceCache:function(){this.sourceCache={}},loadTexture:function(M,k,F){this.loadTextureSource(M,function(G){var Q=_(G);N(Q,k),F(Q)})},loadTextureSource:function(M,k){var F=this,G=this.sourceCache,Q=this.hash(M);G[Q]?G[Q].then(k):function X(lt){G[Q]=Promise.resolve(lt),G[Q].then(k)}("CANVAS"!==M.tagName?new Promise(function(lt,rt){O.srcLoader.validateSrc(M,function(pt){F.loadImage(pt,lt)},function(pt){F.loadVideo(pt,lt)})}):new $.Source(M))},loadCubeMapTexture:function(M,k){var F=this,G=0,Q=new $.CubeTexture;function X(rt){F.loadTextureSource(M[rt],function(pt){Q.images[rt]=pt,6==++G&&(Q.needsUpdate=!0,k(Q))})}if(Q.colorSpace=$.SRGBColorSpace,6===M.length)for(var lt=0;lt<M.length;lt++)X(lt);else B("Cube map texture requires exactly 6 sources, got only %s sources",M.length)},loadImage:function(M,k){var F;k("string"==typeof M?(F=M,new Promise(function(G,Q){C.load(F,function(X){G(new $.Source(X))},function(){},function(X){D("`$s` could not be fetched (Error code: %s; Response: %s)",X.status,X.statusText)})})):new $.Source(M))},loadVideo:function(M,k){var F,G;"string"!=typeof M&&((G=F=M).autoplay=G.hasAttribute("autoplay")&&"false"!==G.getAttribute("autoplay"),G.controls=G.hasAttribute("controls")&&"false"!==G.getAttribute("controls"),"false"===G.getAttribute("loop")&&G.removeAttribute("loop"),"false"===G.getAttribute("preload")&&(G.preload="none"),G.crossOrigin=G.crossOrigin||"anonymous",G.setAttribute("playsinline",""),G.setAttribute("webkit-playsinline","")),F=F||function(G){var Q=document.createElement("video");return Q.setAttribute("playsinline",""),Q.setAttribute("webkit-playsinline",""),Q.autoplay=!0,Q.loop=!0,Q.crossOrigin="anonymous",Q.addEventListener("error",function(){B("`%s` is not a valid video",G)},!0),Q.src=G,Q}(M),k(new $.Source(F))},hash:function(M){return M.tagName&&(M.id||M.src)||M},registerMaterial:function(M){this.materials[M.uuid]=M},unregisterMaterial:function(M){delete this.materials[M.uuid]}})},2382:(ot,ht,I)=>{(0,I(1876).registerSystem)("obb-collider",{schema:{showColliders:{default:!1}},init:function(){this.collisions=[],this.colliderEls=[]},addCollider:function(U){this.colliderEls.push(U),this.data.showColliders?U.components["obb-collider"].showCollider():U.components["obb-collider"].hideCollider(),this.tick=this.detectCollisions},removeCollider:function(U){var $=this.colliderEls,O=$.indexOf(U);U.components["obb-collider"].hideCollider(),O>-1&&$.splice(O,1),0===$.length&&(this.tick=void 0)},registerCollision:function(U,$){var O=this.collisions,N=!1,_=U.obb,E=$.obb,D=U.renderColliderMesh,B=$.renderColliderMesh;D&&D.material.color.set(16711680),B&&B.material.color.set(16711680);for(var C=0;C<O.length;C++)if(O[C].componentA.obb===_&&O[C].componentB.obb===E||O[C].componentA.obb===E&&O[C].componentB.obb===_){N=!0,O[C].detected=!0;break}N||(O.push({componentA:U,componentB:$,detected:!0}),U.el.emit("obbcollisionstarted",{trackedObject3D:U.trackedObject3D,withEl:$.el}),$.el.emit("obbcollisionstarted",{trackedObject3D:$.trackedObject3D,withEl:U.el}))},resetCollisions:function(){for(var U=this.collisions,$=0;$<U.length;$++)U[$].detected=!1},clearCollisions:function(){for(var U,$,O,N,_=this.collisions,E=[],D=0;D<_.length;D++)_[D].detected?E.push(_[D]):(N=($=_[D].componentB).renderColliderMesh,(O=(U=_[D].componentA).renderColliderMesh)&&O.material.color.set(65280),U.el.emit("obbcollisionended",{trackedObject3D:this.trackedObject3D,withEl:$.el}),N&&N.material.color.set(65280),$.el.emit("obbcollisionended",{trackedObject3D:this.trackedObject3D,withEl:U.el}));this.collisions=E},detectCollisions:function(){var U,$,O,N,_=this.colliderEls;if(!(_.length<2)){this.resetCollisions();for(var E=0;E<_.length;E++)if(O=_[E].components["obb-collider"],0!==(U=_[E].components["obb-collider"].obb).halfSize.x&&0!==U.halfSize.y&&0!==U.halfSize.z)for(var D=E+1;D<_.length;D++)0!==($=(N=_[D].components["obb-collider"]).obb).halfSize.x&&0!==$.halfSize.y&&0!==$.halfSize.z&&U.intersectsOBB($)&&this.registerCollision(O,N);this.clearCollisions()}}})},6769:(ot,ht,I)=>{var U=I(1876).registerSystem,$=I(7427),O=I(9437),N=(0,$.debug)("components:renderer:warn");function _(B,C){return B.groupOrder!==C.groupOrder?B.groupOrder-C.groupOrder:B.renderOrder!==C.renderOrder?B.renderOrder-C.renderOrder:B.z-C.z}function E(B,C){return B.groupOrder!==C.groupOrder?B.groupOrder-C.groupOrder:B.renderOrder-C.renderOrder}function D(B,C){return B.groupOrder!==C.groupOrder?B.groupOrder-C.groupOrder:B.renderOrder!==C.renderOrder?B.renderOrder-C.renderOrder:C.z-B.z}ot.exports.System=U("renderer",{schema:{antialias:{default:"auto",oneOf:["true","false","auto"]},highRefreshRate:{default:$.device.isOculusBrowser()},logarithmicDepthBuffer:{default:"auto",oneOf:["true","false","auto"]},maxCanvasWidth:{default:-1},maxCanvasHeight:{default:-1},multiviewStereo:{default:!1},physicallyCorrectLights:{default:!1},exposure:{default:1,if:{toneMapping:["ACESFilmic","linear","reinhard","cineon"]}},toneMapping:{default:"no",oneOf:["no","ACESFilmic","linear","reinhard","cineon"]},precision:{default:"high",oneOf:["high","medium","low"]},anisotropy:{default:1},sortTransparentObjects:{default:!1},colorManagement:{default:!0},alpha:{default:!0},stencil:{default:!1},foveationLevel:{default:1}},init:function(){var B=this.data,C=this.el,M=this.data.toneMapping.charAt(0).toUpperCase()+this.data.toneMapping.slice(1),k=C.renderer;B.physicallyCorrectLights||(k.useLegacyLights=!B.physicallyCorrectLights),k.toneMapping=O[M+"ToneMapping"],O.Texture.DEFAULT_ANISOTROPY=B.anisotropy,O.ColorManagement.enabled=B.colorManagement,k.outputColorSpace=B.colorManagement?O.SRGBColorSpace:O.LinearSRGBColorSpace,C.hasAttribute("antialias")&&N('Component `antialias` is deprecated. Use `renderer="antialias: true"` instead.'),C.hasAttribute("logarithmicDepthBuffer")&&N('Component `logarithmicDepthBuffer` is deprecated. Use `renderer="logarithmicDepthBuffer: true"` instead.'),k.sortObjects=!0,k.setOpaqueSort(_)},update:function(){var B=this.data,C=this.el.renderer,M=this.data.toneMapping.charAt(0).toUpperCase()+this.data.toneMapping.slice(1);C.toneMapping=O[M+"ToneMapping"],C.toneMappingExposure=B.exposure,C.xr.setFoveation(B.foveationLevel),B.sortObjects&&N('`sortObjects` property is deprecated. Use `renderer="sortTransparentObjects: true"` instead.'),C.setTransparentSort(B.sortTransparentObjects?D:E)},applyColorCorrection:function(B){this.data.colorManagement&&B&&B.isTexture&&B.colorSpace!==O.SRGBColorSpace&&(B.colorSpace=O.SRGBColorSpace,B.needsUpdate=!0)},setWebXRFrameRate:function(B){var C,M=this.data,k=B.supportedFrameRates;k&&B.updateTargetFrameRate&&(C=k.includes(90)?M.highRefreshRate?90:72:M.highRefreshRate?72:60,B.updateTargetFrameRate(C).catch(function(F){console.warn("failed to set target frame rate of "+C+". Error info: "+F)}))}}),ot.exports.sortFrontToBack=_,ot.exports.sortRenderOrderOnly=E,ot.exports.sortBackToFront=D},5426:(ot,ht,I)=>{var U=I(1876).registerSystem,$=I(9437),O={basic:$.BasicShadowMap,pcf:$.PCFShadowMap,pcfsoft:$.PCFSoftShadowMap};ot.exports.System=U("shadow",{schema:{enabled:{default:!0},autoUpdate:{default:!0},type:{default:"pcf",oneOf:["basic","pcf","pcfsoft"]}},init:function(){var N=this.sceneEl,_=this.data;this.shadowMapEnabled=!1,N.renderer.shadowMap.type=O[_.type],N.renderer.shadowMap.autoUpdate=_.autoUpdate},update:function(N){N.enabled!==this.data.enabled&&this.setShadowMapEnabled(this.shadowMapEnabled)},setShadowMapEnabled:function(N){var _=this.sceneEl,E=this.sceneEl.renderer;this.shadowMapEnabled=N;var B,D=this.data.enabled&&this.shadowMapEnabled;E&&D!==E.shadowMap.enabled&&(E.shadowMap.enabled=D,(B=_).hasLoaded&&B.object3D.traverse(function(C){if(C.material)for(var M=Array.isArray(C.material)?C.material:[C.material],k=0;k<M.length;k++)M[k].needsUpdate=!0}))}})},5078:(ot,ht,I)=>{var U=I(1876).registerSystem,$=I(7427),O=$.device.isWebXRAvailable;ot.exports.System=U("tracked-controls-webvr",{init:function(){var N=this;this.controllers=[],this.isChrome=-1!==navigator.userAgent.indexOf("Chrome"),this.updateControllerList(),this.throttledUpdateControllerList=$.throttle(this.updateControllerList,500,this),O||navigator.getVRDisplays&&this.sceneEl.addEventListener("enter-vr",function(){navigator.getVRDisplays().then(function(_){_.length&&(N.vrDisplay=_[0])})})},tick:function(){this.isChrome?this.updateControllerList():this.throttledUpdateControllerList()},updateControllerList:function(){var N,_,E,D,B=this.controllers;if(_=navigator.getGamepads&&navigator.getGamepads()){for(D=B.length,B.length=0,E=0;E<_.length;++E)(N=_[E])&&N.pose&&B.push(N);B.length!==D&&this.el.emit("controllersupdated",void 0,!1)}}})},3448:(ot,ht,I)=>{var U=I(1876).registerSystem,$=I(7427);ot.exports.System=U("tracked-controls-webxr",{init:function(){this.controllers=[],this.oldControllers=[],this.oldControllersLength=0,this.throttledUpdateControllerList=$.throttle(this.updateControllerList,500,this),this.updateReferenceSpace=this.updateReferenceSpace.bind(this),this.el.addEventListener("enter-vr",this.updateReferenceSpace),this.el.addEventListener("exit-vr",this.updateReferenceSpace)},tick:function(){this.throttledUpdateControllerList()},updateReferenceSpace:function(){var O=this,N=this.el.xrSession;if(!N)return this.referenceSpace=void 0,this.controllers=[],void(this.oldControllersLength>0&&(this.oldControllersLength=0,this.el.emit("controllersupdated",void 0,!1)));var _=O.el.sceneEl.systems.webxr.sessionReferenceSpaceType;N.requestReferenceSpace(_).then(function(E){O.referenceSpace=E}).catch(function(E){throw O.el.sceneEl.systems.webxr.warnIfFeatureNotRequested(_,'tracked-controls-webxr uses reference space "'+_+'".'),E})},updateControllerList:function(){var O,N=this.el.xrSession,_=this.oldControllers;if(!N)return 0===this.oldControllersLength?void 0:(this.oldControllersLength=0,this.controllers=[],void this.el.emit("controllersupdated",void 0,!1));if(N.inputSources){if(this.controllers=N.inputSources,this.oldControllersLength===this.controllers.length){var E=!0;for(O=0;O<this.controllers.length;++O)if(this.controllers[O]!==_[O]||this.controllers[O].gamepad!==_[O].gamepad){E=!1;break}if(E)return}for(_.length=0,O=0;O<this.controllers.length;O++)_.push(this.controllers[O]);this.oldControllersLength=this.controllers.length,this.el.emit("controllersupdated",void 0,!1)}}})},6696:(ot,ht,I)=>{var U=I(1876).registerSystem,$=I(7427).debug("systems:webxr:warn");ot.exports.System=U("webxr",{schema:{referenceSpaceType:{type:"string",default:"local-floor"},requiredFeatures:{type:"array",default:["local-floor"]},optionalFeatures:{type:"array",default:["bounded-floor"]},overlayElement:{type:"selector"}},update:function(){var O=this.data;this.sessionConfiguration={requiredFeatures:O.requiredFeatures,optionalFeatures:O.optionalFeatures},this.sessionReferenceSpaceType=O.referenceSpaceType,O.overlayElement&&(O.overlayElement.classList.remove("a-dom-overlay"),O.optionalFeatures.includes("dom-overlay")||(O.optionalFeatures.push("dom-overlay"),this.el.setAttribute("webxr",O)),this.warnIfFeatureNotRequested("dom-overlay"),this.sessionConfiguration.domOverlay={root:O.overlayElement},O.overlayElement.classList.add("a-dom-overlay"))},wasFeatureRequested:function(O){return"viewer"===O||"local"===O||!(!this.sessionConfiguration.requiredFeatures.includes(O)&&!this.sessionConfiguration.optionalFeatures.includes(O))},warnIfFeatureNotRequested:function(O,N){this.wasFeatureRequested(O)||$((N?N+" ":"")+'Please add the feature "'+O+"\" to a-scene's webxr system options in requiredFeatures/optionalFeatures.")}})},676:(ot,ht,I)=>{var U=I(8940)("utils:coordinates:warn"),$=["x","y","z","w"],O=/^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/;ot.exports.regex=O;var N=/\s+/g;function _(D){return O.test(D)}function E(D){return null!=D&&D.constructor===String?parseFloat(D,10):D}ot.exports.parse=function(D,B,C){var M,k,F,G,Q,X,lt,rt,pt=C&&"object"==typeof C?C:{};if(D&&D instanceof Object)return X=void 0===D.y?B&&B.y:D.y,lt=void 0===D.z?B&&B.z:D.z,rt=void 0===D.w?B&&B.w:D.w,null!=(Q=void 0===D.x?B&&B.x:D.x)&&(pt.x=E(Q)),null!=X&&(pt.y=E(X)),null!=lt&&(pt.z=E(lt)),null!=rt&&(pt.w=E(rt)),pt;if(null==D)return"object"==typeof B?Object.assign(pt,B):B;for(M=D.trim().split(N),G=0;G<$.length;G++)if(F=$[G],M[G])pt[F]=parseFloat(M[G],10);else{if(void 0===(k=B&&B[F]))continue;pt[F]=E(k)}return pt},ot.exports.stringify=function(D){var B;return"object"!=typeof D?D:(B=D.x+" "+D.y,null!=D.z&&(B+=" "+D.z),null!=D.w&&(B+=" "+D.w),B)},ot.exports.equals=function(D,B){return"object"!=typeof D||"object"!=typeof B?D===B:D.x===B.x&&D.y===B.y&&D.z===B.z&&D.w===B.w},ot.exports.isCoordinates=_,ot.exports.isCoordinate=function(D){return U("`AFRAME.utils.isCoordinate` has been renamed to `AFRAME.utils.isCoordinates`"),_(D)},ot.exports.toVector3=function(D){return new THREE.Vector3(D.x,D.y,D.z)}},8940:(ot,ht,I)=>{var U=I(8878),$=I(9485).isBrowserEnvironment,O={colors:{debug:"gray",error:"red",info:"gray",warn:"orange"}};U.formatArgs=function(_){if(_[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+_[0]+(this.useColors?"%c ":" "),this.useColors){this.color=(k=this.namespace.split(":"),O.colors&&O.colors[k[k.length-1]]||null);var D="color: "+this.color;_.splice(1,0,D,"color: inherit");var B=0,C=0;_[0].replace(/%[a-zA-Z%]/g,function(M){"%%"!==M&&(B++,"%c"===M&&(C=B))}),_.splice(C,0,D)}var k};var N=function(){try{return window.localStorage}catch{}}();N&&(parseInt(N.logs,10)||"true"===N.logs)?U.enable("*"):U.enable("*:error,*:info,*:warn"),$&&(window.logs=U),ot.exports=U},9485:(ot,ht,I)=>{var U,$=I(8878)("device:error"),O=!1,N=!1,_=ot.exports.isWebXRAvailable=void 0!==navigator.xr;if(window.addEventListener("vrdisplayactivate",function(vt){var bt;_||(bt=document.createElement("canvas"),U=vt.display,bt.getContext("webgl",{}),U.requestPresent([{source:bt}]).then(function(){},function(){}))}),_){var E=function(){var vt=document.querySelector("a-scene");vt?vt.hasLoaded?vt.components["xr-mode-ui"].updateEnterInterfaces():vt.addEventListener("loaded",E):window.addEventListener("DOMContentLoaded",E)},D=function(vt){$("WebXR session support error: "+vt.message)};navigator.xr.isSessionSupported?(navigator.xr.isSessionSupported("immersive-vr").then(function(vt){O=vt,E()}).catch(D),navigator.xr.isSessionSupported("immersive-ar").then(function(vt){N=vt,E()}).catch(function(){})):navigator.xr.supportsSession?(navigator.xr.supportsSession("immersive-vr").then(function(){O=!0,E()}).catch(D),navigator.xr.supportsSession("immersive-ar").then(function(){N=!0,E()}).catch(function(){})):$("WebXR has neither isSessionSupported or supportsSession?!")}else navigator.getVRDisplays&&navigator.getVRDisplays().then(function(vt){var bt=document.querySelector("a-scene");U=vt.length&&vt[0],bt&&bt.emit("displayconnected",{vrDisplay:U})});function B(){return U}ot.exports.getVRDisplay=B,ot.exports.checkHeadsetConnected=function(){return O||N||!!B()},ot.exports.checkARSupport=function(){return N},ot.exports.checkVRSupport=function(){return O};var C,M,k=(M=!1,C=window.navigator.userAgent||window.navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(C)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(C.substr(0,4)))&&(M=!0),(Q()||F()||pt())&&(M=!0),rt()&&(M=!1),function(){return M});function F(vt){var bt=vt||window.navigator.userAgent;return/Nexus (7|9)|xoom|sch-i800|playbook|tablet|kindle/i.test(bt)||G()}function G(vt,bt,ft){var wt=vt||window.navigator.userAgent,et=bt||window.navigator.platform,xt=ft||window.navigator.maxTouchPoints||0;return("iPad"===et||"MacIntel"===et)&&xt>0&&/Macintosh|Intel|iPad|ipad/i.test(wt)&&!window.MSStream}function Q(){return/iPad|iPhone|iPod/.test(window.navigator.platform)}function X(){return/(OculusBrowser)/i.test(window.navigator.userAgent)}function lt(){return/(Mobile VR)/i.test(window.navigator.userAgent)}function rt(){return X()||lt()}function pt(){return/R7 Build/.test(window.navigator.userAgent)}ot.exports.isMobile=k,ot.exports.isTablet=F,ot.exports.isIpad=G,ot.exports.isIOS=Q,ot.exports.isMobileDeviceRequestingDesktopSite=function(){return!k()&&!rt()&&void 0!==window.orientation},ot.exports.isOculusBrowser=X,ot.exports.isFirefoxReality=lt,ot.exports.isMobileVR=rt,ot.exports.isR7=pt,ot.exports.isLandscape=function(){var vt=window.orientation;return pt()&&(vt+=90),90===vt||-90===vt},ot.exports.isBrowserEnvironment=typeof process>"u"||!0===process.browser,ot.exports.isNodeEnvironment=!ot.exports.isBrowserEnvironment},7264:(ot,ht,I)=>{var U=I(8183).split;function $(O,N){var _=U(O,N=N||".");return 1===_.length?_[0]:_}ot.exports.getComponentPropertyPath=$,ot.exports.getComponentProperty=function(O,N,_){var E;return-1!==N.indexOf(_=_||".")?(E=$(N,_)).constructor===String?O.getAttribute(E):O.getAttribute(E[0])[E[1]]:O.getAttribute(N)},ot.exports.setComponentProperty=function(O,N,_,E){var D;-1===N.indexOf(E=E||".")?O.setAttribute(N,_):(D=$(N,E)).constructor===String?O.setAttribute(D,_):O.setAttribute(D[0],D[1],_)}},9202:ot=>{ot.exports=function(ht){var I=ht.style.width,U=ht.style.height;ht.style.width=parseInt(I,10)+1+"px",ht.style.height=parseInt(U,10)+1+"px",setTimeout(function(){ht.style.width=I,ht.style.height=U},200)}},7427:(ot,ht,I)=>{var U=I(8940),$=I(1124),O=I(9485),N=I(1451),_=U("utils:warn");ot.exports.bind=function(C){return C.bind.apply(C,Array.prototype.slice.call(arguments,1))},ot.exports.coordinates=I(676),ot.exports.debug=U,ot.exports.device=O,ot.exports.entity=I(7264),ot.exports.forceCanvasResizeSafariMobile=I(9202),ot.exports.material=I(8066),ot.exports.objectPool=N,ot.exports.split=I(8183).split,ot.exports.styleParser=I(3845),ot.exports.trackedControls=I(7960),ot.exports.checkHeadsetConnected=function(){return _("`utils.checkHeadsetConnected` has moved to `utils.device.checkHeadsetConnected`"),O.checkHeadsetConnected(arguments)},ot.exports.isGearVR=ot.exports.device.isGearVR=function(){_("`utils.isGearVR` has been deprecated, use `utils.device.isMobileVR`")},ot.exports.isIOS=function(){return _("`utils.isIOS` has moved to `utils.device.isIOS`"),O.isIOS(arguments)},ot.exports.isOculusGo=ot.exports.device.isOculusGo=function(){_("`utils.isOculusGo` has been deprecated, use `utils.device.isMobileVR`")},ot.exports.isMobile=function(){return _("`utils.isMobile has moved to `utils.device.isMobile`"),O.isMobile(arguments)},ot.exports.throttle=function(C,M,k){var F;return k&&(C=C.bind(k)),function(){var G=Date.now();(void 0===F||(void 0===F?M:G-F)>=M)&&(F=G,C.apply(null,arguments))}},ot.exports.throttleLeadingAndTrailing=function(C,M,k){var F,G,Q;k&&(C=C.bind(k));var X=function(){F=Date.now(),C.apply(this,Q),G=void 0};return function(){var lt=Date.now(),rt=void 0===F?M:lt-F;rt>=M?(clearTimeout(G),G=void 0,F=lt,C.apply(null,arguments)):(G=G||setTimeout(X,M-rt),Q=arguments)}},ot.exports.throttleTick=function(C,M,k){var F;return k&&(C=C.bind(k)),function(G,Q){var X=void 0===F?Q:G-F;(void 0===F||X>=M)&&(F=G,C(G,X))}},ot.exports.debounce=function(C,M,k){var F;return function(){var G=this,Q=arguments,X=k&&!F;clearTimeout(F),F=setTimeout(function(){F=null,k||C.apply(G,Q)},M),X&&C.apply(G,Q)}},ot.exports.extend=Object.assign,ot.exports.extendDeep=$,ot.exports.clone=function(C){return JSON.parse(JSON.stringify(C))};var E,D,B=(E=N.createPool(function(){return[]}),function(C,M){var k,F,G,Q,X,lt;if(void 0===C||void 0===M||null===C||null===M||!(C&&M&&C.constructor===Object&&M.constructor===Object||C.constructor===Array&&M.constructor===Array))return C===M;for(k in F=E.use(),G=E.use(),F.length=0,G.length=0,C)F.push(k);for(k in M)G.push(k);if(F.length!==G.length)return E.recycle(F),E.recycle(G),!1;for(Q=0;Q<F.length;++Q)if(lt=M[F[Q]],"object"==typeof(X=C[F[Q]])||"object"==typeof lt||Array.isArray(X)&&Array.isArray(lt)){if(X===lt)continue;if(!B(X,lt))return E.recycle(F),E.recycle(G),!1}else if(X!==lt)return E.recycle(F),E.recycle(G),!1;return E.recycle(F),E.recycle(G),!0});ot.exports.deepEqual=B,ot.exports.diff=(D=[],function(C,M,k){var F,G,Q,X,lt,rt,pt;for(lt in X=k||{},D.length=0,C)D.push(lt);if(!M)return X;for(Q in M)-1===D.indexOf(Q)&&D.push(Q);for(rt=0;rt<D.length;rt++)F=C[lt=D[rt]],G=M[lt],((pt=F&&G&&F.constructor===Object&&G.constructor===Object)&&!B(F,G)||!pt&&F!==G)&&(X[lt]=G);return X}),ot.exports.shouldCaptureKeyEvent=function(C){return!C.metaKey&&document.activeElement===document.body},ot.exports.splitString=function(C,M){void 0===M&&(M=" ");var k=new RegExp(M,"g");return(C=(C||"").replace(k,M)).split(M)},ot.exports.getElData=function(C,M){M=M||{};var k={};return Object.keys(M).forEach(function(F){C.hasAttribute(F)&&(k[F]=C.getAttribute(F))}),k},ot.exports.getUrlParameter=function(C){C=C.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var M=new RegExp("[\\?&]"+C+"=([^&#]*)").exec(location.search);return null===M?"":decodeURIComponent(M[1].replace(/\+/g," "))},ot.exports.isIframed=function(){return window.top!==window.self},ot.exports.findAllScenes=function(C){for(var M=[],k=C.getElementsByTagName("*"),F=0,G=k.length;F<G;F++)k[F].isScene&&M.push(k[F]);return M},ot.exports.srcLoader=I(1857)},1957:()=>{window.addEventListener("orientationchange",function(){document.documentElement.style.height="initial",setTimeout(function(){document.documentElement.style.height="100%",setTimeout(function(){window.scrollTo(0,1)},500)},500)})},4500:ot=>{ot.exports=function(ht){return/(iphone|ipod|ipad).*os.(7_|8_|9_)/i.test(ht)}},8066:(ot,ht,I)=>{var U=I(9437),$=I(1857),O=I(8940)("utils:material:warn"),N=new Set(["emissiveMap","envMap","map","specularMap"]);function _(M,k){var F=k.offset||{x:0,y:0},G=k.repeat||{x:1,y:1},X=k.anisotropy||U.Texture.DEFAULT_ANISOTROPY,lt=M.wrapS,rt=M.wrapT,pt=M.magFilter,vt=M.minFilter;!!k.npot&&(lt=U.ClampToEdgeWrapping,rt=U.ClampToEdgeWrapping,pt=U.LinearFilter,vt=U.LinearFilter),1===G.x&&1===G.y||(lt=U.RepeatWrapping,rt=U.RepeatWrapping),M.offset.set(F.x,F.y),M.repeat.set(G.x,G.y),M.wrapS===lt&&M.wrapT===rt&&M.magFilter===pt&&M.minFilter===vt&&M.anisotropy===X||(M.wrapS=lt,M.wrapT=rt,M.magFilter=pt,M.minFilter=vt,M.anisotropy=X,M.needsUpdate=!0)}ot.exports.setTextureProperties=_,ot.exports.updateMapMaterialFromData=function(M,k,F,G){var Q=F.el,X=F.material,lt=Q.sceneEl.systems.renderer,rt=G[k];if(F.materialSrcs||(F.materialSrcs={}),!rt)return delete F.materialSrcs[M],void pt(null);function pt(vt){X[M]!==vt&&(X[M]&&X[M].dispose(),X[M]=vt,X.needsUpdate=!0,D(Q,vt))}rt===F.materialSrcs[M]&&X[M]?_(X[M],G):(F.materialSrcs[M]=rt,rt instanceof U.Texture?pt(rt):Q.sceneEl.systems.material.loadTextureSource(rt,function(vt){if(F.materialSrcs[M]===rt){var bt=X[M];!bt||null!==vt&&B(bt,vt)||(bt=null),!bt&&vt&&(bt=C(vt)),bt&&(bt.source!==vt&&(bt.source=vt,bt.needsUpdate=!0),N.has(M)&&lt.applyColorCorrection(bt),_(bt,G)),pt(bt)}}))},ot.exports.updateMap=function(M,k){return ot.exports.updateMapMaterialFromData("map","src",M,k)},ot.exports.updateDistortionMap=function(M,k,F){var G=M;"ambientOcclusion"===M&&(G="ao");var Q={};return Q.src=F[M+"Map"],Q.offset=F[M+"TextureOffset"],Q.repeat=F[M+"TextureRepeat"],Q.wrap=F[M+"TextureWrap"],ot.exports.updateMapMaterialFromData(G+"Map","src",k,Q)};var E={};function D(M,k){function F(){M.emit("materialvideoloadeddata",{src:k.image,texture:k})}function G(){M.emit("materialvideoended",{src:k.image,texture:k})}k&&(M.emit("materialtextureloaded",{src:k.image,texture:k}),k.image&&"VIDEO"===k.image.tagName&&(k.image.addEventListener("loadeddata",F),k.image.addEventListener("ended",G),k.addEventListener("dispose",function(){k.image.removeEventListener("loadeddata",F),k.image.removeEventListener("ended",G)})))}function B(M,k){return k.data instanceof HTMLCanvasElement?M.isCanvasTexture:k.data instanceof HTMLVideoElement?M.isVideoTexture&&M.source===k:M.isTexture&&!M.isCanvasTexture&&!M.isVideoTexture}function C(M){var k;return(k=M.data instanceof HTMLCanvasElement?new U.CanvasTexture:M.data instanceof HTMLVideoElement?new U.VideoTexture(M.data):new U.Texture).source=M,k.needsUpdate=!0,k}ot.exports.updateEnvMap=function(M,k){var F=M.material,G=M.el,Q="envMap",X=k.envMap,lt=k.sphericalEnvMap,rt=k.refract;if(lt&&(X=lt,O("`sphericalEnvMap` property is deprecated, using spherical map as equirectangular map instead. Use `envMap` property with a CubeMap or Equirectangular image instead.")),M.materialSrcs||(M.materialSrcs={}),!X)return delete M.materialSrcs[Q],F.envMap=null,void(F.needsUpdate=!0);function pt(vt){M.materialSrcs[Q]===X&&(F.envMap=vt,F.needsUpdate=!0,D(G,vt))}M.materialSrcs[Q]=X,E[X]?E[X].then(pt):E[X]=new Promise(function(vt){$.validateEnvMapSrc(X,function(bt){G.sceneEl.systems.material.loadCubeMapTexture(bt,function(ft){ft.mapping=rt?U.CubeRefractionMapping:U.CubeReflectionMapping,pt(ft),vt(ft)})},function(bt){G.sceneEl.systems.material.loadTexture(bt,{src:bt},function(ft){ft.mapping=rt?U.EquirectangularRefractionMapping:U.EquirectangularReflectionMapping,pt(ft),vt(ft)})})})},ot.exports.handleTextureEvents=D,ot.exports.isCompatibleTexture=B,ot.exports.createCompatibleTexture=C},3657:ot=>{function ht(I,U,$){return(U.dot(I)-U.dot($))/U.length()}ot.exports.distanceOfPointFromPlane=ht,ot.exports.nearestPointInPlane=function(I,U,$,O){var N=ht(I,U,$);return O.copy(U),O.multiplyScalar(N),O.add($),O}},1451:ot=>{var ht=Object.freeze(Object.create(null));function I(){return{}}function U($){var O;if($&&$.constructor===Object)for(O in $)$[O]=void 0}ot.exports.createPool=function($){var O=[],N=null;function _(E){var D,B;if((E=void 0===E?O.length:E)>0&&null==N&&(N=0),E>0)for(D=O.length,O.length+=Number(E),B=D;B<O.length;B++)O[B]=$();return O.length}return $=$||I,{grow:_,pool:O,recycle:function(E){E instanceof Object&&(null!==N&&-1!==N?O[--N]=E:O[O.length]=E)},size:function(){return O.length},use:function(){var E;return null!==N&&N!==O.length||_(O.length||5),E=O[N],O[N++]=ht,U(E),E}}},ot.exports.clearObject=U,ot.exports.removeUnusedKeys=function($,O){var N;if($&&$.constructor===Object)for(N in $)N in O||delete $[N]}},8183:ot=>{var ht;ot.exports.split=(ht={},function(I,U){return U in ht||(ht[U]={}),I in ht[U]||(ht[U][I]=I.split(U)),ht[U][I]})},1857:(ot,ht,I)=>{var U=I(8940)("utils:src-loader:warn");function $(E,D,B){var C,M,k;M=function(C){C?D(E):B(E)},(C=E).tagName?M("IMG"===C.tagName):((k=new XMLHttpRequest).open("HEAD",C),k.addEventListener("load",function(F){var G;k.status>=200&&k.status<300?null==(G=k.getResponseHeader("Content-Type"))?_(C,M):G.startsWith("image")?M(!0):M(!1):_(C,M),k.abort()}),k.send())}function O(E,D,B){var C,M,k,F="",G=[];if("string"==typeof E){let X=function(lt){G.push(lt),6===G.length&&D(G)};for(M=0;M<5;M++)F+="(url\\((?:[^\\)]+)\\),\\s*)";if(F+="(url\\((?:[^\\)]+)\\)\\s*)",k=E.match(new RegExp(F))){for(M=1;M<7;M++)$(N(k[M]),X);return}if(!E.startsWith("#"))return void $(N(E)||E,B)}if(C=E.tagName?E:function(X){try{var lt=document.querySelector(X);return lt||U('No element was found matching the selector: "%s"',X),lt}catch{return void U('"%s" is not a valid selector',X)}}(E))return"A-CUBEMAP"===C.tagName&&C.srcs?D(C.srcs):"IMG"===C.tagName?B(C):void U('Selector "%s" does not point to <a-cubemap> or <img>',E)}function N(E){var D=E.match(/url\((.+)\)/);if(D)return D[1]}function _(E,D){var B=new Image;B.addEventListener("load",function(){D(!0)}),B.addEventListener("error",function(){D(!1)}),B.src=E}ot.exports={parseUrl:N,validateSrc:$,validateCubemapSrc:function(E,D){return O(E,D,function(){U("Expected cubemap but got image")})},validateEnvMapSrc:O}},3845:ot=>{var ht=/-([a-z])/g;function I(_){return _.replace(ht,N)}ot.exports.parse=function(_,E){var D;return"string"!=typeof _||(D=function(B,C){var M,k,F,G,Q,X;for(C=C||{},M=O(B),k=0;k<M.length;k++)(F=M[k])&&(G=F.indexOf(":"),Q=F.substr(0,G).trim(),X=F.substr(G+1).trim(),C[I(Q)]=X);return C}(_,E))[""]?_:D},ot.exports.stringify=function(_){return"string"==typeof _?_:function(E){var D,B=0,C=0,M="";for(D in E)B++;for(D in E)M+=D+": "+E[D],C<B-1&&(M+="; "),C++;return M}(_)},ot.exports.toCamelCase=I;var U,$,O=(U=[],$=/url\([^)]+$/,function(_){var E,D="",B=0;for(U.length=0;B<_.length;)-1===(E=_.indexOf(";",B))&&(E=_.length),D+=_.substring(B,E),$.test(D)?(D+=";",B=E+1):(U.push(D.trim()),D="",B=E+1);return U});function N(_){return _[1].toUpperCase()}},7960:(ot,ht,I)=>{var U=I(1343).DEFAULT_HANDEDNESS,$=["x","y","z","w"],O=2;function N(B,C,M){var k,F,G=B.el.sceneEl;return!!(C&&(F=G&&G.systems["tracked-controls-webvr"])&&(k=F.controllers).length&&E(k,null,C,M.hand,M.index||0))}function _(B,C,M){var k,F=B.el.sceneEl,G=F&&F.systems["tracked-controls-webxr"];return!!G&&!(!(k=G.controllers)||!k.length)&&D(k,C,M.hand,M.index,M.iterateControllerProfiles,M.handTracking)}function E(B,C,M,k,F){var G,Q,X=0;for(Q=0;Q<B.length;Q++)if(G=B[Q],(!M||G.id.startsWith(M))&&(M||G.id===C)&&(!k||!G.hand||k===G.hand)){if(!k||G.hand||X===O*F+(k===U?0:1))return G;++X}}function D(B,C,M,k,F,G){var Q,X,lt,rt,pt=!1;for(Q=0;Q<B.length;Q++){if(rt=(lt=B[Q]).profiles,G)pt=lt.hand;else if(F)for(X=0;X<rt.length&&!(pt=rt[X].startsWith(C));X++);else pt=rt.length>0&&rt[0].startsWith(C);if(pt)if("right"===lt.handedness||"left"===lt.handedness){if(lt.handedness===M)return B[Q]}else if(Q===k)return B[Q]}}ot.exports.checkControllerPresentAndSetup=function(B,C,M){var k,F,G=B.el,Q=G.sceneEl.hasWebXR;if(F=!!(k=(Q?_:N)(B,C,M)),!B.controllerPresent||B.controllerEventsActive||Q||B.addEventListeners(),F===B.controllerPresent)return F;B.controllerPresent=F,F?(B.addEventListeners(),B.injectTrackedControls(k),G.emit("controllerconnected",{name:B.name,component:B})):(B.removeEventListeners(),G.emit("controllerdisconnected",{name:B.name,component:B}))},ot.exports.isControllerPresentWebVR=N,ot.exports.isControllerPresentWebXR=_,ot.exports.findMatchingControllerWebVR=E,ot.exports.findMatchingControllerWebXR=D,ot.exports.emitIfAxesChanged=function(B,C,M){var k,F,G,Q,X;for(F in C){for(k=C[F],G=!1,X=0;X<k.length;X++)M.detail.changed[k[X]]&&(G=!0);if(G){for(Q={},X=0;X<k.length;X++)Q[$[X]]=M.detail.axis[k[X]];B.el.emit(F+"moved",Q)}}},ot.exports.onButtonEvent=function(B,C,M,k){var F=(k?M.mapping[k]:M.mapping).buttons[B];M.el.emit(F+C),M.updateModel&&M.updateModel(F,C)}},7469:()=>{THREE.DeviceOrientationControls=function(ot){var ht=this;this.object=ot,this.object.rotation.reorder("YXZ"),this.enabled=!0,this.deviceOrientation={},this.screenOrientation=0,this.alphaOffset=0;var I,U,$,O,N=function(D){ht.deviceOrientation=D},_=function(){ht.screenOrientation=window.orientation||0},E=(I=new THREE.Vector3(0,0,1),U=new THREE.Euler,$=new THREE.Quaternion,O=new THREE.Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5)),function(D,B,C,M,k){U.set(C,B,-M,"YXZ"),D.setFromEuler(U),D.multiply(O),D.multiply($.setFromAxisAngle(I,-k))});this.connect=function(){_(),window.addEventListener("orientationchange",_,!1),window.addEventListener("deviceorientation",N,!1),ht.enabled=!0},this.disconnect=function(){window.removeEventListener("orientationchange",_,!1),window.removeEventListener("deviceorientation",N,!1),ht.enabled=!1},this.update=function(){if(!1!==ht.enabled){var D=ht.deviceOrientation;if(D){var B=D.alpha?THREE.MathUtils.degToRad(D.alpha)+ht.alphaOffset:0,C=D.beta?THREE.MathUtils.degToRad(D.beta):0,M=D.gamma?THREE.MathUtils.degToRad(D.gamma):0,k=ht.screenOrientation?THREE.MathUtils.degToRad(ht.screenOrientation):0;E(ht.object.quaternion,B,C,M,k)}}},this.dispose=function(){ht.disconnect()},this.connect()}},3729:ot=>{window.glStats=function(){var ht=null,I=0,U=0,$=0,O=0,N=0,_=0,E=0;function D(B,C){return function(){C.apply(this,arguments),B.apply(this,arguments)}}return WebGLRenderingContext.prototype.drawArrays=D(WebGLRenderingContext.prototype.drawArrays,function(){I++,arguments[0]==this.POINTS?_+=arguments[2]:N+=arguments[2]}),WebGLRenderingContext.prototype.drawElements=D(WebGLRenderingContext.prototype.drawElements,function(){U++,O+=arguments[1]/3,N+=arguments[1]}),WebGLRenderingContext.prototype.useProgram=D(WebGLRenderingContext.prototype.useProgram,function(){$++}),WebGLRenderingContext.prototype.bindTexture=D(WebGLRenderingContext.prototype.bindTexture,function(){E++}),{update:function(){ht("allcalls").set(I+U),ht("drawElements").set(U),ht("drawArrays").set(I),ht("bindTexture").set(E),ht("useProgram").set($),ht("glfaces").set(O),ht("glvertices").set(N),ht("glpoints").set(_)},start:function(){I=0,U=0,$=0,O=0,N=0,_=0,E=0},end:function(){},attach:function(B){ht=B},values:{allcalls:{over:3e3,caption:"Calls (hook)"},drawelements:{caption:"drawElements (hook)"},drawarrays:{caption:"drawArrays (hook)"}},groups:[{caption:"WebGL",values:["allcalls","drawelements","drawarrays","useprogram","bindtexture","glfaces","glvertices","glpoints"]}],fractions:[{base:"allcalls",steps:["drawelements","drawarrays"]}]}},window.threeStats=function(ht){var I=null;return{update:function(){I("renderer.info.memory.geometries").set(ht.info.memory.geometries),I("renderer.info.programs").set(ht.info.programs.length),I("renderer.info.memory.textures").set(ht.info.memory.textures),I("renderer.info.render.calls").set(ht.info.render.calls),I("renderer.info.render.triangles").set(ht.info.render.triangles),I("renderer.info.render.points").set(ht.info.render.points)},start:function(){},end:function(){},attach:function(U){I=U},values:{"renderer.info.memory.geometries":{caption:"Geometries"},"renderer.info.memory.textures":{caption:"Textures"},"renderer.info.programs":{caption:"Programs"},"renderer.info.render.calls":{caption:"Calls"},"renderer.info.render.triangles":{caption:"Triangles",over:1e3},"renderer.info.render.points":{caption:"Points"}},groups:[{caption:"Three.js - Memory",values:["renderer.info.memory.geometries","renderer.info.programs","renderer.info.memory.textures"]},{caption:"Three.js - Render",values:["renderer.info.render.calls","renderer.info.render.triangles","renderer.info.render.points"]}],fractions:[]}},window.BrowserStats=function(){var ht=null,I=0,U=0;window.performance&&!performance.memory&&(performance.memory={usedJSHeapSize:0,totalJSHeapSize:0}),0===performance.memory.totalJSHeapSize&&console.warn("totalJSHeapSize === 0... performance.memory is only available in Chrome .");var $=Math.log(1024);function O(N){var _=Math.floor(Math.log(N)/$);return Math.round(100*N/Math.pow(1024,_))/100}return{update:function(){I=O(performance.memory.usedJSHeapSize),U=O(performance.memory.totalJSHeapSize),ht("memory").set(I),ht("total").set(U)},start:function(){I=0},end:function(){},attach:function(N){ht=N},values:{memory:{caption:"Used Memory",average:!0,avgMs:1e3,over:22},total:{caption:"Total Memory"}},groups:[{caption:"Browser",values:["memory","total"]}],fractions:[{base:"total",steps:["memory"]}]}},ot.exports={glStats:window.glStats,threeStats:window.threeStats,BrowserStats:window.BrowserStats}},282:ot=>{"use strict";(function(){"performance"in window==0&&(window.performance={});var ht=window.performance;if("now"in ht==0){var I=Date.now();ht.timing&&ht.timing.navigationStart&&(I=ht.timing.navigationStart),ht.now=function(){return Date.now()-I}}ht.mark||(ht.mark=function(){}),ht.measure||(ht.measure=function(){})})(),window.rStats=function(ht){function I(Q,X){for(var lt=Object.keys(Q),rt=0,pt=lt.length;rt<pt;rt++)X(lt[rt])}var U=ht||{},$=U.colours||["#850700","#c74900","#fcb300","#284280","#4c7c0c"];(U.css||["https://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300",(U.CSSPath?U.CSSPath:"")+"rStats.css"]).forEach(function(Q){var X,lt;X=Q,(lt=document.createElement("link")).href=X,lt.rel="stylesheet",lt.type="text/css",document.getElementsByTagName("head")[0].appendChild(lt)}),U.values||(U.values={});var N,_,E=10,D=200,B={};function C(Q,X,lt){var rt=lt||{},pt=document.createElement("canvas"),vt=pt.getContext("2d"),bt=0,ft=0,wt=rt.color?rt.color:"#666666",et=document.createElement("canvas"),xt=et.getContext("2d");et.width=1,et.height=2*E,xt.fillStyle="#444444",xt.fillRect(0,0,1,2*E),xt.fillStyle=wt,xt.fillRect(0,E,1,E),xt.fillStyle="#ffffff",xt.globalAlpha=.5,xt.fillRect(0,E,1,1),xt.globalAlpha=1;var Rt=document.createElement("canvas"),Yt=Rt.getContext("2d");return Rt.width=1,Rt.height=2*E,Yt.fillStyle="#444444",Yt.fillRect(0,0,1,2*E),Yt.fillStyle="#b70000",Yt.fillRect(0,E,1,E),Yt.globalAlpha=.5,Yt.fillStyle="#ffffff",Yt.fillRect(0,E,1,1),Yt.globalAlpha=1,pt.width=D,pt.height=E,pt.style.width=pt.width+"px",pt.style.height=pt.height+"px",pt.className="rs-canvas",Q.appendChild(pt),vt.fillStyle="#444444",vt.fillRect(0,0,pt.width,pt.height),{draw:function(ve,xe){(ft+=.1*(ve-ft))>(bt*=.99)&&(bt=ft),vt.drawImage(pt,1,0,pt.width-1,pt.height,0,0,pt.width-1,pt.height),vt.drawImage(xe?Rt:et,pt.width-1,pt.height-ft*pt.height/bt-E)}}}function M(Q,X){var lt=document.createElement("canvas"),rt=lt.getContext("2d");return lt.width=D,lt.height=E*X,lt.style.width=lt.width+"px",lt.style.height=lt.height+"px",lt.className="rs-canvas",Q.appendChild(lt),rt.fillStyle="#444444",rt.fillRect(0,0,lt.width,lt.height),{draw:function(pt){rt.drawImage(lt,1,0,lt.width-1,lt.height,0,0,lt.width-1,lt.height);var vt=0;I(pt,function(bt){var ft=pt[bt]*lt.height;rt.fillStyle=$[bt],rt.fillRect(lt.width-1,vt,1,ft),vt+=ft})}}}function k(Q,X){var lt,rt=Q,pt=0,vt=0,bt=0,ft=0,wt=performance.now(),et=0,xt=document.createElement("div"),Rt=document.createElement("span"),Yt=document.createElement("div"),ve=document.createTextNode(""),xe=U?U.values[rt.toLowerCase()]:null,Ge=new C(xt,rt,xe),en=!1;function nn(nr){if(xe&&xe.average){ft+=nr,et++;var hr=performance.now();hr-wt>=(xe.avgMs||1e3)&&(bt=ft/et,ft=0,wt=hr,et=0)}}function vn(){lt=performance.now(),U.userTimingAPI&&performance.mark(rt+"-start"),en=!0}function _n(){pt=performance.now()-lt,U.userTimingAPI&&(performance.mark(rt+"-end"),en&&performance.measure(rt,rt+"-start",rt+"-end")),nn(pt)}return Rt.className="rs-counter-id",Rt.textContent=xe&&xe.caption?xe.caption:rt,Yt.className="rs-counter-value",Yt.appendChild(ve),xt.appendChild(Rt),xt.appendChild(Yt),X?X.div.appendChild(xt):_.appendChild(xt),lt=performance.now(),{set:function(nr){nn(pt=nr)},start:vn,tick:function(){_n(),vn()},end:_n,frame:function(){var nr=performance.now(),hr=nr-lt;vt++,hr>1e3&&(pt=xe&&!1===xe.interpolate?vt:1e3*vt/hr,vt=0,lt=nr,nn(pt))},value:function(){return pt},draw:function(){ve.nodeValue=Math.round(100*(xe&&xe.average?bt:pt))/100;var hr=xe&&(xe.below&&pt<xe.below||xe.over&&pt>xe.over);Ge.draw(pt,hr),xt.className=hr?"rs-counter-base alarm":"rs-counter-base"}}}function F(Q){var X=Q.toLowerCase();if(void 0===X&&(X="default"),B[X])return B[X];var lt=null;U&&U.groups&&I(U.groups,function(pt){var vt=U.groups[parseInt(pt,10)];lt||-1===vt.values.indexOf(X.toLowerCase())||(lt=vt)});var rt=new k(X,lt);return B[X]=rt,rt}function G(){I(U.plugins,function(Q){U.plugins[Q].update()}),I(B,function(Q){B[Q].draw()}),U&&U.fractions&&I(U.fractions,function(Q){var X=U.fractions[parseInt(Q,10)],lt=[],rt=B[X.base.toLowerCase()];rt&&(rt=rt.value(),I(U.fractions[Q].steps,function(pt){var vt=U.fractions[Q].steps[parseInt(pt,10)].toLowerCase(),bt=B[vt];bt&&lt.push(bt.value()/rt)})),X.graph.draw(lt)})}return function(){if(U.plugins){U.values||(U.values={}),U.groups||(U.groups=[]),U.fractions||(U.fractions=[]);for(var Q=0;Q<U.plugins.length;Q++)U.plugins[Q].attach(F),I(U.plugins[Q].values,function(X){U.values[X]=U.plugins[Q].values[X]}),U.groups=U.groups.concat(U.plugins[Q].groups),U.fractions=U.fractions.concat(U.plugins[Q].fractions)}else U.plugins={};(N=document.createElement("div")).className="rs-base",(_=document.createElement("div")).className="rs-container",_.style.height="auto",N.appendChild(_),document.body.appendChild(N),U&&(U.groups&&I(U.groups,function(X){var lt=U.groups[parseInt(X,10)],rt=document.createElement("div");rt.className="rs-group",lt.div=rt;var pt=document.createElement("h1");pt.textContent=lt.caption,pt.addEventListener("click",function(vt){this.classList.toggle("hidden"),vt.preventDefault()}.bind(rt)),_.appendChild(pt),_.appendChild(rt)}),U.fractions&&I(U.fractions,function(X){var lt=U.fractions[parseInt(X,10)],rt=document.createElement("div");rt.className="rs-fraction";var pt=document.createElement("div");pt.className="rs-legend";var vt=0;I(U.fractions[X].steps,function(ft){var wt=document.createElement("p");wt.textContent=U.fractions[X].steps[ft],wt.style.color=$[vt],pt.appendChild(wt),vt++}),rt.appendChild(pt),rt.style.height=vt*E+"px",lt.div=rt;var bt=new M(rt,vt);lt.graph=bt,_.appendChild(rt)}))}(),function(Q){return Q?F(Q):{element:N,update:G}}},ot.exports=window.rStats},2535:ot=>{ot.exports={base64:function(I,U){return"data:"+I+";base64,"+U},isMobile:function(){var I,U=!1;return I=navigator.userAgent||navigator.vendor||window.opera,(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(I)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(I.substr(0,4)))&&(U=!0),U},isIOS:function(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)},isIFrame:function(){try{return window.self!==window.top}catch{return!0}},appendQueryParameter:function(I,U,$){var O=I.indexOf("?")<0?"?":"&";return I+(O+U+"=")+$},getQueryParameter:function(I){I=I.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");var U=new RegExp("[\\?&]"+I+"=([^&#]*)").exec(location.search);return null===U?"":decodeURIComponent(U[1].replace(/\+/g," "))},isLandscapeMode:function(){return 90==window.orientation||-90==window.orientation}}},5928:(ot,ht,I)=>{var U,$=I(2535);ot.exports=(U=navigator.userAgent||navigator.vendor||window.opera).match(/iPhone/i)||U.match(/iPod/i)?function(){var O=null;this.request=function(){O||(O=setInterval(function(){window.location.href="/",setTimeout(window.stop,0)},15e3))},this.release=function(){O&&(clearInterval(O),O=null)}}:function(){var O=document.createElement("video");O.addEventListener("ended",function(){O.play()}),this.request=function(){O.paused&&(O.src=$.base64("video/webm","GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw=="),O.play())},this.release=function(){O.pause(),O.src=""}}},8217:(ot,ht,I)=>{"use strict";I.d(ht,{A:()=>pt});var U=I(963),$=I.n(U),O=I(9089),N=I.n(O),_=I(6492),E=I.n(_),D=new URL(I(9169),I.b),B=new URL(I(6085),I.b),C=new URL(I(3931),I.b),M=new URL(I(7889),I.b),k=new URL(I(6517),I.b),F=N()($()),G=E()(D),Q=E()(B),X=E()(C),lt=E()(M),rt=E()(k);F.push([ot.id,`/* .a-fullscreen means not embedded. */\nhtml.a-fullscreen {\n  bottom: 0;\n  left: 0;\n  position: fixed;\n  right: 0;\n  top: 0;\n}\n\nhtml.a-fullscreen body {\n  height: 100%;\n  margin: 0;\n  overflow: hidden;\n  padding: 0;\n  width: 100%;\n}\n\n/* Class is removed when doing <a-scene embedded>. */\nhtml.a-fullscreen .a-canvas {\n  width: 100% !important;\n  height: 100% !important;\n  top: 0 !important;\n  left: 0 !important;\n  right: 0 !important;\n  bottom: 0 !important;\n  position: fixed !important;\n}\n\nhtml:not(.a-fullscreen) .a-enter-vr,\nhtml:not(.a-fullscreen) .a-enter-ar {\n  right: 5px;\n  bottom: 5px;\n}\n\nhtml:not(.a-fullscreen) .a-enter-ar {\n  right: 60px;\n}\n\n/* In chrome mobile the user agent stylesheet set it to white  */\n:-webkit-full-screen {\n  background-color: transparent;\n}\n\n.a-hidden {\n  display: none !important;\n}\n\n.a-canvas {\n  height: 100%;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n\n.a-canvas.a-grab-cursor:hover {\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\ncanvas.a-canvas.a-mouse-cursor-hover:hover {\n  cursor: pointer;\n}\n\n.a-inspector-loader {\n  background-color: #ed3160;\n  position: fixed;\n  left: 3px;\n  top: 3px;\n  padding: 6px 10px;\n  color: #fff;\n  text-decoration: none;\n  font-size: 12px;\n  font-family: Roboto,sans-serif;\n  text-align: center;\n  z-index: 99999;\n  width: 204px;\n}\n\n/* Inspector loader animation */\n@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }\n@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }\n@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }\n@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }\n@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }\n@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }\n\n.a-inspector-loader .dots span {\n  animation: dots-1 2s infinite steps(1);\n  -webkit-animation: dots-1 2s infinite steps(1);\n}\n\n.a-inspector-loader .dots span:first-child + span {\n  animation-name: dots-2;\n  -webkit-animation-name: dots-2;\n}\n\n.a-inspector-loader .dots span:first-child + span + span {\n  animation-name: dots-3;\n  -webkit-animation-name: dots-3;\n}\n\na-scene {\n  display: block;\n  position: relative;\n  height: 100%;\n  width: 100%;\n}\n\na-assets,\na-scene video,\na-scene img,\na-scene audio {\n  display: none;\n}\n\n.a-enter-vr-modal,\n.a-orientation-modal {\n  font-family: Consolas, Andale Mono, Courier New, monospace;\n}\n\n.a-enter-vr-modal a {\n  border-bottom: 1px solid #fff;\n  padding: 2px 0;\n  text-decoration: none;\n  transition: .1s color ease-in;\n}\n\n.a-enter-vr-modal a:hover {\n  background-color: #fff;\n  color: #111;\n  padding: 2px 4px;\n  position: relative;\n  left: -4px;\n}\n\n.a-enter-vr,\n.a-enter-ar {\n  font-family: sans-serif, monospace;\n  font-size: 13px;\n  width: 100%;\n  font-weight: 200;\n  line-height: 16px;\n  position: absolute;\n  right: 20px;\n  bottom: 20px;\n}\n\n.a-enter-ar.xr {\n  right: 90px;\n}\n\n.a-enter-vr-button,\n.a-enter-vr-modal,\n.a-enter-vr-modal a {\n  color: #fff;\n  user-select: none;\n  outline: none;\n}\n\n.a-enter-vr-button {\n  background: rgba(0, 0, 0, 0.35) url(${G}) 50% 50% no-repeat;\n}\n\n.a-enter-ar-button {\n  background: rgba(0, 0, 0, 0.20) url(${Q}) 50% 50% no-repeat;\n}\n\n.a-enter-vr.fullscreen .a-enter-vr-button {\n  background-image: url(${X});\n}\n\n.a-enter-vr-button,\n.a-enter-ar-button {\n  background-size: 90% 90%;\n  border: 0;\n  bottom: 0;\n  cursor: pointer;\n  min-width: 58px;\n  min-height: 34px;\n  /* 1.74418604651 */\n  /*\n    In order to keep the aspect ratio when resizing\n    padding-top percentages are relative to the containing block's width.\n    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio\n  */\n  padding-right: 0;\n  padding-top: 0;\n  position: absolute;\n  right: 0;\n  transition: background-color .05s ease;\n  -webkit-transition: background-color .05s ease;\n  z-index: 9999;\n  border-radius: 8px;\n  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */\n}\n\n.a-enter-ar-button {\n  background-size: 100% 90%;\n  border-radius: 7px;\n}\n\n.a-enter-ar-button:active,\n.a-enter-ar-button:hover,\n.a-enter-vr-button:active,\n.a-enter-vr-button:hover {\n  background-color: #ef2d5e;\n}\n\n.a-enter-vr-button.resethover {\n  background-color: rgba(0, 0, 0, 0.35);\n}\n\n.a-enter-vr-modal {\n  background-color: #666;\n  border-radius: 0;\n  display: none;\n  min-height: 32px;\n  margin-right: 70px;\n  padding: 9px;\n  width: 280px;\n  right: 2%;\n  position: absolute;\n}\n\n.a-enter-vr-modal:after {\n  border-bottom: 10px solid transparent;\n  border-left: 10px solid #666;\n  border-top: 10px solid transparent;\n  display: inline-block;\n  content: '';\n  position: absolute;\n  right: -5px;\n  top: 5px;\n  width: 0;\n  height: 0;\n}\n\n.a-enter-vr-modal p,\n.a-enter-vr-modal a {\n  display: inline;\n}\n\n.a-enter-vr-modal p {\n  margin: 0;\n}\n\n.a-enter-vr-modal p:after {\n  content: ' ';\n}\n\n.a-orientation-modal {\n  background: rgba(244, 244, 244, 1) url(${lt}) center no-repeat;\n  background-size: 50% 50%;\n  bottom: 0;\n  font-size: 14px;\n  font-weight: 600;\n  left: 0;\n  line-height: 20px;\n  right: 0;\n  position: fixed;\n  top: 0;\n  z-index: 9999999;\n}\n\n.a-orientation-modal:after {\n  color: #666;\n  content: "Insert phone into Cardboard holder.";\n  display: block;\n  position: absolute;\n  text-align: center;\n  top: 70%;\n  transform: translateY(-70%);\n  width: 100%;\n}\n\n.a-orientation-modal button {\n  background: url(${rt}) no-repeat;\n  border: none;\n  height: 50px;\n  text-indent: -9999px;\n  width: 50px;\n}\n\n.a-loader-title {\n  background-color: rgba(0, 0, 0, 0.6);\n  font-family: sans-serif, monospace;\n  text-align: center;\n  font-size: 20px;\n  height: 50px;\n  font-weight: 300;\n  line-height: 50px;\n  position: absolute;\n  right: 0px;\n  left: 0px;\n  top: 0px;\n  color: white;\n}\n\n.a-modal {\n  position: absolute;\n  background: rgba(0, 0, 0, 0.60);\n  background-size: 50% 50%;\n  bottom: 0;\n  font-size: 14px;\n  font-weight: 600;\n  left: 0;\n  line-height: 20px;\n  right: 0;\n  position: fixed;\n  top: 0;\n  z-index: 9999999;\n}\n\n.a-dialog {\n  position: relative;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 199995;\n  width: 300px;\n  height: 200px;\n  background-size: contain;\n  background-color: white;\n  font-family: sans-serif, monospace;\n  font-size: 20px;\n  border-radius: 3px;\n  padding: 6px;\n}\n\n.a-dialog-text-container {\n  width: 100%;\n  height: 70%;\n  align-self: flex-start;\n  display: flex;\n  justify-content: center;\n  align-content: center;\n  flex-direction: column;\n}\n\n.a-dialog-text {\n  display: inline-block;\n  font-weight: normal;\n  font-size: 14pt;\n  margin: 8px;\n}\n\n.a-dialog-buttons-container {\n  display: inline-flex;\n  align-self: flex-end;\n  width: 100%;\n  height: 30%;\n}\n\n.a-dialog-button {\n  cursor: pointer;\n  align-self: center;\n  opacity: 0.9;\n  height: 80%;\n  width: 50%;\n  font-size: 12pt;\n  margin: 4px;\n  border-radius: 2px;\n  text-align:center;\n  border: none;\n  display: inline-block;\n  -webkit-transition: all 0.25s ease-in-out;\n  transition: all 0.25s ease-in-out;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);\n  user-select: none;\n}\n\n.a-dialog-permission-button:hover {\n  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);\n}\n\n.a-dialog-allow-button {\n  background-color: #00ceff;\n}\n\n.a-dialog-deny-button {\n  background-color: #ff005b;\n}\n\n.a-dialog-ok-button {\n  background-color: #00ceff;\n  width: 100%;\n}\n\n.a-dom-overlay:not(.a-no-style) {\n  overflow: hidden;\n  position: absolute;\n  pointer-events: none;\n  box-sizing: border-box;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  top: 0;\n  padding: 1em;\n}\n\n.a-dom-overlay:not(.a-no-style)>* {\n  pointer-events: auto;\n}\n`,"",{version:3,sources:["webpack://./src/style/aframe.css"],names:[],mappings:"AAAA,sCAAsC;AACtC;EACE,SAAS;EACT,OAAO;EACP,eAAe;EACf,QAAQ;EACR,MAAM;AACR;;AAEA;EACE,YAAY;EACZ,SAAS;EACT,gBAAgB;EAChB,UAAU;EACV,WAAW;AACb;;AAEA,oDAAoD;AACpD;EACE,sBAAsB;EACtB,uBAAuB;EACvB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;EACnB,oBAAoB;EACpB,0BAA0B;AAC5B;;AAEA;;EAEE,UAAU;EACV,WAAW;AACb;;AAEA;EACE,WAAW;AACb;;AAEA,gEAAgE;AAChE;EACE,6BAA6B;AAC/B;;AAEA;EACE,wBAAwB;AAC1B;;AAEA;EACE,YAAY;EACZ,OAAO;EACP,kBAAkB;EAClB,MAAM;EACN,WAAW;AACb;;AAEA;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;AACtB;;AAEA;EACE,eAAe;AACjB;;AAEA;EACE,yBAAyB;EACzB,eAAe;EACf,SAAS;EACT,QAAQ;EACR,iBAAiB;EACjB,WAAW;EACX,qBAAqB;EACrB,eAAe;EACf,8BAA8B;EAC9B,kBAAkB;EAClB,cAAc;EACd,YAAY;AACd;;AAEA,+BAA+B;AAC/B,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,oBAAoB,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AAC7D,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;AACrE,4BAA4B,OAAO,UAAU,EAAE,EAAE,MAAM,UAAU,EAAE,EAAE;;AAErE;EACE,sCAAsC;EACtC,8CAA8C;AAChD;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,sBAAsB;EACtB,8BAA8B;AAChC;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,YAAY;EACZ,WAAW;AACb;;AAEA;;;;EAIE,aAAa;AACf;;AAEA;;EAEE,0DAA0D;AAC5D;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,qBAAqB;EACrB,6BAA6B;AAC/B;;AAEA;EACE,sBAAsB;EACtB,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,UAAU;AACZ;;AAEA;;EAEE,kCAAkC;EAClC,eAAe;EACf,WAAW;EACX,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;AACb;;AAEA;;;EAGE,WAAW;EACX,iBAAiB;EACjB,aAAa;AACf;;AAEA;EACE,yFAA4qB;AAC9qB;;AAEA;EACE,yFAAkzB;AACpzB;;AAEA;EACE,yDAA2qK;AAC7qK;;AAEA;;EAEE,wBAAwB;EACxB,SAAS;EACT,SAAS;EACT,eAAe;EACf,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB;;;;GAIC;EACD,gBAAgB;EAChB,cAAc;EACd,kBAAkB;EAClB,QAAQ;EACR,sCAAsC;EACtC,8CAA8C;EAC9C,aAAa;EACb,kBAAkB;EAClB,0BAA0B,EAAE,8CAA8C;AAC5E;;AAEA;EACE,yBAAyB;EACzB,kBAAkB;AACpB;;AAEA;;;;EAIE,yBAAyB;AAC3B;;AAEA;EACE,qCAAqC;AACvC;;AAEA;EACE,sBAAsB;EACtB,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,SAAS;EACT,kBAAkB;AACpB;;AAEA;EACE,qCAAqC;EACrC,4BAA4B;EAC5B,kCAAkC;EAClC,qBAAqB;EACrB,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,QAAQ;EACR,SAAS;AACX;;AAEA;;EAEE,eAAe;AACjB;;AAEA;EACE,SAAS;AACX;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,2FAAivF;EACjvF,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,WAAW;EACX,8CAA8C;EAC9C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,QAAQ;EACR,2BAA2B;EAC3B,WAAW;AACb;;AAEA;EACE,6DAA25B;EAC35B,YAAY;EACZ,YAAY;EACZ,oBAAoB;EACpB,WAAW;AACb;;AAEA;EACE,oCAAoC;EACpC,kCAAkC;EAClC,kBAAkB;EAClB,eAAe;EACf,YAAY;EACZ,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,UAAU;EACV,SAAS;EACT,QAAQ;EACR,YAAY;AACd;;AAEA;EACE,kBAAkB;EAClB,+BAA+B;EAC/B,wBAAwB;EACxB,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,OAAO;EACP,iBAAiB;EACjB,QAAQ;EACR,eAAe;EACf,MAAM;EACN,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,QAAQ;EACR,gCAAgC;EAChC,eAAe;EACf,YAAY;EACZ,aAAa;EACb,wBAAwB;EACxB,uBAAuB;EACvB,kCAAkC;EAClC,eAAe;EACf,kBAAkB;EAClB,YAAY;AACd;;AAEA;EACE,WAAW;EACX,WAAW;EACX,sBAAsB;EACtB,aAAa;EACb,uBAAuB;EACvB,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,mBAAmB;EACnB,eAAe;EACf,WAAW;AACb;;AAEA;EACE,oBAAoB;EACpB,oBAAoB;EACpB,WAAW;EACX,WAAW;AACb;;AAEA;EACE,eAAe;EACf,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,UAAU;EACV,eAAe;EACf,WAAW;EACX,kBAAkB;EAClB,iBAAiB;EACjB,YAAY;EACZ,qBAAqB;EACrB,yCAAyC;EACzC,iCAAiC;EACjC,wEAAwE;EACxE,iBAAiB;AACnB;;AAEA;EACE,mEAAmE;AACrE;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,yBAAyB;EACzB,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,kBAAkB;EAClB,oBAAoB;EACpB,sBAAsB;EACtB,SAAS;EACT,OAAO;EACP,QAAQ;EACR,MAAM;EACN,YAAY;AACd;;AAEA;EACE,oBAAoB;AACtB",sourcesContent:["/* .a-fullscreen means not embedded. */\nhtml.a-fullscreen {\n  bottom: 0;\n  left: 0;\n  position: fixed;\n  right: 0;\n  top: 0;\n}\n\nhtml.a-fullscreen body {\n  height: 100%;\n  margin: 0;\n  overflow: hidden;\n  padding: 0;\n  width: 100%;\n}\n\n/* Class is removed when doing <a-scene embedded>. */\nhtml.a-fullscreen .a-canvas {\n  width: 100% !important;\n  height: 100% !important;\n  top: 0 !important;\n  left: 0 !important;\n  right: 0 !important;\n  bottom: 0 !important;\n  position: fixed !important;\n}\n\nhtml:not(.a-fullscreen) .a-enter-vr,\nhtml:not(.a-fullscreen) .a-enter-ar {\n  right: 5px;\n  bottom: 5px;\n}\n\nhtml:not(.a-fullscreen) .a-enter-ar {\n  right: 60px;\n}\n\n/* In chrome mobile the user agent stylesheet set it to white  */\n:-webkit-full-screen {\n  background-color: transparent;\n}\n\n.a-hidden {\n  display: none !important;\n}\n\n.a-canvas {\n  height: 100%;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n\n.a-canvas.a-grab-cursor:hover {\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\ncanvas.a-canvas.a-mouse-cursor-hover:hover {\n  cursor: pointer;\n}\n\n.a-inspector-loader {\n  background-color: #ed3160;\n  position: fixed;\n  left: 3px;\n  top: 3px;\n  padding: 6px 10px;\n  color: #fff;\n  text-decoration: none;\n  font-size: 12px;\n  font-family: Roboto,sans-serif;\n  text-align: center;\n  z-index: 99999;\n  width: 204px;\n}\n\n/* Inspector loader animation */\n@keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }\n@keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }\n@keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }\n@-webkit-keyframes dots-1 { from { opacity: 0; } 25% { opacity: 1; } }\n@-webkit-keyframes dots-2 { from { opacity: 0; } 50% { opacity: 1; } }\n@-webkit-keyframes dots-3 { from { opacity: 0; } 75% { opacity: 1; } }\n\n.a-inspector-loader .dots span {\n  animation: dots-1 2s infinite steps(1);\n  -webkit-animation: dots-1 2s infinite steps(1);\n}\n\n.a-inspector-loader .dots span:first-child + span {\n  animation-name: dots-2;\n  -webkit-animation-name: dots-2;\n}\n\n.a-inspector-loader .dots span:first-child + span + span {\n  animation-name: dots-3;\n  -webkit-animation-name: dots-3;\n}\n\na-scene {\n  display: block;\n  position: relative;\n  height: 100%;\n  width: 100%;\n}\n\na-assets,\na-scene video,\na-scene img,\na-scene audio {\n  display: none;\n}\n\n.a-enter-vr-modal,\n.a-orientation-modal {\n  font-family: Consolas, Andale Mono, Courier New, monospace;\n}\n\n.a-enter-vr-modal a {\n  border-bottom: 1px solid #fff;\n  padding: 2px 0;\n  text-decoration: none;\n  transition: .1s color ease-in;\n}\n\n.a-enter-vr-modal a:hover {\n  background-color: #fff;\n  color: #111;\n  padding: 2px 4px;\n  position: relative;\n  left: -4px;\n}\n\n.a-enter-vr,\n.a-enter-ar {\n  font-family: sans-serif, monospace;\n  font-size: 13px;\n  width: 100%;\n  font-weight: 200;\n  line-height: 16px;\n  position: absolute;\n  right: 20px;\n  bottom: 20px;\n}\n\n.a-enter-ar.xr {\n  right: 90px;\n}\n\n.a-enter-vr-button,\n.a-enter-vr-modal,\n.a-enter-vr-modal a {\n  color: #fff;\n  user-select: none;\n  outline: none;\n}\n\n.a-enter-vr-button {\n  background: rgba(0, 0, 0, 0.35) url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z' fill='%23fff'/%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z' fill='%23fff'/%3E%3C/svg%3E\") 50% 50% no-repeat;\n}\n\n.a-enter-ar-button {\n  background: rgba(0, 0, 0, 0.20) url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='108' height='62' viewBox='0 0 108 62'%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z' fill='%23fff'/%3E%3Cpath d='M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z' fill='%23fff'/%3E%3Cpath d='M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z' fill='%23fff'/%3E%3C/svg%3E\") 50% 50% no-repeat;\n}\n\n.a-enter-vr.fullscreen .a-enter-vr-button {\n  background-image: url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8' standalone='no'%3F%3E%3Csvg width='108' height='62' viewBox='0 0 108 62' version='1.1' id='svg320' sodipodi:docname='fullscreen-aframe.svg' xml:space='preserve' inkscape:version='1.2.1 (9c6d41e  2022-07-14)' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:cc='http://creativecommons.org/ns%23' xmlns:dc='http://purl.org/dc/elements/1.1/'%3E%3Cdefs id='defs324' /%3E%3Csodipodi:namedview id='namedview322' pagecolor='%23ffffff' bordercolor='%23000000' borderopacity='0.25' inkscape:showpageshadow='2' inkscape:pageopacity='0.0' inkscape:pagecheckerboard='0' inkscape:deskcolor='%23d1d1d1' showgrid='false' inkscape:zoom='3.8064516' inkscape:cx='91.423729' inkscape:cy='-1.4449153' inkscape:window-width='1440' inkscape:window-height='847' inkscape:window-x='32' inkscape:window-y='25' inkscape:window-maximized='0' inkscape:current-layer='svg320' /%3E%3Ctitle id='title312'%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d='M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z' fill='%23fff' id='path314' style='fill:%23ffffff' /%3E%3Cg id='g356' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g358' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g360' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g362' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g364' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g366' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g368' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g370' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g372' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g374' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g376' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g378' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g380' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g382' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cg id='g384' transform='translate(-206.61017 -232.61864)'%3E%3C/g%3E%3Cmetadata id='metadata561'%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=''%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d='m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4' id='path596' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4' id='path598' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4' id='path600' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3Cpath d='m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616' id='path602' style='fill:%23ffffff%3Bstroke-width:1.50194' /%3E%3C/svg%3E\");\n}\n\n.a-enter-vr-button,\n.a-enter-ar-button {\n  background-size: 90% 90%;\n  border: 0;\n  bottom: 0;\n  cursor: pointer;\n  min-width: 58px;\n  min-height: 34px;\n  /* 1.74418604651 */\n  /*\n    In order to keep the aspect ratio when resizing\n    padding-top percentages are relative to the containing block's width.\n    http://stackoverflow.com/questions/12121090/responsively-change-div-size-keeping-aspect-ratio\n  */\n  padding-right: 0;\n  padding-top: 0;\n  position: absolute;\n  right: 0;\n  transition: background-color .05s ease;\n  -webkit-transition: background-color .05s ease;\n  z-index: 9999;\n  border-radius: 8px;\n  touch-action: manipulation; /* Prevent iOS double tap zoom on the button */\n}\n\n.a-enter-ar-button {\n  background-size: 100% 90%;\n  border-radius: 7px;\n}\n\n.a-enter-ar-button:active,\n.a-enter-ar-button:hover,\n.a-enter-vr-button:active,\n.a-enter-vr-button:hover {\n  background-color: #ef2d5e;\n}\n\n.a-enter-vr-button.resethover {\n  background-color: rgba(0, 0, 0, 0.35);\n}\n\n.a-enter-vr-modal {\n  background-color: #666;\n  border-radius: 0;\n  display: none;\n  min-height: 32px;\n  margin-right: 70px;\n  padding: 9px;\n  width: 280px;\n  right: 2%;\n  position: absolute;\n}\n\n.a-enter-vr-modal:after {\n  border-bottom: 10px solid transparent;\n  border-left: 10px solid #666;\n  border-top: 10px solid transparent;\n  display: inline-block;\n  content: '';\n  position: absolute;\n  right: -5px;\n  top: 5px;\n  width: 0;\n  height: 0;\n}\n\n.a-enter-vr-modal p,\n.a-enter-vr-modal a {\n  display: inline;\n}\n\n.a-enter-vr-modal p {\n  margin: 0;\n}\n\n.a-enter-vr-modal p:after {\n  content: ' ';\n}\n\n.a-orientation-modal {\n  background: rgba(244, 244, 244, 1) url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center no-repeat;\n  background-size: 50% 50%;\n  bottom: 0;\n  font-size: 14px;\n  font-weight: 600;\n  left: 0;\n  line-height: 20px;\n  right: 0;\n  position: fixed;\n  top: 0;\n  z-index: 9999999;\n}\n\n.a-orientation-modal:after {\n  color: #666;\n  content: \"Insert phone into Cardboard holder.\";\n  display: block;\n  position: absolute;\n  text-align: center;\n  top: 70%;\n  transform: translateY(-70%);\n  width: 100%;\n}\n\n.a-orientation-modal button {\n  background: url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E) no-repeat;\n  border: none;\n  height: 50px;\n  text-indent: -9999px;\n  width: 50px;\n}\n\n.a-loader-title {\n  background-color: rgba(0, 0, 0, 0.6);\n  font-family: sans-serif, monospace;\n  text-align: center;\n  font-size: 20px;\n  height: 50px;\n  font-weight: 300;\n  line-height: 50px;\n  position: absolute;\n  right: 0px;\n  left: 0px;\n  top: 0px;\n  color: white;\n}\n\n.a-modal {\n  position: absolute;\n  background: rgba(0, 0, 0, 0.60);\n  background-size: 50% 50%;\n  bottom: 0;\n  font-size: 14px;\n  font-weight: 600;\n  left: 0;\n  line-height: 20px;\n  right: 0;\n  position: fixed;\n  top: 0;\n  z-index: 9999999;\n}\n\n.a-dialog {\n  position: relative;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 199995;\n  width: 300px;\n  height: 200px;\n  background-size: contain;\n  background-color: white;\n  font-family: sans-serif, monospace;\n  font-size: 20px;\n  border-radius: 3px;\n  padding: 6px;\n}\n\n.a-dialog-text-container {\n  width: 100%;\n  height: 70%;\n  align-self: flex-start;\n  display: flex;\n  justify-content: center;\n  align-content: center;\n  flex-direction: column;\n}\n\n.a-dialog-text {\n  display: inline-block;\n  font-weight: normal;\n  font-size: 14pt;\n  margin: 8px;\n}\n\n.a-dialog-buttons-container {\n  display: inline-flex;\n  align-self: flex-end;\n  width: 100%;\n  height: 30%;\n}\n\n.a-dialog-button {\n  cursor: pointer;\n  align-self: center;\n  opacity: 0.9;\n  height: 80%;\n  width: 50%;\n  font-size: 12pt;\n  margin: 4px;\n  border-radius: 2px;\n  text-align:center;\n  border: none;\n  display: inline-block;\n  -webkit-transition: all 0.25s ease-in-out;\n  transition: all 0.25s ease-in-out;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.10), 0 1px 2px rgba(0, 0, 0, 0.20);\n  user-select: none;\n}\n\n.a-dialog-permission-button:hover {\n  box-shadow: 0 7px 14px rgba(0,0,0,0.20), 0 2px 2px rgba(0,0,0,0.20);\n}\n\n.a-dialog-allow-button {\n  background-color: #00ceff;\n}\n\n.a-dialog-deny-button {\n  background-color: #ff005b;\n}\n\n.a-dialog-ok-button {\n  background-color: #00ceff;\n  width: 100%;\n}\n\n.a-dom-overlay:not(.a-no-style) {\n  overflow: hidden;\n  position: absolute;\n  pointer-events: none;\n  box-sizing: border-box;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  top: 0;\n  padding: 1em;\n}\n\n.a-dom-overlay:not(.a-no-style)>* {\n  pointer-events: auto;\n}\n"],sourceRoot:""}]);const pt=F},2470:(ot,ht,I)=>{"use strict";I.d(ht,{A:()=>_});var U=I(963),$=I.n(U),O=I(9089),N=I.n(O)()($());N.push([ot.id,".rs-base {\n  background-color: #333;\n  color: #fafafa;\n  border-radius: 0;\n  font: 10px monospace;\n  left: 5px;\n  line-height: 1em;\n  opacity: 0.85;\n  overflow: hidden;\n  padding: 10px;\n  position: fixed;\n  top: 5px;\n  width: 300px;\n  z-index: 10000;\n}\n\n.rs-base div.hidden {\n  display: none;\n}\n\n.rs-base h1 {\n  color: #fff;\n  cursor: pointer;\n  font-size: 1.4em;\n  font-weight: 300;\n  margin: 0 0 5px;\n  padding: 0;\n}\n\n.rs-group {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-flex-direction: column-reverse;\n  flex-direction: column-reverse;\n  margin-bottom: 5px;\n}\n\n.rs-group:last-child {\n  margin-bottom: 0;\n}\n\n.rs-counter-base {\n  align-items: center;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  height: 10px;\n  -webkit-justify-content: space-between;\n  justify-content: space-between;\n  margin: 2px 0;\n}\n\n.rs-counter-base.alarm {\n  color: #b70000;\n  text-shadow: 0 0 0 #b70000,\n               0 0 1px #fff,\n               0 0 1px #fff,\n               0 0 2px #fff,\n               0 0 2px #fff,\n               0 0 3px #fff,\n               0 0 3px #fff,\n               0 0 4px #fff,\n               0 0 4px #fff;\n}\n\n.rs-counter-id {\n  font-weight: 300;\n  -webkit-box-ordinal-group: 0;\n  -webkit-order: 0;\n  order: 0;\n  width: 54px;\n}\n\n.rs-counter-value {\n  font-weight: 300;\n  -webkit-box-ordinal-group: 1;\n  -webkit-order: 1;\n  order: 1;\n  text-align: right;\n  width: 35px;\n}\n\n.rs-canvas {\n  -webkit-box-ordinal-group: 2;\n  -webkit-order: 2;\n  order: 2;\n}\n\n@media (min-width: 480px) {\n  .rs-base {\n    left: 20px;\n    top: 20px;\n  }\n}\n","",{version:3,sources:["webpack://./src/style/rStats.css"],names:[],mappings:"AAAA;EACE,sBAAsB;EACtB,cAAc;EACd,gBAAgB;EAChB,oBAAoB;EACpB,SAAS;EACT,gBAAgB;EAChB,aAAa;EACb,gBAAgB;EAChB,aAAa;EACb,eAAe;EACf,QAAQ;EACR,YAAY;EACZ,cAAc;AAChB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;EACX,eAAe;EACf,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,UAAU;AACZ;;AAEA;EACE,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,sCAAsC;EACtC,8BAA8B;EAC9B,kBAAkB;AACpB;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,mBAAmB;EACnB,oBAAoB;EACpB,qBAAqB;EACrB,aAAa;EACb,YAAY;EACZ,sCAAsC;EACtC,8BAA8B;EAC9B,aAAa;AACf;;AAEA;EACE,cAAc;EACd;;;;;;;;2BAQyB;AAC3B;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,WAAW;AACb;;AAEA;EACE,gBAAgB;EAChB,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;EACR,iBAAiB;EACjB,WAAW;AACb;;AAEA;EACE,4BAA4B;EAC5B,gBAAgB;EAChB,QAAQ;AACV;;AAEA;EACE;IACE,UAAU;IACV,SAAS;EACX;AACF",sourcesContent:[".rs-base {\n  background-color: #333;\n  color: #fafafa;\n  border-radius: 0;\n  font: 10px monospace;\n  left: 5px;\n  line-height: 1em;\n  opacity: 0.85;\n  overflow: hidden;\n  padding: 10px;\n  position: fixed;\n  top: 5px;\n  width: 300px;\n  z-index: 10000;\n}\n\n.rs-base div.hidden {\n  display: none;\n}\n\n.rs-base h1 {\n  color: #fff;\n  cursor: pointer;\n  font-size: 1.4em;\n  font-weight: 300;\n  margin: 0 0 5px;\n  padding: 0;\n}\n\n.rs-group {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-flex-direction: column-reverse;\n  flex-direction: column-reverse;\n  margin-bottom: 5px;\n}\n\n.rs-group:last-child {\n  margin-bottom: 0;\n}\n\n.rs-counter-base {\n  align-items: center;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  height: 10px;\n  -webkit-justify-content: space-between;\n  justify-content: space-between;\n  margin: 2px 0;\n}\n\n.rs-counter-base.alarm {\n  color: #b70000;\n  text-shadow: 0 0 0 #b70000,\n               0 0 1px #fff,\n               0 0 1px #fff,\n               0 0 2px #fff,\n               0 0 2px #fff,\n               0 0 3px #fff,\n               0 0 3px #fff,\n               0 0 4px #fff,\n               0 0 4px #fff;\n}\n\n.rs-counter-id {\n  font-weight: 300;\n  -webkit-box-ordinal-group: 0;\n  -webkit-order: 0;\n  order: 0;\n  width: 54px;\n}\n\n.rs-counter-value {\n  font-weight: 300;\n  -webkit-box-ordinal-group: 1;\n  -webkit-order: 1;\n  order: 1;\n  text-align: right;\n  width: 35px;\n}\n\n.rs-canvas {\n  -webkit-box-ordinal-group: 2;\n  -webkit-order: 2;\n  order: 2;\n}\n\n@media (min-width: 480px) {\n  .rs-base {\n    left: 20px;\n    top: 20px;\n  }\n}\n"],sourceRoot:""}]);const _=N},7180:(ot,ht,I)=>{"use strict";I.r(ht),I.d(ht,{default:()=>X});var U=I(5072),$=I.n(U),O=I(7825),N=I.n(O),_=I(7659),E=I.n(_),D=I(5056),B=I.n(D),C=I(540),M=I.n(C),k=I(1113),F=I.n(k),G=I(8217),Q={};Q.styleTagTransform=F(),Q.setAttributes=B(),Q.insert=E().bind(null,"head"),Q.domAPI=N(),Q.insertStyleElement=M(),$()(G.A,Q);const X=G.A&&G.A.locals?G.A.locals:void 0},9379:(ot,ht,I)=>{"use strict";I.r(ht),I.d(ht,{default:()=>X});var U=I(5072),$=I.n(U),O=I(7825),N=I.n(O),_=I(7659),E=I.n(_),D=I(5056),B=I.n(D),C=I(540),M=I.n(C),k=I(1113),F=I.n(k),G=I(2470),Q={};Q.styleTagTransform=F(),Q.setAttributes=B(),Q.insert=E().bind(null,"head"),Q.domAPI=N(),Q.insertStyleElement=M(),$()(G.A,Q);const X=G.A&&G.A.locals?G.A.locals:void 0},5072:ot=>{"use strict";var ht=[];function I(O){for(var N=-1,_=0;_<ht.length;_++)if(ht[_].identifier===O){N=_;break}return N}function U(O,N){for(var _={},E=[],D=0;D<O.length;D++){var B=O[D],C=N.base?B[0]+N.base:B[0],M=_[C]||0,k="".concat(C," ").concat(M);_[C]=M+1;var F=I(k),G={css:B[1],media:B[2],sourceMap:B[3],supports:B[4],layer:B[5]};if(-1!==F)ht[F].references++,ht[F].updater(G);else{var Q=$(G,N);N.byIndex=D,ht.splice(D,0,{identifier:k,updater:Q,references:1})}E.push(k)}return E}function $(O,N){var _=N.domAPI(N);return _.update(O),function(E){if(E){if(E.css===O.css&&E.media===O.media&&E.sourceMap===O.sourceMap&&E.supports===O.supports&&E.layer===O.layer)return;_.update(O=E)}else _.remove()}}ot.exports=function(O,N){var _=U(O=O||[],N=N||{});return function(E){E=E||[];for(var D=0;D<_.length;D++){var B=I(_[D]);ht[B].references--}for(var C=U(E,N),M=0;M<_.length;M++){var k=I(_[M]);0===ht[k].references&&(ht[k].updater(),ht.splice(k,1))}_=C}}},7659:ot=>{"use strict";var ht={};ot.exports=function(I,U){var $=function(O){if(void 0===ht[O]){var N=document.querySelector(O);if(window.HTMLIFrameElement&&N instanceof window.HTMLIFrameElement)try{N=N.contentDocument.head}catch{N=null}ht[O]=N}return ht[O]}(I);if(!$)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");$.appendChild(U)}},540:ot=>{"use strict";ot.exports=function(ht){var I=document.createElement("style");return ht.setAttributes(I,ht.attributes),ht.insert(I,ht.options),I}},5056:(ot,ht,I)=>{"use strict";ot.exports=function(U){var $=I.nc;$&&U.setAttribute("nonce",$)}},7825:ot=>{"use strict";ot.exports=function(ht){if(typeof document>"u")return{update:function(){},remove:function(){}};var I=ht.insertStyleElement(ht);return{update:function(U){!function($,O,N){var _="";N.supports&&(_+="@supports (".concat(N.supports,") {")),N.media&&(_+="@media ".concat(N.media," {"));var E=void 0!==N.layer;E&&(_+="@layer".concat(N.layer.length>0?" ".concat(N.layer):""," {")),_+=N.css,E&&(_+="}"),N.media&&(_+="}"),N.supports&&(_+="}");var D=N.sourceMap;D&&typeof btoa<"u"&&(_+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(D))))," */")),O.styleTagTransform(_,$,O.options)}(I,ht,U)},remove:function(){!function(U){if(null===U.parentNode)return!1;U.parentNode.removeChild(U)}(I)}}}},1113:ot=>{"use strict";ot.exports=function(ht,I){if(I.styleSheet)I.styleSheet.cssText=ht;else{for(;I.firstChild;)I.removeChild(I.firstChild);I.appendChild(document.createTextNode(ht))}}},3931:ot=>{"use strict";ot.exports="data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27 standalone=%27no%27%3F%3E%3Csvg width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27 version=%271.1%27 id=%27svg320%27 sodipodi:docname=%27fullscreen-aframe.svg%27 xml:space=%27preserve%27 inkscape:version=%271.2.1 %289c6d41e  2022-07-14%29%27 xmlns:inkscape=%27http://www.inkscape.org/namespaces/inkscape%27 xmlns:sodipodi=%27http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd%27 xmlns=%27http://www.w3.org/2000/svg%27 xmlns:svg=%27http://www.w3.org/2000/svg%27 xmlns:rdf=%27http://www.w3.org/1999/02/22-rdf-syntax-ns%23%27 xmlns:cc=%27http://creativecommons.org/ns%23%27 xmlns:dc=%27http://purl.org/dc/elements/1.1/%27%3E%3Cdefs id=%27defs324%27 /%3E%3Csodipodi:namedview id=%27namedview322%27 pagecolor=%27%23ffffff%27 bordercolor=%27%23000000%27 borderopacity=%270.25%27 inkscape:showpageshadow=%272%27 inkscape:pageopacity=%270.0%27 inkscape:pagecheckerboard=%270%27 inkscape:deskcolor=%27%23d1d1d1%27 showgrid=%27false%27 inkscape:zoom=%273.8064516%27 inkscape:cx=%2791.423729%27 inkscape:cy=%27-1.4449153%27 inkscape:window-width=%271440%27 inkscape:window-height=%27847%27 inkscape:window-x=%2732%27 inkscape:window-y=%2725%27 inkscape:window-maximized=%270%27 inkscape:current-layer=%27svg320%27 /%3E%3Ctitle id=%27title312%27%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96 0H12A12 12 0 0 0 0 12V50A12 12 0 0 0 12 62H96a12 12 0 0 0 12-12V12A12 12 0 0 0 96 0Zm8 50a8 8 0 0 1-8 8H12a8 8 0 0 1-8-8V12a8 8 0 0 1 8-8H96a8 8 0 0 1 8 8Z%27 fill=%27%23fff%27 id=%27path314%27 style=%27fill:%23ffffff%27 /%3E%3Cg id=%27g356%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g358%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g360%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g362%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g364%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g366%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g368%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g370%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g372%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g374%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g376%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g378%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g380%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g382%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cg id=%27g384%27 transform=%27translate%28-206.61017 -232.61864%29%27%3E%3C/g%3E%3Cmetadata id=%27metadata561%27%3E%3Crdf:RDF%3E%3Ccc:Work rdf:about=%27%27%3E%3Cdc:title%3Eaframe-armode-noborder-reduced-tracking%3C/dc:title%3E%3C/cc:Work%3E%3C/rdf:RDF%3E%3C/metadata%3E%3Cpath d=%27m 98.168511 40.083649 c 0 -1.303681 -0.998788 -2.358041 -2.239389 -2.358041 -1.230088 0.0031 -2.240892 1.05436 -2.240892 2.358041 v 4.881296 l -9.041661 -9.041662 c -0.874129 -0.875631 -2.288954 -0.875631 -3.16308 0 -0.874129 0.874126 -0.874129 2.293459 0 3.167585 l 8.995101 8.992101 h -4.858767 c -1.323206 0.0031 -2.389583 1.004796 -2.389583 2.239386 0 1.237598 1.066377 2.237888 2.389583 2.237888 h 10.154599 c 1.323206 0 2.388082 -0.998789 2.392587 -2.237888 -0.0044 -0.03305 -0.009 -0.05858 -0.0134 -0.09161 0.0046 -0.04207 0.0134 -0.08712 0.0134 -0.13066 V 40.085172 h -1.52e-4%27 id=%27path596%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 23.091002 35.921781 -9.026643 9.041662 v -4.881296 c 0 -1.303681 -1.009302 -2.355037 -2.242393 -2.358041 -1.237598 0 -2.237888 1.05436 -2.237888 2.358041 l -0.0031 10.016421 c 0 0.04356 0.01211 0.08862 0.0015 0.130659 -0.0031 0.03153 -0.009 0.05709 -0.01211 0.09161 0.0031 1.239099 1.069379 2.237888 2.391085 2.237888 h 10.156101 c 1.320202 0 2.388079 -1.000291 2.388079 -2.237888 0 -1.234591 -1.067877 -2.236383 -2.388079 -2.239387 h -4.858767 l 8.995101 -8.9921 c 0.871126 -0.874127 0.871126 -2.293459 0 -3.167586 -0.875628 -0.877132 -2.291957 -0.877132 -3.169087 -1.52e-4%27 id=%27path598%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 84.649572 25.978033 9.041662 -9.041664 v 4.881298 c 0 1.299176 1.010806 2.350532 2.240891 2.355037 1.240601 0 2.23939 -1.055861 2.23939 -2.355037 V 11.798242 c 0 -0.04356 -0.009 -0.08862 -0.0134 -0.127671 0.0044 -0.03153 0.009 -0.06157 0.0134 -0.09313 -0.0044 -1.240598 -1.069379 -2.2393873 -2.391085 -2.2393873 h -10.1546 c -1.323205 0 -2.38958 0.9987893 -2.38958 2.2393873 0 1.233091 1.066375 2.237887 2.38958 2.240891 h 4.858768 l -8.995102 8.9921 c -0.874129 0.872625 -0.874129 2.288954 0 3.161578 0.874127 0.880137 2.288951 0.880137 3.16308 1.5e-4%27 id=%27path600%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3Cpath d=%27m 17.264988 13.822853 h 4.857265 c 1.320202 -0.0031 2.388079 -1.0078 2.388079 -2.240889 0 -1.240601 -1.067877 -2.2393893 -2.388079 -2.2393893 H 11.967654 c -1.321707 0 -2.388082 0.9987883 -2.391085 2.2393893 0.0031 0.03153 0.009 0.06157 0.01211 0.09313 -0.0031 0.03905 -0.0015 0.08262 -0.0015 0.127671 l 0.0031 10.020926 c 0 1.299176 1.00029 2.355038 2.237887 2.355038 1.233092 -0.0044 2.242393 -1.055862 2.242393 -2.355038 v -4.881295 l 9.026644 9.041661 c 0.877132 0.878635 2.293459 0.878635 3.169087 0 0.871125 -0.872624 0.871125 -2.288953 0 -3.161577 l -8.995282 -8.993616%27 id=%27path602%27 style=%27fill:%23ffffff%3Bstroke-width:1.50194%27 /%3E%3C/svg%3E"},6085:ot=>{"use strict";ot.exports="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-armode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0Zm8,50a8,8,0,0,1-8,8H12a8,8,0,0,1-8-8V12a8,8,0,0,1,8-8H96a8,8,0,0,1,8,8Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M43.35,39.82H32.51L30.45,46H23.88L35,16h5.73L52,46H45.43Zm-9.17-5h7.5L37.91,23.58Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M68.11,35H63.18V46H57V16H68.15q5.31,0,8.2,2.37a8.18,8.18,0,0,1,2.88,6.7,9.22,9.22,0,0,1-1.33,5.12,9.09,9.09,0,0,1-4,3.26l6.49,12.26V46H73.73Zm-4.93-5h5a5.09,5.09,0,0,0,3.6-1.18,4.21,4.21,0,0,0,1.28-3.27,4.56,4.56,0,0,0-1.2-3.34A5,5,0,0,0,68.15,21h-5Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"},9169:ot=>{"use strict";ot.exports="data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%27108%27 height=%2762%27 viewBox=%270 0 108 62%27%3E%3Ctitle%3Eaframe-vrmode-noborder-reduced-tracking%3C/title%3E%3Cpath d=%27M68.81,21.56H64.23v8.27h4.58a4.13,4.13,0,0,0,3.1-1.09,4.2,4.2,0,0,0,1-3,4.24,4.24,0,0,0-1-3A4.05,4.05,0,0,0,68.81,21.56Z%27 fill=%27%23fff%27/%3E%3Cpath d=%27M96,0H12A12,12,0,0,0,0,12V50A12,12,0,0,0,12,62H96a12,12,0,0,0,12-12V12A12,12,0,0,0,96,0ZM41.9,46H34L24,16h8l6,21.84,6-21.84H52Zm39.29,0H73.44L68.15,35.39H64.23V46H57V16H68.81q5.32,0,8.34,2.37a8,8,0,0,1,3,6.69,9.68,9.68,0,0,1-1.27,5.18,8.9,8.9,0,0,1-4,3.34l6.26,12.11Z%27 fill=%27%23fff%27/%3E%3C/svg%3E"},6517:ot=>{"use strict";ot.exports="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E"},7889:ot=>{"use strict";ot.exports="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E"},9611:(ot,ht,I)=>{"use strict";I.d(ht,{A:()=>jx});var U={};I.r(U),I.d(U,{ACESFilmicToneMapping:()=>Ae,AddEquation:()=>et,AddOperation:()=>st,AdditiveAnimationBlendMode:()=>dl,AdditiveBlending:()=>vt,AgXToneMapping:()=>_e,AlphaFormat:()=>Ri,AlwaysCompare:()=>Ld,AlwaysDepth:()=>Xa,AlwaysStencilFunc:()=>wh,AmbientLight:()=>ev,AnimationAction:()=>Zg,AnimationClip:()=>Rp,AnimationLoader:()=>Jb,AnimationMixer:()=>hy,AnimationObjectGroup:()=>cy,AnimationUtils:()=>X1,ArcCurve:()=>Vf,ArrayCamera:()=>Mf,ArrowHelper:()=>yx,AttachedBindMode:()=>hn,Audio:()=>Yg,AudioAnalyser:()=>wu,AudioContext:()=>Wg,AudioListener:()=>Xg,AudioLoader:()=>ry,AxesHelper:()=>vx,BackSide:()=>X,BasicDepthPacking:()=>Pl,BasicShadowMap:()=>M,BatchedMesh:()=>Ji,Bone:()=>du,BooleanKeyframeTrack:()=>od,Box2:()=>ax,Box3:()=>ta,Box3Helper:()=>gx,BoxGeometry:()=>Ko,BoxHelper:()=>mx,BufferAttribute:()=>wr,BufferGeometry:()=>gr,BufferGeometryLoader:()=>sl,ByteType:()=>Kn,Cache:()=>Il,Camera:()=>Xm,CameraHelper:()=>fx,CanvasTexture:()=>bp,CapsuleGeometry:()=>qf,CatmullRomCurve3:()=>wc,CineonToneMapping:()=>Ht,CircleGeometry:()=>gu,ClampToEdgeWrapping:()=>Ut,Clock:()=>Fp,Color:()=>En,ColorKeyframeTrack:()=>q0,ColorManagement:()=>Jr,CompressedArrayTexture:()=>$1,CompressedCubeTexture:()=>vp,CompressedTexture:()=>Ea,CompressedTextureLoader:()=>Z1,ConeGeometry:()=>ih,ConstantAlphaFactor:()=>Oa,ConstantColorFactor:()=>As,CubeCamera:()=>A1,CubeReflectionMapping:()=>Wr,CubeRefractionMapping:()=>ii,CubeTexture:()=>vf,CubeTextureLoader:()=>Zb,CubeUVReflectionMapping:()=>lr,CubicBezierCurve:()=>U0,CubicBezierCurve3:()=>wp,CubicInterpolant:()=>Y1,CullFaceBack:()=>D,CullFaceFront:()=>B,CullFaceFrontBack:()=>C,CullFaceNone:()=>E,Curve:()=>nl,CurvePath:()=>G1,CustomBlending:()=>wt,CustomToneMapping:()=>Wt,CylinderGeometry:()=>Zl,Cylindrical:()=>pv,Data3DTexture:()=>Rh,DataArrayTexture:()=>kh,DataTexture:()=>pu,DataTextureLoader:()=>tx,DataUtils:()=>pf,DecrementStencilOp:()=>Om,DecrementWrapStencilOp:()=>Md,DefaultLoadingManager:()=>sm,DepthFormat:()=>Bi,DepthStencilFormat:()=>Ta,DepthTexture:()=>h0,DetachedBindMode:()=>kn,DirectionalLight:()=>ny,DirectionalLightHelper:()=>px,DiscreteInterpolant:()=>j0,DisplayP3ColorSpace:()=>Nu,DodecahedronGeometry:()=>Do,DoubleSide:()=>lt,DstAlphaFactor:()=>nr,DstColorFactor:()=>Cs,DynamicCopyUsage:()=>sf,DynamicDrawUsage:()=>ef,DynamicReadUsage:()=>nf,EdgesGeometry:()=>Q1,EllipseCurve:()=>xp,EqualCompare:()=>XA,EqualDepth:()=>ys,EqualStencilFunc:()=>Jp,EquirectangularReflectionMapping:()=>mo,EquirectangularRefractionMapping:()=>si,Euler:()=>Gi,EventDispatcher:()=>to,ExtrudeGeometry:()=>Ng,FileLoader:()=>La,Float16BufferAttribute:()=>Xl,Float32BufferAttribute:()=>Tn,FloatType:()=>wn,Fog:()=>le,FogExp2:()=>va,FramebufferTexture:()=>$s,FrontSide:()=>Q,Frustum:()=>Ra,GLBufferAttribute:()=>uv,GLSL1:()=>Vm,GLSL3:()=>Lu,GreaterCompare:()=>tf,GreaterDepth:()=>qs,GreaterEqualCompare:()=>Ch,GreaterEqualDepth:()=>To,GreaterEqualStencilFunc:()=>Rd,GreaterStencilFunc:()=>Um,GridHelper:()=>hx,Group:()=>tl,HalfFloatType:()=>br,HemisphereLight:()=>Y0,HemisphereLightHelper:()=>ux,IcosahedronGeometry:()=>Mp,ImageBitmapLoader:()=>uh,ImageLoader:()=>Np,ImageUtils:()=>_h,IncrementStencilOp:()=>Sd,IncrementWrapStencilOp:()=>Pm,InstancedBufferAttribute:()=>Jl,InstancedBufferGeometry:()=>rv,InstancedInterleavedBuffer:()=>cv,InstancedMesh:()=>xo,Int16BufferAttribute:()=>r0,Int32BufferAttribute:()=>s0,Int8BufferAttribute:()=>p1,IntType:()=>Tr,InterleavedBuffer:()=>Ku,InterleavedBufferAttribute:()=>ba,Interpolant:()=>Au,InterpolateDiscrete:()=>$i,InterpolateLinear:()=>Zs,InterpolateSmooth:()=>Qo,InvertStencilOp:()=>Td,KeepStencilOp:()=>Ul,KeyframeTrack:()=>tc,LOD:()=>Bf,LatheGeometry:()=>jf,Layers:()=>qd,LessCompare:()=>Nd,LessDepth:()=>Ya,LessEqualCompare:()=>Eh,LessEqualDepth:()=>_i,LessEqualStencilFunc:()=>Zp,LessStencilFunc:()=>Kp,Light:()=>ch,LightProbe:()=>Gg,Line:()=>Ni,Line3:()=>mv,LineBasicMaterial:()=>ls,LineCurve:()=>Tg,LineCurve3:()=>Ep,LineDashedMaterial:()=>rm,LineLoop:()=>zf,LineSegments:()=>Ai,LinearDisplayP3ColorSpace:()=>Uc,LinearFilter:()=>cn,LinearInterpolant:()=>$g,LinearMipMapLinearFilter:()=>Mr,LinearMipMapNearestFilter:()=>qe,LinearMipmapLinearFilter:()=>Sn,LinearMipmapNearestFilter:()=>bn,LinearSRGBColorSpace:()=>ps,LinearToneMapping:()=>Z,LinearTransfer:()=>ac,Loader:()=>Ca,LoaderUtils:()=>vu,LoadingManager:()=>Bp,LoopOnce:()=>Js,LoopPingPong:()=>ds,LoopRepeat:()=>hs,LuminanceAlphaFormat:()=>_o,LuminanceFormat:()=>go,MOUSE:()=>N,Material:()=>di,MaterialLoader:()=>Qg,MathUtils:()=>Fu,Matrix3:()=>yr,Matrix4:()=>Yn,MaxEquation:()=>ve,Mesh:()=>os,MeshBasicMaterial:()=>no,MeshDepthMaterial:()=>Wh,MeshDistanceMaterial:()=>cu,MeshLambertMaterial:()=>Og,MeshMatcapMaterial:()=>nm,MeshNormalMaterial:()=>q1,MeshPhongMaterial:()=>em,MeshPhysicalMaterial:()=>rl,MeshStandardMaterial:()=>kp,MeshToonMaterial:()=>Fg,MinEquation:()=>Yt,MirroredRepeatWrapping:()=>jt,MixOperation:()=>q,MultiplyBlending:()=>ft,MultiplyOperation:()=>Ct,NearestFilter:()=>be,NearestMipMapLinearFilter:()=>pn,NearestMipMapNearestFilter:()=>tn,NearestMipmapLinearFilter:()=>ke,NearestMipmapNearestFilter:()=>Ze,NeutralToneMapping:()=>We,NeverCompare:()=>Bd,NeverDepth:()=>js,NeverStencilFunc:()=>_d,NoBlending:()=>rt,NoColorSpace:()=>vo,NoToneMapping:()=>ut,NormalAnimationBlendMode:()=>hl,NormalBlending:()=>pt,NotEqualCompare:()=>Dd,NotEqualDepth:()=>se,NotEqualStencilFunc:()=>kd,NumberKeyframeTrack:()=>ld,Object3D:()=>hi,ObjectLoader:()=>iv,ObjectSpaceNormalMap:()=>xh,OctahedronGeometry:()=>lh,OneFactor:()=>Ge,OneMinusConstantAlphaFactor:()=>ha,OneMinusConstantColorFactor:()=>ua,OneMinusDstAlphaFactor:()=>hr,OneMinusDstColorFactor:()=>Ti,OneMinusSrcAlphaFactor:()=>_n,OneMinusSrcColorFactor:()=>nn,OrthographicCamera:()=>bf,P3Primaries:()=>$c,PCFShadowMap:()=>k,PCFSoftShadowMap:()=>F,PMREMGenerator:()=>u0,Path:()=>Wf,PerspectiveCamera:()=>ea,Plane:()=>tu,PlaneGeometry:()=>ap,PlaneHelper:()=>Ax,PointLight:()=>ey,PointLightHelper:()=>lx,Points:()=>nh,PointsMaterial:()=>wa,PolarGridHelper:()=>dx,PolyhedronGeometry:()=>Ec,PositionalAudio:()=>oy,PropertyBinding:()=>pi,PropertyMixer:()=>ly,QuadraticBezierCurve:()=>Cp,QuadraticBezierCurve3:()=>z0,Quaternion:()=>_s,QuaternionKeyframeTrack:()=>il,QuaternionLinearInterpolant:()=>K1,RED_GREEN_RGTC2_Format:()=>rs,RED_RGTC1_Format:()=>us,REVISION:()=>O,RGBADepthPacking:()=>Wo,RGBAFormat:()=>de,RGBAIntegerFormat:()=>Ms,RGBA_ASTC_10x10_Format:()=>dr,RGBA_ASTC_10x5_Format:()=>Be,RGBA_ASTC_10x6_Format:()=>Pn,RGBA_ASTC_10x8_Format:()=>Xn,RGBA_ASTC_12x10_Format:()=>Ar,RGBA_ASTC_12x12_Format:()=>xr,RGBA_ASTC_4x4_Format:()=>It,RGBA_ASTC_5x4_Format:()=>Mt,RGBA_ASTC_5x5_Format:()=>Gt,RGBA_ASTC_6x5_Format:()=>Xt,RGBA_ASTC_6x6_Format:()=>Me,RGBA_ASTC_8x5_Format:()=>sn,RGBA_ASTC_8x6_Format:()=>un,RGBA_ASTC_8x8_Format:()=>Ie,RGBA_BPTC_Format:()=>_r,RGBA_ETC2_EAC_Format:()=>mt,RGBA_PVRTC_2BPPV1_Format:()=>Go,RGBA_PVRTC_4BPPV1_Format:()=>Ol,RGBA_S3TC_DXT1_Format:()=>Pa,RGBA_S3TC_DXT3_Format:()=>Ys,RGBA_S3TC_DXT5_Format:()=>Ks,RGBFormat:()=>jr,RGB_BPTC_SIGNED_Format:()=>Pr,RGB_BPTC_UNSIGNED_Format:()=>ui,RGB_ETC1_Format:()=>Li,RGB_ETC2_Format:()=>K,RGB_PVRTC_2BPPV1_Format:()=>oi,RGB_PVRTC_4BPPV1_Format:()=>Ka,RGB_S3TC_DXT1_Format:()=>_a,RGFormat:()=>Ss,RGIntegerFormat:()=>Xs,RawShaderMaterial:()=>Lg,Ray:()=>hc,Raycaster:()=>hv,Rec709Primaries:()=>zc,RectAreaLight:()=>nv,RedFormat:()=>da,RedIntegerFormat:()=>pa,ReinhardToneMapping:()=>_t,RenderTarget:()=>$d,RepeatWrapping:()=>ki,ReplaceStencilOp:()=>Id,ReverseSubtractEquation:()=>Rt,RingGeometry:()=>sd,SIGNED_RED_GREEN_RGTC2_Format:()=>Ts,SIGNED_RED_RGTC1_Format:()=>Fi,SRGBColorSpace:()=>qi,SRGBTransfer:()=>Ii,Scene:()=>up,ShaderChunk:()=>Ur,ShaderLib:()=>Yl,ShaderMaterial:()=>xl,ShadowMaterial:()=>W0,Shape:()=>td,ShapeGeometry:()=>Tp,ShapePath:()=>bx,ShapeUtils:()=>Yi,ShortType:()=>gn,Skeleton:()=>Us,SkeletonHelper:()=>ox,SkinnedMesh:()=>Lf,Source:()=>fl,Sphere:()=>Ls,SphereGeometry:()=>oo,Spherical:()=>dv,SphericalHarmonics3:()=>Dp,SplineCurve:()=>rh,SpotLight:()=>Z0,SpotLightHelper:()=>yy,Sprite:()=>R0,SpriteMaterial:()=>Gr,SrcAlphaFactor:()=>vn,SrcAlphaSaturateFactor:()=>Is,SrcColorFactor:()=>en,StaticCopyUsage:()=>Fd,StaticDrawUsage:()=>Du,StaticReadUsage:()=>$m,StereoCamera:()=>iy,StreamCopyUsage:()=>Od,StreamDrawUsage:()=>zm,StreamReadUsage:()=>rf,StringKeyframeTrack:()=>cd,SubtractEquation:()=>xt,SubtractiveBlending:()=>bt,TOUCH:()=>_,TangentSpaceNormalMap:()=>wi,TetrahedronGeometry:()=>Zf,Texture:()=>Vi,TextureLoader:()=>X0,TorusGeometry:()=>ad,TorusKnotGeometry:()=>_p,Triangle:()=>Re,TriangleFanDrawMode:()=>yo,TriangleStripDrawMode:()=>pl,TrianglesDrawMode:()=>Ho,TubeGeometry:()=>Dg,UVMapping:()=>Hr,Uint16BufferAttribute:()=>i0,Uint32BufferAttribute:()=>mf,Uint8BufferAttribute:()=>Kt,Uint8ClampedBufferAttribute:()=>_b,Uniform:()=>cm,UniformsGroup:()=>dy,UniformsLib:()=>Bn,UniformsUtils:()=>ju,UnsignedByteType:()=>jn,UnsignedInt248Type:()=>ai,UnsignedInt5999Type:()=>ci,UnsignedIntType:()=>rr,UnsignedShort4444Type:()=>xi,UnsignedShort5551Type:()=>cr,UnsignedShortType:()=>vr,VSMShadowMap:()=>G,Vector2:()=>Ye,Vector3:()=>Dt,Vector4:()=>li,VectorKeyframeTrack:()=>ud,VideoTexture:()=>fs,WebGL3DRenderTarget:()=>Qm,WebGLArrayRenderTarget:()=>Gm,WebGLCoordinateSystem:()=>ko,WebGLCubeRenderTarget:()=>o0,WebGLMultipleRenderTargets:()=>xx,WebGLRenderTarget:()=>bo,WebGLRenderer:()=>uu,WebGLUtils:()=>yg,WebGPUCoordinateSystem:()=>Vc,WireframeGeometry:()=>H0,WrapAroundEnding:()=>Ao,ZeroCurvatureEnding:()=>Ja,ZeroFactor:()=>xe,ZeroSlopeEnding:()=>Za,ZeroStencilOp:()=>Fm,createCanvasElement:()=>lf});var $={};I.r($),I.d($,{computeMikkTSpaceTangents:()=>Ex,computeMorphedAttributes:()=>kx,deepCloneAttribute:()=>Ix,deinterleaveAttribute:()=>sA,deinterleaveGeometry:()=>Mx,estimateBytesUsed:()=>Tx,interleaveAttributes:()=>Sx,mergeAttributes:()=>xy,mergeGeometries:()=>Cx,mergeGroups:()=>wv,mergeVertices:()=>_x,toCreasedNormals:()=>Ev,toTrianglesDrawMode:()=>wy});const O="164",N={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},_={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},E=0,D=1,B=2,C=3,M=0,k=1,F=2,G=3,Q=0,X=1,lt=2,rt=0,pt=1,vt=2,bt=3,ft=4,wt=5,et=100,xt=101,Rt=102,Yt=103,ve=104,xe=200,Ge=201,en=202,nn=203,vn=204,_n=205,nr=206,hr=207,Cs=208,Ti=209,Is=210,As=211,ua=212,Oa=213,ha=214,js=0,Xa=1,Ya=2,_i=3,ys=4,To=5,qs=6,se=7,Ct=0,q=1,st=2,ut=0,Z=1,_t=2,Ht=3,Ae=4,Wt=5,_e=6,We=7,hn="attached",kn="detached",Hr=300,Wr=301,ii=302,mo=303,si=304,lr=306,ki=1e3,Ut=1001,jt=1002,be=1003,Ze=1004,tn=1004,ke=1005,pn=1005,cn=1006,bn=1007,qe=1007,Sn=1008,Mr=1008,jn=1009,Kn=1010,gn=1011,vr=1012,Tr=1013,rr=1014,wn=1015,br=1016,xi=1017,cr=1018,ai=1020,ci=35902,Ri=1021,jr=1022,de=1023,go=1024,_o=1025,Bi=1026,Ta=1027,da=1028,pa=1029,Ss=1030,Xs=1031,Ms=1033,_a=33776,Pa=33777,Ys=33778,Ks=33779,Ka=35840,oi=35841,Ol=35842,Go=35843,Li=36196,K=37492,mt=37496,It=37808,Mt=37809,Gt=37810,Xt=37811,Me=37812,sn=37813,un=37814,Ie=37815,Be=37816,Pn=37817,Xn=37818,dr=37819,Ar=37820,xr=37821,_r=36492,Pr=36494,ui=36495,us=36283,Fi=36284,rs=36285,Ts=36286,Js=2200,hs=2201,ds=2202,$i=2300,Zs=2301,Qo=2302,Ja=2400,Za=2401,Ao=2402,hl=2500,dl=2501,Ho=0,pl=1,yo=2,Pl=3200,Wo=3201,wi=0,xh=1,vo="",qi="srgb",ps="srgb-linear",Nu="display-p3",Uc="display-p3-linear",ac="linear",Ii="srgb",zc="rec709",$c="p3",Fm=0,Ul=7680,Id=7681,Sd=7682,Om=7683,Pm=34055,Md=34056,Td=5386,_d=512,Kp=513,Jp=514,Zp=515,Um=516,kd=517,Rd=518,wh=519,Bd=512,Nd=513,XA=514,Eh=515,tf=516,Dd=517,Ch=518,Ld=519,Du=35044,ef=35048,zm=35040,$m=35045,nf=35049,rf=35041,Fd=35046,sf=35050,Od=35042,Vm="100",Lu="300 es",ko=2e3,Vc=2001;class to{addEventListener(e,s){void 0===this._listeners&&(this._listeners={});const l=this._listeners;void 0===l[e]&&(l[e]=[]),-1===l[e].indexOf(s)&&l[e].push(s)}hasEventListener(e,s){if(void 0===this._listeners)return!1;const l=this._listeners;return void 0!==l[e]&&-1!==l[e].indexOf(s)}removeEventListener(e,s){if(void 0===this._listeners)return;const l=this._listeners[e];if(void 0!==l){const c=l.indexOf(s);-1!==c&&l.splice(c,1)}}dispatchEvent(e){if(void 0===this._listeners)return;const s=this._listeners[e.type];if(void 0!==s){e.target=this;const l=s.slice(0);for(let c=0,d=l.length;c<d;c++)l[c].call(this,e);e.target=null}}}const fa=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let af=1234567;const zl=Math.PI/180,oc=180/Math.PI;function Ua(){const A=4294967295*Math.random()|0,e=4294967295*Math.random()|0,s=4294967295*Math.random()|0,l=4294967295*Math.random()|0;return(fa[255&A]+fa[A>>8&255]+fa[A>>16&255]+fa[A>>24&255]+"-"+fa[255&e]+fa[e>>8&255]+"-"+fa[e>>16&15|64]+fa[e>>24&255]+"-"+fa[63&s|128]+fa[s>>8&255]+"-"+fa[s>>16&255]+fa[s>>24&255]+fa[255&l]+fa[l>>8&255]+fa[l>>16&255]+fa[l>>24&255]).toLowerCase()}function Ki(A,e,s){return Math.max(e,Math.min(s,A))}function YA(A,e){return(A%e+e)%e}function lc(A,e,s){return(1-s)*A+s*e}function ma(A,e){switch(e.constructor){case Float32Array:return A;case Uint32Array:return A/4294967295;case Uint16Array:return A/65535;case Uint8Array:return A/255;case Int32Array:return Math.max(A/2147483647,-1);case Int16Array:return Math.max(A/32767,-1);case Int8Array:return Math.max(A/127,-1);default:throw new Error("Invalid component type.")}}function Br(A,e){switch(e.constructor){case Float32Array:return A;case Uint32Array:return Math.round(4294967295*A);case Uint16Array:return Math.round(65535*A);case Uint8Array:return Math.round(255*A);case Int32Array:return Math.round(2147483647*A);case Int16Array:return Math.round(32767*A);case Int8Array:return Math.round(127*A);default:throw new Error("Invalid component type.")}}const Fu={DEG2RAD:zl,RAD2DEG:oc,generateUUID:Ua,clamp:Ki,euclideanModulo:YA,mapLinear:function(A,e,s,l,c){return l+(A-e)*(c-l)/(s-e)},inverseLerp:function(A,e,s){return A!==e?(s-A)/(e-A):0},lerp:lc,damp:function(A,e,s,l){return lc(A,e,1-Math.exp(-s*l))},pingpong:function(A,e=1){return e-Math.abs(YA(A,2*e)-e)},smoothstep:function(A,e,s){return A<=e?0:A>=s?1:(A=(A-e)/(s-e))*A*(3-2*A)},smootherstep:function(A,e,s){return A<=e?0:A>=s?1:(A=(A-e)/(s-e))*A*A*(A*(6*A-15)+10)},randInt:function(A,e){return A+Math.floor(Math.random()*(e-A+1))},randFloat:function(A,e){return A+Math.random()*(e-A)},randFloatSpread:function(A){return A*(.5-Math.random())},seededRandom:function(A){void 0!==A&&(af=A);let e=af+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(A){return A*zl},radToDeg:function(A){return A*oc},isPowerOfTwo:function(A){return!(A&A-1)&&0!==A},ceilPowerOfTwo:function(A){return Math.pow(2,Math.ceil(Math.log(A)/Math.LN2))},floorPowerOfTwo:function(A){return Math.pow(2,Math.floor(Math.log(A)/Math.LN2))},setQuaternionFromProperEuler:function(A,e,s,l,c){const d=Math.cos,g=Math.sin,v=d(s/2),x=g(s/2),w=d((e+l)/2),S=g((e+l)/2),P=d((e-l)/2),z=g((e-l)/2),W=d((l-e)/2),Y=g((l-e)/2);switch(c){case"XYX":A.set(v*S,x*P,x*z,v*w);break;case"YZY":A.set(x*z,v*S,x*P,v*w);break;case"ZXZ":A.set(x*P,x*z,v*S,v*w);break;case"XZX":A.set(v*S,x*Y,x*W,v*w);break;case"YXY":A.set(x*W,v*S,x*Y,v*w);break;case"ZYZ":A.set(x*Y,x*W,v*S,v*w);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+c)}},normalize:Br,denormalize:ma};class Ye{constructor(e=0,s=0){Ye.prototype.isVector2=!0,this.x=e,this.y=s}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,s){return this.x=e,this.y=s,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,s){switch(e){case 0:this.x=s;break;case 1:this.y=s;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,s){return this.x=e.x+s.x,this.y=e.y+s.y,this}addScaledVector(e,s){return this.x+=e.x*s,this.y+=e.y*s,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,s){return this.x=e.x-s.x,this.y=e.y-s.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const s=this.x,l=this.y,c=e.elements;return this.x=c[0]*s+c[3]*l+c[6],this.y=c[1]*s+c[4]*l+c[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,s){return this.x=Math.max(e.x,Math.min(s.x,this.x)),this.y=Math.max(e.y,Math.min(s.y,this.y)),this}clampScalar(e,s){return this.x=Math.max(e,Math.min(s,this.x)),this.y=Math.max(e,Math.min(s,this.y)),this}clampLength(e,s){const l=this.length();return this.divideScalar(l||1).multiplyScalar(Math.max(e,Math.min(s,l)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const s=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===s)return Math.PI/2;const l=this.dot(e)/s;return Math.acos(Ki(l,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const s=this.x-e.x,l=this.y-e.y;return s*s+l*l}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,s){return this.x+=(e.x-this.x)*s,this.y+=(e.y-this.y)*s,this}lerpVectors(e,s,l){return this.x=e.x+(s.x-e.x)*l,this.y=e.y+(s.y-e.y)*l,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,s=0){return this.x=e[s],this.y=e[s+1],this}toArray(e=[],s=0){return e[s]=this.x,e[s+1]=this.y,e}fromBufferAttribute(e,s){return this.x=e.getX(s),this.y=e.getY(s),this}rotateAround(e,s){const l=Math.cos(s),c=Math.sin(s),d=this.x-e.x,g=this.y-e.y;return this.x=d*l-g*c+e.x,this.y=d*c+g*l+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class yr{constructor(e,s,l,c,d,g,v,x,w){yr.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==e&&this.set(e,s,l,c,d,g,v,x,w)}set(e,s,l,c,d,g,v,x,w){const S=this.elements;return S[0]=e,S[1]=c,S[2]=v,S[3]=s,S[4]=d,S[5]=x,S[6]=l,S[7]=g,S[8]=w,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const s=this.elements,l=e.elements;return s[0]=l[0],s[1]=l[1],s[2]=l[2],s[3]=l[3],s[4]=l[4],s[5]=l[5],s[6]=l[6],s[7]=l[7],s[8]=l[8],this}extractBasis(e,s,l){return e.setFromMatrix3Column(this,0),s.setFromMatrix3Column(this,1),l.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const s=e.elements;return this.set(s[0],s[4],s[8],s[1],s[5],s[9],s[2],s[6],s[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,s){const l=e.elements,c=s.elements,d=this.elements,g=l[0],v=l[3],x=l[6],w=l[1],S=l[4],P=l[7],z=l[2],W=l[5],Y=l[8],tt=c[0],J=c[3],at=c[6],it=c[1],ct=c[4],At=c[7],Ft=c[2],Tt=c[5],Pt=c[8];return d[0]=g*tt+v*it+x*Ft,d[3]=g*J+v*ct+x*Tt,d[6]=g*at+v*At+x*Pt,d[1]=w*tt+S*it+P*Ft,d[4]=w*J+S*ct+P*Tt,d[7]=w*at+S*At+P*Pt,d[2]=z*tt+W*it+Y*Ft,d[5]=z*J+W*ct+Y*Tt,d[8]=z*at+W*At+Y*Pt,this}multiplyScalar(e){const s=this.elements;return s[0]*=e,s[3]*=e,s[6]*=e,s[1]*=e,s[4]*=e,s[7]*=e,s[2]*=e,s[5]*=e,s[8]*=e,this}determinant(){const e=this.elements,s=e[0],l=e[1],c=e[2],d=e[3],g=e[4],v=e[5],x=e[6],w=e[7],S=e[8];return s*g*S-s*v*w-l*d*S+l*v*x+c*d*w-c*g*x}invert(){const e=this.elements,s=e[0],l=e[1],c=e[2],d=e[3],g=e[4],v=e[5],x=e[6],w=e[7],S=e[8],P=S*g-v*w,z=v*x-S*d,W=w*d-g*x,Y=s*P+l*z+c*W;if(0===Y)return this.set(0,0,0,0,0,0,0,0,0);const tt=1/Y;return e[0]=P*tt,e[1]=(c*w-S*l)*tt,e[2]=(v*l-c*g)*tt,e[3]=z*tt,e[4]=(S*s-c*x)*tt,e[5]=(c*d-v*s)*tt,e[6]=W*tt,e[7]=(l*x-w*s)*tt,e[8]=(g*s-l*d)*tt,this}transpose(){let e;const s=this.elements;return e=s[1],s[1]=s[3],s[3]=e,e=s[2],s[2]=s[6],s[6]=e,e=s[5],s[5]=s[7],s[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const s=this.elements;return e[0]=s[0],e[1]=s[3],e[2]=s[6],e[3]=s[1],e[4]=s[4],e[5]=s[7],e[6]=s[2],e[7]=s[5],e[8]=s[8],this}setUvTransform(e,s,l,c,d,g,v){const x=Math.cos(d),w=Math.sin(d);return this.set(l*x,l*w,-l*(x*g+w*v)+g+e,-c*w,c*x,-c*(-w*g+x*v)+v+s,0,0,1),this}scale(e,s){return this.premultiply(Ou.makeScale(e,s)),this}rotate(e){return this.premultiply(Ou.makeRotation(-e)),this}translate(e,s){return this.premultiply(Ou.makeTranslation(e,s)),this}makeTranslation(e,s){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,s,0,0,1),this}makeRotation(e){const s=Math.cos(e),l=Math.sin(e);return this.set(s,-l,0,l,s,0,0,0,1),this}makeScale(e,s){return this.set(e,0,0,0,s,0,0,0,1),this}equals(e){const s=this.elements,l=e.elements;for(let c=0;c<9;c++)if(s[c]!==l[c])return!1;return!0}fromArray(e,s=0){for(let l=0;l<9;l++)this.elements[l]=e[l+s];return this}toArray(e=[],s=0){const l=this.elements;return e[s]=l[0],e[s+1]=l[1],e[s+2]=l[2],e[s+3]=l[3],e[s+4]=l[4],e[s+5]=l[5],e[s+6]=l[6],e[s+7]=l[7],e[s+8]=l[8],e}clone(){return(new this.constructor).fromArray(this.elements)}}const Ou=new yr;function Pd(A){for(let e=A.length-1;e>=0;--e)if(A[e]>=65535)return!0;return!1}const of={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Gc(A,e){return new of[A](e)}function Qc(A){return document.createElementNS("http://www.w3.org/1999/xhtml",A)}function lf(){const A=Qc("canvas");return A.style.display="block",A}const Ih={};function Ud(A){A in Ih||(Ih[A]=!0,console.warn(A))}const Sh=(new yr).set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),Mh=(new yr).set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Th={[ps]:{transfer:ac,primaries:zc,toReference:A=>A,fromReference:A=>A},[qi]:{transfer:Ii,primaries:zc,toReference:A=>A.convertSRGBToLinear(),fromReference:A=>A.convertLinearToSRGB()},[Uc]:{transfer:ac,primaries:$c,toReference:A=>A.applyMatrix3(Mh),fromReference:A=>A.applyMatrix3(Sh)},[Nu]:{transfer:Ii,primaries:$c,toReference:A=>A.convertSRGBToLinear().applyMatrix3(Mh),fromReference:A=>A.applyMatrix3(Sh).convertLinearToSRGB()}},cf=new Set([ps,Uc]),Jr={enabled:!0,_workingColorSpace:ps,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(A){if(!cf.has(A))throw new Error(`Unsupported working color space, "${A}".`);this._workingColorSpace=A},convert:function(A,e,s){return!1!==this.enabled&&e!==s&&e&&s?(0,Th[s].fromReference)((0,Th[e].toReference)(A)):A},fromWorkingColorSpace:function(A,e){return this.convert(A,this._workingColorSpace,e)},toWorkingColorSpace:function(A,e){return this.convert(A,e,this._workingColorSpace)},getPrimaries:function(A){return Th[A].primaries},getTransfer:function(A){return A===vo?ac:Th[A].transfer}};function cc(A){return A<.04045?.0773993808*A:Math.pow(.9478672986*A+.0521327014,2.4)}function Pu(A){return A<.0031308?12.92*A:1.055*Math.pow(A,.41666)-.055}let $l;class _h{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let s;if(e instanceof HTMLCanvasElement)s=e;else{void 0===$l&&($l=Qc("canvas")),$l.width=e.width,$l.height=e.height;const l=$l.getContext("2d");e instanceof ImageData?l.putImageData(e,0,0):l.drawImage(e,0,0,e.width,e.height),s=$l}return s.width>2048||s.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),s.toDataURL("image/jpeg",.6)):s.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const s=Qc("canvas");s.width=e.width,s.height=e.height;const l=s.getContext("2d");l.drawImage(e,0,0,e.width,e.height);const c=l.getImageData(0,0,e.width,e.height),d=c.data;for(let g=0;g<d.length;g++)d[g]=255*cc(d[g]/255);return l.putImageData(c,0,0),s}if(e.data){const s=e.data.slice(0);for(let l=0;l<s.length;l++)s[l]=s instanceof Uint8Array||s instanceof Uint8ClampedArray?Math.floor(255*cc(s[l]/255)):cc(s[l]);return{data:s,width:e.width,height:e.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let zd=0;class fl{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:zd++}),this.uuid=Ua(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){!0===e&&this.version++}toJSON(e){const s=void 0===e||"string"==typeof e;if(!s&&void 0!==e.images[this.uuid])return e.images[this.uuid];const l={uuid:this.uuid,url:""},c=this.data;if(null!==c){let d;if(Array.isArray(c)){d=[];for(let g=0,v=c.length;g<v;g++)d.push(Uu(c[g].isDataTexture?c[g].image:c[g]))}else d=Uu(c);l.url=d}return s||(e.images[this.uuid]=l),l}}function Uu(A){return typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&A instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&A instanceof ImageBitmap?_h.getDataURL(A):A.data?{data:Array.from(A.data),width:A.width,height:A.height,type:A.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let uf=0;class Vi extends to{constructor(e=Vi.DEFAULT_IMAGE,s=Vi.DEFAULT_MAPPING,l=Ut,c=Ut,d=cn,g=Sn,v=de,x=jn,w=Vi.DEFAULT_ANISOTROPY,S=vo){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:uf++}),this.uuid=Ua(),this.name="",this.source=new fl(e),this.mipmaps=[],this.mapping=s,this.channel=0,this.wrapS=l,this.wrapT=c,this.magFilter=d,this.minFilter=g,this.anisotropy=w,this.format=v,this.internalFormat=null,this.type=x,this.offset=new Ye(0,0),this.repeat=new Ye(1,1),this.center=new Ye(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new yr,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=S,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const s=void 0===e||"string"==typeof e;if(!s&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const l={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(l.userData=this.userData),s||(e.textures[this.uuid]=l),l}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Hr)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case ki:e.x=e.x-Math.floor(e.x);break;case Ut:e.x=e.x<0?0:1;break;case jt:e.x=1===Math.abs(Math.floor(e.x)%2)?Math.ceil(e.x)-e.x:e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case ki:e.y=e.y-Math.floor(e.y);break;case Ut:e.y=e.y<0?0:1;break;case jt:e.y=1===Math.abs(Math.floor(e.y)%2)?Math.ceil(e.y)-e.y:e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){!0===e&&this.pmremVersion++}}Vi.DEFAULT_IMAGE=null,Vi.DEFAULT_MAPPING=Hr,Vi.DEFAULT_ANISOTROPY=1;class li{constructor(e=0,s=0,l=0,c=1){li.prototype.isVector4=!0,this.x=e,this.y=s,this.z=l,this.w=c}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,s,l,c){return this.x=e,this.y=s,this.z=l,this.w=c,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,s){switch(e){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;case 3:this.w=s;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,s){return this.x=e.x+s.x,this.y=e.y+s.y,this.z=e.z+s.z,this.w=e.w+s.w,this}addScaledVector(e,s){return this.x+=e.x*s,this.y+=e.y*s,this.z+=e.z*s,this.w+=e.w*s,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,s){return this.x=e.x-s.x,this.y=e.y-s.y,this.z=e.z-s.z,this.w=e.w-s.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const s=this.x,l=this.y,c=this.z,d=this.w,g=e.elements;return this.x=g[0]*s+g[4]*l+g[8]*c+g[12]*d,this.y=g[1]*s+g[5]*l+g[9]*c+g[13]*d,this.z=g[2]*s+g[6]*l+g[10]*c+g[14]*d,this.w=g[3]*s+g[7]*l+g[11]*c+g[15]*d,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const s=Math.sqrt(1-e.w*e.w);return s<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/s,this.y=e.y/s,this.z=e.z/s),this}setAxisAngleFromRotationMatrix(e){let s,l,c,d;const x=e.elements,w=x[0],S=x[4],P=x[8],z=x[1],W=x[5],Y=x[9],tt=x[2],J=x[6],at=x[10];if(Math.abs(S-z)<.01&&Math.abs(P-tt)<.01&&Math.abs(Y-J)<.01){if(Math.abs(S+z)<.1&&Math.abs(P+tt)<.1&&Math.abs(Y+J)<.1&&Math.abs(w+W+at-3)<.1)return this.set(1,0,0,0),this;s=Math.PI;const ct=(w+1)/2,At=(W+1)/2,Ft=(at+1)/2,Tt=(S+z)/4,Pt=(P+tt)/4,zt=(Y+J)/4;return ct>At&&ct>Ft?ct<.01?(l=0,c=.707106781,d=.707106781):(l=Math.sqrt(ct),c=Tt/l,d=Pt/l):At>Ft?At<.01?(l=.707106781,c=0,d=.707106781):(c=Math.sqrt(At),l=Tt/c,d=zt/c):Ft<.01?(l=.707106781,c=.707106781,d=0):(d=Math.sqrt(Ft),l=Pt/d,c=zt/d),this.set(l,c,d,s),this}let it=Math.sqrt((J-Y)*(J-Y)+(P-tt)*(P-tt)+(z-S)*(z-S));return Math.abs(it)<.001&&(it=1),this.x=(J-Y)/it,this.y=(P-tt)/it,this.z=(z-S)/it,this.w=Math.acos((w+W+at-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,s){return this.x=Math.max(e.x,Math.min(s.x,this.x)),this.y=Math.max(e.y,Math.min(s.y,this.y)),this.z=Math.max(e.z,Math.min(s.z,this.z)),this.w=Math.max(e.w,Math.min(s.w,this.w)),this}clampScalar(e,s){return this.x=Math.max(e,Math.min(s,this.x)),this.y=Math.max(e,Math.min(s,this.y)),this.z=Math.max(e,Math.min(s,this.z)),this.w=Math.max(e,Math.min(s,this.w)),this}clampLength(e,s){const l=this.length();return this.divideScalar(l||1).multiplyScalar(Math.max(e,Math.min(s,l)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,s){return this.x+=(e.x-this.x)*s,this.y+=(e.y-this.y)*s,this.z+=(e.z-this.z)*s,this.w+=(e.w-this.w)*s,this}lerpVectors(e,s,l){return this.x=e.x+(s.x-e.x)*l,this.y=e.y+(s.y-e.y)*l,this.z=e.z+(s.z-e.z)*l,this.w=e.w+(s.w-e.w)*l,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,s=0){return this.x=e[s],this.y=e[s+1],this.z=e[s+2],this.w=e[s+3],this}toArray(e=[],s=0){return e[s]=this.x,e[s+1]=this.y,e[s+2]=this.z,e[s+3]=this.w,e}fromBufferAttribute(e,s){return this.x=e.getX(s),this.y=e.getY(s),this.z=e.getZ(s),this.w=e.getW(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class $d extends to{constructor(e=1,s=1,l={}){super(),this.isRenderTarget=!0,this.width=e,this.height=s,this.depth=1,this.scissor=new li(0,0,e,s),this.scissorTest=!1,this.viewport=new li(0,0,e,s);const c={width:e,height:s,depth:1};l=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:cn,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},l);const d=new Vi(c,l.mapping,l.wrapS,l.wrapT,l.magFilter,l.minFilter,l.format,l.type,l.anisotropy,l.colorSpace);d.flipY=!1,d.generateMipmaps=l.generateMipmaps,d.internalFormat=l.internalFormat,this.textures=[];const g=l.count;for(let v=0;v<g;v++)this.textures[v]=d.clone(),this.textures[v].isRenderTargetTexture=!0;this.depthBuffer=l.depthBuffer,this.stencilBuffer=l.stencilBuffer,this.resolveDepthBuffer=l.resolveDepthBuffer,this.resolveStencilBuffer=l.resolveStencilBuffer,this.depthTexture=l.depthTexture,this.samples=l.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}setSize(e,s,l=1){if(this.width!==e||this.height!==s||this.depth!==l){this.width=e,this.height=s,this.depth=l;for(let c=0,d=this.textures.length;c<d;c++)this.textures[c].image.width=e,this.textures[c].image.height=s,this.textures[c].image.depth=l;this.dispose()}this.viewport.set(0,0,e,s),this.scissor.set(0,0,e,s)}clone(){return(new this.constructor).copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let l=0,c=e.textures.length;l<c;l++)this.textures[l]=e.textures[l].clone(),this.textures[l].isRenderTargetTexture=!0;const s=Object.assign({},e.texture.image);return this.texture.source=new fl(s),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class bo extends $d{constructor(e=1,s=1,l={}){super(e,s,l),this.isWebGLRenderTarget=!0}}class kh extends Vi{constructor(e=null,s=1,l=1,c=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:s,height:l,depth:c},this.magFilter=be,this.minFilter=be,this.wrapR=Ut,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Gm extends bo{constructor(e=1,s=1,l=1,c={}){super(e,s,c),this.isWebGLArrayRenderTarget=!0,this.depth=l,this.texture=new kh(null,e,s,l),this.texture.isRenderTargetTexture=!0}}class Rh extends Vi{constructor(e=null,s=1,l=1,c=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:s,height:l,depth:c},this.magFilter=be,this.minFilter=be,this.wrapR=Ut,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Qm extends bo{constructor(e=1,s=1,l=1,c={}){super(e,s,c),this.isWebGL3DRenderTarget=!0,this.depth=l,this.texture=new Rh(null,e,s,l),this.texture.isRenderTargetTexture=!0}}class _s{constructor(e=0,s=0,l=0,c=1){this.isQuaternion=!0,this._x=e,this._y=s,this._z=l,this._w=c}static slerpFlat(e,s,l,c,d,g,v){let x=l[c+0],w=l[c+1],S=l[c+2],P=l[c+3];const z=d[g+0],W=d[g+1],Y=d[g+2],tt=d[g+3];if(0===v)return e[s+0]=x,e[s+1]=w,e[s+2]=S,void(e[s+3]=P);if(1===v)return e[s+0]=z,e[s+1]=W,e[s+2]=Y,void(e[s+3]=tt);if(P!==tt||x!==z||w!==W||S!==Y){let J=1-v;const at=x*z+w*W+S*Y+P*tt,it=at>=0?1:-1,ct=1-at*at;if(ct>Number.EPSILON){const Ft=Math.sqrt(ct),Tt=Math.atan2(Ft,at*it);J=Math.sin(J*Tt)/Ft,v=Math.sin(v*Tt)/Ft}const At=v*it;if(x=x*J+z*At,w=w*J+W*At,S=S*J+Y*At,P=P*J+tt*At,J===1-v){const Ft=1/Math.sqrt(x*x+w*w+S*S+P*P);x*=Ft,w*=Ft,S*=Ft,P*=Ft}}e[s]=x,e[s+1]=w,e[s+2]=S,e[s+3]=P}static multiplyQuaternionsFlat(e,s,l,c,d,g){const v=l[c],x=l[c+1],w=l[c+2],S=l[c+3],P=d[g],z=d[g+1],W=d[g+2],Y=d[g+3];return e[s]=v*Y+S*P+x*W-w*z,e[s+1]=x*Y+S*z+w*P-v*W,e[s+2]=w*Y+S*W+v*z-x*P,e[s+3]=S*Y-v*P-x*z-w*W,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,s,l,c){return this._x=e,this._y=s,this._z=l,this._w=c,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,s=!0){const l=e._x,c=e._y,d=e._z,g=e._order,v=Math.cos,x=Math.sin,w=v(l/2),S=v(c/2),P=v(d/2),z=x(l/2),W=x(c/2),Y=x(d/2);switch(g){case"XYZ":this._x=z*S*P+w*W*Y,this._y=w*W*P-z*S*Y,this._z=w*S*Y+z*W*P,this._w=w*S*P-z*W*Y;break;case"YXZ":this._x=z*S*P+w*W*Y,this._y=w*W*P-z*S*Y,this._z=w*S*Y-z*W*P,this._w=w*S*P+z*W*Y;break;case"ZXY":this._x=z*S*P-w*W*Y,this._y=w*W*P+z*S*Y,this._z=w*S*Y+z*W*P,this._w=w*S*P-z*W*Y;break;case"ZYX":this._x=z*S*P-w*W*Y,this._y=w*W*P+z*S*Y,this._z=w*S*Y-z*W*P,this._w=w*S*P+z*W*Y;break;case"YZX":this._x=z*S*P+w*W*Y,this._y=w*W*P+z*S*Y,this._z=w*S*Y-z*W*P,this._w=w*S*P-z*W*Y;break;case"XZY":this._x=z*S*P-w*W*Y,this._y=w*W*P-z*S*Y,this._z=w*S*Y+z*W*P,this._w=w*S*P+z*W*Y;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+g)}return!0===s&&this._onChangeCallback(),this}setFromAxisAngle(e,s){const l=s/2,c=Math.sin(l);return this._x=e.x*c,this._y=e.y*c,this._z=e.z*c,this._w=Math.cos(l),this._onChangeCallback(),this}setFromRotationMatrix(e){const s=e.elements,l=s[0],c=s[4],d=s[8],g=s[1],v=s[5],x=s[9],w=s[2],S=s[6],P=s[10],z=l+v+P;if(z>0){const W=.5/Math.sqrt(z+1);this._w=.25/W,this._x=(S-x)*W,this._y=(d-w)*W,this._z=(g-c)*W}else if(l>v&&l>P){const W=2*Math.sqrt(1+l-v-P);this._w=(S-x)/W,this._x=.25*W,this._y=(c+g)/W,this._z=(d+w)/W}else if(v>P){const W=2*Math.sqrt(1+v-l-P);this._w=(d-w)/W,this._x=(c+g)/W,this._y=.25*W,this._z=(x+S)/W}else{const W=2*Math.sqrt(1+P-l-v);this._w=(g-c)/W,this._x=(d+w)/W,this._y=(x+S)/W,this._z=.25*W}return this._onChangeCallback(),this}setFromUnitVectors(e,s){let l=e.dot(s)+1;return l<Number.EPSILON?(l=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=l):(this._x=0,this._y=-e.z,this._z=e.y,this._w=l)):(this._x=e.y*s.z-e.z*s.y,this._y=e.z*s.x-e.x*s.z,this._z=e.x*s.y-e.y*s.x,this._w=l),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ki(this.dot(e),-1,1)))}rotateTowards(e,s){const l=this.angleTo(e);if(0===l)return this;const c=Math.min(1,s/l);return this.slerp(e,c),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,s){const l=e._x,c=e._y,d=e._z,g=e._w,v=s._x,x=s._y,w=s._z,S=s._w;return this._x=l*S+g*v+c*w-d*x,this._y=c*S+g*x+d*v-l*w,this._z=d*S+g*w+l*x-c*v,this._w=g*S-l*v-c*x-d*w,this._onChangeCallback(),this}slerp(e,s){if(0===s)return this;if(1===s)return this.copy(e);const l=this._x,c=this._y,d=this._z,g=this._w;let v=g*e._w+l*e._x+c*e._y+d*e._z;if(v<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,v=-v):this.copy(e),v>=1)return this._w=g,this._x=l,this._y=c,this._z=d,this;const x=1-v*v;if(x<=Number.EPSILON){const W=1-s;return this._w=W*g+s*this._w,this._x=W*l+s*this._x,this._y=W*c+s*this._y,this._z=W*d+s*this._z,this.normalize(),this}const w=Math.sqrt(x),S=Math.atan2(w,v),P=Math.sin((1-s)*S)/w,z=Math.sin(s*S)/w;return this._w=g*P+this._w*z,this._x=l*P+this._x*z,this._y=c*P+this._y*z,this._z=d*P+this._z*z,this._onChangeCallback(),this}slerpQuaternions(e,s,l){return this.copy(e).slerp(s,l)}random(){const e=2*Math.PI*Math.random(),s=2*Math.PI*Math.random(),l=Math.random(),c=Math.sqrt(1-l),d=Math.sqrt(l);return this.set(c*Math.sin(e),c*Math.cos(e),d*Math.sin(s),d*Math.cos(s))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,s=0){return this._x=e[s],this._y=e[s+1],this._z=e[s+2],this._w=e[s+3],this._onChangeCallback(),this}toArray(e=[],s=0){return e[s]=this._x,e[s+1]=this._y,e[s+2]=this._z,e[s+3]=this._w,e}fromBufferAttribute(e,s){return this._x=e.getX(s),this._y=e.getY(s),this._z=e.getZ(s),this._w=e.getW(s),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Dt{constructor(e=0,s=0,l=0){Dt.prototype.isVector3=!0,this.x=e,this.y=s,this.z=l}set(e,s,l){return void 0===l&&(l=this.z),this.x=e,this.y=s,this.z=l,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,s){switch(e){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,s){return this.x=e.x+s.x,this.y=e.y+s.y,this.z=e.z+s.z,this}addScaledVector(e,s){return this.x+=e.x*s,this.y+=e.y*s,this.z+=e.z*s,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,s){return this.x=e.x-s.x,this.y=e.y-s.y,this.z=e.z-s.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,s){return this.x=e.x*s.x,this.y=e.y*s.y,this.z=e.z*s.z,this}applyEuler(e){return this.applyQuaternion(hf.setFromEuler(e))}applyAxisAngle(e,s){return this.applyQuaternion(hf.setFromAxisAngle(e,s))}applyMatrix3(e){const s=this.x,l=this.y,c=this.z,d=e.elements;return this.x=d[0]*s+d[3]*l+d[6]*c,this.y=d[1]*s+d[4]*l+d[7]*c,this.z=d[2]*s+d[5]*l+d[8]*c,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const s=this.x,l=this.y,c=this.z,d=e.elements,g=1/(d[3]*s+d[7]*l+d[11]*c+d[15]);return this.x=(d[0]*s+d[4]*l+d[8]*c+d[12])*g,this.y=(d[1]*s+d[5]*l+d[9]*c+d[13])*g,this.z=(d[2]*s+d[6]*l+d[10]*c+d[14])*g,this}applyQuaternion(e){const s=this.x,l=this.y,c=this.z,d=e.x,g=e.y,v=e.z,x=e.w,w=2*(g*c-v*l),S=2*(v*s-d*c),P=2*(d*l-g*s);return this.x=s+x*w+g*P-v*S,this.y=l+x*S+v*w-d*P,this.z=c+x*P+d*S-g*w,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const s=this.x,l=this.y,c=this.z,d=e.elements;return this.x=d[0]*s+d[4]*l+d[8]*c,this.y=d[1]*s+d[5]*l+d[9]*c,this.z=d[2]*s+d[6]*l+d[10]*c,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,s){return this.x=Math.max(e.x,Math.min(s.x,this.x)),this.y=Math.max(e.y,Math.min(s.y,this.y)),this.z=Math.max(e.z,Math.min(s.z,this.z)),this}clampScalar(e,s){return this.x=Math.max(e,Math.min(s,this.x)),this.y=Math.max(e,Math.min(s,this.y)),this.z=Math.max(e,Math.min(s,this.z)),this}clampLength(e,s){const l=this.length();return this.divideScalar(l||1).multiplyScalar(Math.max(e,Math.min(s,l)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,s){return this.x+=(e.x-this.x)*s,this.y+=(e.y-this.y)*s,this.z+=(e.z-this.z)*s,this}lerpVectors(e,s,l){return this.x=e.x+(s.x-e.x)*l,this.y=e.y+(s.y-e.y)*l,this.z=e.z+(s.z-e.z)*l,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,s){const l=e.x,c=e.y,d=e.z,g=s.x,v=s.y,x=s.z;return this.x=c*x-d*v,this.y=d*g-l*x,this.z=l*v-c*g,this}projectOnVector(e){const s=e.lengthSq();if(0===s)return this.set(0,0,0);const l=e.dot(this)/s;return this.copy(e).multiplyScalar(l)}projectOnPlane(e){return Vd.copy(this).projectOnVector(e),this.sub(Vd)}reflect(e){return this.sub(Vd.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const s=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===s)return Math.PI/2;const l=this.dot(e)/s;return Math.acos(Ki(l,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const s=this.x-e.x,l=this.y-e.y,c=this.z-e.z;return s*s+l*l+c*c}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,s,l){const c=Math.sin(s)*e;return this.x=c*Math.sin(l),this.y=Math.cos(s)*e,this.z=c*Math.cos(l),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,s,l){return this.x=e*Math.sin(s),this.y=l,this.z=e*Math.cos(s),this}setFromMatrixPosition(e){const s=e.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(e){const s=this.setFromMatrixColumn(e,0).length(),l=this.setFromMatrixColumn(e,1).length(),c=this.setFromMatrixColumn(e,2).length();return this.x=s,this.y=l,this.z=c,this}setFromMatrixColumn(e,s){return this.fromArray(e.elements,4*s)}setFromMatrix3Column(e,s){return this.fromArray(e.elements,3*s)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,s=0){return this.x=e[s],this.y=e[s+1],this.z=e[s+2],this}toArray(e=[],s=0){return e[s]=this.x,e[s+1]=this.y,e[s+2]=this.z,e}fromBufferAttribute(e,s){return this.x=e.getX(s),this.y=e.getY(s),this.z=e.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,s=2*Math.random()-1,l=Math.sqrt(1-s*s);return this.x=l*Math.cos(e),this.y=s,this.z=l*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Vd=new Dt,hf=new _s;class ta{constructor(e=new Dt(1/0,1/0,1/0),s=new Dt(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=s}set(e,s){return this.min.copy(e),this.max.copy(s),this}setFromArray(e){this.makeEmpty();for(let s=0,l=e.length;s<l;s+=3)this.expandByPoint(eo.fromArray(e,s));return this}setFromBufferAttribute(e){this.makeEmpty();for(let s=0,l=e.count;s<l;s++)this.expandByPoint(eo.fromBufferAttribute(e,s));return this}setFromPoints(e){this.makeEmpty();for(let s=0,l=e.length;s<l;s++)this.expandByPoint(e[s]);return this}setFromCenterAndSize(e,s){const l=eo.copy(s).multiplyScalar(.5);return this.min.copy(e).sub(l),this.max.copy(e).add(l),this}setFromObject(e,s=!1){return this.makeEmpty(),this.expandByObject(e,s)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,s=!1){e.updateWorldMatrix(!1,!1);const l=e.geometry;if(void 0!==l){const d=l.getAttribute("position");if(!0===s&&void 0!==d&&!0!==e.isInstancedMesh)for(let g=0,v=d.count;g<v;g++)!0===e.isMesh?e.getVertexPosition(g,eo):eo.fromBufferAttribute(d,g),eo.applyMatrix4(e.matrixWorld),this.expandByPoint(eo);else void 0!==e.boundingBox?(null===e.boundingBox&&e.computeBoundingBox(),Hc.copy(e.boundingBox)):(null===l.boundingBox&&l.computeBoundingBox(),Hc.copy(l.boundingBox)),Hc.applyMatrix4(e.matrixWorld),this.union(Hc)}const c=e.children;for(let d=0,g=c.length;d<g;d++)this.expandByObject(c[d],s);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,s){return s.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,eo),eo.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let s,l;return e.normal.x>0?(s=e.normal.x*this.min.x,l=e.normal.x*this.max.x):(s=e.normal.x*this.max.x,l=e.normal.x*this.min.x),e.normal.y>0?(s+=e.normal.y*this.min.y,l+=e.normal.y*this.max.y):(s+=e.normal.y*this.max.y,l+=e.normal.y*this.min.y),e.normal.z>0?(s+=e.normal.z*this.min.z,l+=e.normal.z*this.max.z):(s+=e.normal.z*this.max.z,l+=e.normal.z*this.min.z),s<=-e.constant&&l>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(jc),zu.subVectors(this.max,jc),Vl.subVectors(e.a,jc),Gl.subVectors(e.b,jc),Wc.subVectors(e.c,jc),Ql.subVectors(Gl,Vl),gl.subVectors(Wc,Gl),uc.subVectors(Vl,Wc);let s=[0,-Ql.z,Ql.y,0,-gl.z,gl.y,0,-uc.z,uc.y,Ql.z,0,-Ql.x,gl.z,0,-gl.x,uc.z,0,-uc.x,-Ql.y,Ql.x,0,-gl.y,gl.x,0,-uc.y,uc.x,0];return!!Gd(s,Vl,Gl,Wc,zu)&&(s=[1,0,0,0,1,0,0,0,1],!!Gd(s,Vl,Gl,Wc,zu)&&($u.crossVectors(Ql,gl),s=[$u.x,$u.y,$u.z],Gd(s,Vl,Gl,Wc,zu)))}clampPoint(e,s){return s.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,eo).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=.5*this.getSize(eo).length()),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(ml[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),ml[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),ml[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),ml[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),ml[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),ml[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),ml[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),ml[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(ml)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const ml=[new Dt,new Dt,new Dt,new Dt,new Dt,new Dt,new Dt,new Dt],eo=new Dt,Hc=new ta,Vl=new Dt,Gl=new Dt,Wc=new Dt,Ql=new Dt,gl=new Dt,uc=new Dt,jc=new Dt,zu=new Dt,$u=new Dt,Al=new Dt;function Gd(A,e,s,l,c){for(let d=0,g=A.length-3;d<=g;d+=3){Al.fromArray(A,d);const v=c.x*Math.abs(Al.x)+c.y*Math.abs(Al.y)+c.z*Math.abs(Al.z),x=e.dot(Al),w=s.dot(Al),S=l.dot(Al);if(Math.max(-Math.max(x,w,S),Math.min(x,w,S))>v)return!1}return!0}const Hm=new ta,qc=new Dt,Bh=new Dt;class Ls{constructor(e=new Dt,s=-1){this.isSphere=!0,this.center=e,this.radius=s}set(e,s){return this.center.copy(e),this.radius=s,this}setFromPoints(e,s){const l=this.center;void 0!==s?l.copy(s):Hm.setFromPoints(e).getCenter(l);let c=0;for(let d=0,g=e.length;d<g;d++)c=Math.max(c,l.distanceToSquared(e[d]));return this.radius=Math.sqrt(c),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const s=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=s*s}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,s){const l=this.center.distanceToSquared(e);return s.copy(e),l>this.radius*this.radius&&(s.sub(this.center).normalize(),s.multiplyScalar(this.radius).add(this.center)),s}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;qc.subVectors(e,this.center);const s=qc.lengthSq();if(s>this.radius*this.radius){const l=Math.sqrt(s),c=.5*(l-this.radius);this.center.addScaledVector(qc,c/l),this.radius+=c}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(!0===this.center.equals(e.center)?this.radius=Math.max(this.radius,e.radius):(Bh.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(qc.copy(e.center).add(Bh)),this.expandByPoint(qc.copy(e.center).sub(Bh))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Fs=new Dt,KA=new Dt,Xc=new Dt,yl=new Dt,Qd=new Dt,Hd=new Dt,Wd=new Dt;class hc{constructor(e=new Dt,s=new Dt(0,0,-1)){this.origin=e,this.direction=s}set(e,s){return this.origin.copy(e),this.direction.copy(s),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,s){return s.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Fs)),this}closestPointToPoint(e,s){s.subVectors(e,this.origin);const l=s.dot(this.direction);return l<0?s.copy(this.origin):s.copy(this.origin).addScaledVector(this.direction,l)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const s=Fs.subVectors(e,this.origin).dot(this.direction);return s<0?this.origin.distanceToSquared(e):(Fs.copy(this.origin).addScaledVector(this.direction,s),Fs.distanceToSquared(e))}distanceSqToSegment(e,s,l,c){KA.copy(e).add(s).multiplyScalar(.5),Xc.copy(s).sub(e).normalize(),yl.copy(this.origin).sub(KA);const d=.5*e.distanceTo(s),g=-this.direction.dot(Xc),v=yl.dot(this.direction),x=-yl.dot(Xc),w=yl.lengthSq(),S=Math.abs(1-g*g);let P,z,W,Y;if(S>0)if(P=g*x-v,z=g*v-x,Y=d*S,P>=0)if(z>=-Y)if(z<=Y){const tt=1/S;P*=tt,z*=tt,W=P*(P+g*z+2*v)+z*(g*P+z+2*x)+w}else z=d,P=Math.max(0,-(g*z+v)),W=-P*P+z*(z+2*x)+w;else z=-d,P=Math.max(0,-(g*z+v)),W=-P*P+z*(z+2*x)+w;else z<=-Y?(P=Math.max(0,-(-g*d+v)),z=P>0?-d:Math.min(Math.max(-d,-x),d),W=-P*P+z*(z+2*x)+w):z<=Y?(P=0,z=Math.min(Math.max(-d,-x),d),W=z*(z+2*x)+w):(P=Math.max(0,-(g*d+v)),z=P>0?d:Math.min(Math.max(-d,-x),d),W=-P*P+z*(z+2*x)+w);else z=g>0?-d:d,P=Math.max(0,-(g*z+v)),W=-P*P+z*(z+2*x)+w;return l&&l.copy(this.origin).addScaledVector(this.direction,P),c&&c.copy(KA).addScaledVector(Xc,z),W}intersectSphere(e,s){Fs.subVectors(e.center,this.origin);const l=Fs.dot(this.direction),c=Fs.dot(Fs)-l*l,d=e.radius*e.radius;if(c>d)return null;const g=Math.sqrt(d-c),v=l-g,x=l+g;return x<0?null:this.at(v<0?x:v,s)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const s=e.normal.dot(this.direction);if(0===s)return 0===e.distanceToPoint(this.origin)?0:null;const l=-(this.origin.dot(e.normal)+e.constant)/s;return l>=0?l:null}intersectPlane(e,s){const l=this.distanceToPlane(e);return null===l?null:this.at(l,s)}intersectsPlane(e){const s=e.distanceToPoint(this.origin);return 0===s||e.normal.dot(this.direction)*s<0}intersectBox(e,s){let l,c,d,g,v,x;const w=1/this.direction.x,S=1/this.direction.y,P=1/this.direction.z,z=this.origin;return w>=0?(l=(e.min.x-z.x)*w,c=(e.max.x-z.x)*w):(l=(e.max.x-z.x)*w,c=(e.min.x-z.x)*w),S>=0?(d=(e.min.y-z.y)*S,g=(e.max.y-z.y)*S):(d=(e.max.y-z.y)*S,g=(e.min.y-z.y)*S),l>g||d>c?null:((d>l||isNaN(l))&&(l=d),(g<c||isNaN(c))&&(c=g),P>=0?(v=(e.min.z-z.z)*P,x=(e.max.z-z.z)*P):(v=(e.max.z-z.z)*P,x=(e.min.z-z.z)*P),l>x||v>c?null:((v>l||l!=l)&&(l=v),(x<c||c!=c)&&(c=x),c<0?null:this.at(l>=0?l:c,s)))}intersectsBox(e){return null!==this.intersectBox(e,Fs)}intersectTriangle(e,s,l,c,d){Qd.subVectors(s,e),Hd.subVectors(l,e),Wd.crossVectors(Qd,Hd);let g,v=this.direction.dot(Wd);if(v>0){if(c)return null;g=1}else{if(!(v<0))return null;g=-1,v=-v}yl.subVectors(this.origin,e);const x=g*this.direction.dot(Hd.crossVectors(yl,Hd));if(x<0)return null;const w=g*this.direction.dot(Qd.cross(yl));if(w<0||x+w>v)return null;const S=-g*yl.dot(Wd);return S<0?null:this.at(S/v,d)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Yn{constructor(e,s,l,c,d,g,v,x,w,S,P,z,W,Y,tt,J){Yn.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==e&&this.set(e,s,l,c,d,g,v,x,w,S,P,z,W,Y,tt,J)}set(e,s,l,c,d,g,v,x,w,S,P,z,W,Y,tt,J){const at=this.elements;return at[0]=e,at[4]=s,at[8]=l,at[12]=c,at[1]=d,at[5]=g,at[9]=v,at[13]=x,at[2]=w,at[6]=S,at[10]=P,at[14]=z,at[3]=W,at[7]=Y,at[11]=tt,at[15]=J,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Yn).fromArray(this.elements)}copy(e){const s=this.elements,l=e.elements;return s[0]=l[0],s[1]=l[1],s[2]=l[2],s[3]=l[3],s[4]=l[4],s[5]=l[5],s[6]=l[6],s[7]=l[7],s[8]=l[8],s[9]=l[9],s[10]=l[10],s[11]=l[11],s[12]=l[12],s[13]=l[13],s[14]=l[14],s[15]=l[15],this}copyPosition(e){const s=this.elements,l=e.elements;return s[12]=l[12],s[13]=l[13],s[14]=l[14],this}setFromMatrix3(e){const s=e.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(e,s,l){return e.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),l.setFromMatrixColumn(this,2),this}makeBasis(e,s,l){return this.set(e.x,s.x,l.x,0,e.y,s.y,l.y,0,e.z,s.z,l.z,0,0,0,0,1),this}extractRotation(e){const s=this.elements,l=e.elements,c=1/jd.setFromMatrixColumn(e,0).length(),d=1/jd.setFromMatrixColumn(e,1).length(),g=1/jd.setFromMatrixColumn(e,2).length();return s[0]=l[0]*c,s[1]=l[1]*c,s[2]=l[2]*c,s[3]=0,s[4]=l[4]*d,s[5]=l[5]*d,s[6]=l[6]*d,s[7]=0,s[8]=l[8]*g,s[9]=l[9]*g,s[10]=l[10]*g,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(e){const s=this.elements,l=e.x,c=e.y,d=e.z,g=Math.cos(l),v=Math.sin(l),x=Math.cos(c),w=Math.sin(c),S=Math.cos(d),P=Math.sin(d);if("XYZ"===e.order){const z=g*S,W=g*P,Y=v*S,tt=v*P;s[0]=x*S,s[4]=-x*P,s[8]=w,s[1]=W+Y*w,s[5]=z-tt*w,s[9]=-v*x,s[2]=tt-z*w,s[6]=Y+W*w,s[10]=g*x}else if("YXZ"===e.order){const z=x*S,W=x*P,Y=w*S,tt=w*P;s[0]=z+tt*v,s[4]=Y*v-W,s[8]=g*w,s[1]=g*P,s[5]=g*S,s[9]=-v,s[2]=W*v-Y,s[6]=tt+z*v,s[10]=g*x}else if("ZXY"===e.order){const z=x*S,W=x*P,Y=w*S,tt=w*P;s[0]=z-tt*v,s[4]=-g*P,s[8]=Y+W*v,s[1]=W+Y*v,s[5]=g*S,s[9]=tt-z*v,s[2]=-g*w,s[6]=v,s[10]=g*x}else if("ZYX"===e.order){const z=g*S,W=g*P,Y=v*S,tt=v*P;s[0]=x*S,s[4]=Y*w-W,s[8]=z*w+tt,s[1]=x*P,s[5]=tt*w+z,s[9]=W*w-Y,s[2]=-w,s[6]=v*x,s[10]=g*x}else if("YZX"===e.order){const z=g*x,W=g*w,Y=v*x,tt=v*w;s[0]=x*S,s[4]=tt-z*P,s[8]=Y*P+W,s[1]=P,s[5]=g*S,s[9]=-v*S,s[2]=-w*S,s[6]=W*P+Y,s[10]=z-tt*P}else if("XZY"===e.order){const z=g*x,W=g*w,Y=v*x,tt=v*w;s[0]=x*S,s[4]=-P,s[8]=w*S,s[1]=z*P+tt,s[5]=g*S,s[9]=W*P-Y,s[2]=Y*P-W,s[6]=v*S,s[10]=tt*P+z}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Mb,e,JA)}lookAt(e,s,l){const c=this.elements;return za.subVectors(e,s),0===za.lengthSq()&&(za.z=1),za.normalize(),Yc.crossVectors(l,za),0===Yc.lengthSq()&&(1===Math.abs(l.z)?za.x+=1e-4:za.z+=1e-4,za.normalize(),Yc.crossVectors(l,za)),Yc.normalize(),dc.crossVectors(za,Yc),c[0]=Yc.x,c[4]=dc.x,c[8]=za.x,c[1]=Yc.y,c[5]=dc.y,c[9]=za.y,c[2]=Yc.z,c[6]=dc.z,c[10]=za.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,s){const l=e.elements,c=s.elements,d=this.elements,g=l[0],v=l[4],x=l[8],w=l[12],S=l[1],P=l[5],z=l[9],W=l[13],Y=l[2],tt=l[6],J=l[10],at=l[14],it=l[3],ct=l[7],At=l[11],Ft=l[15],Tt=c[0],Pt=c[4],zt=c[8],ee=c[12],ce=c[1],ne=c[5],ge=c[9],ie=c[13],pe=c[2],Oe=c[6],Pe=c[10],ze=c[14],Fe=c[3],Dn=c[7],Nn=c[11],fn=c[15];return d[0]=g*Tt+v*ce+x*pe+w*Fe,d[4]=g*Pt+v*ne+x*Oe+w*Dn,d[8]=g*zt+v*ge+x*Pe+w*Nn,d[12]=g*ee+v*ie+x*ze+w*fn,d[1]=S*Tt+P*ce+z*pe+W*Fe,d[5]=S*Pt+P*ne+z*Oe+W*Dn,d[9]=S*zt+P*ge+z*Pe+W*Nn,d[13]=S*ee+P*ie+z*ze+W*fn,d[2]=Y*Tt+tt*ce+J*pe+at*Fe,d[6]=Y*Pt+tt*ne+J*Oe+at*Dn,d[10]=Y*zt+tt*ge+J*Pe+at*Nn,d[14]=Y*ee+tt*ie+J*ze+at*fn,d[3]=it*Tt+ct*ce+At*pe+Ft*Fe,d[7]=it*Pt+ct*ne+At*Oe+Ft*Dn,d[11]=it*zt+ct*ge+At*Pe+Ft*Nn,d[15]=it*ee+ct*ie+At*ze+Ft*fn,this}multiplyScalar(e){const s=this.elements;return s[0]*=e,s[4]*=e,s[8]*=e,s[12]*=e,s[1]*=e,s[5]*=e,s[9]*=e,s[13]*=e,s[2]*=e,s[6]*=e,s[10]*=e,s[14]*=e,s[3]*=e,s[7]*=e,s[11]*=e,s[15]*=e,this}determinant(){const e=this.elements,s=e[0],l=e[4],c=e[8],d=e[12],g=e[1],v=e[5],x=e[9],w=e[13],S=e[2],P=e[6],z=e[10],W=e[14];return e[3]*(+d*x*P-c*w*P-d*v*z+l*w*z+c*v*W-l*x*W)+e[7]*(+s*x*W-s*w*z+d*g*z-c*g*W+c*w*S-d*x*S)+e[11]*(+s*w*P-s*v*W-d*g*P+l*g*W+d*v*S-l*w*S)+e[15]*(-c*v*S-s*x*P+s*v*z+c*g*P-l*g*z+l*x*S)}transpose(){const e=this.elements;let s;return s=e[1],e[1]=e[4],e[4]=s,s=e[2],e[2]=e[8],e[8]=s,s=e[6],e[6]=e[9],e[9]=s,s=e[3],e[3]=e[12],e[12]=s,s=e[7],e[7]=e[13],e[13]=s,s=e[11],e[11]=e[14],e[14]=s,this}setPosition(e,s,l){const c=this.elements;return e.isVector3?(c[12]=e.x,c[13]=e.y,c[14]=e.z):(c[12]=e,c[13]=s,c[14]=l),this}invert(){const e=this.elements,s=e[0],l=e[1],c=e[2],d=e[3],g=e[4],v=e[5],x=e[6],w=e[7],S=e[8],P=e[9],z=e[10],W=e[11],Y=e[12],tt=e[13],J=e[14],at=e[15],it=P*J*w-tt*z*w+tt*x*W-v*J*W-P*x*at+v*z*at,ct=Y*z*w-S*J*w-Y*x*W+g*J*W+S*x*at-g*z*at,At=S*tt*w-Y*P*w+Y*v*W-g*tt*W-S*v*at+g*P*at,Ft=Y*P*x-S*tt*x-Y*v*z+g*tt*z+S*v*J-g*P*J,Tt=s*it+l*ct+c*At+d*Ft;if(0===Tt)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const Pt=1/Tt;return e[0]=it*Pt,e[1]=(tt*z*d-P*J*d-tt*c*W+l*J*W+P*c*at-l*z*at)*Pt,e[2]=(v*J*d-tt*x*d+tt*c*w-l*J*w-v*c*at+l*x*at)*Pt,e[3]=(P*x*d-v*z*d-P*c*w+l*z*w+v*c*W-l*x*W)*Pt,e[4]=ct*Pt,e[5]=(S*J*d-Y*z*d+Y*c*W-s*J*W-S*c*at+s*z*at)*Pt,e[6]=(Y*x*d-g*J*d-Y*c*w+s*J*w+g*c*at-s*x*at)*Pt,e[7]=(g*z*d-S*x*d+S*c*w-s*z*w-g*c*W+s*x*W)*Pt,e[8]=At*Pt,e[9]=(Y*P*d-S*tt*d-Y*l*W+s*tt*W+S*l*at-s*P*at)*Pt,e[10]=(g*tt*d-Y*v*d+Y*l*w-s*tt*w-g*l*at+s*v*at)*Pt,e[11]=(S*v*d-g*P*d-S*l*w+s*P*w+g*l*W-s*v*W)*Pt,e[12]=Ft*Pt,e[13]=(S*tt*c-Y*P*c+Y*l*z-s*tt*z-S*l*J+s*P*J)*Pt,e[14]=(Y*v*c-g*tt*c-Y*l*x+s*tt*x+g*l*J-s*v*J)*Pt,e[15]=(g*P*c-S*v*c+S*l*x-s*P*x-g*l*z+s*v*z)*Pt,this}scale(e){const s=this.elements,l=e.x,c=e.y,d=e.z;return s[0]*=l,s[4]*=c,s[8]*=d,s[1]*=l,s[5]*=c,s[9]*=d,s[2]*=l,s[6]*=c,s[10]*=d,s[3]*=l,s[7]*=c,s[11]*=d,this}getMaxScaleOnAxis(){const e=this.elements;return Math.sqrt(Math.max(e[0]*e[0]+e[1]*e[1]+e[2]*e[2],e[4]*e[4]+e[5]*e[5]+e[6]*e[6],e[8]*e[8]+e[9]*e[9]+e[10]*e[10]))}makeTranslation(e,s,l){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,s,0,0,1,l,0,0,0,1),this}makeRotationX(e){const s=Math.cos(e),l=Math.sin(e);return this.set(1,0,0,0,0,s,-l,0,0,l,s,0,0,0,0,1),this}makeRotationY(e){const s=Math.cos(e),l=Math.sin(e);return this.set(s,0,l,0,0,1,0,0,-l,0,s,0,0,0,0,1),this}makeRotationZ(e){const s=Math.cos(e),l=Math.sin(e);return this.set(s,-l,0,0,l,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,s){const l=Math.cos(s),c=Math.sin(s),d=1-l,g=e.x,v=e.y,x=e.z,w=d*g,S=d*v;return this.set(w*g+l,w*v-c*x,w*x+c*v,0,w*v+c*x,S*v+l,S*x-c*g,0,w*x-c*v,S*x+c*g,d*x*x+l,0,0,0,0,1),this}makeScale(e,s,l){return this.set(e,0,0,0,0,s,0,0,0,0,l,0,0,0,0,1),this}makeShear(e,s,l,c,d,g){return this.set(1,l,d,0,e,1,g,0,s,c,1,0,0,0,0,1),this}compose(e,s,l){const c=this.elements,d=s._x,g=s._y,v=s._z,x=s._w,w=d+d,S=g+g,P=v+v,z=d*w,W=d*S,Y=d*P,tt=g*S,J=g*P,at=v*P,it=x*w,ct=x*S,At=x*P,Ft=l.x,Tt=l.y,Pt=l.z;return c[0]=(1-(tt+at))*Ft,c[1]=(W+At)*Ft,c[2]=(Y-ct)*Ft,c[3]=0,c[4]=(W-At)*Tt,c[5]=(1-(z+at))*Tt,c[6]=(J+it)*Tt,c[7]=0,c[8]=(Y+ct)*Pt,c[9]=(J-it)*Pt,c[10]=(1-(z+tt))*Pt,c[11]=0,c[12]=e.x,c[13]=e.y,c[14]=e.z,c[15]=1,this}decompose(e,s,l){const c=this.elements;let d=jd.set(c[0],c[1],c[2]).length();const g=jd.set(c[4],c[5],c[6]).length(),v=jd.set(c[8],c[9],c[10]).length();this.determinant()<0&&(d=-d),e.x=c[12],e.y=c[13],e.z=c[14],Hl.copy(this);const x=1/d,w=1/g,S=1/v;return Hl.elements[0]*=x,Hl.elements[1]*=x,Hl.elements[2]*=x,Hl.elements[4]*=w,Hl.elements[5]*=w,Hl.elements[6]*=w,Hl.elements[8]*=S,Hl.elements[9]*=S,Hl.elements[10]*=S,s.setFromRotationMatrix(Hl),l.x=d,l.y=g,l.z=v,this}makePerspective(e,s,l,c,d,g,v=ko){const x=this.elements,w=2*d/(s-e),S=2*d/(l-c),P=(s+e)/(s-e),z=(l+c)/(l-c);let W,Y;if(v===ko)W=-(g+d)/(g-d),Y=-2*g*d/(g-d);else{if(v!==Vc)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+v);W=-g/(g-d),Y=-g*d/(g-d)}return x[0]=w,x[4]=0,x[8]=P,x[12]=0,x[1]=0,x[5]=S,x[9]=z,x[13]=0,x[2]=0,x[6]=0,x[10]=W,x[14]=Y,x[3]=0,x[7]=0,x[11]=-1,x[15]=0,this}makeOrthographic(e,s,l,c,d,g,v=ko){const x=this.elements,w=1/(s-e),S=1/(l-c),P=1/(g-d),z=(s+e)*w,W=(l+c)*S;let Y,tt;if(v===ko)Y=(g+d)*P,tt=-2*P;else{if(v!==Vc)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+v);Y=d*P,tt=-1*P}return x[0]=2*w,x[4]=0,x[8]=0,x[12]=-z,x[1]=0,x[5]=2*S,x[9]=0,x[13]=-W,x[2]=0,x[6]=0,x[10]=tt,x[14]=-Y,x[3]=0,x[7]=0,x[11]=0,x[15]=1,this}equals(e){const s=this.elements,l=e.elements;for(let c=0;c<16;c++)if(s[c]!==l[c])return!1;return!0}fromArray(e,s=0){for(let l=0;l<16;l++)this.elements[l]=e[l+s];return this}toArray(e=[],s=0){const l=this.elements;return e[s]=l[0],e[s+1]=l[1],e[s+2]=l[2],e[s+3]=l[3],e[s+4]=l[4],e[s+5]=l[5],e[s+6]=l[6],e[s+7]=l[7],e[s+8]=l[8],e[s+9]=l[9],e[s+10]=l[10],e[s+11]=l[11],e[s+12]=l[12],e[s+13]=l[13],e[s+14]=l[14],e[s+15]=l[15],e}}const jd=new Dt,Hl=new Yn,Mb=new Dt(0,0,0),JA=new Dt(1,1,1),Yc=new Dt,dc=new Dt,za=new Dt,ZA=new Yn,Vu=new _s;class Gi{constructor(e=0,s=0,l=0,c=Gi.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=s,this._z=l,this._order=c}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,s,l,c=this._order){return this._x=e,this._y=s,this._z=l,this._order=c,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,s=this._order,l=!0){const c=e.elements,d=c[0],g=c[4],v=c[8],x=c[1],w=c[5],S=c[9],P=c[2],z=c[6],W=c[10];switch(s){case"XYZ":this._y=Math.asin(Ki(v,-1,1)),Math.abs(v)<.9999999?(this._x=Math.atan2(-S,W),this._z=Math.atan2(-g,d)):(this._x=Math.atan2(z,w),this._z=0);break;case"YXZ":this._x=Math.asin(-Ki(S,-1,1)),Math.abs(S)<.9999999?(this._y=Math.atan2(v,W),this._z=Math.atan2(x,w)):(this._y=Math.atan2(-P,d),this._z=0);break;case"ZXY":this._x=Math.asin(Ki(z,-1,1)),Math.abs(z)<.9999999?(this._y=Math.atan2(-P,W),this._z=Math.atan2(-g,w)):(this._y=0,this._z=Math.atan2(x,d));break;case"ZYX":this._y=Math.asin(-Ki(P,-1,1)),Math.abs(P)<.9999999?(this._x=Math.atan2(z,W),this._z=Math.atan2(x,d)):(this._x=0,this._z=Math.atan2(-g,w));break;case"YZX":this._z=Math.asin(Ki(x,-1,1)),Math.abs(x)<.9999999?(this._x=Math.atan2(-S,w),this._y=Math.atan2(-P,d)):(this._x=0,this._y=Math.atan2(v,W));break;case"XZY":this._z=Math.asin(-Ki(g,-1,1)),Math.abs(g)<.9999999?(this._x=Math.atan2(z,w),this._y=Math.atan2(v,d)):(this._x=Math.atan2(-S,W),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+s)}return this._order=s,!0===l&&this._onChangeCallback(),this}setFromQuaternion(e,s,l){return ZA.makeRotationFromQuaternion(e),this.setFromRotationMatrix(ZA,s,l)}setFromVector3(e,s=this._order){return this.set(e.x,e.y,e.z,s)}reorder(e){return Vu.setFromEuler(this),this.setFromQuaternion(Vu,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],s=0){return e[s]=this._x,e[s+1]=this._y,e[s+2]=this._z,e[s+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Gi.DEFAULT_ORDER="XYZ";class qd{constructor(){this.mask=1}set(e){this.mask=1<<e>>>0}enable(e){this.mask|=1<<e}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e}disable(e){this.mask&=~(1<<e)}disableAll(){this.mask=0}test(e){return!!(this.mask&e.mask)}isEnabled(e){return!!(this.mask&1<<e)}}let u1=0;const Qi=new Dt,Nh=new _s,Xi=new Yn,Wl=new Dt,Gu=new Dt,h1=new Dt,Kc=new _s,Jc=new Dt(1,0,0),ga=new Dt(0,1,0),t0=new Dt(0,0,1),jl={type:"added"},Dh={type:"removed"},Xd={type:"childadded",child:null},e0={type:"childremoved",child:null};class hi extends to{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:u1++}),this.uuid=Ua(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=hi.DEFAULT_UP.clone();const e=new Dt,s=new Gi,l=new _s,c=new Dt(1,1,1);s._onChange(function(){l.setFromEuler(s,!1)}),l._onChange(function(){s.setFromQuaternion(l,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:s},quaternion:{configurable:!0,enumerable:!0,value:l},scale:{configurable:!0,enumerable:!0,value:c},modelViewMatrix:{value:new Yn},normalMatrix:{value:new yr}}),this.matrix=new Yn,this.matrixWorld=new Yn,this.matrixAutoUpdate=hi.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=hi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new qd,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,s){this.quaternion.setFromAxisAngle(e,s)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,s){return Nh.setFromAxisAngle(e,s),this.quaternion.multiply(Nh),this}rotateOnWorldAxis(e,s){return Nh.setFromAxisAngle(e,s),this.quaternion.premultiply(Nh),this}rotateX(e){return this.rotateOnAxis(Jc,e)}rotateY(e){return this.rotateOnAxis(ga,e)}rotateZ(e){return this.rotateOnAxis(t0,e)}translateOnAxis(e,s){return Qi.copy(e).applyQuaternion(this.quaternion),this.position.add(Qi.multiplyScalar(s)),this}translateX(e){return this.translateOnAxis(Jc,e)}translateY(e){return this.translateOnAxis(ga,e)}translateZ(e){return this.translateOnAxis(t0,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Xi.copy(this.matrixWorld).invert())}lookAt(e,s,l){e.isVector3?Wl.copy(e):Wl.set(e,s,l);const c=this.parent;this.updateWorldMatrix(!0,!1),Gu.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Xi.lookAt(Gu,Wl,this.up):Xi.lookAt(Wl,Gu,this.up),this.quaternion.setFromRotationMatrix(Xi),c&&(Xi.extractRotation(c.matrixWorld),Nh.setFromRotationMatrix(Xi),this.quaternion.premultiply(Nh.invert()))}add(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.add(arguments[s]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(jl),Xd.child=e,this.dispatchEvent(Xd),Xd.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let l=0;l<arguments.length;l++)this.remove(arguments[l]);return this}const s=this.children.indexOf(e);return-1!==s&&(e.parent=null,this.children.splice(s,1),e.dispatchEvent(Dh),e0.child=e,this.dispatchEvent(e0),e0.child=null),this}removeFromParent(){const e=this.parent;return null!==e&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Xi.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),Xi.multiply(e.parent.matrixWorld)),e.applyMatrix4(Xi),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(jl),Xd.child=e,this.dispatchEvent(Xd),Xd.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,s){if(this[e]===s)return this;for(let l=0,c=this.children.length;l<c;l++){const d=this.children[l].getObjectByProperty(e,s);if(void 0!==d)return d}}getObjectsByProperty(e,s,l=[]){this[e]===s&&l.push(this);const c=this.children;for(let d=0,g=c.length;d<g;d++)c[d].getObjectsByProperty(e,s,l);return l}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Gu,e,h1),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Gu,Kc,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const s=this.matrixWorld.elements;return e.set(s[8],s[9],s[10]).normalize()}raycast(){}traverse(e){e(this);const s=this.children;for(let l=0,c=s.length;l<c;l++)s[l].traverse(e)}traverseVisible(e){if(!1===this.visible)return;e(this);const s=this.children;for(let l=0,c=s.length;l<c;l++)s[l].traverseVisible(e)}traverseAncestors(e){const s=this.parent;null!==s&&(e(s),s.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const s=this.children;for(let l=0,c=s.length;l<c;l++){const d=s[l];!0!==d.matrixWorldAutoUpdate&&!0!==e||d.updateMatrixWorld(e)}}updateWorldMatrix(e,s){const l=this.parent;if(!0===e&&null!==l&&!0===l.matrixWorldAutoUpdate&&l.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===s){const c=this.children;for(let d=0,g=c.length;d<g;d++){const v=c[d];!0===v.matrixWorldAutoUpdate&&v.updateWorldMatrix(!1,!0)}}}toJSON(e){const s=void 0===e||"string"==typeof e,l={};s&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},l.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const c={};function d(v,x){return void 0===v[x.uuid]&&(v[x.uuid]=x.toJSON(e)),x.uuid}if(c.uuid=this.uuid,c.type=this.type,""!==this.name&&(c.name=this.name),!0===this.castShadow&&(c.castShadow=!0),!0===this.receiveShadow&&(c.receiveShadow=!0),!1===this.visible&&(c.visible=!1),!1===this.frustumCulled&&(c.frustumCulled=!1),0!==this.renderOrder&&(c.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(c.userData=this.userData),c.layers=this.layers.mask,c.matrix=this.matrix.toArray(),c.up=this.up.toArray(),!1===this.matrixAutoUpdate&&(c.matrixAutoUpdate=!1),this.isInstancedMesh&&(c.type="InstancedMesh",c.count=this.count,c.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(c.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(c.type="BatchedMesh",c.perObjectFrustumCulled=this.perObjectFrustumCulled,c.sortObjects=this.sortObjects,c.drawRanges=this._drawRanges,c.reservedRanges=this._reservedRanges,c.visibility=this._visibility,c.active=this._active,c.bounds=this._bounds.map(v=>({boxInitialized:v.boxInitialized,boxMin:v.box.min.toArray(),boxMax:v.box.max.toArray(),sphereInitialized:v.sphereInitialized,sphereRadius:v.sphere.radius,sphereCenter:v.sphere.center.toArray()})),c.maxGeometryCount=this._maxGeometryCount,c.maxVertexCount=this._maxVertexCount,c.maxIndexCount=this._maxIndexCount,c.geometryInitialized=this._geometryInitialized,c.geometryCount=this._geometryCount,c.matricesTexture=this._matricesTexture.toJSON(e),null!==this.boundingSphere&&(c.boundingSphere={center:c.boundingSphere.center.toArray(),radius:c.boundingSphere.radius}),null!==this.boundingBox&&(c.boundingBox={min:c.boundingBox.min.toArray(),max:c.boundingBox.max.toArray()})),this.isScene)this.background&&(this.background.isColor?c.background=this.background.toJSON():this.background.isTexture&&(c.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(c.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){c.geometry=d(e.geometries,this.geometry);const v=this.geometry.parameters;if(void 0!==v&&void 0!==v.shapes){const x=v.shapes;if(Array.isArray(x))for(let w=0,S=x.length;w<S;w++)d(e.shapes,x[w]);else d(e.shapes,x)}}if(this.isSkinnedMesh&&(c.bindMode=this.bindMode,c.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(d(e.skeletons,this.skeleton),c.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const v=[];for(let x=0,w=this.material.length;x<w;x++)v.push(d(e.materials,this.material[x]));c.material=v}else c.material=d(e.materials,this.material);if(this.children.length>0){c.children=[];for(let v=0;v<this.children.length;v++)c.children.push(this.children[v].toJSON(e).object)}if(this.animations.length>0){c.animations=[];for(let v=0;v<this.animations.length;v++)c.animations.push(d(e.animations,this.animations[v]))}if(s){const v=g(e.geometries),x=g(e.materials),w=g(e.textures),S=g(e.images),P=g(e.shapes),z=g(e.skeletons),W=g(e.animations),Y=g(e.nodes);v.length>0&&(l.geometries=v),x.length>0&&(l.materials=x),w.length>0&&(l.textures=w),S.length>0&&(l.images=S),P.length>0&&(l.shapes=P),z.length>0&&(l.skeletons=z),W.length>0&&(l.animations=W),Y.length>0&&(l.nodes=Y)}return l.object=c,l;function g(v){const x=[];for(const w in v){const S=v[w];delete S.metadata,x.push(S)}return x}}clone(e){return(new this.constructor).copy(this,e)}copy(e,s=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),!0===s)for(let l=0;l<e.children.length;l++)this.add(e.children[l].clone());return this}}hi.DEFAULT_UP=new Dt(0,1,0),hi.DEFAULT_MATRIX_AUTO_UPDATE=!0,hi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ql=new Dt,jo=new Dt,Wm=new Dt,vl=new Dt,pc=new Dt,is=new Dt,bl=new Dt,Qu=new Dt,n0=new Dt,Zr=new Dt;class Re{constructor(e=new Dt,s=new Dt,l=new Dt){this.a=e,this.b=s,this.c=l}static getNormal(e,s,l,c){c.subVectors(l,s),ql.subVectors(e,s),c.cross(ql);const d=c.lengthSq();return d>0?c.multiplyScalar(1/Math.sqrt(d)):c.set(0,0,0)}static getBarycoord(e,s,l,c,d){ql.subVectors(c,s),jo.subVectors(l,s),Wm.subVectors(e,s);const g=ql.dot(ql),v=ql.dot(jo),x=ql.dot(Wm),w=jo.dot(jo),S=jo.dot(Wm),P=g*w-v*v;if(0===P)return d.set(0,0,0),null;const z=1/P,W=(w*x-v*S)*z,Y=(g*S-v*x)*z;return d.set(1-W-Y,Y,W)}static containsPoint(e,s,l,c){return null!==this.getBarycoord(e,s,l,c,vl)&&vl.x>=0&&vl.y>=0&&vl.x+vl.y<=1}static getInterpolation(e,s,l,c,d,g,v,x){return null===this.getBarycoord(e,s,l,c,vl)?(x.x=0,x.y=0,"z"in x&&(x.z=0),"w"in x&&(x.w=0),null):(x.setScalar(0),x.addScaledVector(d,vl.x),x.addScaledVector(g,vl.y),x.addScaledVector(v,vl.z),x)}static isFrontFacing(e,s,l,c){return ql.subVectors(l,s),jo.subVectors(e,s),ql.cross(jo).dot(c)<0}set(e,s,l){return this.a.copy(e),this.b.copy(s),this.c.copy(l),this}setFromPointsAndIndices(e,s,l,c){return this.a.copy(e[s]),this.b.copy(e[l]),this.c.copy(e[c]),this}setFromAttributeAndIndices(e,s,l,c){return this.a.fromBufferAttribute(e,s),this.b.fromBufferAttribute(e,l),this.c.fromBufferAttribute(e,c),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return ql.subVectors(this.c,this.b),jo.subVectors(this.a,this.b),.5*ql.cross(jo).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(.3333333333333333)}getNormal(e){return Re.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,s){return Re.getBarycoord(e,this.a,this.b,this.c,s)}getInterpolation(e,s,l,c,d){return Re.getInterpolation(e,this.a,this.b,this.c,s,l,c,d)}containsPoint(e){return Re.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Re.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,s){const l=this.a,c=this.b,d=this.c;let g,v;pc.subVectors(c,l),is.subVectors(d,l),Qu.subVectors(e,l);const x=pc.dot(Qu),w=is.dot(Qu);if(x<=0&&w<=0)return s.copy(l);n0.subVectors(e,c);const S=pc.dot(n0),P=is.dot(n0);if(S>=0&&P<=S)return s.copy(c);const z=x*P-S*w;if(z<=0&&x>=0&&S<=0)return g=x/(x-S),s.copy(l).addScaledVector(pc,g);Zr.subVectors(e,d);const W=pc.dot(Zr),Y=is.dot(Zr);if(Y>=0&&W<=Y)return s.copy(d);const tt=W*w-x*Y;if(tt<=0&&w>=0&&Y<=0)return v=w/(w-Y),s.copy(l).addScaledVector(is,v);const J=S*Y-W*P;if(J<=0&&P-S>=0&&W-Y>=0)return bl.subVectors(d,c),v=(P-S)/(P-S+(W-Y)),s.copy(c).addScaledVector(bl,v);const at=1/(J+tt+z);return g=tt*at,v=z*at,s.copy(l).addScaledVector(pc,g).addScaledVector(is,v)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const Yd={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},fc={h:0,s:0,l:0},Kd={h:0,s:0,l:0};function df(A,e,s){return s<0&&(s+=1),s>1&&(s-=1),s<.16666666666666666?A+6*(e-A)*s:s<.5?e:s<.6666666666666666?A+6*(e-A)*(.6666666666666666-s):A}class En{constructor(e,s,l){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,s,l)}set(e,s,l){if(void 0===s&&void 0===l){const c=e;c&&c.isColor?this.copy(c):"number"==typeof c?this.setHex(c):"string"==typeof c&&this.setStyle(c)}else this.setRGB(e,s,l);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,s=qi){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,Jr.toWorkingColorSpace(this,s),this}setRGB(e,s,l,c=Jr.workingColorSpace){return this.r=e,this.g=s,this.b=l,Jr.toWorkingColorSpace(this,c),this}setHSL(e,s,l,c=Jr.workingColorSpace){if(e=YA(e,1),s=Ki(s,0,1),l=Ki(l,0,1),0===s)this.r=this.g=this.b=l;else{const d=l<=.5?l*(1+s):l+s-l*s,g=2*l-d;this.r=df(g,d,e+.3333333333333333),this.g=df(g,d,e),this.b=df(g,d,e-.3333333333333333)}return Jr.toWorkingColorSpace(this,c),this}setStyle(e,s=qi){function l(d){void 0!==d&&parseFloat(d)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let c;if(c=/^(\w+)\(([^\)]*)\)/.exec(e)){let d;const v=c[2];switch(c[1]){case"rgb":case"rgba":if(d=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(v))return l(d[4]),this.setRGB(Math.min(255,parseInt(d[1],10))/255,Math.min(255,parseInt(d[2],10))/255,Math.min(255,parseInt(d[3],10))/255,s);if(d=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(v))return l(d[4]),this.setRGB(Math.min(100,parseInt(d[1],10))/100,Math.min(100,parseInt(d[2],10))/100,Math.min(100,parseInt(d[3],10))/100,s);break;case"hsl":case"hsla":if(d=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(v))return l(d[4]),this.setHSL(parseFloat(d[1])/360,parseFloat(d[2])/100,parseFloat(d[3])/100,s);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(c=/^\#([A-Fa-f\d]+)$/.exec(e)){const d=c[1],g=d.length;if(3===g)return this.setRGB(parseInt(d.charAt(0),16)/15,parseInt(d.charAt(1),16)/15,parseInt(d.charAt(2),16)/15,s);if(6===g)return this.setHex(parseInt(d,16),s);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,s);return this}setColorName(e,s=qi){const l=Yd[e.toLowerCase()];return void 0!==l?this.setHex(l,s):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=cc(e.r),this.g=cc(e.g),this.b=cc(e.b),this}copyLinearToSRGB(e){return this.r=Pu(e.r),this.g=Pu(e.g),this.b=Pu(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=qi){return Jr.fromWorkingColorSpace(ka.copy(this),e),65536*Math.round(Ki(255*ka.r,0,255))+256*Math.round(Ki(255*ka.g,0,255))+Math.round(Ki(255*ka.b,0,255))}getHexString(e=qi){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,s=Jr.workingColorSpace){Jr.fromWorkingColorSpace(ka.copy(this),s);const l=ka.r,c=ka.g,d=ka.b,g=Math.max(l,c,d),v=Math.min(l,c,d);let x,w;const S=(v+g)/2;if(v===g)x=0,w=0;else{const P=g-v;switch(w=S<=.5?P/(g+v):P/(2-g-v),g){case l:x=(c-d)/P+(c<d?6:0);break;case c:x=(d-l)/P+2;break;case d:x=(l-c)/P+4}x/=6}return e.h=x,e.s=w,e.l=S,e}getRGB(e,s=Jr.workingColorSpace){return Jr.fromWorkingColorSpace(ka.copy(this),s),e.r=ka.r,e.g=ka.g,e.b=ka.b,e}getStyle(e=qi){Jr.fromWorkingColorSpace(ka.copy(this),e);const s=ka.r,l=ka.g,c=ka.b;return e!==qi?`color(${e} ${s.toFixed(3)} ${l.toFixed(3)} ${c.toFixed(3)})`:`rgb(${Math.round(255*s)},${Math.round(255*l)},${Math.round(255*c)})`}offsetHSL(e,s,l){return this.getHSL(fc),this.setHSL(fc.h+e,fc.s+s,fc.l+l)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,s){return this.r=e.r+s.r,this.g=e.g+s.g,this.b=e.b+s.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,s){return this.r+=(e.r-this.r)*s,this.g+=(e.g-this.g)*s,this.b+=(e.b-this.b)*s,this}lerpColors(e,s,l){return this.r=e.r+(s.r-e.r)*l,this.g=e.g+(s.g-e.g)*l,this.b=e.b+(s.b-e.b)*l,this}lerpHSL(e,s){this.getHSL(fc),e.getHSL(Kd);const l=lc(fc.h,Kd.h,s),c=lc(fc.s,Kd.s,s),d=lc(fc.l,Kd.l,s);return this.setHSL(l,c,d),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const s=this.r,l=this.g,c=this.b,d=e.elements;return this.r=d[0]*s+d[3]*l+d[6]*c,this.g=d[1]*s+d[4]*l+d[7]*c,this.b=d[2]*s+d[5]*l+d[8]*c,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,s=0){return this.r=e[s],this.g=e[s+1],this.b=e[s+2],this}toArray(e=[],s=0){return e[s]=this.r,e[s+1]=this.g,e[s+2]=this.b,e}fromBufferAttribute(e,s){return this.r=e.getX(s),this.g=e.getY(s),this.b=e.getZ(s),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ka=new En;En.NAMES=Yd;let Tb=0;class di extends to{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Tb++}),this.uuid=Ua(),this.name="",this.type="Material",this.blending=pt,this.side=Q,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=vn,this.blendDst=_n,this.blendEquation=et,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new En(0,0,0),this.blendAlpha=0,this.depthFunc=_i,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=wh,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Ul,this.stencilZFail=Ul,this.stencilZPass=Ul,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(void 0!==e)for(const s in e){const l=e[s];if(void 0===l){console.warn(`THREE.Material: parameter '${s}' has value of undefined.`);continue}const c=this[s];void 0!==c?c&&c.isColor?c.set(l):c&&c.isVector3&&l&&l.isVector3?c.copy(l):this[s]=l:console.warn(`THREE.Material: '${s}' is not a property of THREE.${this.type}.`)}}toJSON(e){const s=void 0===e||"string"==typeof e;s&&(e={textures:{},images:{}});const l={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};function c(d){const g=[];for(const v in d){const x=d[v];delete x.metadata,g.push(x)}return g}if(l.uuid=this.uuid,l.type=this.type,""!==this.name&&(l.name=this.name),this.color&&this.color.isColor&&(l.color=this.color.getHex()),void 0!==this.roughness&&(l.roughness=this.roughness),void 0!==this.metalness&&(l.metalness=this.metalness),void 0!==this.sheen&&(l.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(l.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(l.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(l.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(l.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(l.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(l.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(l.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(l.shininess=this.shininess),void 0!==this.clearcoat&&(l.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(l.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(l.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(l.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(l.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,l.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.dispersion&&(l.dispersion=this.dispersion),void 0!==this.iridescence&&(l.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(l.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(l.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(l.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(l.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),void 0!==this.anisotropy&&(l.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(l.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(l.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(l.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(l.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(l.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(l.lightMap=this.lightMap.toJSON(e).uuid,l.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(l.aoMap=this.aoMap.toJSON(e).uuid,l.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(l.bumpMap=this.bumpMap.toJSON(e).uuid,l.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(l.normalMap=this.normalMap.toJSON(e).uuid,l.normalMapType=this.normalMapType,l.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(l.displacementMap=this.displacementMap.toJSON(e).uuid,l.displacementScale=this.displacementScale,l.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(l.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(l.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(l.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(l.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(l.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(l.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(l.envMap=this.envMap.toJSON(e).uuid,void 0!==this.combine&&(l.combine=this.combine)),void 0!==this.envMapRotation&&(l.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(l.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(l.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(l.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(l.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.transmission&&(l.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(l.transmissionMap=this.transmissionMap.toJSON(e).uuid),void 0!==this.thickness&&(l.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(l.thicknessMap=this.thicknessMap.toJSON(e).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(l.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(l.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(l.size=this.size),null!==this.shadowSide&&(l.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(l.sizeAttenuation=this.sizeAttenuation),this.blending!==pt&&(l.blending=this.blending),this.side!==Q&&(l.side=this.side),!0===this.vertexColors&&(l.vertexColors=!0),this.opacity<1&&(l.opacity=this.opacity),!0===this.transparent&&(l.transparent=!0),this.blendSrc!==vn&&(l.blendSrc=this.blendSrc),this.blendDst!==_n&&(l.blendDst=this.blendDst),this.blendEquation!==et&&(l.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(l.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(l.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(l.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(l.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(l.blendAlpha=this.blendAlpha),this.depthFunc!==_i&&(l.depthFunc=this.depthFunc),!1===this.depthTest&&(l.depthTest=this.depthTest),!1===this.depthWrite&&(l.depthWrite=this.depthWrite),!1===this.colorWrite&&(l.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(l.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==wh&&(l.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(l.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(l.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Ul&&(l.stencilFail=this.stencilFail),this.stencilZFail!==Ul&&(l.stencilZFail=this.stencilZFail),this.stencilZPass!==Ul&&(l.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(l.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(l.rotation=this.rotation),!0===this.polygonOffset&&(l.polygonOffset=!0),0!==this.polygonOffsetFactor&&(l.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(l.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(l.linewidth=this.linewidth),void 0!==this.dashSize&&(l.dashSize=this.dashSize),void 0!==this.gapSize&&(l.gapSize=this.gapSize),void 0!==this.scale&&(l.scale=this.scale),!0===this.dithering&&(l.dithering=!0),this.alphaTest>0&&(l.alphaTest=this.alphaTest),!0===this.alphaHash&&(l.alphaHash=!0),!0===this.alphaToCoverage&&(l.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(l.premultipliedAlpha=!0),!0===this.forceSinglePass&&(l.forceSinglePass=!0),!0===this.wireframe&&(l.wireframe=!0),this.wireframeLinewidth>1&&(l.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(l.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(l.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(l.flatShading=!0),!1===this.visible&&(l.visible=!1),!1===this.toneMapped&&(l.toneMapped=!1),!1===this.fog&&(l.fog=!1),Object.keys(this.userData).length>0&&(l.userData=this.userData),s){const d=c(e.textures),g=c(e.images);d.length>0&&(l.textures=d),g.length>0&&(l.images=g)}return l}clone(){return(new this.constructor).copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const s=e.clippingPlanes;let l=null;if(null!==s){const c=s.length;l=new Array(c);for(let d=0;d!==c;++d)l[d]=s[d].clone()}return this.clippingPlanes=l,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}}class no extends di{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new En(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Gi,this.combine=Ct,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Ei=function d1(){const A=new ArrayBuffer(4),e=new Float32Array(A),s=new Uint32Array(A),l=new Uint32Array(512),c=new Uint32Array(512);for(let x=0;x<256;++x){const w=x-127;w<-27?(l[x]=0,l[256|x]=32768,c[x]=24,c[256|x]=24):w<-14?(l[x]=1024>>-w-14,l[256|x]=1024>>-w-14|32768,c[x]=-w-1,c[256|x]=-w-1):w<=15?(l[x]=w+15<<10,l[256|x]=w+15<<10|32768,c[x]=13,c[256|x]=13):w<128?(l[x]=31744,l[256|x]=64512,c[x]=24,c[256|x]=24):(l[x]=31744,l[256|x]=64512,c[x]=13,c[256|x]=13)}const d=new Uint32Array(2048),g=new Uint32Array(64),v=new Uint32Array(64);for(let x=1;x<1024;++x){let w=x<<13,S=0;for(;!(8388608&w);)w<<=1,S-=8388608;w&=-8388609,S+=947912704,d[x]=w|S}for(let x=1024;x<2048;++x)d[x]=939524096+(x-1024<<13);for(let x=1;x<31;++x)g[x]=x<<23;g[31]=1199570944,g[32]=2147483648;for(let x=33;x<63;++x)g[x]=2147483648+(x-32<<23);g[63]=3347054592;for(let x=1;x<64;++x)32!==x&&(v[x]=1024);return{floatView:e,uint32View:s,baseTable:l,shiftTable:c,mantissaTable:d,exponentTable:g,offsetTable:v}}();function $a(A){Math.abs(A)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),A=Ki(A,-65504,65504),Ei.floatView[0]=A;const e=Ei.uint32View[0],s=e>>23&511;return Ei.baseTable[s]+((8388607&e)>>Ei.shiftTable[s])}function qo(A){const e=A>>10;return Ei.uint32View[0]=Ei.mantissaTable[Ei.offsetTable[e]+(1023&A)]+Ei.exponentTable[e],Ei.floatView[0]}const pf={toHalfFloat:$a,fromHalfFloat:qo},ks=new Dt,ff=new Ye;class wr{constructor(e,s,l=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=s,this.count=void 0!==e?e.length/s:0,this.normalized=l,this.usage=Du,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=wn,this.version=0}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}get updateRange(){return Ud("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,s){this.updateRanges.push({start:e,count:s})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,s,l){e*=this.itemSize,l*=s.itemSize;for(let c=0,d=this.itemSize;c<d;c++)this.array[e+c]=s.array[l+c];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(2===this.itemSize)for(let s=0,l=this.count;s<l;s++)ff.fromBufferAttribute(this,s),ff.applyMatrix3(e),this.setXY(s,ff.x,ff.y);else if(3===this.itemSize)for(let s=0,l=this.count;s<l;s++)ks.fromBufferAttribute(this,s),ks.applyMatrix3(e),this.setXYZ(s,ks.x,ks.y,ks.z);return this}applyMatrix4(e){for(let s=0,l=this.count;s<l;s++)ks.fromBufferAttribute(this,s),ks.applyMatrix4(e),this.setXYZ(s,ks.x,ks.y,ks.z);return this}applyNormalMatrix(e){for(let s=0,l=this.count;s<l;s++)ks.fromBufferAttribute(this,s),ks.applyNormalMatrix(e),this.setXYZ(s,ks.x,ks.y,ks.z);return this}transformDirection(e){for(let s=0,l=this.count;s<l;s++)ks.fromBufferAttribute(this,s),ks.transformDirection(e),this.setXYZ(s,ks.x,ks.y,ks.z);return this}set(e,s=0){return this.array.set(e,s),this}getComponent(e,s){let l=this.array[e*this.itemSize+s];return this.normalized&&(l=ma(l,this.array)),l}setComponent(e,s,l){return this.normalized&&(l=Br(l,this.array)),this.array[e*this.itemSize+s]=l,this}getX(e){let s=this.array[e*this.itemSize];return this.normalized&&(s=ma(s,this.array)),s}setX(e,s){return this.normalized&&(s=Br(s,this.array)),this.array[e*this.itemSize]=s,this}getY(e){let s=this.array[e*this.itemSize+1];return this.normalized&&(s=ma(s,this.array)),s}setY(e,s){return this.normalized&&(s=Br(s,this.array)),this.array[e*this.itemSize+1]=s,this}getZ(e){let s=this.array[e*this.itemSize+2];return this.normalized&&(s=ma(s,this.array)),s}setZ(e,s){return this.normalized&&(s=Br(s,this.array)),this.array[e*this.itemSize+2]=s,this}getW(e){let s=this.array[e*this.itemSize+3];return this.normalized&&(s=ma(s,this.array)),s}setW(e,s){return this.normalized&&(s=Br(s,this.array)),this.array[e*this.itemSize+3]=s,this}setXY(e,s,l){return e*=this.itemSize,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array)),this.array[e+0]=s,this.array[e+1]=l,this}setXYZ(e,s,l,c){return e*=this.itemSize,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array),c=Br(c,this.array)),this.array[e+0]=s,this.array[e+1]=l,this.array[e+2]=c,this}setXYZW(e,s,l,c,d){return e*=this.itemSize,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array),c=Br(c,this.array),d=Br(d,this.array)),this.array[e+0]=s,this.array[e+1]=l,this.array[e+2]=c,this.array[e+3]=d,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(e.name=this.name),this.usage!==Du&&(e.usage=this.usage),e}}class p1 extends wr{constructor(e,s,l){super(new Int8Array(e),s,l)}}class Kt extends wr{constructor(e,s,l){super(new Uint8Array(e),s,l)}}class _b extends wr{constructor(e,s,l){super(new Uint8ClampedArray(e),s,l)}}class r0 extends wr{constructor(e,s,l){super(new Int16Array(e),s,l)}}class i0 extends wr{constructor(e,s,l){super(new Uint16Array(e),s,l)}}class s0 extends wr{constructor(e,s,l){super(new Int32Array(e),s,l)}}class mf extends wr{constructor(e,s,l){super(new Uint32Array(e),s,l)}}class Xl extends wr{constructor(e,s,l){super(new Uint16Array(e),s,l),this.isFloat16BufferAttribute=!0}getX(e){let s=qo(this.array[e*this.itemSize]);return this.normalized&&(s=ma(s,this.array)),s}setX(e,s){return this.normalized&&(s=Br(s,this.array)),this.array[e*this.itemSize]=$a(s),this}getY(e){let s=qo(this.array[e*this.itemSize+1]);return this.normalized&&(s=ma(s,this.array)),s}setY(e,s){return this.normalized&&(s=Br(s,this.array)),this.array[e*this.itemSize+1]=$a(s),this}getZ(e){let s=qo(this.array[e*this.itemSize+2]);return this.normalized&&(s=ma(s,this.array)),s}setZ(e,s){return this.normalized&&(s=Br(s,this.array)),this.array[e*this.itemSize+2]=$a(s),this}getW(e){let s=qo(this.array[e*this.itemSize+3]);return this.normalized&&(s=ma(s,this.array)),s}setW(e,s){return this.normalized&&(s=Br(s,this.array)),this.array[e*this.itemSize+3]=$a(s),this}setXY(e,s,l){return e*=this.itemSize,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array)),this.array[e+0]=$a(s),this.array[e+1]=$a(l),this}setXYZ(e,s,l,c){return e*=this.itemSize,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array),c=Br(c,this.array)),this.array[e+0]=$a(s),this.array[e+1]=$a(l),this.array[e+2]=$a(c),this}setXYZW(e,s,l,c,d){return e*=this.itemSize,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array),c=Br(c,this.array),d=Br(d,this.array)),this.array[e+0]=$a(s),this.array[e+1]=$a(l),this.array[e+2]=$a(c),this.array[e+3]=$a(d),this}}class Tn extends wr{constructor(e,s,l){super(new Float32Array(e),s,l)}}let f1=0;const Xo=new Yn,Bt=new hi,mc=new Dt,Ro=new ta,Jt=new ta,ss=new Dt;class gr extends to{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:f1++}),this.uuid=Ua(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return this.index=Array.isArray(e)?new(Pd(e)?mf:i0)(e,1):e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,s){return this.attributes[e]=s,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,s,l=0){this.groups.push({start:e,count:s,materialIndex:l})}clearGroups(){this.groups=[]}setDrawRange(e,s){this.drawRange.start=e,this.drawRange.count=s}applyMatrix4(e){const s=this.attributes.position;void 0!==s&&(s.applyMatrix4(e),s.needsUpdate=!0);const l=this.attributes.normal;if(void 0!==l){const d=(new yr).getNormalMatrix(e);l.applyNormalMatrix(d),l.needsUpdate=!0}const c=this.attributes.tangent;return void 0!==c&&(c.transformDirection(e),c.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(e){return Xo.makeRotationFromQuaternion(e),this.applyMatrix4(Xo),this}rotateX(e){return Xo.makeRotationX(e),this.applyMatrix4(Xo),this}rotateY(e){return Xo.makeRotationY(e),this.applyMatrix4(Xo),this}rotateZ(e){return Xo.makeRotationZ(e),this.applyMatrix4(Xo),this}translate(e,s,l){return Xo.makeTranslation(e,s,l),this.applyMatrix4(Xo),this}scale(e,s,l){return Xo.makeScale(e,s,l),this.applyMatrix4(Xo),this}lookAt(e){return Bt.lookAt(e),Bt.updateMatrix(),this.applyMatrix4(Bt.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(mc).negate(),this.translate(mc.x,mc.y,mc.z),this}setFromPoints(e){const s=[];for(let l=0,c=e.length;l<c;l++){const d=e[l];s.push(d.x,d.y,d.z||0)}return this.setAttribute("position",new Tn(s,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new ta);const e=this.attributes.position,s=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new Dt(-1/0,-1/0,-1/0),new Dt(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),s)for(let l=0,c=s.length;l<c;l++)Ro.setFromBufferAttribute(s[l]),this.morphTargetsRelative?(ss.addVectors(this.boundingBox.min,Ro.min),this.boundingBox.expandByPoint(ss),ss.addVectors(this.boundingBox.max,Ro.max),this.boundingBox.expandByPoint(ss)):(this.boundingBox.expandByPoint(Ro.min),this.boundingBox.expandByPoint(Ro.max))}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Ls);const e=this.attributes.position,s=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new Dt,1/0);if(e){const l=this.boundingSphere.center;if(Ro.setFromBufferAttribute(e),s)for(let d=0,g=s.length;d<g;d++)Jt.setFromBufferAttribute(s[d]),this.morphTargetsRelative?(ss.addVectors(Ro.min,Jt.min),Ro.expandByPoint(ss),ss.addVectors(Ro.max,Jt.max),Ro.expandByPoint(ss)):(Ro.expandByPoint(Jt.min),Ro.expandByPoint(Jt.max));Ro.getCenter(l);let c=0;for(let d=0,g=e.count;d<g;d++)ss.fromBufferAttribute(e,d),c=Math.max(c,l.distanceToSquared(ss));if(s)for(let d=0,g=s.length;d<g;d++){const v=s[d],x=this.morphTargetsRelative;for(let w=0,S=v.count;w<S;w++)ss.fromBufferAttribute(v,w),x&&(mc.fromBufferAttribute(e,w),ss.add(mc)),c=Math.max(c,l.distanceToSquared(ss))}this.boundingSphere.radius=Math.sqrt(c),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,s=this.attributes;if(null===e||void 0===s.position||void 0===s.normal||void 0===s.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const l=s.position,c=s.normal,d=s.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new wr(new Float32Array(4*l.count),4));const g=this.getAttribute("tangent"),v=[],x=[];for(let zt=0;zt<l.count;zt++)v[zt]=new Dt,x[zt]=new Dt;const w=new Dt,S=new Dt,P=new Dt,z=new Ye,W=new Ye,Y=new Ye,tt=new Dt,J=new Dt;function at(zt,ee,ce){w.fromBufferAttribute(l,zt),S.fromBufferAttribute(l,ee),P.fromBufferAttribute(l,ce),z.fromBufferAttribute(d,zt),W.fromBufferAttribute(d,ee),Y.fromBufferAttribute(d,ce),S.sub(w),P.sub(w),W.sub(z),Y.sub(z);const ne=1/(W.x*Y.y-Y.x*W.y);isFinite(ne)&&(tt.copy(S).multiplyScalar(Y.y).addScaledVector(P,-W.y).multiplyScalar(ne),J.copy(P).multiplyScalar(W.x).addScaledVector(S,-Y.x).multiplyScalar(ne),v[zt].add(tt),v[ee].add(tt),v[ce].add(tt),x[zt].add(J),x[ee].add(J),x[ce].add(J))}let it=this.groups;0===it.length&&(it=[{start:0,count:e.count}]);for(let zt=0,ee=it.length;zt<ee;++zt){const ce=it[zt],ne=ce.start;for(let ge=ne,ie=ne+ce.count;ge<ie;ge+=3)at(e.getX(ge+0),e.getX(ge+1),e.getX(ge+2))}const ct=new Dt,At=new Dt,Ft=new Dt,Tt=new Dt;function Pt(zt){Ft.fromBufferAttribute(c,zt),Tt.copy(Ft);const ee=v[zt];ct.copy(ee),ct.sub(Ft.multiplyScalar(Ft.dot(ee))).normalize(),At.crossVectors(Tt,ee);const ce=At.dot(x[zt])<0?-1:1;g.setXYZW(zt,ct.x,ct.y,ct.z,ce)}for(let zt=0,ee=it.length;zt<ee;++zt){const ce=it[zt],ne=ce.start;for(let ge=ne,ie=ne+ce.count;ge<ie;ge+=3)Pt(e.getX(ge+0)),Pt(e.getX(ge+1)),Pt(e.getX(ge+2))}}computeVertexNormals(){const e=this.index,s=this.getAttribute("position");if(void 0!==s){let l=this.getAttribute("normal");if(void 0===l)l=new wr(new Float32Array(3*s.count),3),this.setAttribute("normal",l);else for(let z=0,W=l.count;z<W;z++)l.setXYZ(z,0,0,0);const c=new Dt,d=new Dt,g=new Dt,v=new Dt,x=new Dt,w=new Dt,S=new Dt,P=new Dt;if(e)for(let z=0,W=e.count;z<W;z+=3){const Y=e.getX(z+0),tt=e.getX(z+1),J=e.getX(z+2);c.fromBufferAttribute(s,Y),d.fromBufferAttribute(s,tt),g.fromBufferAttribute(s,J),S.subVectors(g,d),P.subVectors(c,d),S.cross(P),v.fromBufferAttribute(l,Y),x.fromBufferAttribute(l,tt),w.fromBufferAttribute(l,J),v.add(S),x.add(S),w.add(S),l.setXYZ(Y,v.x,v.y,v.z),l.setXYZ(tt,x.x,x.y,x.z),l.setXYZ(J,w.x,w.y,w.z)}else for(let z=0,W=s.count;z<W;z+=3)c.fromBufferAttribute(s,z+0),d.fromBufferAttribute(s,z+1),g.fromBufferAttribute(s,z+2),S.subVectors(g,d),P.subVectors(c,d),S.cross(P),l.setXYZ(z+0,S.x,S.y,S.z),l.setXYZ(z+1,S.x,S.y,S.z),l.setXYZ(z+2,S.x,S.y,S.z);this.normalizeNormals(),l.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let s=0,l=e.count;s<l;s++)ss.fromBufferAttribute(e,s),ss.normalize(),e.setXYZ(s,ss.x,ss.y,ss.z)}toNonIndexed(){function e(v,x){const w=v.array,S=v.itemSize,P=v.normalized,z=new w.constructor(x.length*S);let W=0,Y=0;for(let tt=0,J=x.length;tt<J;tt++){W=v.isInterleavedBufferAttribute?x[tt]*v.data.stride+v.offset:x[tt]*S;for(let at=0;at<S;at++)z[Y++]=w[W++]}return new wr(z,S,P)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const s=new gr,l=this.index.array,c=this.attributes;for(const v in c){const x=e(c[v],l);s.setAttribute(v,x)}const d=this.morphAttributes;for(const v in d){const x=[],w=d[v];for(let S=0,P=w.length;S<P;S++){const z=e(w[S],l);x.push(z)}s.morphAttributes[v]=x}s.morphTargetsRelative=this.morphTargetsRelative;const g=this.groups;for(let v=0,x=g.length;v<x;v++){const w=g[v];s.addGroup(w.start,w.count,w.materialIndex)}return s}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const x=this.parameters;for(const w in x)void 0!==x[w]&&(e[w]=x[w]);return e}e.data={attributes:{}};const s=this.index;null!==s&&(e.data.index={type:s.array.constructor.name,array:Array.prototype.slice.call(s.array)});const l=this.attributes;for(const x in l)e.data.attributes[x]=l[x].toJSON(e.data);const c={};let d=!1;for(const x in this.morphAttributes){const w=this.morphAttributes[x],S=[];for(let P=0,z=w.length;P<z;P++)S.push(w[P].toJSON(e.data));S.length>0&&(c[x]=S,d=!0)}d&&(e.data.morphAttributes=c,e.data.morphTargetsRelative=this.morphTargetsRelative);const g=this.groups;g.length>0&&(e.data.groups=JSON.parse(JSON.stringify(g)));const v=this.boundingSphere;return null!==v&&(e.data.boundingSphere={center:v.center.toArray(),radius:v.radius}),e}clone(){return(new this.constructor).copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const s={};this.name=e.name;const l=e.index;null!==l&&this.setIndex(l.clone(s));const c=e.attributes;for(const w in c)this.setAttribute(w,c[w].clone(s));const d=e.morphAttributes;for(const w in d){const S=[],P=d[w];for(let z=0,W=P.length;z<W;z++)S.push(P[z].clone(s));this.morphAttributes[w]=S}this.morphTargetsRelative=e.morphTargetsRelative;const g=e.groups;for(let w=0,S=g.length;w<S;w++){const P=g[w];this.addGroup(P.start,P.count,P.materialIndex)}const v=e.boundingBox;null!==v&&(this.boundingBox=v.clone());const x=e.boundingSphere;return null!==x&&(this.boundingSphere=x.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Yo=new Yn,Zc=new hc,Jd=new Ls,gf=new Dt,Zd=new Dt,Hu=new Dt,Lh=new Dt,tp=new Dt,Af=new Dt,yf=new Ye,ep=new Ye,Wu=new Ye,m1=new Dt,as=new Dt,g1=new Dt,jm=new Dt,np=new Dt;class os extends hi{constructor(e=new gr,s=new no){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=s,this.updateMorphTargets()}copy(e,s){return super.copy(e,s),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,s=Object.keys(e);if(s.length>0){const l=e[s[0]];if(void 0!==l){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,d=l.length;c<d;c++){const g=l[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[g]=c}}}}getVertexPosition(e,s){const l=this.geometry,d=l.morphAttributes.position,g=l.morphTargetsRelative;s.fromBufferAttribute(l.attributes.position,e);const v=this.morphTargetInfluences;if(d&&v){Af.set(0,0,0);for(let x=0,w=d.length;x<w;x++){const S=v[x];0!==S&&(tp.fromBufferAttribute(d[x],e),Af.addScaledVector(g?tp:tp.sub(s),S))}s.add(Af)}return s}raycast(e,s){const l=this.geometry,d=this.matrixWorld;if(void 0!==this.material){if(null===l.boundingSphere&&l.computeBoundingSphere(),Jd.copy(l.boundingSphere),Jd.applyMatrix4(d),Zc.copy(e.ray).recast(e.near),!1===Jd.containsPoint(Zc.origin)&&(null===Zc.intersectSphere(Jd,gf)||Zc.origin.distanceToSquared(gf)>(e.far-e.near)**2))return;Yo.copy(d).invert(),Zc.copy(e.ray).applyMatrix4(Yo),null!==l.boundingBox&&!1===Zc.intersectsBox(l.boundingBox)||this._computeIntersections(e,s,Zc)}}_computeIntersections(e,s,l){let c;const d=this.geometry,g=this.material,v=d.index,x=d.attributes.position,w=d.attributes.uv,S=d.attributes.uv1,P=d.attributes.normal,z=d.groups,W=d.drawRange;if(null!==v)if(Array.isArray(g))for(let Y=0,tt=z.length;Y<tt;Y++){const J=z[Y],at=g[J.materialIndex];for(let it=Math.max(J.start,W.start),ct=Math.min(v.count,Math.min(J.start+J.count,W.start+W.count));it<ct;it+=3)c=rp(this,at,e,l,w,S,P,v.getX(it),v.getX(it+1),v.getX(it+2)),c&&(c.faceIndex=Math.floor(it/3),c.face.materialIndex=J.materialIndex,s.push(c))}else for(let Y=Math.max(0,W.start),tt=Math.min(v.count,W.start+W.count);Y<tt;Y+=3)c=rp(this,g,e,l,w,S,P,v.getX(Y),v.getX(Y+1),v.getX(Y+2)),c&&(c.faceIndex=Math.floor(Y/3),s.push(c));else if(void 0!==x)if(Array.isArray(g))for(let Y=0,tt=z.length;Y<tt;Y++){const J=z[Y],at=g[J.materialIndex];for(let it=Math.max(J.start,W.start),ct=Math.min(x.count,Math.min(J.start+J.count,W.start+W.count));it<ct;it+=3)c=rp(this,at,e,l,w,S,P,it,it+1,it+2),c&&(c.faceIndex=Math.floor(it/3),c.face.materialIndex=J.materialIndex,s.push(c))}else for(let Y=Math.max(0,W.start),tt=Math.min(x.count,W.start+W.count);Y<tt;Y+=3)c=rp(this,g,e,l,w,S,P,Y,Y+1,Y+2),c&&(c.faceIndex=Math.floor(Y/3),s.push(c))}}function rp(A,e,s,l,c,d,g,v,x,w){A.getVertexPosition(v,Zd),A.getVertexPosition(x,Hu),A.getVertexPosition(w,Lh);const S=function(P,z,W,Y,tt,J,at,it){let ct;if(ct=z.side===X?Y.intersectTriangle(at,J,tt,!0,it):Y.intersectTriangle(tt,J,at,z.side===Q,it),null===ct)return null;np.copy(it),np.applyMatrix4(P.matrixWorld);const At=W.ray.origin.distanceTo(np);return At<W.near||At>W.far?null:{distance:At,point:np.clone(),object:P}}(A,e,s,l,Zd,Hu,Lh,jm);if(S){c&&(yf.fromBufferAttribute(c,v),ep.fromBufferAttribute(c,x),Wu.fromBufferAttribute(c,w),S.uv=Re.getInterpolation(jm,Zd,Hu,Lh,yf,ep,Wu,new Ye)),d&&(yf.fromBufferAttribute(d,v),ep.fromBufferAttribute(d,x),Wu.fromBufferAttribute(d,w),S.uv1=Re.getInterpolation(jm,Zd,Hu,Lh,yf,ep,Wu,new Ye)),g&&(m1.fromBufferAttribute(g,v),as.fromBufferAttribute(g,x),g1.fromBufferAttribute(g,w),S.normal=Re.getInterpolation(jm,Zd,Hu,Lh,m1,as,g1,new Dt),S.normal.dot(l.direction)>0&&S.normal.multiplyScalar(-1));const P={a:v,b:x,c:w,normal:new Dt,materialIndex:0};Re.getNormal(Zd,Hu,Lh,P.normal),S.face=P}return S}class Ko extends gr{constructor(e=1,s=1,l=1,c=1,d=1,g=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:s,depth:l,widthSegments:c,heightSegments:d,depthSegments:g};const v=this;c=Math.floor(c),d=Math.floor(d),g=Math.floor(g);const x=[],w=[],S=[],P=[];let z=0,W=0;function Y(tt,J,at,it,ct,At,Ft,Tt,Pt,zt,ee){const ce=At/Pt,ne=Ft/zt,ge=At/2,ie=Ft/2,pe=Tt/2,Oe=Pt+1,Pe=zt+1;let ze=0,Fe=0;const Dn=new Dt;for(let Nn=0;Nn<Pe;Nn++){const fn=Nn*ne-ie;for(let xn=0;xn<Oe;xn++)Dn[tt]=(xn*ce-ge)*it,Dn[J]=fn*ct,Dn[at]=pe,w.push(Dn.x,Dn.y,Dn.z),Dn[tt]=0,Dn[J]=0,Dn[at]=Tt>0?1:-1,S.push(Dn.x,Dn.y,Dn.z),P.push(xn/Pt),P.push(1-Nn/zt),ze+=1}for(let Nn=0;Nn<zt;Nn++)for(let fn=0;fn<Pt;fn++){const In=z+fn+Oe*(Nn+1),Mn=z+(fn+1)+Oe*(Nn+1),Ce=z+(fn+1)+Oe*Nn;x.push(z+fn+Oe*Nn,In,Ce),x.push(In,Mn,Ce),Fe+=6}v.addGroup(W,Fe,ee),W+=Fe,z+=ze}Y("z","y","x",-1,-1,l,s,e,g,d,0),Y("z","y","x",1,-1,l,s,-e,g,d,1),Y("x","z","y",1,1,e,l,s,c,g,2),Y("x","z","y",1,-1,e,l,-s,c,g,3),Y("x","y","z",1,-1,e,s,l,c,d,4),Y("x","y","z",-1,-1,e,s,-l,c,d,5),this.setIndex(x),this.setAttribute("position",new Tn(w,3)),this.setAttribute("normal",new Tn(S,3)),this.setAttribute("uv",new Tn(P,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Ko(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Jo(A){const e={};for(const s in A){e[s]={};for(const l in A[s]){const c=A[s][l];c&&(c.isColor||c.isMatrix3||c.isMatrix4||c.isVector2||c.isVector3||c.isVector4||c.isTexture||c.isQuaternion)?c.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[s][l]=null):e[s][l]=c.clone():e[s][l]=Array.isArray(c)?c.slice():c}}return e}function ro(A){const e={};for(let s=0;s<A.length;s++){const l=Jo(A[s]);for(const c in l)e[c]=l[c]}return e}function qm(A){const e=A.getRenderTarget();return null===e?A.outputColorSpace:!0===e.isXRRenderTarget?e.texture.colorSpace:Jr.workingColorSpace}const ju={clone:Jo,merge:ro};class xl extends di{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Jo(e.uniforms),this.uniformsGroups=function(s){const l=[];for(let c=0;c<s.length;c++)l.push(s[c].clone());return l}(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const s=super.toJSON(e);s.glslVersion=this.glslVersion,s.uniforms={};for(const c in this.uniforms){const d=this.uniforms[c].value;s.uniforms[c]=d&&d.isTexture?{type:"t",value:d.toJSON(e).uuid}:d&&d.isColor?{type:"c",value:d.getHex()}:d&&d.isVector2?{type:"v2",value:d.toArray()}:d&&d.isVector3?{type:"v3",value:d.toArray()}:d&&d.isVector4?{type:"v4",value:d.toArray()}:d&&d.isMatrix3?{type:"m3",value:d.toArray()}:d&&d.isMatrix4?{type:"m4",value:d.toArray()}:{value:d}}Object.keys(this.defines).length>0&&(s.defines=this.defines),s.vertexShader=this.vertexShader,s.fragmentShader=this.fragmentShader,s.lights=this.lights,s.clipping=this.clipping;const l={};for(const c in this.extensions)!0===this.extensions[c]&&(l[c]=!0);return Object.keys(l).length>0&&(s.extensions=l),s}}class Xm extends hi{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Yn,this.projectionMatrix=new Yn,this.projectionMatrixInverse=new Yn,this.coordinateSystem=ko}copy(e,s){return super.copy(e,s),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,s){super.updateWorldMatrix(e,s),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}const io=new Dt,Fh=new Ye,a0=new Ye;class ea extends Xm{constructor(e=50,s=1,l=.1,c=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=l,this.far=c,this.focus=10,this.aspect=s,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,s){return super.copy(e,s),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const s=.5*this.getFilmHeight()/e;this.fov=2*oc*Math.atan(s),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*zl*this.fov);return.5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*oc*Math.atan(Math.tan(.5*zl*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,s,l){io.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(io.x,io.y).multiplyScalar(-e/io.z),io.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),l.set(io.x,io.y).multiplyScalar(-e/io.z)}getViewSize(e,s){return this.getViewBounds(e,Fh,a0),s.subVectors(a0,Fh)}setViewOffset(e,s,l,c,d,g){this.aspect=e/s,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=s,this.view.offsetX=l,this.view.offsetY=c,this.view.width=d,this.view.height=g,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let s=e*Math.tan(.5*zl*this.fov)/this.zoom,l=2*s,c=this.aspect*l,d=-.5*c;const g=this.view;if(null!==this.view&&this.view.enabled){const x=g.fullWidth,w=g.fullHeight;d+=g.offsetX*c/x,s-=g.offsetY*l/w,c*=g.width/x,l*=g.height/w}const v=this.filmOffset;0!==v&&(d+=e*v/this.getFilmWidth()),this.projectionMatrix.makePerspective(d,d+c,s,s-l,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const s=super.toJSON(e);return s.object.fov=this.fov,s.object.zoom=this.zoom,s.object.near=this.near,s.object.far=this.far,s.object.focus=this.focus,s.object.aspect=this.aspect,null!==this.view&&(s.object.view=Object.assign({},this.view)),s.object.filmGauge=this.filmGauge,s.object.filmOffset=this.filmOffset,s}}class A1 extends hi{constructor(e,s,l){super(),this.type="CubeCamera",this.renderTarget=l,this.coordinateSystem=null,this.activeMipmapLevel=0;const c=new ea(-90,1,e,s);c.layers=this.layers,this.add(c);const d=new ea(-90,1,e,s);d.layers=this.layers,this.add(d);const g=new ea(-90,1,e,s);g.layers=this.layers,this.add(g);const v=new ea(-90,1,e,s);v.layers=this.layers,this.add(v);const x=new ea(-90,1,e,s);x.layers=this.layers,this.add(x);const w=new ea(-90,1,e,s);w.layers=this.layers,this.add(w)}updateCoordinateSystem(){const e=this.coordinateSystem,s=this.children.concat(),[l,c,d,g,v,x]=s;for(const w of s)this.remove(w);if(e===ko)l.up.set(0,1,0),l.lookAt(1,0,0),c.up.set(0,1,0),c.lookAt(-1,0,0),d.up.set(0,0,-1),d.lookAt(0,1,0),g.up.set(0,0,1),g.lookAt(0,-1,0),v.up.set(0,1,0),v.lookAt(0,0,1),x.up.set(0,1,0),x.lookAt(0,0,-1);else{if(e!==Vc)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);l.up.set(0,-1,0),l.lookAt(-1,0,0),c.up.set(0,-1,0),c.lookAt(1,0,0),d.up.set(0,0,1),d.lookAt(0,1,0),g.up.set(0,0,-1),g.lookAt(0,-1,0),v.up.set(0,-1,0),v.lookAt(0,0,1),x.up.set(0,-1,0),x.lookAt(0,0,-1)}for(const w of s)this.add(w),w.updateMatrixWorld()}update(e,s){null===this.parent&&this.updateMatrixWorld();const{renderTarget:l,activeMipmapLevel:c}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[d,g,v,x,w,S]=this.children,P=e.getRenderTarget(),z=e.getActiveCubeFace(),W=e.getActiveMipmapLevel(),Y=e.xr.enabled;e.xr.enabled=!1;const tt=l.texture.generateMipmaps;l.texture.generateMipmaps=!1,e.setRenderTarget(l,0,c),e.render(s,d),e.setRenderTarget(l,1,c),e.render(s,g),e.setRenderTarget(l,2,c),e.render(s,v),e.setRenderTarget(l,3,c),e.render(s,x),e.setRenderTarget(l,4,c),e.render(s,w),l.texture.generateMipmaps=tt,e.setRenderTarget(l,5,c),e.render(s,S),e.setRenderTarget(P,z,W),e.xr.enabled=Y,l.texture.needsPMREMUpdate=!0}}class vf extends Vi{constructor(e,s,l,c,d,g,v,x,w,S){super(e=void 0!==e?e:[],s=void 0!==s?s:Wr,l,c,d,g,v,x,w,S),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class o0 extends bo{constructor(e=1,s={}){super(e,e,s),this.isWebGLCubeRenderTarget=!0;const l={width:e,height:e,depth:1};this.texture=new vf([l,l,l,l,l,l],s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==s.generateMipmaps&&s.generateMipmaps,this.texture.minFilter=void 0!==s.minFilter?s.minFilter:cn}fromEquirectangularTexture(e,s){this.texture.type=s.type,this.texture.colorSpace=s.colorSpace,this.texture.generateMipmaps=s.generateMipmaps,this.texture.minFilter=s.minFilter,this.texture.magFilter=s.magFilter;const g=new Ko(5,5,5),v=new xl({name:"CubemapFromEquirect",uniforms:Jo({tEquirect:{value:null}}),vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",side:X,blending:rt});v.uniforms.tEquirect.value=s;const x=new os(g,v),w=s.minFilter;return s.minFilter===Sn&&(s.minFilter=cn),new A1(1,10,this).update(e,x),s.minFilter=w,x.geometry.dispose(),x.material.dispose(),this}clear(e,s,l,c){const d=e.getRenderTarget();for(let g=0;g<6;g++)e.setRenderTarget(this,g),e.clear(s,l,c);e.setRenderTarget(d)}}const Ym=new Dt,kb=new Dt,Oh=new yr;class tu{constructor(e=new Dt(1,0,0),s=0){this.isPlane=!0,this.normal=e,this.constant=s}set(e,s){return this.normal.copy(e),this.constant=s,this}setComponents(e,s,l,c){return this.normal.set(e,s,l),this.constant=c,this}setFromNormalAndCoplanarPoint(e,s){return this.normal.copy(e),this.constant=-s.dot(this.normal),this}setFromCoplanarPoints(e,s,l){const c=Ym.subVectors(l,s).cross(kb.subVectors(e,s)).normalize();return this.setFromNormalAndCoplanarPoint(c,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,s){return s.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,s){const l=e.delta(Ym),c=this.normal.dot(l);if(0===c)return 0===this.distanceToPoint(e.start)?s.copy(e.start):null;const d=-(e.start.dot(this.normal)+this.constant)/c;return d<0||d>1?null:s.copy(e.start).addScaledVector(l,d)}intersectsLine(e){const s=this.distanceToPoint(e.start),l=this.distanceToPoint(e.end);return s<0&&l>0||l<0&&s>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,s){const l=s||Oh.getNormalMatrix(e),c=this.coplanarPoint(Ym).applyMatrix4(e),d=this.normal.applyMatrix3(l).normalize();return this.constant=-c.dot(d),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const Ph=new Ls,eu=new Dt;class Ra{constructor(e=new tu,s=new tu,l=new tu,c=new tu,d=new tu,g=new tu){this.planes=[e,s,l,c,d,g]}set(e,s,l,c,d,g){const v=this.planes;return v[0].copy(e),v[1].copy(s),v[2].copy(l),v[3].copy(c),v[4].copy(d),v[5].copy(g),this}copy(e){const s=this.planes;for(let l=0;l<6;l++)s[l].copy(e.planes[l]);return this}setFromProjectionMatrix(e,s=ko){const l=this.planes,c=e.elements,d=c[0],g=c[1],v=c[2],x=c[3],w=c[4],S=c[5],P=c[6],z=c[7],W=c[8],Y=c[9],tt=c[10],J=c[11],at=c[12],it=c[13],ct=c[14],At=c[15];if(l[0].setComponents(x-d,z-w,J-W,At-at).normalize(),l[1].setComponents(x+d,z+w,J+W,At+at).normalize(),l[2].setComponents(x+g,z+S,J+Y,At+it).normalize(),l[3].setComponents(x-g,z-S,J-Y,At-it).normalize(),l[4].setComponents(x-v,z-P,J-tt,At-ct).normalize(),s===ko)l[5].setComponents(x+v,z+P,J+tt,At+ct).normalize();else{if(s!==Vc)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+s);l[5].setComponents(v,P,tt,ct).normalize()}return this}intersectsObject(e){if(void 0!==e.boundingSphere)null===e.boundingSphere&&e.computeBoundingSphere(),Ph.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const s=e.geometry;null===s.boundingSphere&&s.computeBoundingSphere(),Ph.copy(s.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Ph)}intersectsSprite(e){return Ph.center.set(0,0,0),Ph.radius=.7071067811865476,Ph.applyMatrix4(e.matrixWorld),this.intersectsSphere(Ph)}intersectsSphere(e){const s=this.planes,l=e.center,c=-e.radius;for(let d=0;d<6;d++)if(s[d].distanceToPoint(l)<c)return!1;return!0}intersectsBox(e){const s=this.planes;for(let l=0;l<6;l++){const c=s[l];if(eu.x=c.normal.x>0?e.max.x:e.min.x,eu.y=c.normal.y>0?e.max.y:e.min.y,eu.z=c.normal.z>0?e.max.z:e.min.z,c.distanceToPoint(eu)<0)return!1}return!0}containsPoint(e){const s=this.planes;for(let l=0;l<6;l++)if(s[l].distanceToPoint(e)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function sp(){let A=null,e=!1,s=null,l=null;function c(d,g){s(d,g),l=A.requestAnimationFrame(c)}return{start:function(){!0!==e&&null!==s&&(l=A.requestAnimationFrame(c),e=!0)},stop:function(){A.cancelAnimationFrame(l),e=!1},setAnimationLoop:function(d){s=d},setContext:function(d){A=d}}}function y1(A){const e=new WeakMap;return{get:function(s){return s.isInterleavedBufferAttribute&&(s=s.data),e.get(s)},remove:function(s){s.isInterleavedBufferAttribute&&(s=s.data);const l=e.get(s);l&&(A.deleteBuffer(l.buffer),e.delete(s))},update:function(s,l){if(s.isGLBufferAttribute){const d=e.get(s);return void((!d||d.version<s.version)&&e.set(s,{buffer:s.buffer,type:s.type,bytesPerElement:s.elementSize,version:s.version}))}s.isInterleavedBufferAttribute&&(s=s.data);const c=e.get(s);if(void 0===c)e.set(s,function(d,g){const v=d.array,x=d.usage,w=v.byteLength,S=A.createBuffer();let P;if(A.bindBuffer(g,S),A.bufferData(g,v,x),d.onUploadCallback(),v instanceof Float32Array)P=A.FLOAT;else if(v instanceof Uint16Array)P=d.isFloat16BufferAttribute?A.HALF_FLOAT:A.UNSIGNED_SHORT;else if(v instanceof Int16Array)P=A.SHORT;else if(v instanceof Uint32Array)P=A.UNSIGNED_INT;else if(v instanceof Int32Array)P=A.INT;else if(v instanceof Int8Array)P=A.BYTE;else if(v instanceof Uint8Array)P=A.UNSIGNED_BYTE;else{if(!(v instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+v);P=A.UNSIGNED_BYTE}return{buffer:S,type:P,bytesPerElement:v.BYTES_PER_ELEMENT,version:d.version,size:w}}(s,l));else if(c.version<s.version){if(c.size!==s.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");(function(d,g,v){const x=g.array,w=g._updateRange,S=g.updateRanges;if(A.bindBuffer(v,d),-1===w.count&&0===S.length&&A.bufferSubData(v,0,x),0!==S.length){for(let P=0,z=S.length;P<z;P++){const W=S[P];A.bufferSubData(v,W.start*x.BYTES_PER_ELEMENT,x,W.start,W.count)}g.clearUpdateRanges()}-1!==w.count&&(A.bufferSubData(v,w.offset*x.BYTES_PER_ELEMENT,x,w.offset,w.count),w.count=-1),g.onUploadCallback()})(c.buffer,s,l),c.version=s.version}}}}class ap extends gr{constructor(e=1,s=1,l=1,c=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:s,widthSegments:l,heightSegments:c};const d=e/2,g=s/2,v=Math.floor(l),x=Math.floor(c),w=v+1,S=x+1,P=e/v,z=s/x,W=[],Y=[],tt=[],J=[];for(let at=0;at<S;at++){const it=at*z-g;for(let ct=0;ct<w;ct++)Y.push(ct*P-d,-it,0),tt.push(0,0,1),J.push(ct/v),J.push(1-at/x)}for(let at=0;at<x;at++)for(let it=0;it<v;it++){const At=it+w*(at+1),Ft=it+1+w*(at+1),Tt=it+1+w*at;W.push(it+w*at,At,Tt),W.push(At,Ft,Tt)}this.setIndex(W),this.setAttribute("position",new Tn(Y,3)),this.setAttribute("normal",new Tn(tt,3)),this.setAttribute("uv",new Tn(J,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ap(e.width,e.height,e.widthSegments,e.heightSegments)}}const Ur={alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",alphahash_pars_fragment:"#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",batching_pars_vertex:"#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",batching_vertex:"#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",begin_vertex:"vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",colorspace_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment:"\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphinstance_vertex:"#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",normal_fragment_maps:"#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",opaque_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",uv_pars_fragment:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_pars_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",uv_vertex:"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",depth_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"},Bn={common:{diffuse:{value:new En(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new yr},alphaMap:{value:null},alphaMapTransform:{value:new yr},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new yr}},envmap:{envMap:{value:null},envMapRotation:{value:new yr},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new yr}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new yr}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new yr},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new yr},normalScale:{value:new Ye(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new yr},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new yr}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new yr}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new yr}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new En(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new En(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new yr},alphaTest:{value:0},uvTransform:{value:new yr}},sprite:{diffuse:{value:new En(16777215)},opacity:{value:1},center:{value:new Ye(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new yr},alphaMap:{value:null},alphaMapTransform:{value:new yr},alphaTest:{value:0}}},Yl={basic:{uniforms:ro([Bn.common,Bn.specularmap,Bn.envmap,Bn.aomap,Bn.lightmap,Bn.fog]),vertexShader:Ur.meshbasic_vert,fragmentShader:Ur.meshbasic_frag},lambert:{uniforms:ro([Bn.common,Bn.specularmap,Bn.envmap,Bn.aomap,Bn.lightmap,Bn.emissivemap,Bn.bumpmap,Bn.normalmap,Bn.displacementmap,Bn.fog,Bn.lights,{emissive:{value:new En(0)}}]),vertexShader:Ur.meshlambert_vert,fragmentShader:Ur.meshlambert_frag},phong:{uniforms:ro([Bn.common,Bn.specularmap,Bn.envmap,Bn.aomap,Bn.lightmap,Bn.emissivemap,Bn.bumpmap,Bn.normalmap,Bn.displacementmap,Bn.fog,Bn.lights,{emissive:{value:new En(0)},specular:{value:new En(1118481)},shininess:{value:30}}]),vertexShader:Ur.meshphong_vert,fragmentShader:Ur.meshphong_frag},standard:{uniforms:ro([Bn.common,Bn.envmap,Bn.aomap,Bn.lightmap,Bn.emissivemap,Bn.bumpmap,Bn.normalmap,Bn.displacementmap,Bn.roughnessmap,Bn.metalnessmap,Bn.fog,Bn.lights,{emissive:{value:new En(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ur.meshphysical_vert,fragmentShader:Ur.meshphysical_frag},toon:{uniforms:ro([Bn.common,Bn.aomap,Bn.lightmap,Bn.emissivemap,Bn.bumpmap,Bn.normalmap,Bn.displacementmap,Bn.gradientmap,Bn.fog,Bn.lights,{emissive:{value:new En(0)}}]),vertexShader:Ur.meshtoon_vert,fragmentShader:Ur.meshtoon_frag},matcap:{uniforms:ro([Bn.common,Bn.bumpmap,Bn.normalmap,Bn.displacementmap,Bn.fog,{matcap:{value:null}}]),vertexShader:Ur.meshmatcap_vert,fragmentShader:Ur.meshmatcap_frag},points:{uniforms:ro([Bn.points,Bn.fog]),vertexShader:Ur.points_vert,fragmentShader:Ur.points_frag},dashed:{uniforms:ro([Bn.common,Bn.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ur.linedashed_vert,fragmentShader:Ur.linedashed_frag},depth:{uniforms:ro([Bn.common,Bn.displacementmap]),vertexShader:Ur.depth_vert,fragmentShader:Ur.depth_frag},normal:{uniforms:ro([Bn.common,Bn.bumpmap,Bn.normalmap,Bn.displacementmap,{opacity:{value:1}}]),vertexShader:Ur.meshnormal_vert,fragmentShader:Ur.meshnormal_frag},sprite:{uniforms:ro([Bn.sprite,Bn.fog]),vertexShader:Ur.sprite_vert,fragmentShader:Ur.sprite_frag},background:{uniforms:{uvTransform:{value:new yr},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Ur.background_vert,fragmentShader:Ur.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new yr}},vertexShader:Ur.backgroundCube_vert,fragmentShader:Ur.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Ur.cube_vert,fragmentShader:Ur.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ur.equirect_vert,fragmentShader:Ur.equirect_frag},distanceRGBA:{uniforms:ro([Bn.common,Bn.displacementmap,{referencePosition:{value:new Dt},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ur.distanceRGBA_vert,fragmentShader:Ur.distanceRGBA_frag},shadow:{uniforms:ro([Bn.lights,Bn.fog,{color:{value:new En(0)},opacity:{value:1}}]),vertexShader:Ur.shadow_vert,fragmentShader:Ur.shadow_frag}};Yl.physical={uniforms:ro([Yl.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new yr},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new yr},clearcoatNormalScale:{value:new Ye(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new yr},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new yr},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new yr},sheen:{value:0},sheenColor:{value:new En(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new yr},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new yr},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new yr},transmissionSamplerSize:{value:new Ye},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new yr},attenuationDistance:{value:0},attenuationColor:{value:new En(0)},specularColor:{value:new En(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new yr},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new yr},anisotropyVector:{value:new Ye},anisotropyMap:{value:null},anisotropyMapTransform:{value:new yr}}]),vertexShader:Ur.meshphysical_vert,fragmentShader:Ur.meshphysical_frag};const Km={r:0,b:0,g:0},nu=new Gi,$r=new Yn;function yn(A,e,s,l,c,d,g){const v=new En(0);let x,w,S=!0===d?0:1,P=null,z=0,W=null;function Y(J){let at=!0===J.isScene?J.background:null;return at&&at.isTexture&&(at=(J.backgroundBlurriness>0?s:e).get(at)),at}function tt(J,at){J.getRGB(Km,qm(A)),l.buffers.color.setClear(Km.r,Km.g,Km.b,at,g)}return{getClearColor:function(){return v},setClearColor:function(J,at=1){v.set(J),S=at,tt(v,S)},getClearAlpha:function(){return S},setClearAlpha:function(J){S=J,tt(v,S)},render:function(J){let at=!1;const it=Y(J);null===it?tt(v,S):it&&it.isColor&&(tt(it,1),at=!0);const ct=A.xr.getEnvironmentBlendMode();"additive"===ct?l.buffers.color.setClear(0,0,0,1,g):"alpha-blend"===ct&&l.buffers.color.setClear(0,0,0,0,g),(A.autoClear||at)&&A.clear(A.autoClearColor,A.autoClearDepth,A.autoClearStencil)},addToRenderList:function(J,at){const it=Y(at);it&&(it.isCubeTexture||it.mapping===lr)?(void 0===w&&(w=new os(new Ko(1e4,1e4,1e4),new xl({name:"BackgroundCubeMaterial",uniforms:Jo(Yl.backgroundCube.uniforms),vertexShader:Yl.backgroundCube.vertexShader,fragmentShader:Yl.backgroundCube.fragmentShader,side:X,depthTest:!1,depthWrite:!1,fog:!1})),w.geometry.deleteAttribute("normal"),w.geometry.deleteAttribute("uv"),w.onBeforeRender=function(ct,At,Ft){this.matrixWorld.copyPosition(Ft.matrixWorld)},Object.defineProperty(w.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),c.update(w)),nu.copy(at.backgroundRotation),nu.x*=-1,nu.y*=-1,nu.z*=-1,it.isCubeTexture&&!1===it.isRenderTargetTexture&&(nu.y*=-1,nu.z*=-1),w.material.uniforms.envMap.value=it,w.material.uniforms.flipEnvMap.value=it.isCubeTexture&&!1===it.isRenderTargetTexture?-1:1,w.material.uniforms.backgroundBlurriness.value=at.backgroundBlurriness,w.material.uniforms.backgroundIntensity.value=at.backgroundIntensity,w.material.uniforms.backgroundRotation.value.setFromMatrix4($r.makeRotationFromEuler(nu)),w.material.toneMapped=Jr.getTransfer(it.colorSpace)!==Ii,P===it&&z===it.version&&W===A.toneMapping||(w.material.needsUpdate=!0,P=it,z=it.version,W=A.toneMapping),w.layers.enableAll(),J.unshift(w,w.geometry,w.material,0,0,null)):it&&it.isTexture&&(void 0===x&&(x=new os(new ap(2,2),new xl({name:"BackgroundMaterial",uniforms:Jo(Yl.background.uniforms),vertexShader:Yl.background.vertexShader,fragmentShader:Yl.background.fragmentShader,side:Q,depthTest:!1,depthWrite:!1,fog:!1})),x.geometry.deleteAttribute("normal"),Object.defineProperty(x.material,"map",{get:function(){return this.uniforms.t2D.value}}),c.update(x)),x.material.uniforms.t2D.value=it,x.material.uniforms.backgroundIntensity.value=at.backgroundIntensity,x.material.toneMapped=Jr.getTransfer(it.colorSpace)!==Ii,!0===it.matrixAutoUpdate&&it.updateMatrix(),x.material.uniforms.uvTransform.value.copy(it.matrix),P===it&&z===it.version&&W===A.toneMapping||(x.material.needsUpdate=!0,P=it,z=it.version,W=A.toneMapping),x.layers.enableAll(),J.unshift(x,x.geometry,x.material,0,0,null))}}}function ru(A,e){const s=A.getParameter(A.MAX_VERTEX_ATTRIBS),l={},c=w(null);let d=c,g=!1;function v(at){return A.bindVertexArray(at)}function x(at){return A.deleteVertexArray(at)}function w(at){const it=[],ct=[],At=[];for(let Ft=0;Ft<s;Ft++)it[Ft]=0,ct[Ft]=0,At[Ft]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:it,enabledAttributes:ct,attributeDivisors:At,object:at,attributes:{},index:null}}function S(){const at=d.newAttributes;for(let it=0,ct=at.length;it<ct;it++)at[it]=0}function P(at){z(at,0)}function z(at,it){const At=d.enabledAttributes,Ft=d.attributeDivisors;d.newAttributes[at]=1,0===At[at]&&(A.enableVertexAttribArray(at),At[at]=1),Ft[at]!==it&&(A.vertexAttribDivisor(at,it),Ft[at]=it)}function W(){const at=d.newAttributes,it=d.enabledAttributes;for(let ct=0,At=it.length;ct<At;ct++)it[ct]!==at[ct]&&(A.disableVertexAttribArray(ct),it[ct]=0)}function Y(at,it,ct,At,Ft,Tt,Pt){!0===Pt?A.vertexAttribIPointer(at,it,ct,Ft,Tt):A.vertexAttribPointer(at,it,ct,At,Ft,Tt)}function tt(){J(),g=!0,d!==c&&(d=c,v(d.object))}function J(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function(at,it,ct,At,Ft){let Tt=!1;const Pt=function(zt,ee,ce){const ne=!0===ce.wireframe;let ge=l[zt.id];void 0===ge&&(ge={},l[zt.id]=ge);let ie=ge[ee.id];void 0===ie&&(ie={},ge[ee.id]=ie);let pe=ie[ne];return void 0===pe&&(pe=w(A.createVertexArray()),ie[ne]=pe),pe}(At,ct,it);d!==Pt&&(d=Pt,v(d.object)),Tt=function(zt,ee,ce,ne){const ge=d.attributes,ie=ee.attributes;let pe=0;const Oe=ce.getAttributes();for(const Pe in Oe)if(Oe[Pe].location>=0){const ze=ge[Pe];let Fe=ie[Pe];if(void 0===Fe&&("instanceMatrix"===Pe&&zt.instanceMatrix&&(Fe=zt.instanceMatrix),"instanceColor"===Pe&&zt.instanceColor&&(Fe=zt.instanceColor)),void 0===ze||ze.attribute!==Fe||Fe&&ze.data!==Fe.data)return!0;pe++}return d.attributesNum!==pe||d.index!==ne}(at,At,ct,Ft),Tt&&function(zt,ee,ce,ne){const ge={},ie=ee.attributes;let pe=0;const Oe=ce.getAttributes();for(const Pe in Oe)if(Oe[Pe].location>=0){let ze=ie[Pe];void 0===ze&&("instanceMatrix"===Pe&&zt.instanceMatrix&&(ze=zt.instanceMatrix),"instanceColor"===Pe&&zt.instanceColor&&(ze=zt.instanceColor));const Fe={};Fe.attribute=ze,ze&&ze.data&&(Fe.data=ze.data),ge[Pe]=Fe,pe++}d.attributes=ge,d.attributesNum=pe,d.index=ne}(at,At,ct,Ft),null!==Ft&&e.update(Ft,A.ELEMENT_ARRAY_BUFFER),(Tt||g)&&(g=!1,function(zt,ee,ce,ne){S();const ge=ne.attributes,ie=ce.getAttributes(),pe=ee.defaultAttributeValues;for(const Oe in ie){const Pe=ie[Oe];if(Pe.location>=0){let ze=ge[Oe];if(void 0===ze&&("instanceMatrix"===Oe&&zt.instanceMatrix&&(ze=zt.instanceMatrix),"instanceColor"===Oe&&zt.instanceColor&&(ze=zt.instanceColor)),void 0!==ze){const Fe=ze.normalized,Dn=ze.itemSize,Nn=e.get(ze);if(void 0===Nn)continue;const fn=Nn.buffer,xn=Nn.type,In=Nn.bytesPerElement,Mn=xn===A.INT||xn===A.UNSIGNED_INT||ze.gpuType===Tr;if(ze.isInterleavedBufferAttribute){const Ce=ze.data,rn=Ce.stride,On=ze.offset;if(Ce.isInstancedInterleavedBuffer){for(let ln=0;ln<Pe.locationSize;ln++)z(Pe.location+ln,Ce.meshPerAttribute);!0!==zt.isInstancedMesh&&void 0===ne._maxInstanceCount&&(ne._maxInstanceCount=Ce.meshPerAttribute*Ce.count)}else for(let ln=0;ln<Pe.locationSize;ln++)P(Pe.location+ln);A.bindBuffer(A.ARRAY_BUFFER,fn);for(let ln=0;ln<Pe.locationSize;ln++)Y(Pe.location+ln,Dn/Pe.locationSize,xn,Fe,rn*In,(On+Dn/Pe.locationSize*ln)*In,Mn)}else{if(ze.isInstancedBufferAttribute){for(let Ce=0;Ce<Pe.locationSize;Ce++)z(Pe.location+Ce,ze.meshPerAttribute);!0!==zt.isInstancedMesh&&void 0===ne._maxInstanceCount&&(ne._maxInstanceCount=ze.meshPerAttribute*ze.count)}else for(let Ce=0;Ce<Pe.locationSize;Ce++)P(Pe.location+Ce);A.bindBuffer(A.ARRAY_BUFFER,fn);for(let Ce=0;Ce<Pe.locationSize;Ce++)Y(Pe.location+Ce,Dn/Pe.locationSize,xn,Fe,Dn*In,Dn/Pe.locationSize*Ce*In,Mn)}}else if(void 0!==pe){const Fe=pe[Oe];if(void 0!==Fe)switch(Fe.length){case 2:A.vertexAttrib2fv(Pe.location,Fe);break;case 3:A.vertexAttrib3fv(Pe.location,Fe);break;case 4:A.vertexAttrib4fv(Pe.location,Fe);break;default:A.vertexAttrib1fv(Pe.location,Fe)}}}}W()}(at,it,ct,At),null!==Ft&&A.bindBuffer(A.ELEMENT_ARRAY_BUFFER,e.get(Ft).buffer))},reset:tt,resetDefaultState:J,dispose:function(){tt();for(const at in l){const it=l[at];for(const ct in it){const At=it[ct];for(const Ft in At)x(At[Ft].object),delete At[Ft];delete it[ct]}delete l[at]}},releaseStatesOfGeometry:function(at){if(void 0===l[at.id])return;const it=l[at.id];for(const ct in it){const At=it[ct];for(const Ft in At)x(At[Ft].object),delete At[Ft];delete it[ct]}delete l[at.id]},releaseStatesOfProgram:function(at){for(const it in l){const ct=l[it];if(void 0===ct[at.id])continue;const At=ct[at.id];for(const Ft in At)x(At[Ft].object),delete At[Ft];delete ct[at.id]}},initAttributes:S,enableAttribute:P,disableUnusedAttributes:W}}function v1(A,e,s){let l;function c(d,g,v){0!==v&&(A.drawArraysInstanced(l,d,g,v),s.update(g,l,v))}this.setMode=function(d){l=d},this.render=function(d,g){A.drawArrays(l,d,g),s.update(g,l,1)},this.renderInstances=c,this.renderMultiDraw=function(d,g,v){if(0===v)return;const x=e.get("WEBGL_multi_draw");if(null===x)for(let w=0;w<v;w++)this.render(d[w],g[w]);else{x.multiDrawArraysWEBGL(l,d,0,g,0,v);let w=0;for(let S=0;S<v;S++)w+=g[S];s.update(w,l,1)}},this.renderMultiDrawInstances=function(d,g,v,x){if(0===v)return;const w=e.get("WEBGL_multi_draw");if(null===w)for(let S=0;S<d.length;S++)c(d[S],g[S],x[S]);else{w.multiDrawArraysInstancedWEBGL(l,d,0,g,0,x,0,v);let S=0;for(let P=0;P<v;P++)S+=g[P];for(let P=0;P<x.length;P++)s.update(S,l,x[P])}}}function b1(A,e,s,l){let c;function d(P){if("highp"===P){if(A.getShaderPrecisionFormat(A.VERTEX_SHADER,A.HIGH_FLOAT).precision>0&&A.getShaderPrecisionFormat(A.FRAGMENT_SHADER,A.HIGH_FLOAT).precision>0)return"highp";P="mediump"}return"mediump"===P&&A.getShaderPrecisionFormat(A.VERTEX_SHADER,A.MEDIUM_FLOAT).precision>0&&A.getShaderPrecisionFormat(A.FRAGMENT_SHADER,A.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let g=void 0!==s.precision?s.precision:"highp";const v=d(g);v!==g&&(console.warn("THREE.WebGLRenderer:",g,"not supported, using",v,"instead."),g=v);const x=!0===s.logarithmicDepthBuffer,w=A.getParameter(A.MAX_TEXTURE_IMAGE_UNITS),S=A.getParameter(A.MAX_VERTEX_TEXTURE_IMAGE_UNITS);return{isWebGL2:!0,getMaxAnisotropy:function(){if(void 0!==c)return c;if(!0===e.has("EXT_texture_filter_anisotropic")){const P=e.get("EXT_texture_filter_anisotropic");c=A.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else c=0;return c},getMaxPrecision:d,textureFormatReadable:function(P){return P===de||l.convert(P)===A.getParameter(A.IMPLEMENTATION_COLOR_READ_FORMAT)},textureTypeReadable:function(P){const z=P===br&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(P!==jn&&l.convert(P)!==A.getParameter(A.IMPLEMENTATION_COLOR_READ_TYPE)&&P!==wn&&!z)},precision:g,logarithmicDepthBuffer:x,maxTextures:w,maxVertexTextures:S,maxTextureSize:A.getParameter(A.MAX_TEXTURE_SIZE),maxCubemapSize:A.getParameter(A.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes:A.getParameter(A.MAX_VERTEX_ATTRIBS),maxVertexUniforms:A.getParameter(A.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings:A.getParameter(A.MAX_VARYING_VECTORS),maxFragmentUniforms:A.getParameter(A.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures:S>0,maxSamples:A.getParameter(A.MAX_SAMPLES)}}function Uh(A){const e=this;let s=null,l=0,c=!1,d=!1;const g=new tu,v=new yr,x={value:null,needsUpdate:!1};function w(S,P,z,W){const Y=null!==S?S.length:0;let tt=null;if(0!==Y){if(tt=x.value,!0!==W||null===tt){const J=z+4*Y,at=P.matrixWorldInverse;v.getNormalMatrix(at),(null===tt||tt.length<J)&&(tt=new Float32Array(J));for(let it=0,ct=z;it!==Y;++it,ct+=4)g.copy(S[it]).applyMatrix4(at,v),g.normal.toArray(tt,ct),tt[ct+3]=g.constant}x.value=tt,x.needsUpdate=!0}return e.numPlanes=Y,e.numIntersection=0,tt}this.uniform=x,this.numPlanes=0,this.numIntersection=0,this.init=function(S,P){const z=0!==S.length||P||0!==l||c;return c=P,l=S.length,z},this.beginShadows=function(){d=!0,w(null)},this.endShadows=function(){d=!1},this.setGlobalState=function(S,P){s=w(S,P,0)},this.setState=function(S,P,z){const W=S.clippingPlanes,Y=S.clipIntersection,tt=S.clipShadows,J=A.get(S);if(!c||null===W||0===W.length||d&&!tt)d?w(null):(x.value!==s&&(x.value=s,x.needsUpdate=l>0),e.numPlanes=l,e.numIntersection=0);else{const at=d?0:l,it=4*at;let ct=J.clippingState||null;x.value=ct,ct=w(W,P,it,z);for(let At=0;At!==it;++At)ct[At]=s[At];J.clippingState=ct,this.numIntersection=Y?this.numPlanes:0,this.numPlanes+=at}}}function Rb(A){let e=new WeakMap;function s(c,d){return d===mo?c.mapping=Wr:d===si&&(c.mapping=ii),c}function l(c){const d=c.target;d.removeEventListener("dispose",l);const g=e.get(d);void 0!==g&&(e.delete(d),g.dispose())}return{get:function(c){if(c&&c.isTexture){const d=c.mapping;if(d===mo||d===si){if(e.has(c))return s(e.get(c).texture,c.mapping);{const g=c.image;if(g&&g.height>0){const v=new o0(g.height);return v.fromEquirectangularTexture(A,c),e.set(c,v),c.addEventListener("dispose",l),s(v.texture,c.mapping)}return null}}}return c},dispose:function(){e=new WeakMap}}}class bf extends Xm{constructor(e=-1,s=1,l=1,c=-1,d=.1,g=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=s,this.top=l,this.bottom=c,this.near=d,this.far=g,this.updateProjectionMatrix()}copy(e,s){return super.copy(e,s),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,s,l,c,d,g){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=s,this.view.offsetX=l,this.view.offsetY=c,this.view.width=d,this.view.height=g,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),s=(this.top-this.bottom)/(2*this.zoom),l=(this.right+this.left)/2,c=(this.top+this.bottom)/2;let d=l-e,g=l+e,v=c+s,x=c-s;if(null!==this.view&&this.view.enabled){const w=(this.right-this.left)/this.view.fullWidth/this.zoom,S=(this.top-this.bottom)/this.view.fullHeight/this.zoom;d+=w*this.view.offsetX,g=d+w*this.view.width,v-=S*this.view.offsetY,x=v-S*this.view.height}this.projectionMatrix.makeOrthographic(d,g,v,x,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const s=super.toJSON(e);return s.object.zoom=this.zoom,s.object.left=this.left,s.object.right=this.right,s.object.top=this.top,s.object.bottom=this.bottom,s.object.near=this.near,s.object.far=this.far,null!==this.view&&(s.object.view=Object.assign({},this.view)),s}}const l0=[.125,.215,.35,.446,.526,.582],Jm=new bf,c0=new En;let Zm=null,xf=0,wf=0,tg=!1;const iu=(1+Math.sqrt(5))/2,su=1/iu,eg=[new Dt(-iu,su,0),new Dt(iu,su,0),new Dt(-su,0,iu),new Dt(su,0,iu),new Dt(0,iu,-su),new Dt(0,iu,su),new Dt(-1,1,-1),new Dt(1,1,-1),new Dt(-1,1,1),new Dt(1,1,1)];class u0{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,s=0,l=.1,c=100){Zm=this._renderer.getRenderTarget(),xf=this._renderer.getActiveCubeFace(),wf=this._renderer.getActiveMipmapLevel(),tg=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const d=this._allocateTargets();return d.depthBuffer=!0,this._sceneToCubeUV(e,l,c,d),s>0&&this._blur(d,0,0,s),this._applyPMREM(d),this._cleanup(d),d}fromEquirectangular(e,s=null){return this._fromTexture(e,s)}fromCubemap(e,s=null){return this._fromTexture(e,s)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=zh(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=Or(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Zm,xf,wf),this._renderer.xr.enabled=tg,e.scissorTest=!1,ng(e,0,0,e.width,e.height)}_fromTexture(e,s){this._setSize(e.mapping===Wr||e.mapping===ii?0===e.image.length?16:e.image[0].width||e.image[0].image.width:e.image.width/4),Zm=this._renderer.getRenderTarget(),xf=this._renderer.getActiveCubeFace(),wf=this._renderer.getActiveMipmapLevel(),tg=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const l=s||this._allocateTargets();return this._textureToCubeUV(e,l),this._applyPMREM(l),this._cleanup(l),l}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),s=4*this._cubeSize,l={magFilter:cn,minFilter:cn,generateMipmaps:!1,type:br,format:de,colorSpace:ps,depthBuffer:!1},c=x1(e,s,l);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==s){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=x1(e,s,l);const{_lodMax:d}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(g){const v=[],x=[],w=[];let S=g;const P=g-4+1+l0.length;for(let z=0;z<P;z++){const W=Math.pow(2,S);x.push(W);let Y=1/W;z>g-4?Y=l0[z-g+4-1]:0===z&&(Y=0),w.push(Y);const tt=1/(W-2),J=-tt,at=1+tt,it=[J,J,at,J,at,at,J,J,at,at,J,at],ct=6,At=6,Ft=3,Tt=2,Pt=1,zt=new Float32Array(Ft*At*ct),ee=new Float32Array(Tt*At*ct),ce=new Float32Array(Pt*At*ct);for(let ge=0;ge<ct;ge++){const ie=ge%3*2/3-1,pe=ge>2?0:-1;zt.set([ie,pe,0,ie+2/3,pe,0,ie+2/3,pe+1,0,ie,pe,0,ie+2/3,pe+1,0,ie,pe+1,0],Ft*At*ge),ee.set(it,Tt*At*ge),ce.set([ge,ge,ge,ge,ge,ge],Pt*At*ge)}const ne=new gr;ne.setAttribute("position",new wr(zt,Ft)),ne.setAttribute("uv",new wr(ee,Tt)),ne.setAttribute("faceIndex",new wr(ce,Pt)),v.push(ne),S>4&&S--}return{lodPlanes:v,sizeLods:x,sigmas:w}}(d)),this._blurMaterial=function(g,v,x){const w=new Float32Array(20),S=new Dt(0,1,0);return new xl({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/v,CUBEUV_TEXEL_HEIGHT:1/x,CUBEUV_MAX_MIP:`${g}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:w},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:S}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:rt,depthTest:!1,depthWrite:!1})}(d,e,s)}return c}_compileMaterial(e){const s=new os(this._lodPlanes[0],e);this._renderer.compile(s,Jm)}_sceneToCubeUV(e,s,l,c){const d=new ea(90,1,s,l),g=[1,-1,1,1,1,1],v=[1,1,1,-1,-1,-1],x=this._renderer,w=x.autoClear,S=x.toneMapping;x.getClearColor(c0),x.toneMapping=ut,x.autoClear=!1;const P=new no({name:"PMREM.Background",side:X,depthWrite:!1,depthTest:!1}),z=new os(new Ko,P);let W=!1;const Y=e.background;Y?Y.isColor&&(P.color.copy(Y),e.background=null,W=!0):(P.color.copy(c0),W=!0);for(let tt=0;tt<6;tt++){const J=tt%3;0===J?(d.up.set(0,g[tt],0),d.lookAt(v[tt],0,0)):1===J?(d.up.set(0,0,g[tt]),d.lookAt(0,v[tt],0)):(d.up.set(0,g[tt],0),d.lookAt(0,0,v[tt]));const at=this._cubeSize;ng(c,J*at,tt>2?at:0,at,at),x.setRenderTarget(c),W&&x.render(z,d),x.render(e,d)}z.geometry.dispose(),z.material.dispose(),x.toneMapping=S,x.autoClear=w,e.background=Y}_textureToCubeUV(e,s){const l=this._renderer,c=e.mapping===Wr||e.mapping===ii;c?(null===this._cubemapMaterial&&(this._cubemapMaterial=zh()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=Or());const d=c?this._cubemapMaterial:this._equirectMaterial,g=new os(this._lodPlanes[0],d);d.uniforms.envMap.value=e;const v=this._cubeSize;ng(s,0,0,3*v,2*v),l.setRenderTarget(s),l.render(g,Jm)}_applyPMREM(e){const s=this._renderer,l=s.autoClear;s.autoClear=!1;const c=this._lodPlanes.length;for(let d=1;d<c;d++){const g=Math.sqrt(this._sigmas[d]*this._sigmas[d]-this._sigmas[d-1]*this._sigmas[d-1]);this._blur(e,d-1,d,g,eg[(c-d-1)%eg.length])}s.autoClear=l}_blur(e,s,l,c,d){const g=this._pingPongRenderTarget;this._halfBlur(e,g,s,l,c,"latitudinal",d),this._halfBlur(g,e,l,l,c,"longitudinal",d)}_halfBlur(e,s,l,c,d,g,v){const x=this._renderer,w=this._blurMaterial;"latitudinal"!==g&&"longitudinal"!==g&&console.error("blur direction must be either latitudinal or longitudinal!");const S=new os(this._lodPlanes[c],w),P=w.uniforms,z=this._sizeLods[l]-1,W=isFinite(d)?Math.PI/(2*z):2*Math.PI/39,Y=d/W,tt=isFinite(d)?1+Math.floor(3*Y):20;tt>20&&console.warn(`sigmaRadians, ${d}, is too large and will clip, as it requested ${tt} samples when the maximum is set to 20`);const J=[];let at=0;for(let At=0;At<20;++At){const Ft=At/Y,Tt=Math.exp(-Ft*Ft/2);J.push(Tt),0===At?at+=Tt:At<tt&&(at+=2*Tt)}for(let At=0;At<J.length;At++)J[At]=J[At]/at;P.envMap.value=e.texture,P.samples.value=tt,P.weights.value=J,P.latitudinal.value="latitudinal"===g,v&&(P.poleAxis.value=v);const{_lodMax:it}=this;P.dTheta.value=W,P.mipInt.value=it-l;const ct=this._sizeLods[c];ng(s,3*ct*(c>it-4?c-it+4:0),4*(this._cubeSize-ct),3*ct,2*ct),x.setRenderTarget(s),x.render(S,Jm)}}function x1(A,e,s){const l=new bo(A,e,s);return l.texture.mapping=lr,l.texture.name="PMREM.cubeUv",l.scissorTest=!0,l}function ng(A,e,s,l,c){A.viewport.set(e,s,l,c),A.scissor.set(e,s,l,c)}function Or(){return new xl({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:rt,depthTest:!1,depthWrite:!1})}function zh(){return new xl({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:rt,depthTest:!1,depthWrite:!1})}function qr(A){let e=new WeakMap,s=null;function l(c){const d=c.target;d.removeEventListener("dispose",l);const g=e.get(d);void 0!==g&&(e.delete(d),g.dispose())}return{get:function(c){if(c&&c.isTexture){const d=c.mapping,g=d===mo||d===si,v=d===Wr||d===ii;if(g||v){let x=e.get(c);if(c.isRenderTargetTexture&&c.pmremVersion!==(void 0!==x?x.texture.pmremVersion:0))return null===s&&(s=new u0(A)),x=g?s.fromEquirectangular(c,x):s.fromCubemap(c,x),x.texture.pmremVersion=c.pmremVersion,e.set(c,x),x.texture;if(void 0!==x)return x.texture;{const S=c.image;return g&&S&&S.height>0||v&&S&&function(P){let z=0;for(let W=0;W<6;W++)void 0!==P[W]&&z++;return 6===z}(S)?(null===s&&(s=new u0(A)),x=g?s.fromEquirectangular(c):s.fromCubemap(c),x.texture.pmremVersion=c.pmremVersion,e.set(c,x),c.addEventListener("dispose",l),x.texture):null}}}return c},dispose:function(){e=new WeakMap,null!==s&&(s.dispose(),s=null)}}}function Bb(A){const e={};function s(l){if(void 0!==e[l])return e[l];let c;switch(l){case"WEBGL_depth_texture":c=A.getExtension("WEBGL_depth_texture")||A.getExtension("MOZ_WEBGL_depth_texture")||A.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":c=A.getExtension("EXT_texture_filter_anisotropic")||A.getExtension("MOZ_EXT_texture_filter_anisotropic")||A.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":c=A.getExtension("WEBGL_compressed_texture_s3tc")||A.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||A.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":c=A.getExtension("WEBGL_compressed_texture_pvrtc")||A.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:c=A.getExtension(l)}return e[l]=c,c}return{has:function(l){return null!==s(l)},init:function(){s("EXT_color_buffer_float"),s("WEBGL_clip_cull_distance"),s("OES_texture_float_linear"),s("EXT_color_buffer_half_float"),s("WEBGL_multisampled_render_to_texture"),s("WEBGL_render_shared_exponent")},get:function(l){const c=s(l);return null===c&&console.warn("THREE.WebGLRenderer: "+l+" extension not supported."),c}}}function $h(A,e,s,l){const c={},d=new WeakMap;function g(x){const w=x.target;null!==w.index&&e.remove(w.index);for(const P in w.attributes)e.remove(w.attributes[P]);for(const P in w.morphAttributes){const z=w.morphAttributes[P];for(let W=0,Y=z.length;W<Y;W++)e.remove(z[W])}w.removeEventListener("dispose",g),delete c[w.id];const S=d.get(w);S&&(e.remove(S),d.delete(w)),l.releaseStatesOfGeometry(w),!0===w.isInstancedBufferGeometry&&delete w._maxInstanceCount,s.memory.geometries--}function v(x){const w=[],S=x.index,P=x.attributes.position;let z=0;if(null!==S){const tt=S.array;z=S.version;for(let J=0,at=tt.length;J<at;J+=3){const it=tt[J+0],ct=tt[J+1],At=tt[J+2];w.push(it,ct,ct,At,At,it)}}else{if(void 0===P)return;z=P.version;for(let J=0,at=P.array.length/3-1;J<at;J+=3){const it=J+0,ct=J+1,At=J+2;w.push(it,ct,ct,At,At,it)}}const W=new(Pd(w)?mf:i0)(w,1);W.version=z;const Y=d.get(x);Y&&e.remove(Y),d.set(x,W)}return{get:function(x,w){return!0===c[w.id]||(w.addEventListener("dispose",g),c[w.id]=!0,s.memory.geometries++),w},update:function(x){const w=x.attributes;for(const P in w)e.update(w[P],A.ARRAY_BUFFER);const S=x.morphAttributes;for(const P in S){const z=S[P];for(let W=0,Y=z.length;W<Y;W++)e.update(z[W],A.ARRAY_BUFFER)}},getWireframeAttribute:function(x){const w=d.get(x);if(w){const S=x.index;null!==S&&w.version<S.version&&v(x)}else v(x);return d.get(x)}}}function Os(A,e,s){let l,c,d;function g(v,x,w){0!==w&&(A.drawElementsInstanced(l,x,c,v*d,w),s.update(x,l,w))}this.setMode=function(v){l=v},this.setIndex=function(v){c=v.type,d=v.bytesPerElement},this.render=function(v,x){A.drawElements(l,x,c,v*d),s.update(x,l,1)},this.renderInstances=g,this.renderMultiDraw=function(v,x,w){if(0===w)return;const S=e.get("WEBGL_multi_draw");if(null===S)for(let P=0;P<w;P++)this.render(v[P]/d,x[P]);else{S.multiDrawElementsWEBGL(l,x,0,c,v,0,w);let P=0;for(let z=0;z<w;z++)P+=x[z];s.update(P,l,1)}},this.renderMultiDrawInstances=function(v,x,w,S){if(0===w)return;const P=e.get("WEBGL_multi_draw");if(null===P)for(let z=0;z<v.length;z++)g(v[z]/d,x[z],S[z]);else{P.multiDrawElementsInstancedWEBGL(l,x,0,c,v,0,S,0,w);let z=0;for(let W=0;W<w;W++)z+=x[W];for(let W=0;W<S.length;W++)s.update(z,l,S[W])}}}function Nr(A){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(s,l,c){switch(e.calls++,l){case A.TRIANGLES:e.triangles+=c*(s/3);break;case A.LINES:e.lines+=c*(s/2);break;case A.LINE_STRIP:e.lines+=c*(s-1);break;case A.LINE_LOOP:e.lines+=c*s;break;case A.POINTS:e.points+=c*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",l)}}}}function w1(A,e,s){const l=new WeakMap,c=new li;return{update:function(d,g,v){const x=d.morphTargetInfluences,w=g.morphAttributes.position||g.morphAttributes.normal||g.morphAttributes.color,S=void 0!==w?w.length:0;let P=l.get(g);if(void 0===P||P.count!==S){let zt=function(){Tt.dispose(),l.delete(g),g.removeEventListener("dispose",zt)};void 0!==P&&P.texture.dispose();const z=void 0!==g.morphAttributes.position,W=void 0!==g.morphAttributes.normal,Y=void 0!==g.morphAttributes.color,tt=g.morphAttributes.position||[],J=g.morphAttributes.normal||[],at=g.morphAttributes.color||[];let it=0;!0===z&&(it=1),!0===W&&(it=2),!0===Y&&(it=3);let ct=g.attributes.position.count*it,At=1;ct>e.maxTextureSize&&(At=Math.ceil(ct/e.maxTextureSize),ct=e.maxTextureSize);const Ft=new Float32Array(ct*At*4*S),Tt=new kh(Ft,ct,At,S);Tt.type=wn,Tt.needsUpdate=!0;const Pt=4*it;for(let ee=0;ee<S;ee++){const ce=tt[ee],ne=J[ee],ge=at[ee],ie=ct*At*4*ee;for(let pe=0;pe<ce.count;pe++){const Oe=pe*Pt;!0===z&&(c.fromBufferAttribute(ce,pe),Ft[ie+Oe+0]=c.x,Ft[ie+Oe+1]=c.y,Ft[ie+Oe+2]=c.z,Ft[ie+Oe+3]=0),!0===W&&(c.fromBufferAttribute(ne,pe),Ft[ie+Oe+4]=c.x,Ft[ie+Oe+5]=c.y,Ft[ie+Oe+6]=c.z,Ft[ie+Oe+7]=0),!0===Y&&(c.fromBufferAttribute(ge,pe),Ft[ie+Oe+8]=c.x,Ft[ie+Oe+9]=c.y,Ft[ie+Oe+10]=c.z,Ft[ie+Oe+11]=4===ge.itemSize?c.w:1)}}P={count:S,texture:Tt,size:new Ye(ct,At)},l.set(g,P),g.addEventListener("dispose",zt)}if(!0===d.isInstancedMesh&&null!==d.morphTexture)v.getUniforms().setValue(A,"morphTexture",d.morphTexture,s);else{let z=0;for(let Y=0;Y<x.length;Y++)z+=x[Y];const W=g.morphTargetsRelative?1:1-z;v.getUniforms().setValue(A,"morphTargetBaseInfluence",W),v.getUniforms().setValue(A,"morphTargetInfluences",x)}v.getUniforms().setValue(A,"morphTargetsTexture",P.texture,s),v.getUniforms().setValue(A,"morphTargetsTextureSize",P.size)}}}class Vh{constructor(e,s,l){if(this.renderer=e,this.DEFAULT_NUMVIEWS=2,this.maxNumViews=0,this.gl=l,this.extensions=s,this.available=this.extensions.has("OCULUS_multiview"),this.available){const d=this.extensions.get("OCULUS_multiview");this.maxNumViews=this.gl.getParameter(d.MAX_VIEWS_OVR),this.mat4=[],this.mat3=[],this.cameraArray=[];for(var c=0;c<this.maxNumViews;c++)this.mat4[c]=new Yn,this.mat3[c]=new yr}}getCameraArray(e){return e.isArrayCamera?e.cameras:(this.cameraArray[0]=e,this.cameraArray)}updateCameraProjectionMatricesUniform(e,s){for(var l=this.getCameraArray(e),c=0;c<l.length;c++)this.mat4[c].copy(l[c].projectionMatrix);s.setValue(this.gl,"projectionMatrices",this.mat4)}updateCameraViewMatricesUniform(e,s){for(var l=this.getCameraArray(e),c=0;c<l.length;c++)this.mat4[c].copy(l[c].matrixWorldInverse);s.setValue(this.gl,"viewMatrices",this.mat4)}updateObjectMatricesUniforms(e,s,l){for(var c=this.getCameraArray(s),d=0;d<c.length;d++)this.mat4[d].multiplyMatrices(c[d].matrixWorldInverse,e.matrixWorld),this.mat3[d].getNormalMatrix(this.mat4[d]);l.setValue(this.gl,"modelViewMatrices",this.mat4),l.setValue(this.gl,"normalMatrices",this.mat3)}}function E1(A,e,s,l){let c=new WeakMap;function d(g){const v=g.target;v.removeEventListener("dispose",d),s.remove(v.instanceMatrix),null!==v.instanceColor&&s.remove(v.instanceColor)}return{update:function(g){const v=l.render.frame,w=e.get(g,g.geometry);if(c.get(w)!==v&&(e.update(w),c.set(w,v)),g.isInstancedMesh&&(!1===g.hasEventListener("dispose",d)&&g.addEventListener("dispose",d),c.get(g)!==v&&(s.update(g.instanceMatrix,A.ARRAY_BUFFER),null!==g.instanceColor&&s.update(g.instanceColor,A.ARRAY_BUFFER),c.set(g,v))),g.isSkinnedMesh){const S=g.skeleton;c.get(S)!==v&&(S.update(),c.set(S,v))}return w},dispose:function(){c=new WeakMap}}}class h0 extends Vi{constructor(e,s,l,c,d,g,v,x,w,S){if((S=void 0!==S?S:Bi)!==Bi&&S!==Ta)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===l&&S===Bi&&(l=rr),void 0===l&&S===Ta&&(l=ai),super(null,c,d,g,v,x,S,l,w),this.isDepthTexture=!0,this.image={width:e,height:s},this.magFilter=void 0!==v?v:be,this.minFilter=void 0!==x?x:be,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const s=super.toJSON(e);return null!==this.compareFunction&&(s.compareFunction=this.compareFunction),s}}const C1=new Vi,d0=new h0(1,1);d0.compareFunction=Eh;const Ef=new kh,rg=new Rh,ig=new vf,Gh=[],sg=[],I1=new Float32Array(16),ag=new Float32Array(9),p0=new Float32Array(4);function Qh(A,e,s){const l=A[0];if(l<=0||l>0)return A;const c=e*s;let d=Gh[c];if(void 0===d&&(d=new Float32Array(c),Gh[c]=d),0!==e){l.toArray(d,0);for(let g=1,v=0;g!==e;++g)v+=s,A[g].toArray(d,v)}return d}function na(A,e){if(A.length!==e.length)return!1;for(let s=0,l=A.length;s<l;s++)if(A[s]!==e[s])return!1;return!0}function Aa(A,e){for(let s=0,l=e.length;s<l;s++)A[s]=e[s]}function Cf(A,e){let s=sg[e];void 0===s&&(s=new Int32Array(e),sg[e]=s);for(let l=0;l!==e;++l)s[l]=A.allocateTextureUnit();return s}function S1(A,e){const s=this.cache;s[0]!==e&&(A.uniform1f(this.addr,e),s[0]=e)}function M1(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y||(A.uniform2f(this.addr,e.x,e.y),s[0]=e.x,s[1]=e.y);else{if(na(s,e))return;A.uniform2fv(this.addr,e),Aa(s,e)}}function T1(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y&&s[2]===e.z||(A.uniform3f(this.addr,e.x,e.y,e.z),s[0]=e.x,s[1]=e.y,s[2]=e.z);else if(void 0!==e.r)s[0]===e.r&&s[1]===e.g&&s[2]===e.b||(A.uniform3f(this.addr,e.r,e.g,e.b),s[0]=e.r,s[1]=e.g,s[2]=e.b);else{if(na(s,e))return;A.uniform3fv(this.addr,e),Aa(s,e)}}function _1(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y&&s[2]===e.z&&s[3]===e.w||(A.uniform4f(this.addr,e.x,e.y,e.z,e.w),s[0]=e.x,s[1]=e.y,s[2]=e.z,s[3]=e.w);else{if(na(s,e))return;A.uniform4fv(this.addr,e),Aa(s,e)}}function f0(A,e){const s=this.cache,l=e.elements;if(void 0===l){if(na(s,e))return;A.uniformMatrix2fv(this.addr,!1,e),Aa(s,e)}else{if(na(s,l))return;p0.set(l),A.uniformMatrix2fv(this.addr,!1,p0),Aa(s,l)}}function m0(A,e){const s=this.cache,l=e.elements;if(void 0===l){if(na(s,e))return;A.uniformMatrix3fv(this.addr,!1,e),Aa(s,e)}else{if(na(s,l))return;ag.set(l),A.uniformMatrix3fv(this.addr,!1,ag),Aa(s,l)}}function og(A,e){const s=this.cache,l=e.elements;if(void 0===l){if(na(s,e))return;A.uniformMatrix4fv(this.addr,!1,e),Aa(s,e)}else{if(na(s,l))return;I1.set(l),A.uniformMatrix4fv(this.addr,!1,I1),Aa(s,l)}}function g0(A,e){const s=this.cache;s[0]!==e&&(A.uniform1i(this.addr,e),s[0]=e)}function k1(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y||(A.uniform2i(this.addr,e.x,e.y),s[0]=e.x,s[1]=e.y);else{if(na(s,e))return;A.uniform2iv(this.addr,e),Aa(s,e)}}function Hh(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y&&s[2]===e.z||(A.uniform3i(this.addr,e.x,e.y,e.z),s[0]=e.x,s[1]=e.y,s[2]=e.z);else{if(na(s,e))return;A.uniform3iv(this.addr,e),Aa(s,e)}}function Zo(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y&&s[2]===e.z&&s[3]===e.w||(A.uniform4i(this.addr,e.x,e.y,e.z,e.w),s[0]=e.x,s[1]=e.y,s[2]=e.z,s[3]=e.w);else{if(na(s,e))return;A.uniform4iv(this.addr,e),Aa(s,e)}}function on(A,e){const s=this.cache;s[0]!==e&&(A.uniform1ui(this.addr,e),s[0]=e)}function R1(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y||(A.uniform2ui(this.addr,e.x,e.y),s[0]=e.x,s[1]=e.y);else{if(na(s,e))return;A.uniform2uiv(this.addr,e),Aa(s,e)}}function Nb(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y&&s[2]===e.z||(A.uniform3ui(this.addr,e.x,e.y,e.z),s[0]=e.x,s[1]=e.y,s[2]=e.z);else{if(na(s,e))return;A.uniform3uiv(this.addr,e),Aa(s,e)}}function A0(A,e){const s=this.cache;if(void 0!==e.x)s[0]===e.x&&s[1]===e.y&&s[2]===e.z&&s[3]===e.w||(A.uniform4ui(this.addr,e.x,e.y,e.z,e.w),s[0]=e.x,s[1]=e.y,s[2]=e.z,s[3]=e.w);else{if(na(s,e))return;A.uniform4uiv(this.addr,e),Aa(s,e)}}function y0(A,e,s){const l=this.cache,c=s.allocateTextureUnit();l[0]!==c&&(A.uniform1i(this.addr,c),l[0]=c),s.setTexture2D(e||(this.type===A.SAMPLER_2D_SHADOW?d0:C1),c)}function Db(A,e,s){const l=this.cache,c=s.allocateTextureUnit();l[0]!==c&&(A.uniform1i(this.addr,c),l[0]=c),s.setTexture3D(e||rg,c)}function Lb(A,e,s){const l=this.cache,c=s.allocateTextureUnit();l[0]!==c&&(A.uniform1i(this.addr,c),l[0]=c),s.setTextureCube(e||ig,c)}function Fb(A,e,s){const l=this.cache,c=s.allocateTextureUnit();l[0]!==c&&(A.uniform1i(this.addr,c),l[0]=c),s.setTexture2DArray(e||Ef,c)}function v0(A,e){A.uniform1fv(this.addr,e)}function Ob(A,e){const s=Qh(e,this.size,2);A.uniform2fv(this.addr,s)}function Pb(A,e){const s=Qh(e,this.size,3);A.uniform3fv(this.addr,s)}function B1(A,e){const s=Qh(e,this.size,4);A.uniform4fv(this.addr,s)}function N1(A,e){const s=Qh(e,this.size,4);A.uniformMatrix2fv(this.addr,!1,s)}function Ub(A,e){const s=Qh(e,this.size,9);A.uniformMatrix3fv(this.addr,!1,s)}function zb(A,e){const s=Qh(e,this.size,16);A.uniformMatrix4fv(this.addr,!1,s)}function $b(A,e){A.uniform1iv(this.addr,e)}function D1(A,e){A.uniform2iv(this.addr,e)}function Vb(A,e){A.uniform3iv(this.addr,e)}function au(A,e){A.uniform4iv(this.addr,e)}function lg(A,e){A.uniform1uiv(this.addr,e)}function Gb(A,e){A.uniform2uiv(this.addr,e)}function me(A,e){A.uniform3uiv(this.addr,e)}function Dr(A,e){A.uniform4uiv(this.addr,e)}function ya(A,e,s){const l=this.cache,c=e.length,d=Cf(s,c);na(l,d)||(A.uniform1iv(this.addr,d),Aa(l,d));for(let g=0;g!==c;++g)s.setTexture2D(e[g]||C1,d[g])}function Qb(A,e,s){const l=this.cache,c=e.length,d=Cf(s,c);na(l,d)||(A.uniform1iv(this.addr,d),Aa(l,d));for(let g=0;g!==c;++g)s.setTexture3D(e[g]||rg,d[g])}function Hb(A,e,s){const l=this.cache,c=e.length,d=Cf(s,c);na(l,d)||(A.uniform1iv(this.addr,d),Aa(l,d));for(let g=0;g!==c;++g)s.setTextureCube(e[g]||ig,d[g])}function Wb(A,e,s){const l=this.cache,c=e.length,d=Cf(s,c);na(l,d)||(A.uniform1iv(this.addr,d),Aa(l,d));for(let g=0;g!==c;++g)s.setTexture2DArray(e[g]||Ef,d[g])}class jb{constructor(e,s,l){this.id=e,this.addr=l,this.cache=[],this.type=s.type,this.setValue=function(c){switch(c){case 5126:return S1;case 35664:return M1;case 35665:return T1;case 35666:return _1;case 35674:return f0;case 35675:return m0;case 35676:return og;case 5124:case 35670:return g0;case 35667:case 35671:return k1;case 35668:case 35672:return Hh;case 35669:case 35673:return Zo;case 5125:return on;case 36294:return R1;case 36295:return Nb;case 36296:return A0;case 35678:case 36198:case 36298:case 36306:case 35682:return y0;case 35679:case 36299:case 36307:return Db;case 35680:case 36300:case 36308:case 36293:return Lb;case 36289:case 36303:case 36311:case 36292:return Fb}}(s.type)}}class qb{constructor(e,s,l){this.id=e,this.addr=l,this.cache=[],this.type=s.type,this.size=s.size,this.setValue=function(c){switch(c){case 5126:return v0;case 35664:return Ob;case 35665:return Pb;case 35666:return B1;case 35674:return N1;case 35675:return Ub;case 35676:return zb;case 5124:case 35670:return $b;case 35667:case 35671:return D1;case 35668:case 35672:return Vb;case 35669:case 35673:return au;case 5125:return lg;case 36294:return Gb;case 36295:return me;case 36296:return Dr;case 35678:case 36198:case 36298:case 36306:case 35682:return ya;case 35679:case 36299:case 36307:return Qb;case 35680:case 36300:case 36308:case 36293:return Hb;case 36289:case 36303:case 36311:case 36292:return Wb}}(s.type)}}class Xb{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,s,l){const c=this.seq;for(let d=0,g=c.length;d!==g;++d){const v=c[d];v.setValue(e,s[v.id],l)}}}const b0=/(\w+)(\])?(\[|\.)?/g;function cg(A,e){A.seq.push(e),A.map[e.id]=e}function L1(A,e,s){const l=A.name,c=l.length;for(b0.lastIndex=0;;){const d=b0.exec(l);let v=d[1];const w=d[3];if("]"===d[2]&&(v|=0),void 0===w||"["===w&&b0.lastIndex+2===c){cg(s,void 0===w?new jb(v,A,e):new qb(v,A,e));break}{let S=s.map[v];void 0===S&&(S=new Xb(v),cg(s,S)),s=S}}}class ug{constructor(e,s){this.seq=[],this.map={};const l=e.getProgramParameter(s,e.ACTIVE_UNIFORMS);for(let c=0;c<l;++c){const d=e.getActiveUniform(s,c);L1(d,e.getUniformLocation(s,d.name),this)}}setValue(e,s,l,c){const d=this.map[s];void 0!==d&&d.setValue(e,l,c)}setOptional(e,s,l){const c=s[l];void 0!==c&&this.setValue(e,l,c)}static upload(e,s,l,c){for(let d=0,g=s.length;d!==g;++d){const v=s[d],x=l[v.id];!1!==x.needsUpdate&&v.setValue(e,x.value,c)}}static seqWithValue(e,s){const l=[];for(let c=0,d=e.length;c!==d;++c){const g=e[c];g.id in s&&l.push(g)}return l}}function an(A,e,s){const l=A.createShader(e);return A.shaderSource(l,s),A.compileShader(l),l}const hg=37297;let qn=0;function ae(A,e,s){const l=A.getShaderParameter(e,A.COMPILE_STATUS),c=A.getShaderInfoLog(e).trim();if(l&&""===c)return"";const d=/ERROR: 0:(\d+)/.exec(c);if(d){const g=parseInt(d[1]);return s.toUpperCase()+"\n\n"+c+"\n\n"+function(v,x){const w=v.split("\n"),S=[],P=Math.max(x-6,0),z=Math.min(x+6,w.length);for(let W=P;W<z;W++){const Y=W+1;S.push(`${Y===x?">":" "} ${Y}: ${w[W]}`)}return S.join("\n")}(A.getShaderSource(e),g)}return c}function Ba(A,e){const s=function(l){const c=Jr.getPrimaries(Jr.workingColorSpace),d=Jr.getPrimaries(l);let g;switch(c===d?g="":c===$c&&d===zc?g="LinearDisplayP3ToLinearSRGB":c===zc&&d===$c&&(g="LinearSRGBToLinearDisplayP3"),l){case ps:case Uc:return[g,"LinearTransferOETF"];case qi:case Nu:return[g,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",l),[g,"LinearTransferOETF"]}}(e);return`vec4 ${A}( vec4 value ) { return ${s[0]}( ${s[1]}( value ) ); }`}function Oi(A,e){let s;switch(e){case Z:s="Linear";break;case _t:s="Reinhard";break;case Ht:s="OptimizedCineon";break;case Ae:s="ACESFilmic";break;case _e:s="AgX";break;case We:s="Neutral";break;case Wt:s="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),s="Linear"}return"vec3 "+A+"( vec3 color ) { return "+s+"ToneMapping( color ); }"}function zr(A){return""!==A}function F1(A,e){const s=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return A.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,s).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function O1(A,e){return A.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Yb=/^[ \t]*#include +<([\w\d./]+)>/gm;function x0(A){return A.replace(Yb,gc)}const P1=new Map;function gc(A,e){let s=Ur[e];if(void 0===s){const l=P1.get(e);if(void 0===l)throw new Error("Can not resolve #include <"+e+">");s=Ur[l],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,l)}return x0(s)}const dg=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Jn(A){return A.replace(dg,ou)}function ou(A,e,s,l){let c="";for(let d=parseInt(e);d<parseInt(s);d++)c+=l.replace(/\[\s*i\s*\]/g,"[ "+d+" ]").replace(/UNROLLED_LOOP_INDEX/g,d);return c}function If(A){let e=`precision ${A.precision} float;\n\tprecision ${A.precision} int;\n\tprecision ${A.precision} sampler2D;\n\tprecision ${A.precision} samplerCube;\n\tprecision ${A.precision} sampler3D;\n\tprecision ${A.precision} sampler2DArray;\n\tprecision ${A.precision} sampler2DShadow;\n\tprecision ${A.precision} samplerCubeShadow;\n\tprecision ${A.precision} sampler2DArrayShadow;\n\tprecision ${A.precision} isampler2D;\n\tprecision ${A.precision} isampler3D;\n\tprecision ${A.precision} isamplerCube;\n\tprecision ${A.precision} isampler2DArray;\n\tprecision ${A.precision} usampler2D;\n\tprecision ${A.precision} usampler3D;\n\tprecision ${A.precision} usamplerCube;\n\tprecision ${A.precision} usampler2DArray;\n\t`;return"highp"===A.precision?e+="\n#define HIGH_PRECISION":"mediump"===A.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===A.precision&&(e+="\n#define LOW_PRECISION"),e}function op(A,e,s,l){const c=A.getContext(),d=s.defines;let g=s.vertexShader,v=s.fragmentShader;const x=function(ge){let ie="SHADOWMAP_TYPE_BASIC";return ge.shadowMapType===k?ie="SHADOWMAP_TYPE_PCF":ge.shadowMapType===F?ie="SHADOWMAP_TYPE_PCF_SOFT":ge.shadowMapType===G&&(ie="SHADOWMAP_TYPE_VSM"),ie}(s),w=function(ge){let ie="ENVMAP_TYPE_CUBE";if(ge.envMap)switch(ge.envMapMode){case Wr:case ii:ie="ENVMAP_TYPE_CUBE";break;case lr:ie="ENVMAP_TYPE_CUBE_UV"}return ie}(s),S=function(ge){let ie="ENVMAP_MODE_REFLECTION";return ge.envMap&&ge.envMapMode===ii&&(ie="ENVMAP_MODE_REFRACTION"),ie}(s),P=function(ge){let ie="ENVMAP_BLENDING_NONE";if(ge.envMap)switch(ge.combine){case Ct:ie="ENVMAP_BLENDING_MULTIPLY";break;case q:ie="ENVMAP_BLENDING_MIX";break;case st:ie="ENVMAP_BLENDING_ADD"}return ie}(s),z=function(ge){const ie=ge.envMapCubeUVHeight;if(null===ie)return null;const pe=Math.log2(ie)-2,Oe=1/ie;return{texelWidth:1/(3*Math.max(Math.pow(2,pe),112)),texelHeight:Oe,maxMip:pe}}(s),W=[(ge=s).extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",ge.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(zr).join("\n"),Y=function(ge){const ie=[];for(const pe in ge){const Oe=ge[pe];!1!==Oe&&ie.push("#define "+pe+" "+Oe)}return ie.join("\n")}(d),tt=c.createProgram();var ge;let J,at,it=s.glslVersion?"#version "+s.glslVersion+"\n":"";const ct=s.numMultiviewViews;s.isRawShaderMaterial?(J=["#define SHADER_TYPE "+s.shaderType,"#define SHADER_NAME "+s.shaderName,Y].filter(zr).join("\n"),J.length>0&&(J+="\n"),at=["#define SHADER_TYPE "+s.shaderType,"#define SHADER_NAME "+s.shaderName,Y].filter(zr).join("\n"),at.length>0&&(at+="\n")):(J=[If(s),"#define SHADER_TYPE "+s.shaderType,"#define SHADER_NAME "+s.shaderName,Y,s.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",s.batching?"#define USE_BATCHING":"",s.instancing?"#define USE_INSTANCING":"",s.instancingColor?"#define USE_INSTANCING_COLOR":"",s.instancingMorph?"#define USE_INSTANCING_MORPH":"",s.useFog&&s.fog?"#define USE_FOG":"",s.useFog&&s.fogExp2?"#define FOG_EXP2":"",s.map?"#define USE_MAP":"",s.envMap?"#define USE_ENVMAP":"",s.envMap?"#define "+S:"",s.lightMap?"#define USE_LIGHTMAP":"",s.aoMap?"#define USE_AOMAP":"",s.bumpMap?"#define USE_BUMPMAP":"",s.normalMap?"#define USE_NORMALMAP":"",s.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",s.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",s.displacementMap?"#define USE_DISPLACEMENTMAP":"",s.emissiveMap?"#define USE_EMISSIVEMAP":"",s.anisotropy?"#define USE_ANISOTROPY":"",s.anisotropyMap?"#define USE_ANISOTROPYMAP":"",s.clearcoatMap?"#define USE_CLEARCOATMAP":"",s.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",s.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",s.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",s.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",s.specularMap?"#define USE_SPECULARMAP":"",s.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",s.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",s.roughnessMap?"#define USE_ROUGHNESSMAP":"",s.metalnessMap?"#define USE_METALNESSMAP":"",s.alphaMap?"#define USE_ALPHAMAP":"",s.alphaHash?"#define USE_ALPHAHASH":"",s.transmission?"#define USE_TRANSMISSION":"",s.transmissionMap?"#define USE_TRANSMISSIONMAP":"",s.thicknessMap?"#define USE_THICKNESSMAP":"",s.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",s.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",s.mapUv?"#define MAP_UV "+s.mapUv:"",s.alphaMapUv?"#define ALPHAMAP_UV "+s.alphaMapUv:"",s.lightMapUv?"#define LIGHTMAP_UV "+s.lightMapUv:"",s.aoMapUv?"#define AOMAP_UV "+s.aoMapUv:"",s.emissiveMapUv?"#define EMISSIVEMAP_UV "+s.emissiveMapUv:"",s.bumpMapUv?"#define BUMPMAP_UV "+s.bumpMapUv:"",s.normalMapUv?"#define NORMALMAP_UV "+s.normalMapUv:"",s.displacementMapUv?"#define DISPLACEMENTMAP_UV "+s.displacementMapUv:"",s.metalnessMapUv?"#define METALNESSMAP_UV "+s.metalnessMapUv:"",s.roughnessMapUv?"#define ROUGHNESSMAP_UV "+s.roughnessMapUv:"",s.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+s.anisotropyMapUv:"",s.clearcoatMapUv?"#define CLEARCOATMAP_UV "+s.clearcoatMapUv:"",s.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+s.clearcoatNormalMapUv:"",s.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+s.clearcoatRoughnessMapUv:"",s.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+s.iridescenceMapUv:"",s.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+s.iridescenceThicknessMapUv:"",s.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+s.sheenColorMapUv:"",s.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+s.sheenRoughnessMapUv:"",s.specularMapUv?"#define SPECULARMAP_UV "+s.specularMapUv:"",s.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+s.specularColorMapUv:"",s.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+s.specularIntensityMapUv:"",s.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+s.transmissionMapUv:"",s.thicknessMapUv?"#define THICKNESSMAP_UV "+s.thicknessMapUv:"",s.vertexTangents&&!1===s.flatShading?"#define USE_TANGENT":"",s.vertexColors?"#define USE_COLOR":"",s.vertexAlphas?"#define USE_COLOR_ALPHA":"",s.vertexUv1s?"#define USE_UV1":"",s.vertexUv2s?"#define USE_UV2":"",s.vertexUv3s?"#define USE_UV3":"",s.pointsUvs?"#define USE_POINTS_UV":"",s.flatShading?"#define FLAT_SHADED":"",s.skinning?"#define USE_SKINNING":"",s.morphTargets?"#define USE_MORPHTARGETS":"",s.morphNormals&&!1===s.flatShading?"#define USE_MORPHNORMALS":"",s.morphColors?"#define USE_MORPHCOLORS":"",s.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE":"",s.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+s.morphTextureStride:"",s.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+s.morphTargetsCount:"",s.doubleSided?"#define DOUBLE_SIDED":"",s.flipSided?"#define FLIP_SIDED":"",s.shadowMapEnabled?"#define USE_SHADOWMAP":"",s.shadowMapEnabled?"#define "+x:"",s.sizeAttenuation?"#define USE_SIZEATTENUATION":"",s.numLightProbes>0?"#define USE_LIGHT_PROBES":"",s.useLegacyLights?"#define LEGACY_LIGHTS":"",s.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(zr).join("\n"),at=[If(s),"#define SHADER_TYPE "+s.shaderType,"#define SHADER_NAME "+s.shaderName,Y,s.useFog&&s.fog?"#define USE_FOG":"",s.useFog&&s.fogExp2?"#define FOG_EXP2":"",s.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",s.map?"#define USE_MAP":"",s.matcap?"#define USE_MATCAP":"",s.envMap?"#define USE_ENVMAP":"",s.envMap?"#define "+w:"",s.envMap?"#define "+S:"",s.envMap?"#define "+P:"",z?"#define CUBEUV_TEXEL_WIDTH "+z.texelWidth:"",z?"#define CUBEUV_TEXEL_HEIGHT "+z.texelHeight:"",z?"#define CUBEUV_MAX_MIP "+z.maxMip+".0":"",s.lightMap?"#define USE_LIGHTMAP":"",s.aoMap?"#define USE_AOMAP":"",s.bumpMap?"#define USE_BUMPMAP":"",s.normalMap?"#define USE_NORMALMAP":"",s.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",s.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",s.emissiveMap?"#define USE_EMISSIVEMAP":"",s.anisotropy?"#define USE_ANISOTROPY":"",s.anisotropyMap?"#define USE_ANISOTROPYMAP":"",s.clearcoat?"#define USE_CLEARCOAT":"",s.clearcoatMap?"#define USE_CLEARCOATMAP":"",s.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",s.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",s.dispersion?"#define USE_DISPERSION":"",s.iridescence?"#define USE_IRIDESCENCE":"",s.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",s.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",s.specularMap?"#define USE_SPECULARMAP":"",s.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",s.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",s.roughnessMap?"#define USE_ROUGHNESSMAP":"",s.metalnessMap?"#define USE_METALNESSMAP":"",s.alphaMap?"#define USE_ALPHAMAP":"",s.alphaTest?"#define USE_ALPHATEST":"",s.alphaHash?"#define USE_ALPHAHASH":"",s.sheen?"#define USE_SHEEN":"",s.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",s.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",s.transmission?"#define USE_TRANSMISSION":"",s.transmissionMap?"#define USE_TRANSMISSIONMAP":"",s.thicknessMap?"#define USE_THICKNESSMAP":"",s.vertexTangents&&!1===s.flatShading?"#define USE_TANGENT":"",s.vertexColors||s.instancingColor?"#define USE_COLOR":"",s.vertexAlphas?"#define USE_COLOR_ALPHA":"",s.vertexUv1s?"#define USE_UV1":"",s.vertexUv2s?"#define USE_UV2":"",s.vertexUv3s?"#define USE_UV3":"",s.pointsUvs?"#define USE_POINTS_UV":"",s.gradientMap?"#define USE_GRADIENTMAP":"",s.flatShading?"#define FLAT_SHADED":"",s.doubleSided?"#define DOUBLE_SIDED":"",s.flipSided?"#define FLIP_SIDED":"",s.shadowMapEnabled?"#define USE_SHADOWMAP":"",s.shadowMapEnabled?"#define "+x:"",s.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",s.numLightProbes>0?"#define USE_LIGHT_PROBES":"",s.useLegacyLights?"#define LEGACY_LIGHTS":"",s.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",s.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",s.toneMapping!==ut?"#define TONE_MAPPING":"",s.toneMapping!==ut?Ur.tonemapping_pars_fragment:"",s.toneMapping!==ut?Oi("toneMapping",s.toneMapping):"",s.dithering?"#define DITHERING":"",s.opaque?"#define OPAQUE":"",Ur.colorspace_pars_fragment,Ba("linearToOutputTexel",s.outputColorSpace),s.useDepthPacking?"#define DEPTH_PACKING "+s.depthPacking:"","\n"].filter(zr).join("\n")),g=x0(g),g=F1(g,s),g=O1(g,s),v=x0(v),v=F1(v,s),v=O1(v,s),g=Jn(g),v=Jn(v),!0!==s.isRawShaderMaterial&&(it="#version 300 es\n",J=[W,"#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+J,at=["#define varying in",s.glslVersion===Lu?"":"layout(location = 0) out highp vec4 pc_fragColor;",s.glslVersion===Lu?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+at,ct>0&&(J=["#extension GL_OVR_multiview : require","layout(num_views = "+ct+") in;","#define VIEW_ID gl_ViewID_OVR"].join("\n")+"\n"+J,J=J.replace(["uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;"].join("\n"),["uniform mat4 modelViewMatrices["+ct+"];","uniform mat4 projectionMatrices["+ct+"];","uniform mat4 viewMatrices["+ct+"];","uniform mat3 normalMatrices["+ct+"];","#define modelViewMatrix modelViewMatrices[VIEW_ID]","#define projectionMatrix projectionMatrices[VIEW_ID]","#define viewMatrix viewMatrices[VIEW_ID]","#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")),at=["#extension GL_OVR_multiview : require","#define VIEW_ID gl_ViewID_OVR"].join("\n")+"\n"+at,at=at.replace("uniform mat4 viewMatrix;",["uniform mat4 viewMatrices["+ct+"];","#define viewMatrix viewMatrices[VIEW_ID]"].join("\n"))));const Ft=it+at+v,Tt=an(c,c.VERTEX_SHADER,it+J+g),Pt=an(c,c.FRAGMENT_SHADER,Ft);function zt(ge){if(A.debug.checkShaderErrors){const ie=c.getProgramInfoLog(tt).trim(),pe=c.getShaderInfoLog(Tt).trim(),Oe=c.getShaderInfoLog(Pt).trim();let Pe=!0,ze=!0;if(!1===c.getProgramParameter(tt,c.LINK_STATUS))if(Pe=!1,"function"==typeof A.debug.onShaderError)A.debug.onShaderError(c,tt,Tt,Pt);else{const Fe=ae(c,Tt,"vertex"),Dn=ae(c,Pt,"fragment");console.error("THREE.WebGLProgram: Shader Error "+c.getError()+" - VALIDATE_STATUS "+c.getProgramParameter(tt,c.VALIDATE_STATUS)+"\n\nMaterial Name: "+ge.name+"\nMaterial Type: "+ge.type+"\n\nProgram Info Log: "+ie+"\n"+Fe+"\n"+Dn)}else""!==ie?console.warn("THREE.WebGLProgram: Program Info Log:",ie):""!==pe&&""!==Oe||(ze=!1);ze&&(ge.diagnostics={runnable:Pe,programLog:ie,vertexShader:{log:pe,prefix:J},fragmentShader:{log:Oe,prefix:at}})}c.deleteShader(Tt),c.deleteShader(Pt),ee=new ug(c,tt),ce=function(ie,pe){const Oe={},Pe=ie.getProgramParameter(pe,ie.ACTIVE_ATTRIBUTES);for(let ze=0;ze<Pe;ze++){const Fe=ie.getActiveAttrib(pe,ze),Dn=Fe.name;let Nn=1;Fe.type===ie.FLOAT_MAT2&&(Nn=2),Fe.type===ie.FLOAT_MAT3&&(Nn=3),Fe.type===ie.FLOAT_MAT4&&(Nn=4),Oe[Dn]={type:Fe.type,location:ie.getAttribLocation(pe,Dn),locationSize:Nn}}return Oe}(c,tt)}let ee,ce;c.attachShader(tt,Tt),c.attachShader(tt,Pt),void 0!==s.index0AttributeName?c.bindAttribLocation(tt,0,s.index0AttributeName):!0===s.morphTargets&&c.bindAttribLocation(tt,0,"position"),c.linkProgram(tt),this.getUniforms=function(){return void 0===ee&&zt(this),ee},this.getAttributes=function(){return void 0===ce&&zt(this),ce};let ne=!1===s.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===ne&&(ne=c.getProgramParameter(tt,hg)),ne},this.destroy=function(){l.releaseStatesOfProgram(this),c.deleteProgram(tt),this.program=void 0},this.type=s.shaderType,this.name=s.shaderName,this.id=qn++,this.cacheKey=e,this.usedTimes=1,this.program=tt,this.vertexShader=Tt,this.fragmentShader=Pt,this.numMultiviewViews=ct,this}let pg=0;class lu{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const l=e.fragmentShader,c=this._getShaderStage(e.vertexShader),d=this._getShaderStage(l),g=this._getShaderCacheForMaterial(e);return!1===g.has(c)&&(g.add(c),c.usedTimes++),!1===g.has(d)&&(g.add(d),d.usedTimes++),this}remove(e){const s=this.materialCache.get(e);for(const l of s)l.usedTimes--,0===l.usedTimes&&this.shaderCache.delete(l.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const s=this.materialCache;let l=s.get(e);return void 0===l&&(l=new Set,s.set(e,l)),l}_getShaderStage(e){const s=this.shaderCache;let l=s.get(e);return void 0===l&&(l=new zn(e),s.set(e,l)),l}}class zn{constructor(e){this.id=pg++,this.code=e,this.usedTimes=0}}function fg(A,e,s,l,c,d,g){const v=new qd,x=new lu,w=new Set,S=[],P=c.logarithmicDepthBuffer,z=c.vertexTextures;let W=c.precision;const Y={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function tt(J){return w.add(J),0===J?"uv":`uv${J}`}return{getParameters:function(J,at,it,ct,At){const Ft=ct.fog,Tt=At.geometry,zt=(J.isMeshStandardMaterial?s:e).get(J.envMap||(J.isMeshStandardMaterial?ct.environment:null)),ee=zt&&zt.mapping===lr?zt.image.height:null,ce=Y[J.type];null!==J.precision&&(W=c.getMaxPrecision(J.precision),W!==J.precision&&console.warn("THREE.WebGLProgram.getParameters:",J.precision,"not supported, using",W,"instead."));const ne=Tt.morphAttributes.position||Tt.morphAttributes.normal||Tt.morphAttributes.color,ge=void 0!==ne?ne.length:0;let ie,pe,Oe,Pe,ze=0;if(void 0!==Tt.morphAttributes.position&&(ze=1),void 0!==Tt.morphAttributes.normal&&(ze=2),void 0!==Tt.morphAttributes.color&&(ze=3),ce){const Mi=Yl[ce];ie=Mi.vertexShader,pe=Mi.fragmentShader}else ie=J.vertexShader,pe=J.fragmentShader,x.update(J),Oe=x.getVertexShaderID(J),Pe=x.getFragmentShaderID(J);const Fe=A.getRenderTarget(),Nn=!0===At.isInstancedMesh,xn=!!J.map,Mn=!!zt,Ce=!!J.aoMap,rn=!!J.lightMap,On=!!J.bumpMap,ln=!!J.normalMap,Lt=!!J.displacementMap,St=!!J.emissiveMap,Et=!!J.metalnessMap,re=!!J.roughnessMap,$t=J.anisotropy>0,oe=J.clearcoat>0,ye=J.iridescence>0,Xe=J.sheen>0,Fn=J.transmission>0,An=$t&&!!J.anisotropyMap,Un=oe&&!!J.clearcoatMap,ar=oe&&!!J.clearcoatNormalMap,$n=oe&&!!J.clearcoatRoughnessMap,sr=ye&&!!J.iridescenceMap,Xr=ye&&!!J.iridescenceThicknessMap,Ir=Xe&&!!J.sheenColorMap,kr=Xe&&!!J.sheenRoughnessMap,Qr=!!J.specularMap,Ui=!!J.specularColorMap,Zn=!!J.specularIntensityMap,ts=Fn&&!!J.transmissionMap,Gs=Fn&&!!J.thicknessMap,or=!!J.alphaMap,Ue=!!J.extensions;let Ad=ut;J.toneMapped&&(null!==Fe&&!0!==Fe.isXRRenderTarget||(Ad=A.toneMapping));const Nc={shaderID:ce,shaderType:J.type,shaderName:J.name,vertexShader:ie,fragmentShader:pe,defines:J.defines,customVertexShaderID:Oe,customFragmentShaderID:Pe,isRawShaderMaterial:!0===J.isRawShaderMaterial,glslVersion:J.glslVersion,precision:W,batching:!0===At.isBatchedMesh,instancing:Nn,instancingColor:Nn&&null!==At.instanceColor,instancingMorph:Nn&&null!==At.morphTexture,supportsVertexTextures:z,numMultiviewViews:Fe&&Fe.isWebGLMultiviewRenderTarget?Fe.numViews:0,outputColorSpace:null===Fe?A.outputColorSpace:!0===Fe.isXRRenderTarget?Fe.texture.colorSpace:ps,alphaToCoverage:!!J.alphaToCoverage,map:xn,matcap:!!J.matcap,envMap:Mn,envMapMode:Mn&&zt.mapping,envMapCubeUVHeight:ee,aoMap:Ce,lightMap:rn,bumpMap:On,normalMap:ln,displacementMap:z&&Lt,emissiveMap:St,normalMapObjectSpace:ln&&J.normalMapType===xh,normalMapTangentSpace:ln&&J.normalMapType===wi,metalnessMap:Et,roughnessMap:re,anisotropy:$t,anisotropyMap:An,clearcoat:oe,clearcoatMap:Un,clearcoatNormalMap:ar,clearcoatRoughnessMap:$n,dispersion:J.dispersion>0,iridescence:ye,iridescenceMap:sr,iridescenceThicknessMap:Xr,sheen:Xe,sheenColorMap:Ir,sheenRoughnessMap:kr,specularMap:Qr,specularColorMap:Ui,specularIntensityMap:Zn,transmission:Fn,transmissionMap:ts,thicknessMap:Gs,gradientMap:!!J.gradientMap,opaque:!1===J.transparent&&J.blending===pt&&!1===J.alphaToCoverage,alphaMap:or,alphaTest:J.alphaTest>0,alphaHash:!!J.alphaHash,combine:J.combine,mapUv:xn&&tt(J.map.channel),aoMapUv:Ce&&tt(J.aoMap.channel),lightMapUv:rn&&tt(J.lightMap.channel),bumpMapUv:On&&tt(J.bumpMap.channel),normalMapUv:ln&&tt(J.normalMap.channel),displacementMapUv:Lt&&tt(J.displacementMap.channel),emissiveMapUv:St&&tt(J.emissiveMap.channel),metalnessMapUv:Et&&tt(J.metalnessMap.channel),roughnessMapUv:re&&tt(J.roughnessMap.channel),anisotropyMapUv:An&&tt(J.anisotropyMap.channel),clearcoatMapUv:Un&&tt(J.clearcoatMap.channel),clearcoatNormalMapUv:ar&&tt(J.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:$n&&tt(J.clearcoatRoughnessMap.channel),iridescenceMapUv:sr&&tt(J.iridescenceMap.channel),iridescenceThicknessMapUv:Xr&&tt(J.iridescenceThicknessMap.channel),sheenColorMapUv:Ir&&tt(J.sheenColorMap.channel),sheenRoughnessMapUv:kr&&tt(J.sheenRoughnessMap.channel),specularMapUv:Qr&&tt(J.specularMap.channel),specularColorMapUv:Ui&&tt(J.specularColorMap.channel),specularIntensityMapUv:Zn&&tt(J.specularIntensityMap.channel),transmissionMapUv:ts&&tt(J.transmissionMap.channel),thicknessMapUv:Gs&&tt(J.thicknessMap.channel),alphaMapUv:or&&tt(J.alphaMap.channel),vertexTangents:!!Tt.attributes.tangent&&(ln||$t),vertexColors:J.vertexColors,vertexAlphas:!0===J.vertexColors&&!!Tt.attributes.color&&4===Tt.attributes.color.itemSize,pointsUvs:!0===At.isPoints&&!!Tt.attributes.uv&&(xn||or),fog:!!Ft,useFog:!0===J.fog,fogExp2:!!Ft&&Ft.isFogExp2,flatShading:!0===J.flatShading,sizeAttenuation:!0===J.sizeAttenuation,logarithmicDepthBuffer:P,skinning:!0===At.isSkinnedMesh,morphTargets:void 0!==Tt.morphAttributes.position,morphNormals:void 0!==Tt.morphAttributes.normal,morphColors:void 0!==Tt.morphAttributes.color,morphTargetsCount:ge,morphTextureStride:ze,numDirLights:at.directional.length,numPointLights:at.point.length,numSpotLights:at.spot.length,numSpotLightMaps:at.spotLightMap.length,numRectAreaLights:at.rectArea.length,numHemiLights:at.hemi.length,numDirLightShadows:at.directionalShadowMap.length,numPointLightShadows:at.pointShadowMap.length,numSpotLightShadows:at.spotShadowMap.length,numSpotLightShadowsWithMaps:at.numSpotLightShadowsWithMaps,numLightProbes:at.numLightProbes,numClippingPlanes:g.numPlanes,numClipIntersection:g.numIntersection,dithering:J.dithering,shadowMapEnabled:A.shadowMap.enabled&&it.length>0,shadowMapType:A.shadowMap.type,toneMapping:Ad,useLegacyLights:A._useLegacyLights,decodeVideoTexture:xn&&!0===J.map.isVideoTexture&&Jr.getTransfer(J.map.colorSpace)===Ii,premultipliedAlpha:J.premultipliedAlpha,doubleSided:J.side===lt,flipSided:J.side===X,useDepthPacking:J.depthPacking>=0,depthPacking:J.depthPacking||0,index0AttributeName:J.index0AttributeName,extensionClipCullDistance:Ue&&!0===J.extensions.clipCullDistance&&l.has("WEBGL_clip_cull_distance"),extensionMultiDraw:Ue&&!0===J.extensions.multiDraw&&l.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:l.has("KHR_parallel_shader_compile"),customProgramCacheKey:J.customProgramCacheKey()};return Nc.vertexUv1s=w.has(1),Nc.vertexUv2s=w.has(2),Nc.vertexUv3s=w.has(3),w.clear(),Nc},getProgramCacheKey:function(J){const at=[];if(J.shaderID?at.push(J.shaderID):(at.push(J.customVertexShaderID),at.push(J.customFragmentShaderID)),void 0!==J.defines)for(const it in J.defines)at.push(it),at.push(J.defines[it]);return!1===J.isRawShaderMaterial&&((it=at).push((ct=J).precision),it.push(ct.outputColorSpace),it.push(ct.envMapMode),it.push(ct.envMapCubeUVHeight),it.push(ct.mapUv),it.push(ct.alphaMapUv),it.push(ct.lightMapUv),it.push(ct.aoMapUv),it.push(ct.bumpMapUv),it.push(ct.normalMapUv),it.push(ct.displacementMapUv),it.push(ct.emissiveMapUv),it.push(ct.metalnessMapUv),it.push(ct.roughnessMapUv),it.push(ct.anisotropyMapUv),it.push(ct.clearcoatMapUv),it.push(ct.clearcoatNormalMapUv),it.push(ct.clearcoatRoughnessMapUv),it.push(ct.iridescenceMapUv),it.push(ct.iridescenceThicknessMapUv),it.push(ct.sheenColorMapUv),it.push(ct.sheenRoughnessMapUv),it.push(ct.specularMapUv),it.push(ct.specularColorMapUv),it.push(ct.specularIntensityMapUv),it.push(ct.transmissionMapUv),it.push(ct.thicknessMapUv),it.push(ct.combine),it.push(ct.fogExp2),it.push(ct.sizeAttenuation),it.push(ct.morphTargetsCount),it.push(ct.morphAttributeCount),it.push(ct.numDirLights),it.push(ct.numPointLights),it.push(ct.numSpotLights),it.push(ct.numSpotLightMaps),it.push(ct.numHemiLights),it.push(ct.numRectAreaLights),it.push(ct.numDirLightShadows),it.push(ct.numPointLightShadows),it.push(ct.numSpotLightShadows),it.push(ct.numSpotLightShadowsWithMaps),it.push(ct.numLightProbes),it.push(ct.shadowMapType),it.push(ct.toneMapping),it.push(ct.numClippingPlanes),it.push(ct.numClipIntersection),it.push(ct.depthPacking),function(it,ct){v.disableAll(),ct.supportsVertexTextures&&v.enable(0),ct.instancing&&v.enable(1),ct.instancingColor&&v.enable(2),ct.instancingMorph&&v.enable(3),ct.matcap&&v.enable(4),ct.envMap&&v.enable(5),ct.normalMapObjectSpace&&v.enable(6),ct.normalMapTangentSpace&&v.enable(7),ct.clearcoat&&v.enable(8),ct.iridescence&&v.enable(9),ct.alphaTest&&v.enable(10),ct.vertexColors&&v.enable(11),ct.vertexAlphas&&v.enable(12),ct.vertexUv1s&&v.enable(13),ct.vertexUv2s&&v.enable(14),ct.vertexUv3s&&v.enable(15),ct.vertexTangents&&v.enable(16),ct.anisotropy&&v.enable(17),ct.alphaHash&&v.enable(18),ct.batching&&v.enable(19),ct.dispersion&&v.enable(20),it.push(v.mask),v.disableAll(),ct.fog&&v.enable(0),ct.useFog&&v.enable(1),ct.flatShading&&v.enable(2),ct.logarithmicDepthBuffer&&v.enable(3),ct.skinning&&v.enable(4),ct.morphTargets&&v.enable(5),ct.morphNormals&&v.enable(6),ct.morphColors&&v.enable(7),ct.premultipliedAlpha&&v.enable(8),ct.shadowMapEnabled&&v.enable(9),ct.useLegacyLights&&v.enable(10),ct.doubleSided&&v.enable(11),ct.flipSided&&v.enable(12),ct.useDepthPacking&&v.enable(13),ct.dithering&&v.enable(14),ct.transmission&&v.enable(15),ct.sheen&&v.enable(16),ct.opaque&&v.enable(17),ct.pointsUvs&&v.enable(18),ct.decodeVideoTexture&&v.enable(19),ct.alphaToCoverage&&v.enable(20),ct.numMultiviewViews&&v.enable(21),it.push(v.mask)}(at,J),at.push(A.outputColorSpace)),at.push(J.customProgramCacheKey),at.join();var it,ct},getUniforms:function(J){const at=Y[J.type];let it;return it=at?ju.clone(Yl[at].uniforms):J.uniforms,it},acquireProgram:function(J,at){let it;for(let ct=0,At=S.length;ct<At;ct++){const Ft=S[ct];if(Ft.cacheKey===at){it=Ft,++it.usedTimes;break}}return void 0===it&&(it=new op(A,at,J,d),S.push(it)),it},releaseProgram:function(J){if(0==--J.usedTimes){const at=S.indexOf(J);S[at]=S[S.length-1],S.pop(),J.destroy()}},releaseShaderCache:function(J){x.remove(J)},programs:S,dispose:function(){x.dispose()}}}function Ps(){let A=new WeakMap;return{get:function(e){let s=A.get(e);return void 0===s&&(s={},A.set(e,s)),s},remove:function(e){A.delete(e)},update:function(e,s,l){A.get(e)[s]=l},dispose:function(){A=new WeakMap}}}function Ac(A,e){return A.groupOrder!==e.groupOrder?A.groupOrder-e.groupOrder:A.renderOrder!==e.renderOrder?A.renderOrder-e.renderOrder:A.material.id!==e.material.id?A.material.id-e.material.id:A.z!==e.z?A.z-e.z:A.id-e.id}function Sf(A,e){return A.groupOrder!==e.groupOrder?A.groupOrder-e.groupOrder:A.renderOrder!==e.renderOrder?A.renderOrder-e.renderOrder:A.z!==e.z?e.z-A.z:A.id-e.id}function lp(){const A=[];let e=0;const s=[],l=[],c=[];function d(g,v,x,w,S,P){let z=A[e];return void 0===z?(z={id:g.id,object:g,geometry:v,material:x,groupOrder:w,renderOrder:g.renderOrder,z:S,group:P},A[e]=z):(z.id=g.id,z.object=g,z.geometry=v,z.material=x,z.groupOrder=w,z.renderOrder=g.renderOrder,z.z=S,z.group=P),e++,z}return{opaque:s,transmissive:l,transparent:c,init:function(){e=0,s.length=0,l.length=0,c.length=0},push:function(g,v,x,w,S,P){const z=d(g,v,x,w,S,P);x.transmission>0?l.push(z):!0===x.transparent?c.push(z):s.push(z)},unshift:function(g,v,x,w,S,P){const z=d(g,v,x,w,S,P);x.transmission>0?l.unshift(z):!0===x.transparent?c.unshift(z):s.unshift(z)},finish:function(){for(let g=e,v=A.length;g<v;g++){const x=A[g];if(null===x.id)break;x.id=null,x.object=null,x.geometry=null,x.material=null,x.group=null}},sort:function(g,v){s.length>1&&s.sort(g||Ac),l.length>1&&l.sort(v||Sf),c.length>1&&c.sort(v||Sf)}}}function mg(){let A=new WeakMap;return{get:function(e,s){const l=A.get(e);let c;return void 0===l?(c=new lp,A.set(e,[c])):s>=l.length?(c=new lp,l.push(c)):c=l[s],c},dispose:function(){A=new WeakMap}}}function gg(){const A={};return{get:function(e){if(void 0!==A[e.id])return A[e.id];let s;switch(e.type){case"DirectionalLight":s={direction:new Dt,color:new En};break;case"SpotLight":s={position:new Dt,direction:new Dt,color:new En,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":s={position:new Dt,color:new En,distance:0,decay:0};break;case"HemisphereLight":s={direction:new Dt,skyColor:new En,groundColor:new En};break;case"RectAreaLight":s={color:new En,position:new Dt,halfWidth:new Dt,halfHeight:new Dt}}return A[e.id]=s,s}}}let qu=0;function w0(A,e){return(e.castShadow?2:0)-(A.castShadow?2:0)+(e.map?1:0)-(A.map?1:0)}function E0(A){const e=new gg,s=function(){const v={};return{get:function(x){if(void 0!==v[x.id])return v[x.id];let w;switch(x.type){case"DirectionalLight":case"SpotLight":w={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ye};break;case"PointLight":w={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ye,shadowCameraNear:1,shadowCameraFar:1e3}}return v[x.id]=w,w}}}(),l={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let v=0;v<9;v++)l.probe.push(new Dt);const c=new Dt,d=new Yn,g=new Yn;return{setup:function(v,x){let w=0,S=0,P=0;for(let ee=0;ee<9;ee++)l.probe[ee].set(0,0,0);let z=0,W=0,Y=0,tt=0,J=0,at=0,it=0,ct=0,At=0,Ft=0,Tt=0;v.sort(w0);const Pt=!0===x?Math.PI:1;for(let ee=0,ce=v.length;ee<ce;ee++){const ne=v[ee],ge=ne.color,ie=ne.intensity,pe=ne.distance,Oe=ne.shadow&&ne.shadow.map?ne.shadow.map.texture:null;if(ne.isAmbientLight)w+=ge.r*ie*Pt,S+=ge.g*ie*Pt,P+=ge.b*ie*Pt;else if(ne.isLightProbe){for(let Pe=0;Pe<9;Pe++)l.probe[Pe].addScaledVector(ne.sh.coefficients[Pe],ie);Tt++}else if(ne.isDirectionalLight){const Pe=e.get(ne);if(Pe.color.copy(ne.color).multiplyScalar(ne.intensity*Pt),ne.castShadow){const ze=ne.shadow,Fe=s.get(ne);Fe.shadowBias=ze.bias,Fe.shadowNormalBias=ze.normalBias,Fe.shadowRadius=ze.radius,Fe.shadowMapSize=ze.mapSize,l.directionalShadow[z]=Fe,l.directionalShadowMap[z]=Oe,l.directionalShadowMatrix[z]=ne.shadow.matrix,at++}l.directional[z]=Pe,z++}else if(ne.isSpotLight){const Pe=e.get(ne);Pe.position.setFromMatrixPosition(ne.matrixWorld),Pe.color.copy(ge).multiplyScalar(ie*Pt),Pe.distance=pe,Pe.coneCos=Math.cos(ne.angle),Pe.penumbraCos=Math.cos(ne.angle*(1-ne.penumbra)),Pe.decay=ne.decay,l.spot[Y]=Pe;const ze=ne.shadow;if(ne.map&&(l.spotLightMap[At]=ne.map,At++,ze.updateMatrices(ne),ne.castShadow&&Ft++),l.spotLightMatrix[Y]=ze.matrix,ne.castShadow){const Fe=s.get(ne);Fe.shadowBias=ze.bias,Fe.shadowNormalBias=ze.normalBias,Fe.shadowRadius=ze.radius,Fe.shadowMapSize=ze.mapSize,l.spotShadow[Y]=Fe,l.spotShadowMap[Y]=Oe,ct++}Y++}else if(ne.isRectAreaLight){const Pe=e.get(ne);Pe.color.copy(ge).multiplyScalar(ie),Pe.halfWidth.set(.5*ne.width,0,0),Pe.halfHeight.set(0,.5*ne.height,0),l.rectArea[tt]=Pe,tt++}else if(ne.isPointLight){const Pe=e.get(ne);if(Pe.color.copy(ne.color).multiplyScalar(ne.intensity*Pt),Pe.distance=ne.distance,Pe.decay=ne.decay,ne.castShadow){const ze=ne.shadow,Fe=s.get(ne);Fe.shadowBias=ze.bias,Fe.shadowNormalBias=ze.normalBias,Fe.shadowRadius=ze.radius,Fe.shadowMapSize=ze.mapSize,Fe.shadowCameraNear=ze.camera.near,Fe.shadowCameraFar=ze.camera.far,l.pointShadow[W]=Fe,l.pointShadowMap[W]=Oe,l.pointShadowMatrix[W]=ne.shadow.matrix,it++}l.point[W]=Pe,W++}else if(ne.isHemisphereLight){const Pe=e.get(ne);Pe.skyColor.copy(ne.color).multiplyScalar(ie*Pt),Pe.groundColor.copy(ne.groundColor).multiplyScalar(ie*Pt),l.hemi[J]=Pe,J++}}tt>0&&(!0===A.has("OES_texture_float_linear")?(l.rectAreaLTC1=Bn.LTC_FLOAT_1,l.rectAreaLTC2=Bn.LTC_FLOAT_2):(l.rectAreaLTC1=Bn.LTC_HALF_1,l.rectAreaLTC2=Bn.LTC_HALF_2)),l.ambient[0]=w,l.ambient[1]=S,l.ambient[2]=P;const zt=l.hash;zt.directionalLength===z&&zt.pointLength===W&&zt.spotLength===Y&&zt.rectAreaLength===tt&&zt.hemiLength===J&&zt.numDirectionalShadows===at&&zt.numPointShadows===it&&zt.numSpotShadows===ct&&zt.numSpotMaps===At&&zt.numLightProbes===Tt||(l.directional.length=z,l.spot.length=Y,l.rectArea.length=tt,l.point.length=W,l.hemi.length=J,l.directionalShadow.length=at,l.directionalShadowMap.length=at,l.pointShadow.length=it,l.pointShadowMap.length=it,l.spotShadow.length=ct,l.spotShadowMap.length=ct,l.directionalShadowMatrix.length=at,l.pointShadowMatrix.length=it,l.spotLightMatrix.length=ct+At-Ft,l.spotLightMap.length=At,l.numSpotLightShadowsWithMaps=Ft,l.numLightProbes=Tt,zt.directionalLength=z,zt.pointLength=W,zt.spotLength=Y,zt.rectAreaLength=tt,zt.hemiLength=J,zt.numDirectionalShadows=at,zt.numPointShadows=it,zt.numSpotShadows=ct,zt.numSpotMaps=At,zt.numLightProbes=Tt,l.version=qu++)},setupView:function(v,x){let w=0,S=0,P=0,z=0,W=0;const Y=x.matrixWorldInverse;for(let tt=0,J=v.length;tt<J;tt++){const at=v[tt];if(at.isDirectionalLight){const it=l.directional[w];it.direction.setFromMatrixPosition(at.matrixWorld),c.setFromMatrixPosition(at.target.matrixWorld),it.direction.sub(c),it.direction.transformDirection(Y),w++}else if(at.isSpotLight){const it=l.spot[P];it.position.setFromMatrixPosition(at.matrixWorld),it.position.applyMatrix4(Y),it.direction.setFromMatrixPosition(at.matrixWorld),c.setFromMatrixPosition(at.target.matrixWorld),it.direction.sub(c),it.direction.transformDirection(Y),P++}else if(at.isRectAreaLight){const it=l.rectArea[z];it.position.setFromMatrixPosition(at.matrixWorld),it.position.applyMatrix4(Y),g.identity(),d.copy(at.matrixWorld),d.premultiply(Y),g.extractRotation(d),it.halfWidth.set(.5*at.width,0,0),it.halfHeight.set(0,.5*at.height,0),it.halfWidth.applyMatrix4(g),it.halfHeight.applyMatrix4(g),z++}else if(at.isPointLight){const it=l.point[S];it.position.setFromMatrixPosition(at.matrixWorld),it.position.applyMatrix4(Y),S++}else if(at.isHemisphereLight){const it=l.hemi[W];it.direction.setFromMatrixPosition(at.matrixWorld),it.direction.transformDirection(Y),W++}}},state:l}}function C0(A){const e=new E0(A),s=[],l=[],c={lightsArray:s,shadowsArray:l,camera:null,lights:e,transmissionRenderTarget:{}};return{init:function(d){c.camera=d,s.length=0,l.length=0},state:c,setupLights:function(d){e.setup(s,d)},setupLightsView:function(d){e.setupView(s,d)},pushLight:function(d){s.push(d)},pushShadow:function(d){l.push(d)}}}function Ag(A){let e=new WeakMap;return{get:function(s,l=0){const c=e.get(s);let d;return void 0===c?(d=new C0(A),e.set(s,[d])):l>=c.length?(d=new C0(A),c.push(d)):d=c[l],d},dispose:function(){e=new WeakMap}}}class Wh extends di{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Pl,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class cu extends di{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}function I0(A,e,s){let l=new Ra;const c=new Ye,d=new Ye,g=new li,v=new Wh({depthPacking:Wo}),x=new cu,w={},S=s.maxTextureSize,P={[Q]:X,[X]:Q,[lt]:lt},z=new xl({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ye},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),W=z.clone();W.defines.HORIZONTAL_PASS=1;const Y=new gr;Y.setAttribute("position",new wr(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const tt=new os(Y,z),J=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=k;let at=this.type;function it(Tt,Pt){const zt=e.update(tt);z.defines.VSM_SAMPLES!==Tt.blurSamples&&(z.defines.VSM_SAMPLES=Tt.blurSamples,W.defines.VSM_SAMPLES=Tt.blurSamples,z.needsUpdate=!0,W.needsUpdate=!0),null===Tt.mapPass&&(Tt.mapPass=new bo(c.x,c.y)),z.uniforms.shadow_pass.value=Tt.map.texture,z.uniforms.resolution.value=Tt.mapSize,z.uniforms.radius.value=Tt.radius,A.setRenderTarget(Tt.mapPass),A.clear(),A.renderBufferDirect(Pt,null,zt,z,tt,null),W.uniforms.shadow_pass.value=Tt.mapPass.texture,W.uniforms.resolution.value=Tt.mapSize,W.uniforms.radius.value=Tt.radius,A.setRenderTarget(Tt.map),A.clear(),A.renderBufferDirect(Pt,null,zt,W,tt,null)}function ct(Tt,Pt,zt,ee){let ce=null;const ne=!0===zt.isPointLight?Tt.customDistanceMaterial:Tt.customDepthMaterial;if(void 0!==ne)ce=ne;else if(ce=!0===zt.isPointLight?x:v,A.localClippingEnabled&&!0===Pt.clipShadows&&Array.isArray(Pt.clippingPlanes)&&0!==Pt.clippingPlanes.length||Pt.displacementMap&&0!==Pt.displacementScale||Pt.alphaMap&&Pt.alphaTest>0||Pt.map&&Pt.alphaTest>0){const ge=ce.uuid,ie=Pt.uuid;let pe=w[ge];void 0===pe&&(pe={},w[ge]=pe);let Oe=pe[ie];void 0===Oe&&(Oe=ce.clone(),pe[ie]=Oe,Pt.addEventListener("dispose",Ft)),ce=Oe}return ce.visible=Pt.visible,ce.wireframe=Pt.wireframe,ce.side=ee===G?null!==Pt.shadowSide?Pt.shadowSide:Pt.side:null!==Pt.shadowSide?Pt.shadowSide:P[Pt.side],ce.alphaMap=Pt.alphaMap,ce.alphaTest=Pt.alphaTest,ce.map=Pt.map,ce.clipShadows=Pt.clipShadows,ce.clippingPlanes=Pt.clippingPlanes,ce.clipIntersection=Pt.clipIntersection,ce.displacementMap=Pt.displacementMap,ce.displacementScale=Pt.displacementScale,ce.displacementBias=Pt.displacementBias,ce.wireframeLinewidth=Pt.wireframeLinewidth,ce.linewidth=Pt.linewidth,!0===zt.isPointLight&&!0===ce.isMeshDistanceMaterial&&(A.properties.get(ce).light=zt),ce}function At(Tt,Pt,zt,ee,ce){if(!1===Tt.visible)return;if(Tt.layers.test(Pt.layers)&&(Tt.isMesh||Tt.isLine||Tt.isPoints)&&(Tt.castShadow||Tt.receiveShadow&&ce===G)&&(!Tt.frustumCulled||l.intersectsObject(Tt))){Tt.modelViewMatrix.multiplyMatrices(zt.matrixWorldInverse,Tt.matrixWorld);const ge=e.update(Tt),ie=Tt.material;if(Array.isArray(ie)){const pe=ge.groups;for(let Oe=0,Pe=pe.length;Oe<Pe;Oe++){const ze=pe[Oe],Fe=ie[ze.materialIndex];if(Fe&&Fe.visible){const Dn=ct(Tt,Fe,ee,ce);Tt.onBeforeShadow(A,Tt,Pt,zt,ge,Dn,ze),A.renderBufferDirect(zt,null,ge,Dn,Tt,ze),Tt.onAfterShadow(A,Tt,Pt,zt,ge,Dn,ze)}}}else if(ie.visible){const pe=ct(Tt,ie,ee,ce);Tt.onBeforeShadow(A,Tt,Pt,zt,ge,pe,null),A.renderBufferDirect(zt,null,ge,pe,Tt,null),Tt.onAfterShadow(A,Tt,Pt,zt,ge,pe,null)}}const ne=Tt.children;for(let ge=0,ie=ne.length;ge<ie;ge++)At(ne[ge],Pt,zt,ee,ce)}function Ft(Tt){Tt.target.removeEventListener("dispose",Ft);for(const Pt in w){const zt=w[Pt],ee=Tt.target.uuid;ee in zt&&(zt[ee].dispose(),delete zt[ee])}}this.render=function(Tt,Pt,zt){if(!1===J.enabled||!1===J.autoUpdate&&!1===J.needsUpdate||0===Tt.length)return;const ee=A.getRenderTarget(),ce=A.getActiveCubeFace(),ne=A.getActiveMipmapLevel(),ge=A.state;ge.setBlending(rt),ge.buffers.color.setClear(1,1,1,1),ge.buffers.depth.setTest(!0),ge.setScissorTest(!1);const ie=at!==G&&this.type===G,pe=at===G&&this.type!==G;for(let Oe=0,Pe=Tt.length;Oe<Pe;Oe++){const ze=Tt[Oe],Fe=ze.shadow;if(void 0===Fe){console.warn("THREE.WebGLShadowMap:",ze,"has no shadow.");continue}if(!1===Fe.autoUpdate&&!1===Fe.needsUpdate)continue;c.copy(Fe.mapSize);const Dn=Fe.getFrameExtents();if(c.multiply(Dn),d.copy(Fe.mapSize),(c.x>S||c.y>S)&&(c.x>S&&(d.x=Math.floor(S/Dn.x),c.x=d.x*Dn.x,Fe.mapSize.x=d.x),c.y>S&&(d.y=Math.floor(S/Dn.y),c.y=d.y*Dn.y,Fe.mapSize.y=d.y)),null===Fe.map||!0===ie||!0===pe){const fn=this.type!==G?{minFilter:be,magFilter:be}:{};null!==Fe.map&&Fe.map.dispose(),Fe.map=new bo(c.x,c.y,fn),Fe.map.texture.name=ze.name+".shadowMap",Fe.camera.updateProjectionMatrix()}A.setRenderTarget(Fe.map),A.clear();const Nn=Fe.getViewportCount();for(let fn=0;fn<Nn;fn++){const xn=Fe.getViewport(fn);g.set(d.x*xn.x,d.y*xn.y,d.x*xn.z,d.y*xn.w),ge.viewport(g),Fe.updateMatrices(ze,fn),l=Fe.getFrustum(),At(Pt,zt,Fe.camera,ze,this.type)}!0!==Fe.isPointLightShadow&&this.type===G&&it(Fe,zt),Fe.needsUpdate=!1}at=this.type,J.needsUpdate=!1,A.setRenderTarget(ee,ce,ne)}}function S0(A){const e=new function(){let Et=!1;const re=new li;let $t=null;const oe=new li(0,0,0,0);return{setMask:function(fe){$t===fe||Et||(A.colorMask(fe,fe,fe,fe),$t=fe)},setLocked:function(fe){Et=fe},setClear:function(fe,ye,Xe,Fn,An){!0===An&&(fe*=Fn,ye*=Fn,Xe*=Fn),re.set(fe,ye,Xe,Fn),!1===oe.equals(re)&&(A.clearColor(fe,ye,Xe,Fn),oe.copy(re))},reset:function(){Et=!1,$t=null,oe.set(-1,0,0,0)}}},s=new function(){let Et=!1,re=null,$t=null,oe=null;return{setTest:function(fe){fe?In(A.DEPTH_TEST):Mn(A.DEPTH_TEST)},setMask:function(fe){re===fe||Et||(A.depthMask(fe),re=fe)},setFunc:function(fe){if($t!==fe){switch(fe){case js:A.depthFunc(A.NEVER);break;case Xa:A.depthFunc(A.ALWAYS);break;case Ya:A.depthFunc(A.LESS);break;case _i:A.depthFunc(A.LEQUAL);break;case ys:A.depthFunc(A.EQUAL);break;case To:A.depthFunc(A.GEQUAL);break;case qs:A.depthFunc(A.GREATER);break;case se:A.depthFunc(A.NOTEQUAL);break;default:A.depthFunc(A.LEQUAL)}$t=fe}},setLocked:function(fe){Et=fe},setClear:function(fe){oe!==fe&&(A.clearDepth(fe),oe=fe)},reset:function(){Et=!1,re=null,$t=null,oe=null}}},l=new function(){let Et=!1,re=null,$t=null,oe=null,fe=null,ye=null,Xe=null,Fn=null,An=null;return{setTest:function(Un){Et||(Un?In(A.STENCIL_TEST):Mn(A.STENCIL_TEST))},setMask:function(Un){re===Un||Et||(A.stencilMask(Un),re=Un)},setFunc:function(Un,ar,$n){$t===Un&&oe===ar&&fe===$n||(A.stencilFunc(Un,ar,$n),$t=Un,oe=ar,fe=$n)},setOp:function(Un,ar,$n){ye===Un&&Xe===ar&&Fn===$n||(A.stencilOp(Un,ar,$n),ye=Un,Xe=ar,Fn=$n)},setLocked:function(Un){Et=Un},setClear:function(Un){An!==Un&&(A.clearStencil(Un),An=Un)},reset:function(){Et=!1,re=null,$t=null,oe=null,fe=null,ye=null,Xe=null,Fn=null,An=null}}},c=new WeakMap,d=new WeakMap;let g={},v={},x=new WeakMap,w=[],S=null,P=!1,z=null,W=null,Y=null,tt=null,J=null,at=null,it=null,ct=new En(0,0,0),At=0,Ft=!1,Tt=null,Pt=null,zt=null,ee=null,ce=null;const ne=A.getParameter(A.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let ge=!1,ie=0;const pe=A.getParameter(A.VERSION);-1!==pe.indexOf("WebGL")?(ie=parseFloat(/^WebGL (\d)/.exec(pe)[1]),ge=ie>=1):-1!==pe.indexOf("OpenGL ES")&&(ie=parseFloat(/^OpenGL ES (\d)/.exec(pe)[1]),ge=ie>=2);let Oe=null,Pe={};const ze=A.getParameter(A.SCISSOR_BOX),Fe=A.getParameter(A.VIEWPORT),Dn=(new li).fromArray(ze),Nn=(new li).fromArray(Fe);function fn(Et,re,$t,oe){const fe=new Uint8Array(4),ye=A.createTexture();A.bindTexture(Et,ye),A.texParameteri(Et,A.TEXTURE_MIN_FILTER,A.NEAREST),A.texParameteri(Et,A.TEXTURE_MAG_FILTER,A.NEAREST);for(let Xe=0;Xe<$t;Xe++)Et===A.TEXTURE_3D||Et===A.TEXTURE_2D_ARRAY?A.texImage3D(re,0,A.RGBA,1,1,oe,0,A.RGBA,A.UNSIGNED_BYTE,fe):A.texImage2D(re+Xe,0,A.RGBA,1,1,0,A.RGBA,A.UNSIGNED_BYTE,fe);return ye}const xn={};function In(Et){!0!==g[Et]&&(A.enable(Et),g[Et]=!0)}function Mn(Et){!1!==g[Et]&&(A.disable(Et),g[Et]=!1)}xn[A.TEXTURE_2D]=fn(A.TEXTURE_2D,A.TEXTURE_2D,1),xn[A.TEXTURE_CUBE_MAP]=fn(A.TEXTURE_CUBE_MAP,A.TEXTURE_CUBE_MAP_POSITIVE_X,6),xn[A.TEXTURE_2D_ARRAY]=fn(A.TEXTURE_2D_ARRAY,A.TEXTURE_2D_ARRAY,1,1),xn[A.TEXTURE_3D]=fn(A.TEXTURE_3D,A.TEXTURE_3D,1,1),e.setClear(0,0,0,1),s.setClear(1),l.setClear(0),In(A.DEPTH_TEST),s.setFunc(_i),ln(!1),Lt(D),In(A.CULL_FACE),On(rt);const Ce={[et]:A.FUNC_ADD,[xt]:A.FUNC_SUBTRACT,[Rt]:A.FUNC_REVERSE_SUBTRACT};Ce[Yt]=A.MIN,Ce[ve]=A.MAX;const rn={[xe]:A.ZERO,[Ge]:A.ONE,[en]:A.SRC_COLOR,[vn]:A.SRC_ALPHA,[Is]:A.SRC_ALPHA_SATURATE,[Cs]:A.DST_COLOR,[nr]:A.DST_ALPHA,[nn]:A.ONE_MINUS_SRC_COLOR,[_n]:A.ONE_MINUS_SRC_ALPHA,[Ti]:A.ONE_MINUS_DST_COLOR,[hr]:A.ONE_MINUS_DST_ALPHA,[As]:A.CONSTANT_COLOR,[ua]:A.ONE_MINUS_CONSTANT_COLOR,[Oa]:A.CONSTANT_ALPHA,[ha]:A.ONE_MINUS_CONSTANT_ALPHA};function On(Et,re,$t,oe,fe,ye,Xe,Fn,An,Un){if(Et!==rt){if(!1===P&&(In(A.BLEND),P=!0),Et===wt)fe=fe||re,ye=ye||$t,Xe=Xe||oe,re===W&&fe===J||(A.blendEquationSeparate(Ce[re],Ce[fe]),W=re,J=fe),$t===Y&&oe===tt&&ye===at&&Xe===it||(A.blendFuncSeparate(rn[$t],rn[oe],rn[ye],rn[Xe]),Y=$t,tt=oe,at=ye,it=Xe),!1!==Fn.equals(ct)&&An===At||(A.blendColor(Fn.r,Fn.g,Fn.b,An),ct.copy(Fn),At=An),z=Et,Ft=!1;else if(Et!==z||Un!==Ft){if(W===et&&J===et||(A.blendEquation(A.FUNC_ADD),W=et,J=et),Un)switch(Et){case pt:A.blendFuncSeparate(A.ONE,A.ONE_MINUS_SRC_ALPHA,A.ONE,A.ONE_MINUS_SRC_ALPHA);break;case vt:A.blendFunc(A.ONE,A.ONE);break;case bt:A.blendFuncSeparate(A.ZERO,A.ONE_MINUS_SRC_COLOR,A.ZERO,A.ONE);break;case ft:A.blendFuncSeparate(A.ZERO,A.SRC_COLOR,A.ZERO,A.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",Et)}else switch(Et){case pt:A.blendFuncSeparate(A.SRC_ALPHA,A.ONE_MINUS_SRC_ALPHA,A.ONE,A.ONE_MINUS_SRC_ALPHA);break;case vt:A.blendFunc(A.SRC_ALPHA,A.ONE);break;case bt:A.blendFuncSeparate(A.ZERO,A.ONE_MINUS_SRC_COLOR,A.ZERO,A.ONE);break;case ft:A.blendFunc(A.ZERO,A.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",Et)}Y=null,tt=null,at=null,it=null,ct.set(0,0,0),At=0,z=Et,Ft=Un}}else!0===P&&(Mn(A.BLEND),P=!1)}function ln(Et){Tt!==Et&&(A.frontFace(Et?A.CW:A.CCW),Tt=Et)}function Lt(Et){Et!==E?(In(A.CULL_FACE),Et!==Pt&&A.cullFace(Et===D?A.BACK:Et===B?A.FRONT:A.FRONT_AND_BACK)):Mn(A.CULL_FACE),Pt=Et}function St(Et,re,$t){Et?(In(A.POLYGON_OFFSET_FILL),ee===re&&ce===$t||(A.polygonOffset(re,$t),ee=re,ce=$t)):Mn(A.POLYGON_OFFSET_FILL)}return{buffers:{color:e,depth:s,stencil:l},enable:In,disable:Mn,bindFramebuffer:function(Et,re){return v[Et]!==re&&(A.bindFramebuffer(Et,re),v[Et]=re,Et===A.DRAW_FRAMEBUFFER&&(v[A.FRAMEBUFFER]=re),Et===A.FRAMEBUFFER&&(v[A.DRAW_FRAMEBUFFER]=re),!0)},drawBuffers:function(Et,re){let $t=w,oe=!1;if(Et){$t=x.get(re),void 0===$t&&($t=[],x.set(re,$t));const fe=Et.textures;if($t.length!==fe.length||$t[0]!==A.COLOR_ATTACHMENT0){for(let ye=0,Xe=fe.length;ye<Xe;ye++)$t[ye]=A.COLOR_ATTACHMENT0+ye;$t.length=fe.length,oe=!0}}else $t[0]!==A.BACK&&($t[0]=A.BACK,oe=!0);oe&&A.drawBuffers($t)},useProgram:function(Et){return S!==Et&&(A.useProgram(Et),S=Et,!0)},setBlending:On,setMaterial:function(Et,re){Et.side===lt?Mn(A.CULL_FACE):In(A.CULL_FACE);let $t=Et.side===X;re&&($t=!$t),ln($t),Et.blending===pt&&!1===Et.transparent?On(rt):On(Et.blending,Et.blendEquation,Et.blendSrc,Et.blendDst,Et.blendEquationAlpha,Et.blendSrcAlpha,Et.blendDstAlpha,Et.blendColor,Et.blendAlpha,Et.premultipliedAlpha),s.setFunc(Et.depthFunc),s.setTest(Et.depthTest),s.setMask(Et.depthWrite),e.setMask(Et.colorWrite);const oe=Et.stencilWrite;l.setTest(oe),oe&&(l.setMask(Et.stencilWriteMask),l.setFunc(Et.stencilFunc,Et.stencilRef,Et.stencilFuncMask),l.setOp(Et.stencilFail,Et.stencilZFail,Et.stencilZPass)),St(Et.polygonOffset,Et.polygonOffsetFactor,Et.polygonOffsetUnits),!0===Et.alphaToCoverage?In(A.SAMPLE_ALPHA_TO_COVERAGE):Mn(A.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:ln,setCullFace:Lt,setLineWidth:function(Et){Et!==zt&&(ge&&A.lineWidth(Et),zt=Et)},setPolygonOffset:St,setScissorTest:function(Et){Et?In(A.SCISSOR_TEST):Mn(A.SCISSOR_TEST)},activeTexture:function(Et){void 0===Et&&(Et=A.TEXTURE0+ne-1),Oe!==Et&&(A.activeTexture(Et),Oe=Et)},bindTexture:function(Et,re,$t){void 0===$t&&($t=null===Oe?A.TEXTURE0+ne-1:Oe);let oe=Pe[$t];void 0===oe&&(oe={type:void 0,texture:void 0},Pe[$t]=oe),oe.type===Et&&oe.texture===re||(Oe!==$t&&(A.activeTexture($t),Oe=$t),A.bindTexture(Et,re||xn[Et]),oe.type=Et,oe.texture=re)},unbindTexture:function(){const Et=Pe[Oe];void 0!==Et&&void 0!==Et.type&&(A.bindTexture(Et.type,null),Et.type=void 0,Et.texture=void 0)},compressedTexImage2D:function(){try{A.compressedTexImage2D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},compressedTexImage3D:function(){try{A.compressedTexImage3D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},texImage2D:function(){try{A.texImage2D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},texImage3D:function(){try{A.texImage3D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},updateUBOMapping:function(Et,re){let $t=d.get(re);void 0===$t&&($t=new WeakMap,d.set(re,$t));let oe=$t.get(Et);void 0===oe&&(oe=A.getUniformBlockIndex(re,Et.name),$t.set(Et,oe))},uniformBlockBinding:function(Et,re){const $t=d.get(re).get(Et);c.get(re)!==$t&&(A.uniformBlockBinding(re,$t,Et.__bindingPointIndex),c.set(re,$t))},texStorage2D:function(){try{A.texStorage2D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},texStorage3D:function(){try{A.texStorage3D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},texSubImage2D:function(){try{A.texSubImage2D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},texSubImage3D:function(){try{A.texSubImage3D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},compressedTexSubImage2D:function(){try{A.compressedTexSubImage2D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},compressedTexSubImage3D:function(){try{A.compressedTexSubImage3D.apply(A,arguments)}catch(Et){console.error("THREE.WebGLState:",Et)}},scissor:function(Et){!1===Dn.equals(Et)&&(A.scissor(Et.x,Et.y,Et.z,Et.w),Dn.copy(Et))},viewport:function(Et){!1===Nn.equals(Et)&&(A.viewport(Et.x,Et.y,Et.z,Et.w),Nn.copy(Et))},reset:function(){A.disable(A.BLEND),A.disable(A.CULL_FACE),A.disable(A.DEPTH_TEST),A.disable(A.POLYGON_OFFSET_FILL),A.disable(A.SCISSOR_TEST),A.disable(A.STENCIL_TEST),A.disable(A.SAMPLE_ALPHA_TO_COVERAGE),A.blendEquation(A.FUNC_ADD),A.blendFunc(A.ONE,A.ZERO),A.blendFuncSeparate(A.ONE,A.ZERO,A.ONE,A.ZERO),A.blendColor(0,0,0,0),A.colorMask(!0,!0,!0,!0),A.clearColor(0,0,0,0),A.depthMask(!0),A.depthFunc(A.LESS),A.clearDepth(1),A.stencilMask(4294967295),A.stencilFunc(A.ALWAYS,0,4294967295),A.stencilOp(A.KEEP,A.KEEP,A.KEEP),A.clearStencil(0),A.cullFace(A.BACK),A.frontFace(A.CCW),A.polygonOffset(0,0),A.activeTexture(A.TEXTURE0),A.bindFramebuffer(A.FRAMEBUFFER,null),A.bindFramebuffer(A.DRAW_FRAMEBUFFER,null),A.bindFramebuffer(A.READ_FRAMEBUFFER,null),A.useProgram(null),A.lineWidth(1),A.scissor(0,0,A.canvas.width,A.canvas.height),A.viewport(0,0,A.canvas.width,A.canvas.height),g={},Oe=null,Pe={},v={},x=new WeakMap,w=[],S=null,P=!1,z=null,W=null,Y=null,tt=null,J=null,at=null,it=null,ct=new En(0,0,0),At=0,Ft=!1,Tt=null,Pt=null,zt=null,ee=null,ce=null,Dn.set(0,0,A.canvas.width,A.canvas.height),Nn.set(0,0,A.canvas.width,A.canvas.height),e.reset(),s.reset(),l.reset()}}}function M0(A,e,s,l,c,d,g){const v=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,x=typeof navigator<"u"&&/OculusBrowser/g.test(navigator.userAgent),w=e.has("OCULUS_multiview")?e.get("OCULUS_multiview"):null,S=new Ye,P=new WeakMap;let z;const W=new WeakMap;let Y=[],tt=!1,J=!1;try{J=typeof OffscreenCanvas<"u"&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch{}function at(Lt,St){return J?new OffscreenCanvas(Lt,St):Qc("canvas")}function it(Lt,St,Et){let re=1;const $t=ln(Lt);if(($t.width>Et||$t.height>Et)&&(re=Et/Math.max($t.width,$t.height)),re<1){if(typeof HTMLImageElement<"u"&&Lt instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&Lt instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&Lt instanceof ImageBitmap||typeof VideoFrame<"u"&&Lt instanceof VideoFrame){const oe=Math.floor(re*$t.width),fe=Math.floor(re*$t.height);void 0===z&&(z=at(oe,fe));const ye=St?at(oe,fe):z;return ye.width=oe,ye.height=fe,ye.getContext("2d").drawImage(Lt,0,0,oe,fe),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+$t.width+"x"+$t.height+") to ("+oe+"x"+fe+")."),ye}return"data"in Lt&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+$t.width+"x"+$t.height+")."),Lt}return Lt}function ct(Lt){return Lt.generateMipmaps&&Lt.minFilter!==be&&Lt.minFilter!==cn}function At(Lt){A.generateMipmap(Lt)}function Ft(Lt,St,Et,re,$t=!1){if(null!==Lt){if(void 0!==A[Lt])return A[Lt];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+Lt+"'")}let oe=St;if(St===A.RED&&(Et===A.FLOAT&&(oe=A.R32F),Et===A.HALF_FLOAT&&(oe=A.R16F),Et===A.UNSIGNED_BYTE&&(oe=A.R8)),St===A.RED_INTEGER&&(Et===A.UNSIGNED_BYTE&&(oe=A.R8UI),Et===A.UNSIGNED_SHORT&&(oe=A.R16UI),Et===A.UNSIGNED_INT&&(oe=A.R32UI),Et===A.BYTE&&(oe=A.R8I),Et===A.SHORT&&(oe=A.R16I),Et===A.INT&&(oe=A.R32I)),St===A.RG&&(Et===A.FLOAT&&(oe=A.RG32F),Et===A.HALF_FLOAT&&(oe=A.RG16F),Et===A.UNSIGNED_BYTE&&(oe=A.RG8)),St===A.RG_INTEGER&&(Et===A.UNSIGNED_BYTE&&(oe=A.RG8UI),Et===A.UNSIGNED_SHORT&&(oe=A.RG16UI),Et===A.UNSIGNED_INT&&(oe=A.RG32UI),Et===A.BYTE&&(oe=A.RG8I),Et===A.SHORT&&(oe=A.RG16I),Et===A.INT&&(oe=A.RG32I)),St===A.RGB&&Et===A.UNSIGNED_INT_5_9_9_9_REV&&(oe=A.RGB9_E5),St===A.RGBA){const fe=$t?ac:Jr.getTransfer(re);Et===A.FLOAT&&(oe=A.RGBA32F),Et===A.HALF_FLOAT&&(oe=A.RGBA16F),Et===A.UNSIGNED_BYTE&&(oe=fe===Ii?A.SRGB8_ALPHA8:A.RGBA8),Et===A.UNSIGNED_SHORT_4_4_4_4&&(oe=A.RGBA4),Et===A.UNSIGNED_SHORT_5_5_5_1&&(oe=A.RGB5_A1)}return oe!==A.R16F&&oe!==A.R32F&&oe!==A.RG16F&&oe!==A.RG32F&&oe!==A.RGBA16F&&oe!==A.RGBA32F||e.get("EXT_color_buffer_float"),oe}function Tt(Lt,St){return!0===ct(Lt)||Lt.isFramebufferTexture&&Lt.minFilter!==be&&Lt.minFilter!==cn?Math.log2(Math.max(St.width,St.height))+1:void 0!==Lt.mipmaps&&Lt.mipmaps.length>0?Lt.mipmaps.length:Lt.isCompressedTexture&&Array.isArray(Lt.image)?St.mipmaps.length:1}function Pt(Lt){const St=Lt.target;St.removeEventListener("dispose",Pt),function(Et){const re=l.get(Et);if(void 0===re.__webglInit)return;const $t=Et.source,oe=W.get($t);if(oe){const fe=oe[re.__cacheKey];fe.usedTimes--,0===fe.usedTimes&&ee(Et),0===Object.keys(oe).length&&W.delete($t)}l.remove(Et)}(St),St.isVideoTexture&&P.delete(St)}function zt(Lt){const St=Lt.target;St.removeEventListener("dispose",zt),function(Et){const re=l.get(Et);if(Et.depthTexture&&Et.depthTexture.dispose(),Et.isWebGLCubeRenderTarget)for(let oe=0;oe<6;oe++){if(Array.isArray(re.__webglFramebuffer[oe]))for(let fe=0;fe<re.__webglFramebuffer[oe].length;fe++)A.deleteFramebuffer(re.__webglFramebuffer[oe][fe]);else A.deleteFramebuffer(re.__webglFramebuffer[oe]);re.__webglDepthbuffer&&A.deleteRenderbuffer(re.__webglDepthbuffer[oe])}else{if(Array.isArray(re.__webglFramebuffer))for(let oe=0;oe<re.__webglFramebuffer.length;oe++)A.deleteFramebuffer(re.__webglFramebuffer[oe]);else A.deleteFramebuffer(re.__webglFramebuffer);if(re.__webglDepthbuffer&&A.deleteRenderbuffer(re.__webglDepthbuffer),re.__webglMultisampledFramebuffer&&A.deleteFramebuffer(re.__webglMultisampledFramebuffer),re.__webglColorRenderbuffer)for(let oe=0;oe<re.__webglColorRenderbuffer.length;oe++)re.__webglColorRenderbuffer[oe]&&A.deleteRenderbuffer(re.__webglColorRenderbuffer[oe]);re.__webglDepthRenderbuffer&&A.deleteRenderbuffer(re.__webglDepthRenderbuffer)}const $t=Et.textures;for(let oe=0,fe=$t.length;oe<fe;oe++){const ye=l.get($t[oe]);ye.__webglTexture&&(A.deleteTexture(ye.__webglTexture),g.memory.textures--),l.remove($t[oe])}l.remove(Et)}(St)}function ee(Lt){const St=l.get(Lt);A.deleteTexture(St.__webglTexture),delete W.get(Lt.source)[St.__cacheKey],g.memory.textures--}let ce=0;function ne(Lt,St){const Et=l.get(Lt);if(Lt.isVideoTexture&&function(re){const $t=g.render.frame;P.get(re)!==$t&&(P.set(re,$t),re.update())}(Lt),!1===Lt.isRenderTargetTexture&&Lt.version>0&&Et.__version!==Lt.version){const re=Lt.image;if(null===re)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(!1===re.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else if(Fe(Et,Lt,St))return}s.bindTexture(A.TEXTURE_2D,Et.__webglTexture,A.TEXTURE0+St)}function ge(Lt,St){const Et=l.get(Lt);Lt.version>0&&Et.__version!==Lt.version?Fe(Et,Lt,St):s.bindTexture(A.TEXTURE_2D_ARRAY,Et.__webglTexture,A.TEXTURE0+St)}const ie={[ki]:A.REPEAT,[Ut]:A.CLAMP_TO_EDGE,[jt]:A.MIRRORED_REPEAT},pe={[be]:A.NEAREST,[Ze]:A.NEAREST_MIPMAP_NEAREST,[ke]:A.NEAREST_MIPMAP_LINEAR,[cn]:A.LINEAR,[bn]:A.LINEAR_MIPMAP_NEAREST,[Sn]:A.LINEAR_MIPMAP_LINEAR},Oe={[Bd]:A.NEVER,[Ld]:A.ALWAYS,[Nd]:A.LESS,[Eh]:A.LEQUAL,[XA]:A.EQUAL,[Ch]:A.GEQUAL,[tf]:A.GREATER,[Dd]:A.NOTEQUAL};function Pe(Lt,St){if(St.type!==wn||!1!==e.has("OES_texture_float_linear")||St.magFilter!==cn&&St.magFilter!==bn&&St.magFilter!==ke&&St.magFilter!==Sn&&St.minFilter!==cn&&St.minFilter!==bn&&St.minFilter!==ke&&St.minFilter!==Sn||console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),A.texParameteri(Lt,A.TEXTURE_WRAP_S,ie[St.wrapS]),A.texParameteri(Lt,A.TEXTURE_WRAP_T,ie[St.wrapT]),Lt!==A.TEXTURE_3D&&Lt!==A.TEXTURE_2D_ARRAY||A.texParameteri(Lt,A.TEXTURE_WRAP_R,ie[St.wrapR]),A.texParameteri(Lt,A.TEXTURE_MAG_FILTER,pe[St.magFilter]),A.texParameteri(Lt,A.TEXTURE_MIN_FILTER,pe[St.minFilter]),St.compareFunction&&(A.texParameteri(Lt,A.TEXTURE_COMPARE_MODE,A.COMPARE_REF_TO_TEXTURE),A.texParameteri(Lt,A.TEXTURE_COMPARE_FUNC,Oe[St.compareFunction])),!0===e.has("EXT_texture_filter_anisotropic")){if(St.magFilter===be||St.minFilter!==ke&&St.minFilter!==Sn||St.type===wn&&!1===e.has("OES_texture_float_linear"))return;if(St.anisotropy>1||l.get(St).__currentAnisotropy){const Et=e.get("EXT_texture_filter_anisotropic");A.texParameterf(Lt,Et.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(St.anisotropy,c.getMaxAnisotropy())),l.get(St).__currentAnisotropy=St.anisotropy}}}function ze(Lt,St){let Et=!1;void 0===Lt.__webglInit&&(Lt.__webglInit=!0,St.addEventListener("dispose",Pt));const re=St.source;let $t=W.get(re);void 0===$t&&($t={},W.set(re,$t));const oe=function(fe){const ye=[];return ye.push(fe.wrapS),ye.push(fe.wrapT),ye.push(fe.wrapR||0),ye.push(fe.magFilter),ye.push(fe.minFilter),ye.push(fe.anisotropy),ye.push(fe.internalFormat),ye.push(fe.format),ye.push(fe.type),ye.push(fe.generateMipmaps),ye.push(fe.premultiplyAlpha),ye.push(fe.flipY),ye.push(fe.unpackAlignment),ye.push(fe.colorSpace),ye.join()}(St);if(oe!==Lt.__cacheKey){void 0===$t[oe]&&($t[oe]={texture:A.createTexture(),usedTimes:0},g.memory.textures++,Et=!0),$t[oe].usedTimes++;const fe=$t[Lt.__cacheKey];void 0!==fe&&($t[Lt.__cacheKey].usedTimes--,0===fe.usedTimes&&ee(St)),Lt.__cacheKey=oe,Lt.__webglTexture=$t[oe].texture}return Et}function Fe(Lt,St,Et){if(tt)return St.isPendingDeferredUpload||(St.isPendingDeferredUpload=!0,Y.push({textureProperties:Lt,texture:St,slot:Et})),!1;let re=A.TEXTURE_2D;(St.isDataArrayTexture||St.isCompressedArrayTexture)&&(re=A.TEXTURE_2D_ARRAY),St.isData3DTexture&&(re=A.TEXTURE_3D);const $t=ze(Lt,St),oe=St.source;s.bindTexture(re,Lt.__webglTexture,A.TEXTURE0+Et);const fe=l.get(oe);if(oe.version!==fe.__version||!0===$t){s.activeTexture(A.TEXTURE0+Et);const ye=Jr.getPrimaries(Jr.workingColorSpace),Xe=St.colorSpace===vo?null:Jr.getPrimaries(St.colorSpace),Fn=St.colorSpace===vo||ye===Xe?A.NONE:A.BROWSER_DEFAULT_WEBGL;A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL,St.flipY),A.pixelStorei(A.UNPACK_PREMULTIPLY_ALPHA_WEBGL,St.premultiplyAlpha),A.pixelStorei(A.UNPACK_ALIGNMENT,St.unpackAlignment),A.pixelStorei(A.UNPACK_COLORSPACE_CONVERSION_WEBGL,Fn);let An=it(St.image,!1,c.maxTextureSize);An=On(St,An);const Un=d.convert(St.format,St.colorSpace),ar=d.convert(St.type);let $n,sr=Ft(St.internalFormat,Un,ar,St.colorSpace,St.isVideoTexture);Pe(re,St);const Xr=St.mipmaps,Ir=!0!==St.isVideoTexture,kr=void 0===fe.__version||!0===$t,Qr=oe.dataReady,Ui=Tt(St,An);if(St.isDepthTexture)sr=A.DEPTH_COMPONENT16,St.type===wn?sr=A.DEPTH_COMPONENT32F:St.type===rr?sr=A.DEPTH_COMPONENT24:St.type===ai&&(sr=A.DEPTH24_STENCIL8),kr&&(Ir?s.texStorage2D(A.TEXTURE_2D,1,sr,An.width,An.height):s.texImage2D(A.TEXTURE_2D,0,sr,An.width,An.height,0,Un,ar,null));else if(St.isDataTexture)if(Xr.length>0){Ir&&kr&&s.texStorage2D(A.TEXTURE_2D,Ui,sr,Xr[0].width,Xr[0].height);for(let Zn=0,ts=Xr.length;Zn<ts;Zn++)$n=Xr[Zn],Ir?Qr&&s.texSubImage2D(A.TEXTURE_2D,Zn,0,0,$n.width,$n.height,Un,ar,$n.data):s.texImage2D(A.TEXTURE_2D,Zn,sr,$n.width,$n.height,0,Un,ar,$n.data);St.generateMipmaps=!1}else Ir?(kr&&s.texStorage2D(A.TEXTURE_2D,Ui,sr,An.width,An.height),Qr&&s.texSubImage2D(A.TEXTURE_2D,0,0,0,An.width,An.height,Un,ar,An.data)):s.texImage2D(A.TEXTURE_2D,0,sr,An.width,An.height,0,Un,ar,An.data);else if(St.isCompressedTexture)if(St.isCompressedArrayTexture){Ir&&kr&&s.texStorage3D(A.TEXTURE_2D_ARRAY,Ui,sr,Xr[0].width,Xr[0].height,An.depth);for(let Zn=0,ts=Xr.length;Zn<ts;Zn++)$n=Xr[Zn],St.format!==de?null!==Un?Ir?Qr&&s.compressedTexSubImage3D(A.TEXTURE_2D_ARRAY,Zn,0,0,0,$n.width,$n.height,An.depth,Un,$n.data,0,0):s.compressedTexImage3D(A.TEXTURE_2D_ARRAY,Zn,sr,$n.width,$n.height,An.depth,0,$n.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ir?Qr&&s.texSubImage3D(A.TEXTURE_2D_ARRAY,Zn,0,0,0,$n.width,$n.height,An.depth,Un,ar,$n.data):s.texImage3D(A.TEXTURE_2D_ARRAY,Zn,sr,$n.width,$n.height,An.depth,0,Un,ar,$n.data)}else{Ir&&kr&&s.texStorage2D(A.TEXTURE_2D,Ui,sr,Xr[0].width,Xr[0].height);for(let Zn=0,ts=Xr.length;Zn<ts;Zn++)$n=Xr[Zn],St.format!==de?null!==Un?Ir?Qr&&s.compressedTexSubImage2D(A.TEXTURE_2D,Zn,0,0,$n.width,$n.height,Un,$n.data):s.compressedTexImage2D(A.TEXTURE_2D,Zn,sr,$n.width,$n.height,0,$n.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ir?Qr&&s.texSubImage2D(A.TEXTURE_2D,Zn,0,0,$n.width,$n.height,Un,ar,$n.data):s.texImage2D(A.TEXTURE_2D,Zn,sr,$n.width,$n.height,0,Un,ar,$n.data)}else if(St.isDataArrayTexture)Ir?(kr&&s.texStorage3D(A.TEXTURE_2D_ARRAY,Ui,sr,An.width,An.height,An.depth),Qr&&s.texSubImage3D(A.TEXTURE_2D_ARRAY,0,0,0,0,An.width,An.height,An.depth,Un,ar,An.data)):s.texImage3D(A.TEXTURE_2D_ARRAY,0,sr,An.width,An.height,An.depth,0,Un,ar,An.data);else if(St.isData3DTexture)Ir?(kr&&s.texStorage3D(A.TEXTURE_3D,Ui,sr,An.width,An.height,An.depth),Qr&&s.texSubImage3D(A.TEXTURE_3D,0,0,0,0,An.width,An.height,An.depth,Un,ar,An.data)):s.texImage3D(A.TEXTURE_3D,0,sr,An.width,An.height,An.depth,0,Un,ar,An.data);else if(St.isFramebufferTexture){if(kr)if(Ir)s.texStorage2D(A.TEXTURE_2D,Ui,sr,An.width,An.height);else{let Zn=An.width,ts=An.height;for(let Gs=0;Gs<Ui;Gs++)s.texImage2D(A.TEXTURE_2D,Gs,sr,Zn,ts,0,Un,ar,null),Zn>>=1,ts>>=1}}else if(Xr.length>0){if(Ir&&kr){const Zn=ln(Xr[0]);s.texStorage2D(A.TEXTURE_2D,Ui,sr,Zn.width,Zn.height)}for(let Zn=0,ts=Xr.length;Zn<ts;Zn++)$n=Xr[Zn],Ir?Qr&&s.texSubImage2D(A.TEXTURE_2D,Zn,0,0,Un,ar,$n):s.texImage2D(A.TEXTURE_2D,Zn,sr,Un,ar,$n);St.generateMipmaps=!1}else if(Ir){if(kr){const Zn=ln(An);s.texStorage2D(A.TEXTURE_2D,Ui,sr,Zn.width,Zn.height)}Qr&&s.texSubImage2D(A.TEXTURE_2D,0,0,0,Un,ar,An)}else s.texImage2D(A.TEXTURE_2D,0,sr,Un,ar,An);ct(St)&&At(re),fe.__version=oe.version,St.onUpdate&&St.onUpdate(St)}return Lt.__version=St.version,!0}function Dn(Lt,St,Et,re,$t,oe){const fe=d.convert(Et.format,Et.colorSpace),ye=d.convert(Et.type),Xe=Ft(Et.internalFormat,fe,ye,Et.colorSpace);if(!l.get(St).__hasExternalTextures){const An=Math.max(1,St.width>>oe),Un=Math.max(1,St.height>>oe);!0===St.isWebGLMultiviewRenderTarget?s.texStorage3D(A.TEXTURE_2D_ARRAY,0,Xe,St.width,St.height,St.numViews):$t===A.TEXTURE_3D||$t===A.TEXTURE_2D_ARRAY?s.texImage3D($t,oe,Xe,An,Un,St.depth,0,fe,ye,null):s.texImage2D($t,oe,Xe,An,Un,0,fe,ye,null)}s.bindFramebuffer(A.FRAMEBUFFER,Lt);const Fn=rn(St);!0===St.isWebGLMultiviewRenderTarget?Fn?w.framebufferTextureMultisampleMultiviewOVR(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,l.get(Et).__webglTexture,0,Ce(St),0,St.numViews):w.framebufferTextureMultiviewOVR(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0,l.get(Et).__webglTexture,0,0,St.numViews):($t===A.TEXTURE_2D||$t>=A.TEXTURE_CUBE_MAP_POSITIVE_X&&$t<=A.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&(Fn?v.framebufferTexture2DMultisampleEXT(A.FRAMEBUFFER,re,$t,l.get(Et).__webglTexture,0,Ce(St)):A.framebufferTexture2D(A.FRAMEBUFFER,re,$t,l.get(Et).__webglTexture,oe)),s.bindFramebuffer(A.FRAMEBUFFER,null)}function Nn(Lt,St,Et){if(A.bindRenderbuffer(A.RENDERBUFFER,Lt),!0===St.isWebGLMultiviewRenderTarget){const re=rn(St),$t=St.numViews,oe=St.depthTexture;let fe=A.DEPTH_COMPONENT24,ye=A.DEPTH_ATTACHMENT;oe&&oe.isDepthTexture&&(oe.type===wn?fe=A.DEPTH_COMPONENT32F:oe.type===ai&&(fe=A.DEPTH24_STENCIL8,ye=A.DEPTH_STENCIL_ATTACHMENT));let Xe=l.get(St.depthTexture).__webglTexture;void 0===Xe&&(Xe=A.createTexture(),A.bindTexture(A.TEXTURE_2D_ARRAY,Xe),A.texStorage3D(A.TEXTURE_2D_ARRAY,1,fe,St.width,St.height,$t)),re?w.framebufferTextureMultisampleMultiviewOVR(A.FRAMEBUFFER,ye,Xe,0,Ce(St),0,$t):w.framebufferTextureMultiviewOVR(A.FRAMEBUFFER,ye,Xe,0,0,$t)}else if(St.depthBuffer&&!St.stencilBuffer){let re=A.DEPTH_COMPONENT24;if(Et||rn(St)){const $t=St.depthTexture;$t&&$t.isDepthTexture&&($t.type===wn?re=A.DEPTH_COMPONENT32F:$t.type===rr&&(re=A.DEPTH_COMPONENT24));const oe=Ce(St);rn(St)?v.renderbufferStorageMultisampleEXT(A.RENDERBUFFER,oe,re,St.width,St.height):A.renderbufferStorageMultisample(A.RENDERBUFFER,oe,re,St.width,St.height)}else A.renderbufferStorage(A.RENDERBUFFER,re,St.width,St.height);A.framebufferRenderbuffer(A.FRAMEBUFFER,A.DEPTH_ATTACHMENT,A.RENDERBUFFER,Lt)}else if(St.depthBuffer&&St.stencilBuffer){const re=Ce(St);Et&&!1===rn(St)?A.renderbufferStorageMultisample(A.RENDERBUFFER,re,A.DEPTH24_STENCIL8,St.width,St.height):rn(St)?v.renderbufferStorageMultisampleEXT(A.RENDERBUFFER,re,A.DEPTH24_STENCIL8,St.width,St.height):A.renderbufferStorage(A.RENDERBUFFER,A.DEPTH_STENCIL,St.width,St.height),A.framebufferRenderbuffer(A.FRAMEBUFFER,A.DEPTH_STENCIL_ATTACHMENT,A.RENDERBUFFER,Lt)}else{const re=St.textures;for(let $t=0;$t<re.length;$t++){const oe=re[$t],fe=d.convert(oe.format,oe.colorSpace),ye=d.convert(oe.type),Xe=Ft(oe.internalFormat,fe,ye,oe.colorSpace),Fn=Ce(St);Et&&!1===rn(St)?A.renderbufferStorageMultisample(A.RENDERBUFFER,Fn,Xe,St.width,St.height):rn(St)?v.renderbufferStorageMultisampleEXT(A.RENDERBUFFER,Fn,Xe,St.width,St.height):A.renderbufferStorage(A.RENDERBUFFER,Xe,St.width,St.height)}}A.bindRenderbuffer(A.RENDERBUFFER,null)}function fn(Lt,St){if(St&&St.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(s.bindFramebuffer(A.FRAMEBUFFER,Lt),!St.depthTexture||!St.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");l.get(St.depthTexture).__webglTexture&&St.depthTexture.image.width===St.width&&St.depthTexture.image.height===St.height||(St.depthTexture.image.width=St.width,St.depthTexture.image.height=St.height,St.depthTexture.needsUpdate=!0),ne(St.depthTexture,0),1!=St.depthTexture.image.depth?ge(St.depthTexture,0):ne(St.depthTexture,0);const Et=l.get(St.depthTexture).__webglTexture,re=Ce(St);if(!0===St.isWebGLMultiviewRenderTarget){const $t=rn(St),oe=St.numViews;if(St.depthTexture.format===Bi)$t?w.framebufferTextureMultisampleMultiviewOVR(A.FRAMEBUFFER,A.DEPTH_ATTACHMENT,Et,0,re,0,oe):w.framebufferTextureMultiviewOVR(A.FRAMEBUFFER,A.DEPTH_ATTACHMENT,Et,0,0,oe);else{if(St.depthTexture.format!==Ta)throw new Error("Unknown depthTexture format");$t?w.framebufferTextureMultisampleMultiviewOVR(A.FRAMEBUFFER,A.DEPTH_STENCIL_ATTACHMENT,Et,0,re,0,oe):w.framebufferTextureMultiviewOVR(A.FRAMEBUFFER,A.DEPTH_STENCIL_ATTACHMENT,Et,0,0,oe)}}else if(St.depthTexture.format===Bi)rn(St)?v.framebufferTexture2DMultisampleEXT(A.FRAMEBUFFER,A.DEPTH_ATTACHMENT,A.TEXTURE_2D,Et,0,re):A.framebufferTexture2D(A.FRAMEBUFFER,A.DEPTH_ATTACHMENT,A.TEXTURE_2D,Et,0);else{if(St.depthTexture.format!==Ta)throw new Error("Unknown depthTexture format");rn(St)?v.framebufferTexture2DMultisampleEXT(A.FRAMEBUFFER,A.DEPTH_STENCIL_ATTACHMENT,A.TEXTURE_2D,Et,0,re):A.framebufferTexture2D(A.FRAMEBUFFER,A.DEPTH_STENCIL_ATTACHMENT,A.TEXTURE_2D,Et,0)}}function xn(Lt){const St=l.get(Lt),Et=!0===Lt.isWebGLCubeRenderTarget;if(Lt.depthTexture&&!St.__autoAllocateDepthBuffer){if(Et)throw new Error("target.depthTexture not supported in Cube render targets");fn(St.__webglFramebuffer,Lt)}else if(Et){St.__webglDepthbuffer=[];for(let re=0;re<6;re++)s.bindFramebuffer(A.FRAMEBUFFER,St.__webglFramebuffer[re]),St.__webglDepthbuffer[re]=A.createRenderbuffer(),Nn(St.__webglDepthbuffer[re],Lt,!1)}else s.bindFramebuffer(A.FRAMEBUFFER,St.__webglFramebuffer),St.__webglDepthbuffer=A.createRenderbuffer(),Nn(St.__webglDepthbuffer,Lt,!1);s.bindFramebuffer(A.FRAMEBUFFER,null)}const In=[],Mn=[];function Ce(Lt){return Math.min(c.maxSamples,Lt.samples)}function rn(Lt){const St=l.get(Lt);return Lt.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==St.__useRenderToTexture}function On(Lt,St){const Et=Lt.colorSpace,re=Lt.format,$t=Lt.type;return!0===Lt.isCompressedTexture||!0===Lt.isVideoTexture||Et!==ps&&Et!==vo&&(Jr.getTransfer(Et)===Ii?re===de&&$t===jn||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Et)),St}function ln(Lt){return typeof HTMLImageElement<"u"&&Lt instanceof HTMLImageElement?(S.width=Lt.naturalWidth||Lt.width,S.height=Lt.naturalHeight||Lt.height):typeof VideoFrame<"u"&&Lt instanceof VideoFrame?(S.width=Lt.displayWidth,S.height=Lt.displayHeight):(S.width=Lt.width,S.height=Lt.height),S}this.allocateTextureUnit=function(){const Lt=ce;return Lt>=c.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+Lt+" texture units while this GPU supports only "+c.maxTextures),ce+=1,Lt},this.resetTextureUnits=function(){ce=0},this.setTexture2D=ne,this.setTexture2DArray=ge,this.setTexture3D=function(Lt,St){const Et=l.get(Lt);Lt.version>0&&Et.__version!==Lt.version?Fe(Et,Lt,St):s.bindTexture(A.TEXTURE_3D,Et.__webglTexture,A.TEXTURE0+St)},this.setTextureCube=function(Lt,St){const Et=l.get(Lt);Lt.version>0&&Et.__version!==Lt.version?function(re,$t,oe){if(6!==$t.image.length)return;const fe=ze(re,$t),ye=$t.source;s.bindTexture(A.TEXTURE_CUBE_MAP,re.__webglTexture,A.TEXTURE0+oe);const Xe=l.get(ye);if(ye.version!==Xe.__version||!0===fe){s.activeTexture(A.TEXTURE0+oe);const Fn=Jr.getPrimaries(Jr.workingColorSpace),An=$t.colorSpace===vo?null:Jr.getPrimaries($t.colorSpace),Un=$t.colorSpace===vo||Fn===An?A.NONE:A.BROWSER_DEFAULT_WEBGL;A.pixelStorei(A.UNPACK_FLIP_Y_WEBGL,$t.flipY),A.pixelStorei(A.UNPACK_PREMULTIPLY_ALPHA_WEBGL,$t.premultiplyAlpha),A.pixelStorei(A.UNPACK_ALIGNMENT,$t.unpackAlignment),A.pixelStorei(A.UNPACK_COLORSPACE_CONVERSION_WEBGL,Un);const ar=$t.isCompressedTexture||$t.image[0].isCompressedTexture,$n=$t.image[0]&&$t.image[0].isDataTexture,sr=[];for(let or=0;or<6;or++)sr[or]=ar||$n?$n?$t.image[or].image:$t.image[or]:it($t.image[or],!0,c.maxCubemapSize),sr[or]=On($t,sr[or]);const Xr=sr[0],Ir=d.convert($t.format,$t.colorSpace),kr=d.convert($t.type),Qr=Ft($t.internalFormat,Ir,kr,$t.colorSpace),Ui=!0!==$t.isVideoTexture,Zn=void 0===Xe.__version||!0===fe,ts=ye.dataReady;let Gs,rc=Tt($t,Xr);if(Pe(A.TEXTURE_CUBE_MAP,$t),ar){Ui&&Zn&&s.texStorage2D(A.TEXTURE_CUBE_MAP,rc,Qr,Xr.width,Xr.height);for(let or=0;or<6;or++){Gs=sr[or].mipmaps;for(let zi=0;zi<Gs.length;zi++){const Di=Gs[zi];$t.format!==de?null!==Ir?Ui?ts&&s.compressedTexSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,zi,0,0,Di.width,Di.height,Ir,Di.data):s.compressedTexImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,zi,Qr,Di.width,Di.height,0,Di.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Ui?ts&&s.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,zi,0,0,Di.width,Di.height,Ir,kr,Di.data):s.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,zi,Qr,Di.width,Di.height,0,Ir,kr,Di.data)}}}else{if(Gs=$t.mipmaps,Ui&&Zn){Gs.length>0&&rc++;const or=ln(sr[0]);s.texStorage2D(A.TEXTURE_CUBE_MAP,rc,Qr,or.width,or.height)}for(let or=0;or<6;or++)if($n){Ui?ts&&s.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,0,0,0,sr[or].width,sr[or].height,Ir,kr,sr[or].data):s.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,0,Qr,sr[or].width,sr[or].height,0,Ir,kr,sr[or].data);for(let zi=0;zi<Gs.length;zi++){const Di=Gs[zi].image[or].image;Ui?ts&&s.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,zi+1,0,0,Di.width,Di.height,Ir,kr,Di.data):s.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,zi+1,Qr,Di.width,Di.height,0,Ir,kr,Di.data)}}else{Ui?ts&&s.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,0,0,0,Ir,kr,sr[or]):s.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,0,Qr,Ir,kr,sr[or]);for(let zi=0;zi<Gs.length;zi++){const Di=Gs[zi];Ui?ts&&s.texSubImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,zi+1,0,0,Ir,kr,Di.image[or]):s.texImage2D(A.TEXTURE_CUBE_MAP_POSITIVE_X+or,zi+1,Qr,Ir,kr,Di.image[or])}}}ct($t)&&At(A.TEXTURE_CUBE_MAP),Xe.__version=ye.version,$t.onUpdate&&$t.onUpdate($t)}re.__version=$t.version}(Et,Lt,St):s.bindTexture(A.TEXTURE_CUBE_MAP,Et.__webglTexture,A.TEXTURE0+St)},this.rebindTextures=function(Lt,St,Et){const re=l.get(Lt);void 0!==St&&Dn(re.__webglFramebuffer,Lt,Lt.texture,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,0),void 0!==Et&&xn(Lt)},this.uploadTexture=Fe,this.setupRenderTarget=function(Lt){const St=Lt.texture,Et=l.get(Lt),re=l.get(St);Lt.addEventListener("dispose",zt);const $t=Lt.textures,oe=!0===Lt.isWebGLCubeRenderTarget,fe=$t.length>1;if(fe||(void 0===re.__webglTexture&&(re.__webglTexture=A.createTexture()),re.__version=St.version,g.memory.textures++),oe){Et.__webglFramebuffer=[];for(let ye=0;ye<6;ye++)if(St.mipmaps&&St.mipmaps.length>0){Et.__webglFramebuffer[ye]=[];for(let Xe=0;Xe<St.mipmaps.length;Xe++)Et.__webglFramebuffer[ye][Xe]=A.createFramebuffer()}else Et.__webglFramebuffer[ye]=A.createFramebuffer()}else{if(St.mipmaps&&St.mipmaps.length>0){Et.__webglFramebuffer=[];for(let ye=0;ye<St.mipmaps.length;ye++)Et.__webglFramebuffer[ye]=A.createFramebuffer()}else Et.__webglFramebuffer=A.createFramebuffer();if(fe)for(let ye=0,Xe=$t.length;ye<Xe;ye++){const Fn=l.get($t[ye]);void 0===Fn.__webglTexture&&(Fn.__webglTexture=A.createTexture(),g.memory.textures++)}if(Lt.samples>0&&!1===rn(Lt)){Et.__webglMultisampledFramebuffer=A.createFramebuffer(),Et.__webglColorRenderbuffer=[],s.bindFramebuffer(A.FRAMEBUFFER,Et.__webglMultisampledFramebuffer);for(let ye=0;ye<$t.length;ye++){const Xe=$t[ye];Et.__webglColorRenderbuffer[ye]=A.createRenderbuffer(),A.bindRenderbuffer(A.RENDERBUFFER,Et.__webglColorRenderbuffer[ye]);const Fn=d.convert(Xe.format,Xe.colorSpace),An=d.convert(Xe.type),Un=Ft(Xe.internalFormat,Fn,An,Xe.colorSpace,!0===Lt.isXRRenderTarget),ar=Ce(Lt);A.renderbufferStorageMultisample(A.RENDERBUFFER,ar,Un,Lt.width,Lt.height),A.framebufferRenderbuffer(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0+ye,A.RENDERBUFFER,Et.__webglColorRenderbuffer[ye])}A.bindRenderbuffer(A.RENDERBUFFER,null),Lt.depthBuffer&&(Et.__webglDepthRenderbuffer=A.createRenderbuffer(),Nn(Et.__webglDepthRenderbuffer,Lt,!0)),s.bindFramebuffer(A.FRAMEBUFFER,null)}}if(oe){s.bindTexture(A.TEXTURE_CUBE_MAP,re.__webglTexture),Pe(A.TEXTURE_CUBE_MAP,St);for(let ye=0;ye<6;ye++)if(St.mipmaps&&St.mipmaps.length>0)for(let Xe=0;Xe<St.mipmaps.length;Xe++)Dn(Et.__webglFramebuffer[ye][Xe],Lt,St,A.COLOR_ATTACHMENT0,A.TEXTURE_CUBE_MAP_POSITIVE_X+ye,Xe);else Dn(Et.__webglFramebuffer[ye],Lt,St,A.COLOR_ATTACHMENT0,A.TEXTURE_CUBE_MAP_POSITIVE_X+ye,0);ct(St)&&At(A.TEXTURE_CUBE_MAP),s.unbindTexture()}else if(fe){for(let ye=0,Xe=$t.length;ye<Xe;ye++){const Fn=$t[ye],An=l.get(Fn);s.bindTexture(A.TEXTURE_2D,An.__webglTexture),Pe(A.TEXTURE_2D,Fn),Dn(Et.__webglFramebuffer,Lt,Fn,A.COLOR_ATTACHMENT0+ye,A.TEXTURE_2D,0),ct(Fn)&&At(A.TEXTURE_2D)}s.unbindTexture()}else{let ye=A.TEXTURE_2D;if((Lt.isWebGL3DRenderTarget||Lt.isWebGLArrayRenderTarget)&&(ye=Lt.isWebGL3DRenderTarget?A.TEXTURE_3D:A.TEXTURE_2D_ARRAY),!0===Lt.isWebGLMultiviewRenderTarget&&(ye=A.TEXTURE_2D_ARRAY),s.bindTexture(ye,re.__webglTexture),Pe(ye,St),St.mipmaps&&St.mipmaps.length>0)for(let Xe=0;Xe<St.mipmaps.length;Xe++)Dn(Et.__webglFramebuffer[Xe],Lt,St,A.COLOR_ATTACHMENT0,ye,Xe);else Dn(Et.__webglFramebuffer,Lt,St,A.COLOR_ATTACHMENT0,ye,0);ct(St)&&At(ye),s.unbindTexture()}(Lt.depthBuffer||!0===Lt.isWebGLMultiviewRenderTarget)&&this.setupDepthRenderbuffer(Lt)},this.updateRenderTargetMipmap=function(Lt){const St=Lt.textures;for(let Et=0,re=St.length;Et<re;Et++){const $t=St[Et];if(ct($t)){const oe=Lt.isWebGLCubeRenderTarget?A.TEXTURE_CUBE_MAP:A.TEXTURE_2D,fe=l.get($t).__webglTexture;s.bindTexture(oe,fe),At(oe),s.unbindTexture()}}},this.updateMultisampleRenderTarget=function(Lt){if(Lt.samples>0)if(!1===rn(Lt)){const St=Lt.textures,Et=Lt.width,re=Lt.height;let $t=A.COLOR_BUFFER_BIT;const oe=Lt.stencilBuffer?A.DEPTH_STENCIL_ATTACHMENT:A.DEPTH_ATTACHMENT,fe=l.get(Lt),ye=St.length>1;if(ye)for(let Xe=0;Xe<St.length;Xe++)s.bindFramebuffer(A.FRAMEBUFFER,fe.__webglMultisampledFramebuffer),A.framebufferRenderbuffer(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0+Xe,A.RENDERBUFFER,null),s.bindFramebuffer(A.FRAMEBUFFER,fe.__webglFramebuffer),A.framebufferTexture2D(A.DRAW_FRAMEBUFFER,A.COLOR_ATTACHMENT0+Xe,A.TEXTURE_2D,null,0);s.bindFramebuffer(A.READ_FRAMEBUFFER,fe.__webglMultisampledFramebuffer),s.bindFramebuffer(A.DRAW_FRAMEBUFFER,fe.__webglFramebuffer);for(let Xe=0;Xe<St.length;Xe++){if(Lt.resolveDepthBuffer&&(Lt.depthBuffer&&($t|=A.DEPTH_BUFFER_BIT),Lt.stencilBuffer&&Lt.resolveStencilBuffer&&($t|=A.STENCIL_BUFFER_BIT)),ye){A.framebufferRenderbuffer(A.READ_FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.RENDERBUFFER,fe.__webglColorRenderbuffer[Xe]);const Fn=l.get(St[Xe]).__webglTexture;A.framebufferTexture2D(A.DRAW_FRAMEBUFFER,A.COLOR_ATTACHMENT0,A.TEXTURE_2D,Fn,0)}A.blitFramebuffer(0,0,Et,re,0,0,Et,re,$t,A.NEAREST),!0===x&&(In.length=0,Mn.length=0,In.push(A.COLOR_ATTACHMENT0+Xe),Lt.depthBuffer&&!1===Lt.resolveDepthBuffer&&(In.push(oe),Mn.push(oe),A.invalidateFramebuffer(A.DRAW_FRAMEBUFFER,Mn)),A.invalidateFramebuffer(A.READ_FRAMEBUFFER,In))}if(s.bindFramebuffer(A.READ_FRAMEBUFFER,null),s.bindFramebuffer(A.DRAW_FRAMEBUFFER,null),ye)for(let Xe=0;Xe<St.length;Xe++){s.bindFramebuffer(A.FRAMEBUFFER,fe.__webglMultisampledFramebuffer),A.framebufferRenderbuffer(A.FRAMEBUFFER,A.COLOR_ATTACHMENT0+Xe,A.RENDERBUFFER,fe.__webglColorRenderbuffer[Xe]);const Fn=l.get(St[Xe]).__webglTexture;s.bindFramebuffer(A.FRAMEBUFFER,fe.__webglFramebuffer),A.framebufferTexture2D(A.DRAW_FRAMEBUFFER,A.COLOR_ATTACHMENT0+Xe,A.TEXTURE_2D,Fn,0)}s.bindFramebuffer(A.DRAW_FRAMEBUFFER,fe.__webglMultisampledFramebuffer)}else Lt.depthBuffer&&!1===Lt.resolveDepthBuffer&&x&&A.invalidateFramebuffer(A.DRAW_FRAMEBUFFER,[Lt.stencilBuffer?A.DEPTH_STENCIL_ATTACHMENT:A.DEPTH_ATTACHMENT])},this.setupDepthTexture=fn,this.setupDepthRenderbuffer=xn,this.setupFrameBufferTexture=Dn,this.useMultisampledRTT=rn,this.runDeferredUploads=function(){const Lt=tt;tt=!1;for(const St of Y)Fe(St.textureProperties,St.texture,St.slot),St.texture.isPendingDeferredUpload=!1;Y=[],tt=Lt},this.setDeferTextureUploads=function(Lt){tt=Lt}}function yg(A,e){return{convert:function(s,l=vo){let c;const d=Jr.getTransfer(l);if(s===jn)return A.UNSIGNED_BYTE;if(s===xi)return A.UNSIGNED_SHORT_4_4_4_4;if(s===cr)return A.UNSIGNED_SHORT_5_5_5_1;if(s===ci)return A.UNSIGNED_INT_5_9_9_9_REV;if(s===Kn)return A.BYTE;if(s===gn)return A.SHORT;if(s===vr)return A.UNSIGNED_SHORT;if(s===Tr)return A.INT;if(s===rr)return A.UNSIGNED_INT;if(s===wn)return A.FLOAT;if(s===br)return A.HALF_FLOAT;if(s===Ri)return A.ALPHA;if(s===jr)return A.RGB;if(s===de)return A.RGBA;if(s===go)return A.LUMINANCE;if(s===_o)return A.LUMINANCE_ALPHA;if(s===Bi)return A.DEPTH_COMPONENT;if(s===Ta)return A.DEPTH_STENCIL;if(s===da)return A.RED;if(s===pa)return A.RED_INTEGER;if(s===Ss)return A.RG;if(s===Xs)return A.RG_INTEGER;if(s===Ms)return A.RGBA_INTEGER;if(s===_a||s===Pa||s===Ys||s===Ks)if(d===Ii){if(c=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===c)return null;if(s===_a)return c.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===Pa)return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===Ys)return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===Ks)return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(c=e.get("WEBGL_compressed_texture_s3tc"),null===c)return null;if(s===_a)return c.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Pa)return c.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Ys)return c.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Ks)return c.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(s===Ka||s===oi||s===Ol||s===Go){if(c=e.get("WEBGL_compressed_texture_pvrtc"),null===c)return null;if(s===Ka)return c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===oi)return c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===Ol)return c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===Go)return c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(s===Li||s===K||s===mt){if(c=e.get("WEBGL_compressed_texture_etc"),null===c)return null;if(s===Li||s===K)return d===Ii?c.COMPRESSED_SRGB8_ETC2:c.COMPRESSED_RGB8_ETC2;if(s===mt)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:c.COMPRESSED_RGBA8_ETC2_EAC}if(s===It||s===Mt||s===Gt||s===Xt||s===Me||s===sn||s===un||s===Ie||s===Be||s===Pn||s===Xn||s===dr||s===Ar||s===xr){if(c=e.get("WEBGL_compressed_texture_astc"),null===c)return null;if(s===It)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:c.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===Mt)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:c.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===Gt)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:c.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===Xt)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:c.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===Me)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:c.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===sn)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:c.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===un)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:c.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===Ie)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:c.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===Be)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:c.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===Pn)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:c.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===Xn)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:c.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===dr)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:c.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===Ar)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:c.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===xr)return d===Ii?c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:c.COMPRESSED_RGBA_ASTC_12x12_KHR}if(s===_r||s===Pr||s===ui){if(c=e.get("EXT_texture_compression_bptc"),null===c)return null;if(s===_r)return d===Ii?c.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:c.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===Pr)return c.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===ui)return c.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(s===us||s===Fi||s===rs||s===Ts){if(c=e.get("EXT_texture_compression_rgtc"),null===c)return null;if(s===_r)return c.COMPRESSED_RED_RGTC1_EXT;if(s===Fi)return c.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===rs)return c.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===Ts)return c.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return s===ai?A.UNSIGNED_INT_24_8:void 0!==A[s]?A[s]:null}}}class tl extends hi{constructor(){super(),this.isGroup=!0,this.type="Group"}}class Mf extends ea{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}var cp=new Dt,el=new Dt;function yc(A){var e,s,l=this,c=null,d=null,g=null,v=[],x=new Yn,w=new Yn,S=1,P="local-floor";typeof window<"u"&&"VRFrameData"in window&&(d=new window.VRFrameData,window.addEventListener("vrdisplaypresentchange",At,!1));var z=new Yn,W=new _s,Y=new Dt,tt=new ea;tt.viewport=new li,tt.layers.enable(1);var J=new ea;J.viewport=new li,J.layers.enable(2);var at=new Mf([tt,J]);at.layers.enable(1),at.layers.enable(2);var it,ct=new Ye;function At(){if(l.isPresenting=null!==c&&!0===c.isPresenting){var ce=c.getEyeParameters("left");e=2*ce.renderWidth*S,s=ce.renderHeight*S,it=A.getPixelRatio(),A.getSize(ct),A.setDrawingBufferSize(e,s,1),tt.viewport.set(0,0,e/2,s),J.viewport.set(e/2,0,e/2,s),ee.start(),l.dispatchEvent({type:"sessionstart"})}else l.enabled&&A.setDrawingBufferSize(ct.width,ct.height,it),ee.stop(),l.dispatchEvent({type:"sessionend"})}var Ft=[],Tt=[];function Pt(ce){for(var ne=navigator.getGamepads&&navigator.getGamepads(),ge=0,ie=ne.length;ge<ie;ge++){var pe=ne[ge];if(pe&&("Daydream Controller"===pe.id||"Gear VR Controller"===pe.id||"Oculus Go Controller"===pe.id||"OpenVR Gamepad"===pe.id||pe.id.startsWith("Oculus Touch")||pe.id.startsWith("HTC Vive Focus")||pe.id.startsWith("Spatial Controller"))){var Oe=pe.hand;if(0===ce&&(""===Oe||"right"===Oe)||1===ce&&"left"===Oe)return pe}}}function zt(ce,ne){null!==ne&&4===ne.length&&ce.set(ne[0]*e,ne[1]*s,ne[2]*e,ne[3]*s)}this.enabled=!1,this.getController=function(ce){var ne=v[ce];return void 0===ne&&((ne=new tl).matrixAutoUpdate=!1,ne.visible=!1,v[ce]=ne),ne},this.getDevice=function(){return c},this.setDevice=function(ce){void 0!==ce&&(c=ce),ee.setContext(ce)},this.setFramebufferScaleFactor=function(ce){S=ce},this.setReferenceSpaceType=function(ce){P=ce},this.setPoseTarget=function(ce){void 0!==ce&&(g=ce)},this.cameraAutoUpdate=!0,this.updateCamera=function(ce){var ne="local-floor"===P?1.6:0;if(c.depthNear=ce.near,c.depthFar=ce.far,c.getFrameData(d),"local-floor"===P){var ge=c.stageParameters;ge?x.fromArray(ge.sittingToStandingTransform):x.makeTranslation(0,ne,0)}var ie=d.pose,pe=null!==g?g:ce;pe.matrix.copy(x),pe.matrix.decompose(pe.position,pe.quaternion,pe.scale),null!==ie.orientation&&(W.fromArray(ie.orientation),pe.quaternion.multiply(W)),null!==ie.position&&(W.setFromRotationMatrix(x),Y.fromArray(ie.position),Y.applyQuaternion(W),pe.position.add(Y)),pe.updateMatrixWorld();for(var Oe=pe.children,Pe=0,ze=Oe.length;Pe<ze;Pe++)Oe[Pe].updateMatrixWorld(!0);tt.near=ce.near,J.near=ce.near,tt.far=ce.far,J.far=ce.far,tt.matrixWorldInverse.fromArray(d.leftViewMatrix),J.matrixWorldInverse.fromArray(d.rightViewMatrix),w.copy(x).invert(),"local-floor"===P&&(tt.matrixWorldInverse.multiply(w),J.matrixWorldInverse.multiply(w));var Fe=pe.parent;null!==Fe&&(z.copy(Fe.matrixWorld).invert(),tt.matrixWorldInverse.multiply(z),J.matrixWorldInverse.multiply(z)),tt.matrixWorld.copy(tt.matrixWorldInverse).invert(),J.matrixWorld.copy(J.matrixWorldInverse).invert(),tt.projectionMatrix.fromArray(d.leftProjectionMatrix),J.projectionMatrix.fromArray(d.rightProjectionMatrix),function(fn,xn,In){cp.setFromMatrixPosition(xn.matrixWorld),el.setFromMatrixPosition(In.matrixWorld);var Mn=cp.distanceTo(el),Ce=xn.projectionMatrix.elements,rn=In.projectionMatrix.elements,On=Ce[14]/(Ce[10]-1),ln=Ce[14]/(Ce[10]+1),Lt=(Ce[9]+1)/Ce[5],St=(Ce[9]-1)/Ce[5],Et=(Ce[8]-1)/Ce[0],re=(rn[8]+1)/rn[0],$t=On*Et,oe=On*re,fe=Mn/(-Et+re),ye=fe*-Et;xn.matrixWorld.decompose(fn.position,fn.quaternion,fn.scale),fn.translateX(ye),fn.translateZ(fe),fn.matrixWorld.compose(fn.position,fn.quaternion,fn.scale),fn.matrixWorldInverse.copy(fn.matrixWorld).invert();var Xe=On+fe,Fn=ln+fe;fn.projectionMatrix.makePerspective($t-ye,oe+(Mn-ye),Lt*ln/Fn*Xe,St*ln/Fn*Xe,Xe,Fn)}(at,tt,J);var Dn=c.getLayers();if(Dn.length){var Nn=Dn[0];zt(tt.viewport,Nn.leftBounds),zt(J.viewport,Nn.rightBounds)}return function(){for(var fn=0;fn<v.length;fn++){var xn=v[fn],In=Pt(fn);if(void 0!==In&&void 0!==In.pose){if(null===In.pose)return;var Mn=In.pose;!1===Mn.hasPosition&&xn.position.set(.2,-.6,-.05),null!==Mn.position&&xn.position.fromArray(Mn.position),null!==Mn.orientation&&xn.quaternion.fromArray(Mn.orientation),xn.matrix.compose(xn.position,xn.quaternion,xn.scale),xn.matrix.premultiply(x),xn.matrix.decompose(xn.position,xn.quaternion,xn.scale),xn.matrixWorldNeedsUpdate=!0,xn.visible=!0;var Ce="Daydream Controller"===In.id?0:1;void 0===Ft[fn]&&(Ft[fn]=!1),Ft[fn]!==In.buttons[Ce].pressed&&(Ft[fn]=In.buttons[Ce].pressed,!0===Ft[fn]?xn.dispatchEvent({type:"selectstart"}):(xn.dispatchEvent({type:"selectend"}),xn.dispatchEvent({type:"select"}))),Ce=2,void 0===Tt[fn]&&(Tt[fn]=!1),void 0!==In.buttons[Ce]&&Tt[fn]!==In.buttons[Ce].pressed&&(Tt[fn]=In.buttons[Ce].pressed,!0===Tt[fn]?xn.dispatchEvent({type:"squeezestart"}):(xn.dispatchEvent({type:"squeezeend"}),xn.dispatchEvent({type:"squeeze"})))}else xn.visible=!1}}(),at},this.getCamera=function(){return at},this.getFoveation=function(){return 1},this.setFoveation=function(ce){1!==ce&&console.warn("THREE.WebVRManager: setFoveation() not used in WebVR.")},this.getEnvironmentBlendMode=function(){if(l.isPresenting)return"opaque"},this.getStandingMatrix=function(){return x},this.isPresenting=!1;var ee=new sp;this.setAnimationLoop=function(ce){ee.setAnimationLoop(ce),this.isPresenting&&ee.start()},this.submitFrame=function(){this.isPresenting&&c.submitFrame()},this.dispose=function(){typeof window<"u"&&window.removeEventListener("vrdisplaypresentchange",At)},this.setFrameOfReferenceType=function(){console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")}}Object.assign(yc.prototype,{addEventListener:to.prototype.addEventListener,hasEventListener:to.prototype.hasEventListener,removeEventListener:to.prototype.removeEventListener,dispatchEvent:to.prototype.dispatchEvent});class ra extends bo{constructor(e,s,l,c={}){super(e,s,c),this.depthBuffer=!1,this.stencilBuffer=!1,this.numViews=l}copy(e){return super.copy(e),this.numViews=e.numViews,this}}ra.prototype.isWebGLMultiviewRenderTarget=!0;const Xu={type:"move"};class Tf{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new tl,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new tl,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Dt,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Dt),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new tl,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Dt,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Dt),this._grip}dispatchEvent(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const s=this._hand;if(s)for(const l of e.hand.values())this._getHandJoint(s,l)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(e,s,l){let c=null,d=null,g=null;const v=this._targetRay,x=this._grip,w=this._hand;if(e&&"visible-blurred"!==s.session.visibilityState){if(w&&e.hand){g=!0;for(const tt of e.hand.values()){const J=s.getJointPose(tt,l),at=this._getHandJoint(w,tt);null!==J&&(at.matrix.fromArray(J.transform.matrix),at.matrix.decompose(at.position,at.rotation,at.scale),at.matrixWorldNeedsUpdate=!0,at.jointRadius=J.radius),at.visible=null!==J}const z=w.joints["index-finger-tip"].position.distanceTo(w.joints["thumb-tip"].position),W=.02,Y=.005;w.inputState.pinching&&z>W+Y?(w.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!w.inputState.pinching&&z<=W-Y&&(w.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==x&&e.gripSpace&&(d=s.getPose(e.gripSpace,l),null!==d&&(x.matrix.fromArray(d.transform.matrix),x.matrix.decompose(x.position,x.rotation,x.scale),x.matrixWorldNeedsUpdate=!0,d.linearVelocity?(x.hasLinearVelocity=!0,x.linearVelocity.copy(d.linearVelocity)):x.hasLinearVelocity=!1,d.angularVelocity?(x.hasAngularVelocity=!0,x.angularVelocity.copy(d.angularVelocity)):x.hasAngularVelocity=!1));null!==v&&(c=s.getPose(e.targetRaySpace,l),null===c&&null!==d&&(c=d),null!==c&&(v.matrix.fromArray(c.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),v.matrixWorldNeedsUpdate=!0,c.linearVelocity?(v.hasLinearVelocity=!0,v.linearVelocity.copy(c.linearVelocity)):v.hasLinearVelocity=!1,c.angularVelocity?(v.hasAngularVelocity=!0,v.angularVelocity.copy(c.angularVelocity)):v.hasAngularVelocity=!1,this.dispatchEvent(Xu)))}return null!==v&&(v.visible=null!==c),null!==x&&(x.visible=null!==d),null!==w&&(w.visible=null!==g),this}_getHandJoint(e,s){if(void 0===e.joints[s.jointName]){const l=new tl;l.matrixAutoUpdate=!1,l.visible=!1,e.joints[s.jointName]=l,e.add(l)}return e.joints[s.jointName]}}class vg{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,s,l){if(null===this.texture){const c=new Vi;e.properties.get(c).__webglTexture=s.texture,s.depthNear==l.depthNear&&s.depthFar==l.depthFar||(this.depthNear=s.depthNear,this.depthFar=s.depthFar),this.texture=c}}render(e,s){if(null!==this.texture){if(null===this.mesh){const l=s.cameras[0].viewport,c=new xl({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:l.z},depthHeight:{value:l.w}}});this.mesh=new os(new ap(20,20),c)}e.render(this.mesh,s)}}reset(){this.texture=null,this.mesh=null}}class T0 extends to{constructor(e,s,l,c){super();const d=this;let g=null,v=1;var x=null;let w=null,S="local-floor",P=1,z=null,W=null;var Y=[];let tt=null,J=null,at=null,it=null;const ct=new vg,At=s.getContextAttributes();let Ft=null,Tt=null;const Pt=[],zt=[],ee=new Ye;let ce=null;const ne=new ea;ne.layers.enable(1),ne.viewport=new li;const ge=new ea;ge.layers.enable(2),ge.viewport=new li;const ie=[ne,ge],pe=new Mf;pe.layers.enable(1),pe.layers.enable(2);let Oe=null,Pe=null;function ze(Ce){const rn=zt.indexOf(Ce.inputSource);if(-1===rn)return;const On=Pt[rn];void 0!==On&&(On.update(Ce.inputSource,Ce.frame,z||w),On.dispatchEvent({type:Ce.type,data:Ce.inputSource}))}function Fe(){g.removeEventListener("select",ze),g.removeEventListener("selectstart",ze),g.removeEventListener("selectend",ze),g.removeEventListener("squeeze",ze),g.removeEventListener("squeezestart",ze),g.removeEventListener("squeezeend",ze),g.removeEventListener("end",Fe),g.removeEventListener("inputsourceschange",Dn);for(let Ce=0;Ce<Pt.length;Ce++){const rn=zt[Ce];null!==rn&&(zt[Ce]=null,Pt[Ce].disconnect(rn))}Oe=null,Pe=null,ct.reset(),e.setRenderTarget(Ft),at=null,J=null,tt=null,g=null,Tt=null,Mn.stop(),d.isPresenting=!1,e.setPixelRatio(ce),e.setSize(ee.width,ee.height,!1),d.dispatchEvent({type:"sessionend"})}function Dn(Ce){for(let rn=0;rn<Ce.removed.length;rn++){const On=Ce.removed[rn],ln=zt.indexOf(On);ln>=0&&(zt[ln]=null,Pt[ln].disconnect(On))}for(let rn=0;rn<Ce.added.length;rn++){const On=Ce.added[rn];let ln=zt.indexOf(On);if(-1===ln){for(let St=0;St<Pt.length;St++){if(St>=zt.length){zt.push(On),ln=St;break}if(null===zt[St]){zt[St]=On,ln=St;break}}if(-1===ln)break}const Lt=Pt[ln];Lt&&Lt.connect(On)}}this.cameraAutoUpdate=!0,this.layersEnabled=!1,this.enabled=!1,this.isPresenting=!1,this.isMultiview=!1,this.getCameraPose=function(){return W},this.getController=function(Ce){let rn=Pt[Ce];return void 0===rn&&(rn=new Tf,Pt[Ce]=rn),rn.getTargetRaySpace()},this.getControllerGrip=function(Ce){let rn=Pt[Ce];return void 0===rn&&(rn=new Tf,Pt[Ce]=rn),rn.getGripSpace()},this.getHand=function(Ce){let rn=Pt[Ce];return void 0===rn&&(rn=new Tf,Pt[Ce]=rn),rn.getHandSpace()},this.setFramebufferScaleFactor=function(Ce){v=Ce,!0===d.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(Ce){S=Ce,!0===d.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return z||w},this.setReferenceSpace=function(Ce){z=Ce},this.getBaseLayer=function(){return null!==J?J:at},this.getBinding=function(){return tt},this.getFrame=function(){return it},this.getSession=function(){return g},this.setSession=async function(Ce){if(g=Ce,null!==g){if(Ft=e.getRenderTarget(),g.addEventListener("select",ze),g.addEventListener("selectstart",ze),g.addEventListener("selectend",ze),g.addEventListener("squeeze",ze),g.addEventListener("squeezestart",ze),g.addEventListener("squeezeend",ze),g.addEventListener("end",Fe),g.addEventListener("inputsourceschange",Dn),!0!==At.xrCompatible&&await s.makeXRCompatible(),ce=e.getPixelRatio(),e.getSize(ee),void 0===g.renderState.layers)at=new XRWebGLLayer(g,s,{antialias:At.antialias,alpha:!0,depth:At.depth,stencil:At.stencil,framebufferScaleFactor:v}),g.updateRenderState({baseLayer:at}),e.setPixelRatio(1),e.setSize(at.framebufferWidth,at.framebufferHeight,!1),Tt=new bo(at.framebufferWidth,at.framebufferHeight,{format:de,type:jn,colorSpace:e.outputColorSpace,stencilBuffer:At.stencil});else{let rn=null,On=null,ln=null;At.depth&&(ln=At.stencil?s.DEPTH24_STENCIL8:s.DEPTH_COMPONENT24,rn=At.stencil?Ta:Bi,On=At.stencil?ai:rr),d.isMultiview=c&&l.has("OCULUS_multiview");const Lt={colorFormat:s.RGBA8,depthFormat:ln,scaleFactor:v};d.isMultiview&&(Lt.textureType="texture-array"),tt=new XRWebGLBinding(g,s),J=tt.createProjectionLayer(Lt),g.updateRenderState({layers:[J]}),e.setPixelRatio(1),e.setSize(J.textureWidth,J.textureHeight,!1);const St={format:de,type:jn,depthTexture:new h0(J.textureWidth,J.textureHeight,On,void 0,void 0,void 0,void 0,void 0,void 0,rn),stencilBuffer:At.stencil,colorSpace:e.outputColorSpace,samples:At.antialias?4:0,resolveDepthBuffer:!1===J.ignoreDepthValues};if(d.isMultiview){const Et=l.get("OCULUS_multiview");this.maxNumViews=s.getParameter(Et.MAX_VIEWS_OVR),Tt=new ra(J.textureWidth,J.textureHeight,2,St)}else Tt=new bo(J.textureWidth,J.textureHeight,St)}Tt.isXRRenderTarget=!0,this.setFoveation(P),z=null,w=await g.requestReferenceSpace(S),Mn.setContext(g),Mn.start(),d.isPresenting=!0,d.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==g)return g.environmentBlendMode},this.addLayer=function(Ce){window.XRWebGLBinding&&this.layersEnabled&&g&&(Y.push(Ce),this.updateLayers())},this.removeLayer=function(Ce){Y.splice(Y.indexOf(Ce),1),window.XRWebGLBinding&&this.layersEnabled&&g&&this.updateLayers()},this.updateLayers=function(){var Ce=Y.map(function(rn){return rn});Ce.unshift(g.renderState.layers[0]),g.updateRenderState({layers:Ce})};const Nn=new Dt,fn=new Dt;function xn(Ce,rn){null===rn?Ce.matrixWorld.copy(Ce.matrix):Ce.matrixWorld.multiplyMatrices(rn.matrixWorld,Ce.matrix),Ce.matrixWorldInverse.copy(Ce.matrixWorld).invert()}this.setPoseTarget=function(Ce){void 0!==Ce&&(x=Ce)},this.updateCamera=function(Ce){if(null===g)return;null!==ct.texture&&(Ce.near=ct.depthNear,Ce.far=ct.depthFar),pe.near=ge.near=ne.near=Ce.near,pe.far=ge.far=ne.far=Ce.far,Oe===pe.near&&Pe===pe.far||(g.updateRenderState({depthNear:pe.near,depthFar:pe.far}),Oe=pe.near,Pe=pe.far,ne.near=Oe,ne.far=Pe,ge.near=Oe,ge.far=Pe,ne.updateProjectionMatrix(),ge.updateProjectionMatrix(),Ce.updateProjectionMatrix());const rn=pe.cameras;var On=x||Ce;const ln=On.parent;xn(pe,ln);for(let Lt=0;Lt<rn.length;Lt++)xn(rn[Lt],ln);var Lt,St,Et;2===rn.length?function(Lt,St,Et){Nn.setFromMatrixPosition(St.matrixWorld),fn.setFromMatrixPosition(Et.matrixWorld);const re=Nn.distanceTo(fn),$t=St.projectionMatrix.elements,oe=Et.projectionMatrix.elements,fe=$t[14]/($t[10]-1),ye=$t[14]/($t[10]+1),Xe=($t[9]+1)/$t[5],Fn=($t[9]-1)/$t[5],An=($t[8]-1)/$t[0],Un=(oe[8]+1)/oe[0],ar=fe*An,$n=fe*Un,sr=re/(-An+Un),Xr=sr*-An;St.matrixWorld.decompose(Lt.position,Lt.quaternion,Lt.scale),Lt.translateX(Xr),Lt.translateZ(sr),Lt.matrixWorld.compose(Lt.position,Lt.quaternion,Lt.scale),Lt.matrixWorldInverse.copy(Lt.matrixWorld).invert();const Ir=fe+sr,kr=ye+sr;Lt.projectionMatrix.makePerspective(ar-Xr,$n+(re-Xr),Xe*ye/kr*Ir,Fn*ye/kr*Ir,Ir,kr),Lt.projectionMatrixInverse.copy(Lt.projectionMatrix).invert()}(pe,ne,ge):pe.projectionMatrix.copy(ne.projectionMatrix),Lt=Ce,Et=On,(St=pe).matrixWorld.decompose(St.position,St.quaternion,St.scale),null===Et.parent?Et.matrix.copy(St.matrixWorld):(Et.matrix.copy(Et.parent.matrixWorld),Et.matrix.invert(),Et.matrix.multiply(St.matrixWorld)),Et.matrix.decompose(Et.position,Et.quaternion,Et.scale),Et.updateMatrixWorld(!0),Lt.projectionMatrix.copy(St.projectionMatrix),Lt.projectionMatrixInverse.copy(St.projectionMatrixInverse),Lt.isPerspectiveCamera&&(Lt.fov=2*oc*Math.atan(1/Lt.projectionMatrix.elements[5]),Lt.zoom=1)},this.getCamera=function(){return pe},this.getFoveation=function(){if(null!==J||null!==at)return P},this.setFoveation=function(Ce){P=Ce,null!==J&&(J.fixedFoveation=Ce),null!==at&&void 0!==at.fixedFoveation&&(at.fixedFoveation=Ce)},this.hasDepthSensing=function(){return null!==ct.texture};let In=null;const Mn=new sp;Mn.setAnimationLoop(function(Ce,rn){if(W=rn.getViewerPose(z||w),it=rn,null!==W){const On=W.views;null!==at&&(e.setRenderTargetFramebuffer(Tt,at.framebuffer),e.setRenderTarget(Tt));let ln=!1;On.length!==pe.cameras.length&&(pe.cameras.length=0,ln=!0);for(let St=0;St<On.length;St++){const Et=On[St];let re=null;if(null!==at)re=at.getViewport(Et);else{const oe=tt.getViewSubImage(J,Et);re=oe.viewport,0===St&&(e.setRenderTargetTextures(Tt,oe.colorTexture,J.ignoreDepthValues?void 0:oe.depthStencilTexture),e.setRenderTarget(Tt))}let $t=ie[St];void 0===$t&&($t=new ea,$t.layers.enable(St),$t.viewport=new li,ie[St]=$t),$t.matrix.fromArray(Et.transform.matrix),$t.matrix.decompose($t.position,$t.quaternion,$t.scale),$t.projectionMatrix.fromArray(Et.projectionMatrix),$t.projectionMatrixInverse.copy($t.projectionMatrix).invert(),$t.viewport.set(re.x,re.y,re.width,re.height),0===St&&(pe.matrix.copy($t.matrix),pe.matrix.decompose(pe.position,pe.quaternion,pe.scale)),!0===ln&&pe.cameras.push($t)}const Lt=g.enabledFeatures;if(Lt&&Lt.includes("depth-sensing")){const St=tt.getDepthInformation(On[0]);St&&St.isValid&&St.texture&&ct.init(e,St,g.renderState)}}for(let On=0;On<Pt.length;On++){const ln=zt[On],Lt=Pt[On];null!==ln&&void 0!==Lt&&Lt.update(ln,rn,z||w)}ct.render(e,pe),In&&In(Ce,rn),rn.detectedPlanes&&d.dispatchEvent({type:"planesdetected",data:rn}),it=null}),this.setAnimationLoop=function(Ce){In=Ce},this.dispose=function(){}}}const wl=new Gi,jh=new Yn;function Yu(A,e){function s(c,d){!0===c.matrixAutoUpdate&&c.updateMatrix(),d.value.copy(c.matrix)}function l(c,d){c.opacity.value=d.opacity,d.color&&c.diffuse.value.copy(d.color),d.emissive&&c.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity),d.map&&(c.map.value=d.map,s(d.map,c.mapTransform)),d.alphaMap&&(c.alphaMap.value=d.alphaMap,s(d.alphaMap,c.alphaMapTransform)),d.bumpMap&&(c.bumpMap.value=d.bumpMap,s(d.bumpMap,c.bumpMapTransform),c.bumpScale.value=d.bumpScale,d.side===X&&(c.bumpScale.value*=-1)),d.normalMap&&(c.normalMap.value=d.normalMap,s(d.normalMap,c.normalMapTransform),c.normalScale.value.copy(d.normalScale),d.side===X&&c.normalScale.value.negate()),d.displacementMap&&(c.displacementMap.value=d.displacementMap,s(d.displacementMap,c.displacementMapTransform),c.displacementScale.value=d.displacementScale,c.displacementBias.value=d.displacementBias),d.emissiveMap&&(c.emissiveMap.value=d.emissiveMap,s(d.emissiveMap,c.emissiveMapTransform)),d.specularMap&&(c.specularMap.value=d.specularMap,s(d.specularMap,c.specularMapTransform)),d.alphaTest>0&&(c.alphaTest.value=d.alphaTest);const g=e.get(d),v=g.envMap,x=g.envMapRotation;if(v&&(c.envMap.value=v,wl.copy(x),wl.x*=-1,wl.y*=-1,wl.z*=-1,v.isCubeTexture&&!1===v.isRenderTargetTexture&&(wl.y*=-1,wl.z*=-1),c.envMapRotation.value.setFromMatrix4(jh.makeRotationFromEuler(wl)),c.flipEnvMap.value=v.isCubeTexture&&!1===v.isRenderTargetTexture?-1:1,c.reflectivity.value=d.reflectivity,c.ior.value=d.ior,c.refractionRatio.value=d.refractionRatio),d.lightMap){c.lightMap.value=d.lightMap;const w=!0===A._useLegacyLights?Math.PI:1;c.lightMapIntensity.value=d.lightMapIntensity*w,s(d.lightMap,c.lightMapTransform)}d.aoMap&&(c.aoMap.value=d.aoMap,c.aoMapIntensity.value=d.aoMapIntensity,s(d.aoMap,c.aoMapTransform))}return{refreshFogUniforms:function(c,d){d.color.getRGB(c.fogColor.value,qm(A)),d.isFog?(c.fogNear.value=d.near,c.fogFar.value=d.far):d.isFogExp2&&(c.fogDensity.value=d.density)},refreshMaterialUniforms:function(c,d,g,v,x){var S;d.isMeshBasicMaterial||d.isMeshLambertMaterial?l(c,d):d.isMeshToonMaterial?(l(c,d),(S=d).gradientMap&&(c.gradientMap.value=S.gradientMap)):d.isMeshPhongMaterial?(l(c,d),function(w,S){w.specular.value.copy(S.specular),w.shininess.value=Math.max(S.shininess,1e-4)}(c,d)):d.isMeshStandardMaterial?(l(c,d),function(w,S){w.metalness.value=S.metalness,S.metalnessMap&&(w.metalnessMap.value=S.metalnessMap,s(S.metalnessMap,w.metalnessMapTransform)),w.roughness.value=S.roughness,S.roughnessMap&&(w.roughnessMap.value=S.roughnessMap,s(S.roughnessMap,w.roughnessMapTransform)),S.envMap&&(w.envMapIntensity.value=S.envMapIntensity)}(c,d),d.isMeshPhysicalMaterial&&function(w,S,P){w.ior.value=S.ior,S.sheen>0&&(w.sheenColor.value.copy(S.sheenColor).multiplyScalar(S.sheen),w.sheenRoughness.value=S.sheenRoughness,S.sheenColorMap&&(w.sheenColorMap.value=S.sheenColorMap,s(S.sheenColorMap,w.sheenColorMapTransform)),S.sheenRoughnessMap&&(w.sheenRoughnessMap.value=S.sheenRoughnessMap,s(S.sheenRoughnessMap,w.sheenRoughnessMapTransform))),S.clearcoat>0&&(w.clearcoat.value=S.clearcoat,w.clearcoatRoughness.value=S.clearcoatRoughness,S.clearcoatMap&&(w.clearcoatMap.value=S.clearcoatMap,s(S.clearcoatMap,w.clearcoatMapTransform)),S.clearcoatRoughnessMap&&(w.clearcoatRoughnessMap.value=S.clearcoatRoughnessMap,s(S.clearcoatRoughnessMap,w.clearcoatRoughnessMapTransform)),S.clearcoatNormalMap&&(w.clearcoatNormalMap.value=S.clearcoatNormalMap,s(S.clearcoatNormalMap,w.clearcoatNormalMapTransform),w.clearcoatNormalScale.value.copy(S.clearcoatNormalScale),S.side===X&&w.clearcoatNormalScale.value.negate())),S.dispersion>0&&(w.dispersion.value=S.dispersion),S.iridescence>0&&(w.iridescence.value=S.iridescence,w.iridescenceIOR.value=S.iridescenceIOR,w.iridescenceThicknessMinimum.value=S.iridescenceThicknessRange[0],w.iridescenceThicknessMaximum.value=S.iridescenceThicknessRange[1],S.iridescenceMap&&(w.iridescenceMap.value=S.iridescenceMap,s(S.iridescenceMap,w.iridescenceMapTransform)),S.iridescenceThicknessMap&&(w.iridescenceThicknessMap.value=S.iridescenceThicknessMap,s(S.iridescenceThicknessMap,w.iridescenceThicknessMapTransform))),S.transmission>0&&(w.transmission.value=S.transmission,w.transmissionSamplerMap.value=P.texture,w.transmissionSamplerSize.value.set(P.width,P.height),S.transmissionMap&&(w.transmissionMap.value=S.transmissionMap,s(S.transmissionMap,w.transmissionMapTransform)),w.thickness.value=S.thickness,S.thicknessMap&&(w.thicknessMap.value=S.thicknessMap,s(S.thicknessMap,w.thicknessMapTransform)),w.attenuationDistance.value=S.attenuationDistance,w.attenuationColor.value.copy(S.attenuationColor)),S.anisotropy>0&&(w.anisotropyVector.value.set(S.anisotropy*Math.cos(S.anisotropyRotation),S.anisotropy*Math.sin(S.anisotropyRotation)),S.anisotropyMap&&(w.anisotropyMap.value=S.anisotropyMap,s(S.anisotropyMap,w.anisotropyMapTransform))),w.specularIntensity.value=S.specularIntensity,w.specularColor.value.copy(S.specularColor),S.specularColorMap&&(w.specularColorMap.value=S.specularColorMap,s(S.specularColorMap,w.specularColorMapTransform)),S.specularIntensityMap&&(w.specularIntensityMap.value=S.specularIntensityMap,s(S.specularIntensityMap,w.specularIntensityMapTransform))}(c,d,x)):d.isMeshMatcapMaterial?(l(c,d),function(w,S){S.matcap&&(w.matcap.value=S.matcap)}(c,d)):d.isMeshDepthMaterial?l(c,d):d.isMeshDistanceMaterial?(l(c,d),function(w,S){const P=e.get(S).light;w.referencePosition.value.setFromMatrixPosition(P.matrixWorld),w.nearDistance.value=P.shadow.camera.near,w.farDistance.value=P.shadow.camera.far}(c,d)):d.isMeshNormalMaterial?l(c,d):d.isLineBasicMaterial?(function(w,S){w.diffuse.value.copy(S.color),w.opacity.value=S.opacity,S.map&&(w.map.value=S.map,s(S.map,w.mapTransform))}(c,d),d.isLineDashedMaterial&&function(w,S){w.dashSize.value=S.dashSize,w.totalSize.value=S.dashSize+S.gapSize,w.scale.value=S.scale}(c,d)):d.isPointsMaterial?function(w,S,P,z){w.diffuse.value.copy(S.color),w.opacity.value=S.opacity,w.size.value=S.size*P,w.scale.value=.5*z,S.map&&(w.map.value=S.map,s(S.map,w.uvTransform)),S.alphaMap&&(w.alphaMap.value=S.alphaMap,s(S.alphaMap,w.alphaMapTransform)),S.alphaTest>0&&(w.alphaTest.value=S.alphaTest)}(c,d,g,v):d.isSpriteMaterial?function(w,S){w.diffuse.value.copy(S.color),w.opacity.value=S.opacity,w.rotation.value=S.rotation,S.map&&(w.map.value=S.map,s(S.map,w.mapTransform)),S.alphaMap&&(w.alphaMap.value=S.alphaMap,s(S.alphaMap,w.alphaMapTransform)),S.alphaTest>0&&(w.alphaTest.value=S.alphaTest)}(c,d):d.isShadowMaterial?(c.color.value.copy(d.color),c.opacity.value=d.opacity):d.isShaderMaterial&&(d.uniformsNeedUpdate=!1)}}}function Na(A,e,s,l){let c={},d={},g=[];const v=A.getParameter(A.MAX_UNIFORM_BUFFER_BINDINGS);function x(P,z,W,Y){const tt=P.value,J=z+"_"+W;if(void 0===Y[J])return Y[J]="number"==typeof tt||"boolean"==typeof tt?tt:tt.clone(),!0;{const at=Y[J];if("number"==typeof tt||"boolean"==typeof tt){if(at!==tt)return Y[J]=tt,!0}else if(!1===at.equals(tt))return at.copy(tt),!0}return!1}function w(P){const z={boundary:0,storage:0};return"number"==typeof P||"boolean"==typeof P?(z.boundary=4,z.storage=4):P.isVector2?(z.boundary=8,z.storage=8):P.isVector3||P.isColor?(z.boundary=16,z.storage=12):P.isVector4?(z.boundary=16,z.storage=16):P.isMatrix3?(z.boundary=48,z.storage=48):P.isMatrix4?(z.boundary=64,z.storage=64):P.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",P),z}function S(P){const z=P.target;z.removeEventListener("dispose",S);const W=g.indexOf(z.__bindingPointIndex);g.splice(W,1),A.deleteBuffer(c[z.id]),delete c[z.id],delete d[z.id]}return{bind:function(P,z){l.uniformBlockBinding(P,z.program)},update:function(P,z){let W=c[P.id];void 0===W&&(function(J){const at=J.uniforms;let it=0;for(let At=0,Ft=at.length;At<Ft;At++){const Tt=Array.isArray(at[At])?at[At]:[at[At]];for(let Pt=0,zt=Tt.length;Pt<zt;Pt++){const ee=Tt[Pt],ce=Array.isArray(ee.value)?ee.value:[ee.value];for(let ne=0,ge=ce.length;ne<ge;ne++){const ie=w(ce[ne]),pe=it%16;0!==pe&&16-pe<ie.boundary&&(it+=16-pe),ee.__data=new Float32Array(ie.storage/Float32Array.BYTES_PER_ELEMENT),ee.__offset=it,it+=ie.storage}}}const ct=it%16;ct>0&&(it+=16-ct),J.__size=it,J.__cache={}}(P),W=function(J){const at=function(){for(let Ft=0;Ft<v;Ft++)if(-1===g.indexOf(Ft))return g.push(Ft),Ft;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();J.__bindingPointIndex=at;const it=A.createBuffer(),ct=J.__size,At=J.usage;return A.bindBuffer(A.UNIFORM_BUFFER,it),A.bufferData(A.UNIFORM_BUFFER,ct,At),A.bindBuffer(A.UNIFORM_BUFFER,null),A.bindBufferBase(A.UNIFORM_BUFFER,at,it),it}(P),c[P.id]=W,P.addEventListener("dispose",S)),l.updateUBOMapping(P,z.program);const tt=e.render.frame;d[P.id]!==tt&&(function(J){const it=J.uniforms,ct=J.__cache;A.bindBuffer(A.UNIFORM_BUFFER,c[J.id]);for(let At=0,Ft=it.length;At<Ft;At++){const Tt=Array.isArray(it[At])?it[At]:[it[At]];for(let Pt=0,zt=Tt.length;Pt<zt;Pt++){const ee=Tt[Pt];if(!0===x(ee,At,Pt,ct)){const ce=ee.__offset,ne=Array.isArray(ee.value)?ee.value:[ee.value];let ge=0;for(let ie=0;ie<ne.length;ie++){const pe=ne[ie],Oe=w(pe);"number"==typeof pe||"boolean"==typeof pe?(ee.__data[0]=pe,A.bufferSubData(A.UNIFORM_BUFFER,ce+ge,ee.__data)):pe.isMatrix3?(ee.__data[0]=pe.elements[0],ee.__data[1]=pe.elements[1],ee.__data[2]=pe.elements[2],ee.__data[3]=0,ee.__data[4]=pe.elements[3],ee.__data[5]=pe.elements[4],ee.__data[6]=pe.elements[5],ee.__data[7]=0,ee.__data[8]=pe.elements[6],ee.__data[9]=pe.elements[7],ee.__data[10]=pe.elements[8],ee.__data[11]=0):(pe.toArray(ee.__data,ge),ge+=Oe.storage/Float32Array.BYTES_PER_ELEMENT)}A.bufferSubData(A.UNIFORM_BUFFER,ce,ee.__data)}}}A.bindBuffer(A.UNIFORM_BUFFER,null)}(P),d[P.id]=tt)},dispose:function(){for(const P in c)A.deleteBuffer(c[P]);g=[],c={},d={}}}}class uu{constructor(e={}){const{canvas:s=lf(),context:l=null,depth:c=!0,stencil:d=!1,alpha:g=!1,antialias:v=!1,premultipliedAlpha:x=!0,preserveDrawingBuffer:w=!1,powerPreference:S="default",failIfMajorPerformanceCaveat:P=!1,multiviewStereo:z=!1}=e;let W;if(this.isWebGLRenderer=!0,null!==l){if(typeof WebGLRenderingContext<"u"&&l instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");W=l.getContextAttributes().alpha}else W=g;const Y=new Uint32Array(4),tt=new Int32Array(4);let J=null,at=null;const it=[],ct=[];this.domElement=s,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=qi,this._useLegacyLights=!1,this.toneMapping=ut,this.toneMappingExposure=1;const At=this;let Ft=!1,Tt=0,Pt=0,zt=null,ee=-1,ce=null;const ne=new li,ge=new li;let ie=null;const pe=new En(0);let Oe=0,Pe=s.width,ze=s.height,Fe=1,Dn=null,Nn=null;const fn=new li(0,0,Pe,ze),xn=new li(0,0,Pe,ze);let In=!1;const Mn=new Ra;let Ce=!1,rn=!1;const On=new Yn,ln=new Dt,Lt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function St(){return null===zt?Fe:1}let Et,re,$t,oe,fe,ye,Xe,Fn,An,Un,ar,$n,sr,Xr,Ir,kr,Qr,Ui,Zn,ts,Gs,rc,or,zi,Di,Ue=l;function Ad(Qt,Se){return s.getContext(Qt,Se)}try{const Qt={alpha:!0,depth:c,stencil:d,antialias:v,premultipliedAlpha:x,preserveDrawingBuffer:w,powerPreference:S,failIfMajorPerformanceCaveat:P};if("setAttribute"in s&&s.setAttribute("data-engine",`three.js r${O}`),s.addEventListener("webglcontextlost",bA,!1),s.addEventListener("webglcontextrestored",Fy,!1),s.addEventListener("webglcontextcreationerror",Qp,!1),null===Ue){const Se="webgl2";if(Ue=Ad(Se,Qt),null===Ue)throw Ad(Se)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(Qt){throw console.error("THREE.WebGLRenderer: "+Qt.message),Qt}function Nc(){Et=new Bb(Ue),Et.init(),or=new yg(Ue,Et),re=new b1(Ue,Et,e,or),$t=new S0(Ue),oe=new Nr(Ue),fe=new Ps,ye=new M0(Ue,Et,$t,fe,re,or,oe),Xe=new Rb(At),Fn=new qr(At),An=new y1(Ue),zi=new ru(Ue,An),Un=new $h(Ue,An,oe,zi),ar=new E1(Ue,Un,An,oe),ts=new w1(Ue,re,ye),kr=new Uh(fe),$n=new fg(At,Xe,Fn,Et,re,zi,kr),sr=new Yu(At,fe),Xr=new mg,Ir=new Ag(Et),Zn=new yn(At,Xe,Fn,$t,ar,W,x),Ui=new Vh(At,Et,Ue),Qr=new I0(At,ar,re),Di=new Na(Ue,oe,re,$t),Gs=new v1(Ue,Et,oe),rc=new Os(Ue,Et,oe),oe.programs=$n.programs,At.capabilities=re,At.extensions=Et,At.properties=fe,At.renderLists=Xr,At.shadowMap=Qr,At.state=$t,At.info=oe}Nc();const Mi=typeof navigator<"u"&&"xr"in navigator?new T0(At,Ue,Et,z):new yc(At);function bA(Qt){Qt.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),Ft=!0}function Fy(){console.log("THREE.WebGLRenderer: Context Restored."),Ft=!1;const Qt=oe.autoReset,Se=Qr.enabled,Ve=Qr.autoUpdate,Ke=Qr.needsUpdate,Qe=Qr.type;Nc(),oe.autoReset=Qt,Qr.enabled=Se,Qr.autoUpdate=Ve,Qr.needsUpdate=Ke,Qr.type=Qe}function Qp(Qt){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",Qt.statusMessage)}function Ov(Qt){const Se=Qt.target;var Ve;Se.removeEventListener("dispose",Ov),function(Ke){const Qe=fe.get(Ke).programs;void 0!==Qe&&(Qe.forEach(function(Cn){$n.releaseProgram(Cn)}),Ke.isShaderMaterial&&$n.releaseShaderCache(Ke))}(Ve=Se),fe.remove(Ve)}function Oy(Qt,Se,Ve){!0===Qt.transparent&&Qt.side===lt&&!1===Qt.forceSinglePass?(Qt.side=X,Qt.needsUpdate=!0,Ah(Qt,Se,Ve),Qt.side=Q,Qt.needsUpdate=!0,Ah(Qt,Se,Ve),Qt.side=lt):Ah(Qt,Se,Ve)}this.xr=Mi,this.getContext=function(){return Ue},this.getContextAttributes=function(){return Ue.getContextAttributes()},this.forceContextLoss=function(){const Qt=Et.get("WEBGL_lose_context");Qt&&Qt.loseContext()},this.forceContextRestore=function(){const Qt=Et.get("WEBGL_lose_context");Qt&&Qt.restoreContext()},this.getPixelRatio=function(){return Fe},this.setPixelRatio=function(Qt){void 0!==Qt&&(Fe=Qt,this.setSize(Pe,ze,!1))},this.getSize=function(Qt){return Qt.set(Pe,ze)},this.setSize=function(Qt,Se,Ve=!0){Mi.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(Pe=Qt,ze=Se,s.width=Math.floor(Qt*Fe),s.height=Math.floor(Se*Fe),!0===Ve&&(s.style.width=Qt+"px",s.style.height=Se+"px"),this.setViewport(0,0,Qt,Se))},this.getDrawingBufferSize=function(Qt){return Qt.set(Pe*Fe,ze*Fe).floor()},this.setDrawingBufferSize=function(Qt,Se,Ve){Pe=Qt,ze=Se,Fe=Ve,s.width=Math.floor(Qt*Ve),s.height=Math.floor(Se*Ve),this.setViewport(0,0,Qt,Se)},this.getCurrentViewport=function(Qt){return Qt.copy(ne)},this.getViewport=function(Qt){return Qt.copy(fn)},this.setViewport=function(Qt,Se,Ve,Ke){Qt.isVector4?fn.set(Qt.x,Qt.y,Qt.z,Qt.w):fn.set(Qt,Se,Ve,Ke),$t.viewport(ne.copy(fn).multiplyScalar(Fe).round())},this.getScissor=function(Qt){return Qt.copy(xn)},this.setScissor=function(Qt,Se,Ve,Ke){Qt.isVector4?xn.set(Qt.x,Qt.y,Qt.z,Qt.w):xn.set(Qt,Se,Ve,Ke),$t.scissor(ge.copy(xn).multiplyScalar(Fe).round())},this.getScissorTest=function(){return In},this.setScissorTest=function(Qt){$t.setScissorTest(In=Qt)},this.setOpaqueSort=function(Qt){Dn=Qt},this.setTransparentSort=function(Qt){Nn=Qt},this.getClearColor=function(Qt){return Qt.copy(Zn.getClearColor())},this.setClearColor=function(){Zn.setClearColor.apply(Zn,arguments)},this.getClearAlpha=function(){return Zn.getClearAlpha()},this.setClearAlpha=function(){Zn.setClearAlpha.apply(Zn,arguments)},this.clear=function(Qt=!0,Se=!0,Ve=!0){let Ke=0;if(Qt){let Qe=!1;if(null!==zt){const Cn=zt.texture.format;Qe=Cn===Ms||Cn===Xs||Cn===pa}if(Qe){const Cn=zt.texture.type,pr=Cn===jn||Cn===rr||Cn===vr||Cn===ai||Cn===xi||Cn===cr,fr=Zn.getClearColor(),Er=Zn.getClearAlpha(),Yr=fr.r,yi=fr.g,mi=fr.b;pr?(Y[0]=Yr,Y[1]=yi,Y[2]=mi,Y[3]=Er,Ue.clearBufferuiv(Ue.COLOR,0,Y)):(tt[0]=Yr,tt[1]=yi,tt[2]=mi,tt[3]=Er,Ue.clearBufferiv(Ue.COLOR,0,tt))}else Ke|=Ue.COLOR_BUFFER_BIT}Se&&(Ke|=Ue.DEPTH_BUFFER_BIT),Ve&&(Ke|=Ue.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),Ue.clear(Ke)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){s.removeEventListener("webglcontextlost",bA,!1),s.removeEventListener("webglcontextrestored",Fy,!1),s.removeEventListener("webglcontextcreationerror",Qp,!1),Xr.dispose(),Ir.dispose(),fe.dispose(),Xe.dispose(),Fn.dispose(),ar.dispose(),zi.dispose(),Di.dispose(),$n.dispose(),Mi.dispose(),Mi.removeEventListener("sessionstart",Tl),Mi.removeEventListener("sessionend",Uy),gh.stop()},this.renderBufferDirect=function(Qt,Se,Ve,Ke,Qe,Cn){null===Se&&(Se=Lt);const pr=Qe.isMesh&&Qe.matrixWorld.determinant()<0,fr=function(gs,Dc,kl,ni,Ci){!0!==Dc.isScene&&(Dc=Lt),ye.resetTextureUnits();const SA=Dc.fog,zv=null===zt?At.outputColorSpace:!0===zt.isXRRenderTarget?zt.texture.colorSpace:ps,Hp=(ni.isMeshStandardMaterial?Fn:Xe).get(ni.envMap||(ni.isMeshStandardMaterial?Dc.environment:null)),$v=!0===ni.vertexColors&&!!kl.attributes.color&&4===kl.attributes.color.itemSize,Vv=!!kl.attributes.tangent&&(!!ni.normalMap||ni.anisotropy>0),Gv=!!kl.morphAttributes.position,yh=!!kl.morphAttributes.normal,$y=!!kl.morphAttributes.color;let _u=ut;ni.toneMapped&&(null!==zt&&!0!==zt.isXRRenderTarget||(_u=At.toneMapping));const Vy=zt&&zt.isWebGLMultiviewRenderTarget?zt.numViews:0,Gy=kl.morphAttributes.position||kl.morphAttributes.normal||kl.morphAttributes.color,Em=void 0!==Gy?Gy.length:0,ri=fe.get(ni),Wi=at.state.lights;!0!==Ce||!0!==rn&&gs===ce||kr.setState(ni,gs,gs===ce&&ni.id===ee);let Rl=!1;ni.version===ri.__version?ri.needsLights&&ri.lightsStateVersion!==Wi.state.version||ri.outputColorSpace!==zv||Ci.isBatchedMesh&&!1===ri.batching?Rl=!0:Ci.isBatchedMesh||!0!==ri.batching?Ci.isInstancedMesh&&!1===ri.instancing?Rl=!0:Ci.isInstancedMesh||!0!==ri.instancing?Ci.isSkinnedMesh&&!1===ri.skinning?Rl=!0:Ci.isSkinnedMesh||!0!==ri.skinning?Ci.isInstancedMesh&&!0===ri.instancingColor&&null===Ci.instanceColor||Ci.isInstancedMesh&&!1===ri.instancingColor&&null!==Ci.instanceColor||Ci.isInstancedMesh&&!0===ri.instancingMorph&&null===Ci.morphTexture||Ci.isInstancedMesh&&!1===ri.instancingMorph&&null!==Ci.morphTexture||ri.envMap!==Hp||!0===ni.fog&&ri.fog!==SA?Rl=!0:void 0===ri.numClippingPlanes||ri.numClippingPlanes===kr.numPlanes&&ri.numIntersection===kr.numIntersection?(ri.vertexAlphas!==$v||ri.vertexTangents!==Vv||ri.morphTargets!==Gv||ri.morphNormals!==yh||ri.morphColors!==$y||ri.toneMapping!==_u||ri.morphTargetsCount!==Em||ri.numMultiviewViews!==Vy)&&(Rl=!0):Rl=!0:Rl=!0:Rl=!0:Rl=!0:(Rl=!0,ri.__version=ni.version);let vi=ri.currentProgram;!0===Rl&&(vi=Ah(ni,Dc,Ci));let MA=!1,yd=!1,Cm=!1;const Qs=vi.getUniforms(),Lc=ri.uniforms;if($t.useProgram(vi.program)&&(MA=!0,yd=!0,Cm=!0),ni.id!==ee&&(ee=ni.id,yd=!0),MA||ce!==gs){vi.numMultiviewViews>0?(Ui.updateCameraProjectionMatricesUniform(gs,Qs),Ui.updateCameraViewMatricesUniform(gs,Qs)):(Qs.setValue(Ue,"projectionMatrix",gs.projectionMatrix),Qs.setValue(Ue,"viewMatrix",gs.matrixWorldInverse));const Ws=Qs.map.cameraPosition;void 0!==Ws&&Ws.setValue(Ue,ln.setFromMatrixPosition(gs.matrixWorld)),re.logarithmicDepthBuffer&&Qs.setValue(Ue,"logDepthBufFC",2/(Math.log(gs.far+1)/Math.LN2)),(ni.isMeshPhongMaterial||ni.isMeshToonMaterial||ni.isMeshLambertMaterial||ni.isMeshBasicMaterial||ni.isMeshStandardMaterial||ni.isShaderMaterial)&&Qs.setValue(Ue,"isOrthographic",!0===gs.isOrthographicCamera),ce!==gs&&(ce=gs,yd=!0,Cm=!0)}if(Ci.isSkinnedMesh){Qs.setOptional(Ue,Ci,"bindMatrix"),Qs.setOptional(Ue,Ci,"bindMatrixInverse");const Ws=Ci.skeleton;Ws&&(null===Ws.boneTexture&&Ws.computeBoneTexture(),Qs.setValue(Ue,"boneTexture",Ws.boneTexture,ye))}Ci.isBatchedMesh&&(Qs.setOptional(Ue,Ci,"batchingTexture"),Qs.setValue(Ue,"batchingTexture",Ci._matricesTexture,ye));const Im=kl.morphAttributes;var Mo,Hs;if(void 0===Im.position&&void 0===Im.normal&&void 0===Im.color||ts.update(Ci,kl,vi),(yd||ri.receiveShadow!==Ci.receiveShadow)&&(ri.receiveShadow=Ci.receiveShadow,Qs.setValue(Ue,"receiveShadow",Ci.receiveShadow)),ni.isMeshGouraudMaterial&&null!==ni.envMap&&(Lc.envMap.value=Hp,Lc.flipEnvMap.value=Hp.isCubeTexture&&!1===Hp.isRenderTargetTexture?-1:1),ni.isMeshStandardMaterial&&null===ni.envMap&&null!==Dc.environment&&(Lc.envMapIntensity.value=Dc.environmentIntensity),yd&&(Qs.setValue(Ue,"toneMappingExposure",At.toneMappingExposure),ri.needsLights&&((Mo=Lc).ambientLightColor.needsUpdate=Hs=Cm,Mo.lightProbe.needsUpdate=Hs,Mo.directionalLights.needsUpdate=Hs,Mo.directionalLightShadows.needsUpdate=Hs,Mo.pointLights.needsUpdate=Hs,Mo.pointLightShadows.needsUpdate=Hs,Mo.spotLights.needsUpdate=Hs,Mo.spotLightShadows.needsUpdate=Hs,Mo.rectAreaLights.needsUpdate=Hs,Mo.hemisphereLights.needsUpdate=Hs),SA&&!0===ni.fog&&sr.refreshFogUniforms(Lc,SA),sr.refreshMaterialUniforms(Lc,ni,Fe,ze,at.state.transmissionRenderTarget[gs.id]),ug.upload(Ue,EA(ri),Lc,ye)),ni.isShaderMaterial&&!0===ni.uniformsNeedUpdate&&(ug.upload(Ue,EA(ri),Lc,ye),ni.uniformsNeedUpdate=!1),ni.isSpriteMaterial&&Qs.setValue(Ue,"center",Ci.center),vi.numMultiviewViews>0?Ui.updateObjectMatricesUniforms(Ci,gs,Qs):(Qs.setValue(Ue,"modelViewMatrix",Ci.modelViewMatrix),Qs.setValue(Ue,"normalMatrix",Ci.normalMatrix)),Qs.setValue(Ue,"modelMatrix",Ci.matrixWorld),ni.isShaderMaterial||ni.isRawShaderMaterial){const Ws=ni.uniformsGroups;for(let Sm=0,Qv=Ws.length;Sm<Qv;Sm++){const Qy=Ws[Sm];Di.update(Qy,vi),Di.bind(Qy,vi)}}return vi}(Qt,Se,Ve,Ke,Qe);$t.setMaterial(Ke,pr);let Er=Ve.index,Yr=1;if(!0===Ke.wireframe){if(Er=Un.getWireframeAttribute(Ve),void 0===Er)return;Yr=2}const yi=Ve.drawRange,mi=Ve.attributes.position;let es=yi.start*Yr,_l=(yi.start+yi.count)*Yr;null!==Cn&&(es=Math.max(es,Cn.start*Yr),_l=Math.min(_l,(Cn.start+Cn.count)*Yr)),null!==Er?(es=Math.max(es,0),_l=Math.min(_l,Er.count)):null!=mi&&(es=Math.max(es,0),_l=Math.min(_l,mi.count));const xs=_l-es;if(xs<0||xs===1/0)return;let cl;zi.setup(Qe,Ke,fr,Ve,Er);let ws=Gs;if(null!==Er&&(cl=An.get(Er),ws=rc,ws.setIndex(cl)),Qe.isMesh)!0===Ke.wireframe?($t.setLineWidth(Ke.wireframeLinewidth*St()),ws.setMode(Ue.LINES)):ws.setMode(Ue.TRIANGLES);else if(Qe.isLine){let gs=Ke.linewidth;void 0===gs&&(gs=1),$t.setLineWidth(gs*St()),ws.setMode(Qe.isLineSegments?Ue.LINES:Qe.isLineLoop?Ue.LINE_LOOP:Ue.LINE_STRIP)}else Qe.isPoints?ws.setMode(Ue.POINTS):Qe.isSprite&&ws.setMode(Ue.TRIANGLES);if(Qe.isBatchedMesh)null!==Qe._multiDrawInstances?ws.renderMultiDrawInstances(Qe._multiDrawStarts,Qe._multiDrawCounts,Qe._multiDrawCount,Qe._multiDrawInstances):ws.renderMultiDraw(Qe._multiDrawStarts,Qe._multiDrawCounts,Qe._multiDrawCount);else if(Qe.isInstancedMesh)ws.renderInstances(es,xs,Qe.count);else if(Ve.isInstancedBufferGeometry){const Dc=Math.min(Ve.instanceCount,void 0!==Ve._maxInstanceCount?Ve._maxInstanceCount:1/0);ws.renderInstances(es,xs,Dc)}else ws.render(es,xs)},this.compile=function(Qt,Se,Ve=null){null===Ve&&(Ve=Qt),at=Ir.get(Ve),at.init(Se),ct.push(at),Ve.traverseVisible(function(Qe){Qe.isLight&&Qe.layers.test(Se.layers)&&(at.pushLight(Qe),Qe.castShadow&&at.pushShadow(Qe))}),Qt!==Ve&&Qt.traverseVisible(function(Qe){Qe.isLight&&Qe.layers.test(Se.layers)&&(at.pushLight(Qe),Qe.castShadow&&at.pushShadow(Qe))}),at.setupLights(At._useLegacyLights);const Ke=new Set;return Qt.traverse(function(Qe){const Cn=Qe.material;if(Cn)if(Array.isArray(Cn))for(let pr=0;pr<Cn.length;pr++){const fr=Cn[pr];Oy(fr,Ve,Qe),Ke.add(fr)}else Oy(Cn,Ve,Qe),Ke.add(Cn)}),ct.pop(),at=null,Ke},this.compileAsync=function(Qt,Se,Ve=null){const Ke=this.compile(Qt,Se,Ve);return new Promise(Qe=>{function Cn(){Ke.forEach(function(pr){fe.get(pr).currentProgram.isReady()&&Ke.delete(pr)}),0!==Ke.size?setTimeout(Cn,10):Qe(Qt)}null!==Et.get("KHR_parallel_shader_compile")?Cn():setTimeout(Cn,10)})};let Py=null;function Tl(){gh.stop()}function Uy(){gh.start()}const gh=new sp;function Pv(Qt,Se,Ve,Ke){if(!1===Qt.visible)return;if(Qt.layers.test(Se.layers))if(Qt.isGroup)Ve=Qt.renderOrder;else if(Qt.isLOD)!0===Qt.autoUpdate&&Qt.update(Se);else if(Qt.isLight)at.pushLight(Qt),Qt.castShadow&&at.pushShadow(Qt);else if(Qt.isSprite){if(!Qt.frustumCulled||Mn.intersectsSprite(Qt)){Ke&&ln.setFromMatrixPosition(Qt.matrixWorld).applyMatrix4(On);const Cn=ar.update(Qt),pr=Qt.material;pr.visible&&J.push(Qt,Cn,pr,Ve,ln.z,null)}}else if((Qt.isMesh||Qt.isLine||Qt.isPoints)&&(!Qt.frustumCulled||Mn.intersectsObject(Qt))){const Cn=ar.update(Qt),pr=Qt.material;if(Ke&&(void 0!==Qt.boundingSphere?(null===Qt.boundingSphere&&Qt.computeBoundingSphere(),ln.copy(Qt.boundingSphere.center)):(null===Cn.boundingSphere&&Cn.computeBoundingSphere(),ln.copy(Cn.boundingSphere.center)),ln.applyMatrix4(Qt.matrixWorld).applyMatrix4(On)),Array.isArray(pr)){const fr=Cn.groups;for(let Er=0,Yr=fr.length;Er<Yr;Er++){const yi=fr[Er],mi=pr[yi.materialIndex];mi&&mi.visible&&J.push(Qt,Cn,mi,Ve,ln.z,yi)}}else pr.visible&&J.push(Qt,Cn,pr,Ve,ln.z,null)}const Qe=Qt.children;for(let Cn=0,pr=Qe.length;Cn<pr;Cn++)Pv(Qe[Cn],Se,Ve,Ke)}function xA(Qt,Se,Ve,Ke){const Qe=Qt.opaque,Cn=Qt.transmissive,pr=Qt.transparent;at.setupLightsView(Ve),!0===Ce&&kr.setGlobalState(At.clippingPlanes,Ve),Ke&&$t.viewport(ne.copy(Ke)),Qe.length>0&&wm(Qe,Se,Ve),Cn.length>0&&wm(Cn,Se,Ve),pr.length>0&&wm(pr,Se,Ve),$t.buffers.depth.setTest(!0),$t.buffers.depth.setMask(!0),$t.buffers.color.setMask(!0),$t.setPolygonOffset(!1)}function zy(Qt,Se,Ve,Ke){if(null!==(!0===Ve.isScene?Ve.overrideMaterial:null))return;void 0===at.state.transmissionRenderTarget[Ke.id]&&(at.state.transmissionRenderTarget[Ke.id]=new bo(1,1,{generateMipmaps:!0,type:Et.has("EXT_color_buffer_half_float")||Et.has("EXT_color_buffer_float")?br:jn,minFilter:Sn,samples:4,stencilBuffer:d,resolveDepthBuffer:!1,resolveStencilBuffer:!1}));const Qe=at.state.transmissionRenderTarget[Ke.id],Cn=Ke.viewport||ne;Qe.setSize(Cn.z,Cn.w);const pr=At.getRenderTarget();At.setRenderTarget(Qe),At.getClearColor(pe),Oe=At.getClearAlpha(),Oe<1&&At.setClearColor(16777215,.5),At.clear();const fr=At.toneMapping;At.toneMapping=ut;const Er=Ke.viewport;if(void 0!==Ke.viewport&&(Ke.viewport=void 0),at.setupLightsView(Ke),!0===Ce&&kr.setGlobalState(At.clippingPlanes,Ke),wm(Qt,Ve,Ke),ye.updateMultisampleRenderTarget(Qe),ye.updateRenderTargetMipmap(Qe),!1===Et.has("WEBGL_multisampled_render_to_texture")){let Yr=!1;for(let yi=0,mi=Se.length;yi<mi;yi++){const es=Se[yi],_l=es.object,xs=es.geometry,cl=es.material,ws=es.group;if(cl.side===lt&&_l.layers.test(Ke.layers)){const gs=cl.side;cl.side=X,cl.needsUpdate=!0,wA(_l,Ve,Ke,xs,cl,ws),cl.side=gs,cl.needsUpdate=!0,Yr=!0}}!0===Yr&&(ye.updateMultisampleRenderTarget(Qe),ye.updateRenderTargetMipmap(Qe))}At.setRenderTarget(pr),At.setClearColor(pe,Oe),void 0!==Er&&(Ke.viewport=Er),At.toneMapping=fr}function wm(Qt,Se,Ve){const Ke=!0===Se.isScene?Se.overrideMaterial:null;for(let Qe=0,Cn=Qt.length;Qe<Cn;Qe++){const pr=Qt[Qe],fr=pr.object,Er=pr.geometry,Yr=null===Ke?pr.material:Ke,yi=pr.group;fr.layers.test(Ve.layers)&&wA(fr,Se,Ve,Er,Yr,yi)}}function wA(Qt,Se,Ve,Ke,Qe,Cn){Qt.onBeforeRender(At,Se,Ve,Ke,Qe,Cn),Qt.modelViewMatrix.multiplyMatrices(Ve.matrixWorldInverse,Qt.matrixWorld),Qt.normalMatrix.getNormalMatrix(Qt.modelViewMatrix),Qe.onBeforeRender(At,Se,Ve,Ke,Qt,Cn),!0===Qe.transparent&&Qe.side===lt&&!1===Qe.forceSinglePass?(Qe.side=X,Qe.needsUpdate=!0,At.renderBufferDirect(Ve,Se,Ke,Qe,Qt,Cn),Qe.side=Q,Qe.needsUpdate=!0,At.renderBufferDirect(Ve,Se,Ke,Qe,Qt,Cn),Qe.side=lt):At.renderBufferDirect(Ve,Se,Ke,Qe,Qt,Cn),Qt.onAfterRender(At,Se,Ve,Ke,Qe,Cn)}function Ah(Qt,Se,Ve){!0!==Se.isScene&&(Se=Lt);const Ke=fe.get(Qt),Qe=at.state.lights,pr=Qe.state.version,fr=$n.getParameters(Qt,Qe.state,at.state.shadowsArray,Se,Ve),Er=$n.getProgramCacheKey(fr);let Yr=Ke.programs;Ke.environment=Qt.isMeshStandardMaterial?Se.environment:null,Ke.fog=Se.fog,Ke.envMap=(Qt.isMeshStandardMaterial?Fn:Xe).get(Qt.envMap||Ke.environment),Ke.envMapRotation=null!==Ke.environment&&null===Qt.envMap?Se.environmentRotation:Qt.envMapRotation,void 0===Yr&&(Qt.addEventListener("dispose",Ov),Yr=new Map,Ke.programs=Yr);let yi=Yr.get(Er);if(void 0!==yi){if(Ke.currentProgram===yi&&Ke.lightsStateVersion===pr)return CA(Qt,fr),yi}else fr.uniforms=$n.getUniforms(Qt),Qt.onBuild(Ve,fr,At),Qt.onBeforeCompile(fr,At),yi=$n.acquireProgram(fr,Er),Yr.set(Er,yi),Ke.uniforms=fr.uniforms;const mi=Ke.uniforms;return(Qt.isShaderMaterial||Qt.isRawShaderMaterial)&&!0!==Qt.clipping||(mi.clippingPlanes=kr.uniform),CA(Qt,fr),Ke.needsLights=(es=Qt).isMeshLambertMaterial||es.isMeshToonMaterial||es.isMeshPhongMaterial||es.isMeshStandardMaterial||es.isShadowMaterial||es.isShaderMaterial&&!0===es.lights,Ke.lightsStateVersion=pr,Ke.needsLights&&(mi.ambientLightColor.value=Qe.state.ambient,mi.lightProbe.value=Qe.state.probe,mi.directionalLights.value=Qe.state.directional,mi.directionalLightShadows.value=Qe.state.directionalShadow,mi.spotLights.value=Qe.state.spot,mi.spotLightShadows.value=Qe.state.spotShadow,mi.rectAreaLights.value=Qe.state.rectArea,mi.ltc_1.value=Qe.state.rectAreaLTC1,mi.ltc_2.value=Qe.state.rectAreaLTC2,mi.pointLights.value=Qe.state.point,mi.pointLightShadows.value=Qe.state.pointShadow,mi.hemisphereLights.value=Qe.state.hemi,mi.directionalShadowMap.value=Qe.state.directionalShadowMap,mi.directionalShadowMatrix.value=Qe.state.directionalShadowMatrix,mi.spotShadowMap.value=Qe.state.spotShadowMap,mi.spotLightMatrix.value=Qe.state.spotLightMatrix,mi.spotLightMap.value=Qe.state.spotLightMap,mi.pointShadowMap.value=Qe.state.pointShadowMap,mi.pointShadowMatrix.value=Qe.state.pointShadowMatrix),Ke.currentProgram=yi,Ke.uniformsList=null,yi;var es}function EA(Qt){if(null===Qt.uniformsList){const Se=Qt.currentProgram.getUniforms();Qt.uniformsList=ug.seqWithValue(Se.seq,Qt.uniforms)}return Qt.uniformsList}function CA(Qt,Se){const Ve=fe.get(Qt);Ve.outputColorSpace=Se.outputColorSpace,Ve.batching=Se.batching,Ve.instancing=Se.instancing,Ve.instancingColor=Se.instancingColor,Ve.instancingMorph=Se.instancingMorph,Ve.skinning=Se.skinning,Ve.morphTargets=Se.morphTargets,Ve.morphNormals=Se.morphNormals,Ve.morphColors=Se.morphColors,Ve.morphTargetsCount=Se.morphTargetsCount,Ve.numClippingPlanes=Se.numClippingPlanes,Ve.numIntersection=Se.numClipIntersection,Ve.vertexAlphas=Se.vertexAlphas,Ve.vertexTangents=Se.vertexTangents,Ve.toneMapping=Se.toneMapping,Ve.numMultiviewViews=Se.numMultiviewViews}var IA;gh.setAnimationLoop(function(Qt){Py&&Py(Qt)}),typeof self<"u"&&gh.setContext(self),this.setAnimationLoop=function(Qt){Py=Qt,Mi.setAnimationLoop(Qt),null===Qt?gh.stop():gh.start()},Mi.addEventListener("sessionstart",Tl),Mi.addEventListener("sessionend",Uy),this.render=function(Qt,Se){if(void 0!==Se&&!0!==Se.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===Ft)return;!0===Qt.matrixWorldAutoUpdate&&Qt.updateMatrixWorld(),null===Se.parent&&!0===Se.matrixWorldAutoUpdate&&Se.updateMatrixWorld(),!0===Mi.enabled&&!0===Mi.isPresenting&&(!0===Mi.cameraAutoUpdate&&Mi.updateCamera(Se),Se=Mi.getCamera()),!0===Qt.isScene&&Qt.onBeforeRender(At,Qt,Se,zt),at=Ir.get(Qt,ct.length),at.init(Se),ct.push(at),On.multiplyMatrices(Se.projectionMatrix,Se.matrixWorldInverse),Mn.setFromProjectionMatrix(On),rn=this.localClippingEnabled,Ce=kr.init(this.clippingPlanes,rn),J=Xr.get(Qt,it.length),J.init(),it.push(J),Pv(Qt,Se,0,At.sortObjects),J.finish(),!0===At.sortObjects&&J.sort(Dn,Nn);const Ve=!1===Mi.enabled||!1===Mi.isPresenting||!1===Mi.hasDepthSensing();Ve&&Zn.addToRenderList(J,Qt),this.info.render.frame++,!0===Ce&&kr.beginShadows(),Qr.render(at.state.shadowsArray,Qt,Se),!0===Ce&&kr.endShadows(),!0===this.info.autoReset&&this.info.reset();const Qe=J.opaque,Cn=J.transmissive;if(at.setupLights(At._useLegacyLights),Se.isArrayCamera){const pr=Se.cameras;if(Cn.length>0)for(let fr=0,Er=pr.length;fr<Er;fr++)zy(Qe,Cn,Qt,pr[fr]);if(Ve&&Zn.render(Qt),Mi.enabled&&Mi.isMultiview)ye.setDeferTextureUploads(!0),xA(J,Qt,Se,Se.cameras[0].viewport);else for(let fr=0,Er=pr.length;fr<Er;fr++){const Yr=pr[fr];xA(J,Qt,Yr,Yr.viewport)}}else Cn.length>0&&zy(Qe,Cn,Qt,Se),Ve&&Zn.render(Qt),xA(J,Qt,Se);null!==zt&&(ye.updateMultisampleRenderTarget(zt),ye.updateRenderTargetMipmap(zt)),!0===Qt.isScene&&Qt.onAfterRender(At,Qt,Se),ye.runDeferredUploads(),Mi.enabled&&Mi.submitFrame&&Mi.submitFrame(),zi.resetDefaultState(),ee=-1,ce=null,ct.pop(),ct.length>0?(at=ct[ct.length-1],!0===Ce&&kr.setGlobalState(At.clippingPlanes,at.state.camera)):at=null,it.pop(),J=it.length>0?it[it.length-1]:null},this.setTexture2D=(IA=!1,function(Qt,Se){Qt&&Qt.isWebGLRenderTarget&&(IA||(console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),IA=!0),Qt=Qt.texture),ye.setTexture2D(Qt,Se)}),this.getActiveCubeFace=function(){return Tt},this.getActiveMipmapLevel=function(){return Pt},this.getRenderTarget=function(){return zt},this.setRenderTargetTextures=function(Qt,Se,Ve){fe.get(Qt.texture).__webglTexture=Se,fe.get(Qt.depthTexture).__webglTexture=Ve;const Ke=fe.get(Qt);Ke.__hasExternalTextures=!0,Ke.__autoAllocateDepthBuffer=void 0===Ve,Ke.__autoAllocateDepthBuffer||zt&&zt.isWebGLMultiviewRenderTarget||!0===Et.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Ke.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(Qt,Se){const Ve=fe.get(Qt);Ve.__webglFramebuffer=Se,Ve.__useDefaultFramebuffer=void 0===Se},this.setRenderTarget=function(Qt,Se=0,Ve=0){zt=Qt,Tt=Se,Pt=Ve;let Ke=!0,Qe=null,Cn=!1,pr=!1;if(Qt){const fr=fe.get(Qt);void 0!==fr.__useDefaultFramebuffer?($t.bindFramebuffer(Ue.FRAMEBUFFER,null),Ke=!1):void 0===fr.__webglFramebuffer?ye.setupRenderTarget(Qt):fr.__hasExternalTextures&&ye.rebindTextures(Qt,fe.get(Qt.texture).__webglTexture,fe.get(Qt.depthTexture).__webglTexture);const Er=Qt.texture;(Er.isData3DTexture||Er.isDataArrayTexture||Er.isCompressedArrayTexture)&&(pr=!0);const Yr=fe.get(Qt).__webglFramebuffer;Qt.isWebGLCubeRenderTarget?(Qe=Array.isArray(Yr[Se])?Yr[Se][Ve]:Yr[Se],Cn=!0):Qe=Qt.samples>0&&!1===ye.useMultisampledRTT(Qt)?fe.get(Qt).__webglMultisampledFramebuffer:Array.isArray(Yr)?Yr[Ve]:Yr,ne.copy(Qt.viewport),ge.copy(Qt.scissor),ie=Qt.scissorTest}else ne.copy(fn).multiplyScalar(Fe).floor(),ge.copy(xn).multiplyScalar(Fe).floor(),ie=In;if($t.bindFramebuffer(Ue.FRAMEBUFFER,Qe)&&Ke&&$t.drawBuffers(Qt,Qe),$t.viewport(ne),$t.scissor(ge),$t.setScissorTest(ie),Cn){const fr=fe.get(Qt.texture);Ue.framebufferTexture2D(Ue.FRAMEBUFFER,Ue.COLOR_ATTACHMENT0,Ue.TEXTURE_CUBE_MAP_POSITIVE_X+Se,fr.__webglTexture,Ve)}else if(pr){const fr=fe.get(Qt.texture);Ue.framebufferTextureLayer(Ue.FRAMEBUFFER,Ue.COLOR_ATTACHMENT0,fr.__webglTexture,Ve||0,Se||0)}ee=-1},this.readRenderTargetPixels=function(Qt,Se,Ve,Ke,Qe,Cn,pr){if(!Qt||!Qt.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let fr=fe.get(Qt).__webglFramebuffer;if(Qt.isWebGLCubeRenderTarget&&void 0!==pr&&(fr=fr[pr]),fr){$t.bindFramebuffer(Ue.FRAMEBUFFER,fr);try{const Er=Qt.texture,Yr=Er.format,yi=Er.type;if(!re.textureFormatReadable(Yr))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!re.textureTypeReadable(yi))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");Se>=0&&Se<=Qt.width-Ke&&Ve>=0&&Ve<=Qt.height-Qe&&Ue.readPixels(Se,Ve,Ke,Qe,or.convert(Yr),or.convert(yi),Cn)}finally{const Er=null!==zt?fe.get(zt).__webglFramebuffer:null;$t.bindFramebuffer(Ue.FRAMEBUFFER,Er)}}},this.copyFramebufferToTexture=function(Qt,Se,Ve=0){const Ke=Math.pow(2,-Ve),Qe=Math.floor(Se.image.width*Ke),Cn=Math.floor(Se.image.height*Ke);ye.setTexture2D(Se,0),Ue.copyTexSubImage2D(Ue.TEXTURE_2D,Ve,0,0,Qt.x,Qt.y,Qe,Cn),$t.unbindTexture()},this.copyTextureToTexture=function(Qt,Se,Ve,Ke=0){const Qe=Se.image.width,Cn=Se.image.height,pr=or.convert(Ve.format),fr=or.convert(Ve.type);ye.setTexture2D(Ve,0),Ue.pixelStorei(Ue.UNPACK_FLIP_Y_WEBGL,Ve.flipY),Ue.pixelStorei(Ue.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Ve.premultiplyAlpha),Ue.pixelStorei(Ue.UNPACK_ALIGNMENT,Ve.unpackAlignment),Se.isDataTexture?Ue.texSubImage2D(Ue.TEXTURE_2D,Ke,Qt.x,Qt.y,Qe,Cn,pr,fr,Se.image.data):Se.isCompressedTexture?Ue.compressedTexSubImage2D(Ue.TEXTURE_2D,Ke,Qt.x,Qt.y,Se.mipmaps[0].width,Se.mipmaps[0].height,pr,Se.mipmaps[0].data):Ue.texSubImage2D(Ue.TEXTURE_2D,Ke,Qt.x,Qt.y,pr,fr,Se.image),0===Ke&&Ve.generateMipmaps&&Ue.generateMipmap(Ue.TEXTURE_2D),$t.unbindTexture()},this.copyTextureToTexture3D=function(Qt,Se,Ve,Ke,Qe=0){const Cn=Qt.max.x-Qt.min.x,pr=Qt.max.y-Qt.min.y,fr=Qt.max.z-Qt.min.z,Er=or.convert(Ke.format),Yr=or.convert(Ke.type);let yi;if(Ke.isData3DTexture)ye.setTexture3D(Ke,0),yi=Ue.TEXTURE_3D;else{if(!Ke.isDataArrayTexture&&!Ke.isCompressedArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");ye.setTexture2DArray(Ke,0),yi=Ue.TEXTURE_2D_ARRAY}Ue.pixelStorei(Ue.UNPACK_FLIP_Y_WEBGL,Ke.flipY),Ue.pixelStorei(Ue.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Ke.premultiplyAlpha),Ue.pixelStorei(Ue.UNPACK_ALIGNMENT,Ke.unpackAlignment);const mi=Ue.getParameter(Ue.UNPACK_ROW_LENGTH),es=Ue.getParameter(Ue.UNPACK_IMAGE_HEIGHT),_l=Ue.getParameter(Ue.UNPACK_SKIP_PIXELS),xs=Ue.getParameter(Ue.UNPACK_SKIP_ROWS),cl=Ue.getParameter(Ue.UNPACK_SKIP_IMAGES),ws=Ve.isCompressedTexture?Ve.mipmaps[Qe]:Ve.image;Ue.pixelStorei(Ue.UNPACK_ROW_LENGTH,ws.width),Ue.pixelStorei(Ue.UNPACK_IMAGE_HEIGHT,ws.height),Ue.pixelStorei(Ue.UNPACK_SKIP_PIXELS,Qt.min.x),Ue.pixelStorei(Ue.UNPACK_SKIP_ROWS,Qt.min.y),Ue.pixelStorei(Ue.UNPACK_SKIP_IMAGES,Qt.min.z),Ve.isDataTexture||Ve.isData3DTexture?Ue.texSubImage3D(yi,Qe,Se.x,Se.y,Se.z,Cn,pr,fr,Er,Yr,ws.data):Ke.isCompressedArrayTexture?Ue.compressedTexSubImage3D(yi,Qe,Se.x,Se.y,Se.z,Cn,pr,fr,Er,ws.data):Ue.texSubImage3D(yi,Qe,Se.x,Se.y,Se.z,Cn,pr,fr,Er,Yr,ws),Ue.pixelStorei(Ue.UNPACK_ROW_LENGTH,mi),Ue.pixelStorei(Ue.UNPACK_IMAGE_HEIGHT,es),Ue.pixelStorei(Ue.UNPACK_SKIP_PIXELS,_l),Ue.pixelStorei(Ue.UNPACK_SKIP_ROWS,xs),Ue.pixelStorei(Ue.UNPACK_SKIP_IMAGES,cl),0===Qe&&Ke.generateMipmaps&&Ue.generateMipmap(yi),$t.unbindTexture()},this.initTexture=function(Qt){Qt.isCubeTexture?ye.setTextureCube(Qt,0):Qt.isData3DTexture?ye.setTexture3D(Qt,0):Qt.isDataArrayTexture||Qt.isCompressedArrayTexture?ye.setTexture2DArray(Qt,0):ye.setTexture2D(Qt,0),$t.unbindTexture()},this.resetState=function(){Tt=0,Pt=0,zt=null,$t.reset(),zi.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return ko}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const s=this.getContext();s.drawingBufferColorSpace=e===Nu?"display-p3":"srgb",s.unpackColorSpace=Jr.workingColorSpace===Uc?"display-p3":"srgb"}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class va{constructor(e,s=25e-5){this.isFogExp2=!0,this.name="",this.color=new En(e),this.density=s}clone(){return new va(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class le{constructor(e,s=1,l=1e3){this.isFog=!0,this.name="",this.color=new En(e),this.near=s,this.far=l}clone(){return new le(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class up extends hi{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Gi,this.environmentIntensity=1,this.environmentRotation=new Gi,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,s){return super.copy(e,s),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const s=super.toJSON(e);return null!==this.fog&&(s.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(s.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(s.object.backgroundIntensity=this.backgroundIntensity),s.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(s.object.environmentIntensity=this.environmentIntensity),s.object.environmentRotation=this.environmentRotation.toArray(),s}}class Ku{constructor(e,s){this.isInterleavedBuffer=!0,this.array=e,this.stride=s,this.count=void 0!==e?e.length/s:0,this.usage=Du,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=Ua()}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}get updateRange(){return Ud("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,s){this.updateRanges.push({start:e,count:s})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,s,l){e*=this.stride,l*=s.stride;for(let c=0,d=this.stride;c<d;c++)this.array[e+c]=s.array[l+c];return this}set(e,s=0){return this.array.set(e,s),this}clone(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Ua()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const s=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),l=new this.constructor(s,this.stride);return l.setUsage(this.usage),l}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Ua()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const ti=new Dt;class ba{constructor(e,s,l,c=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=s,this.offset=l,this.normalized=c}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let s=0,l=this.data.count;s<l;s++)ti.fromBufferAttribute(this,s),ti.applyMatrix4(e),this.setXYZ(s,ti.x,ti.y,ti.z);return this}applyNormalMatrix(e){for(let s=0,l=this.count;s<l;s++)ti.fromBufferAttribute(this,s),ti.applyNormalMatrix(e),this.setXYZ(s,ti.x,ti.y,ti.z);return this}transformDirection(e){for(let s=0,l=this.count;s<l;s++)ti.fromBufferAttribute(this,s),ti.transformDirection(e),this.setXYZ(s,ti.x,ti.y,ti.z);return this}getComponent(e,s){let l=this.array[e*this.data.stride+this.offset+s];return this.normalized&&(l=ma(l,this.array)),l}setComponent(e,s,l){return this.normalized&&(l=Br(l,this.array)),this.data.array[e*this.data.stride+this.offset+s]=l,this}setX(e,s){return this.normalized&&(s=Br(s,this.array)),this.data.array[e*this.data.stride+this.offset]=s,this}setY(e,s){return this.normalized&&(s=Br(s,this.array)),this.data.array[e*this.data.stride+this.offset+1]=s,this}setZ(e,s){return this.normalized&&(s=Br(s,this.array)),this.data.array[e*this.data.stride+this.offset+2]=s,this}setW(e,s){return this.normalized&&(s=Br(s,this.array)),this.data.array[e*this.data.stride+this.offset+3]=s,this}getX(e){let s=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(s=ma(s,this.array)),s}getY(e){let s=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(s=ma(s,this.array)),s}getZ(e){let s=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(s=ma(s,this.array)),s}getW(e){let s=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(s=ma(s,this.array)),s}setXY(e,s,l){return e=e*this.data.stride+this.offset,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array)),this.data.array[e+0]=s,this.data.array[e+1]=l,this}setXYZ(e,s,l,c){return e=e*this.data.stride+this.offset,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array),c=Br(c,this.array)),this.data.array[e+0]=s,this.data.array[e+1]=l,this.data.array[e+2]=c,this}setXYZW(e,s,l,c,d){return e=e*this.data.stride+this.offset,this.normalized&&(s=Br(s,this.array),l=Br(l,this.array),c=Br(c,this.array),d=Br(d,this.array)),this.data.array[e+0]=s,this.data.array[e+1]=l,this.data.array[e+2]=c,this.data.array[e+3]=d,this}clone(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const s=[];for(let l=0;l<this.count;l++){const c=l*this.data.stride+this.offset;for(let d=0;d<this.itemSize;d++)s.push(this.data.array[c+d])}return new wr(new this.array.constructor(s),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new ba(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const s=[];for(let l=0;l<this.count;l++){const c=l*this.data.stride+this.offset;for(let d=0;d<this.itemSize;d++)s.push(this.data.array[c+d])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:s,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class Gr extends di{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new En(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let El;const _f=new Dt,vc=new Dt,Kl=new Dt,qh=new Ye,hp=new Ye,_0=new Yn,dp=new Dt,pp=new Dt,hu=new Dt,bg=new Ye,Va=new Ye,k0=new Ye;class R0 extends hi{constructor(e=new Gr){if(super(),this.isSprite=!0,this.type="Sprite",void 0===El){El=new gr;const s=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),l=new Ku(s,5);El.setIndex([0,1,2,0,2,3]),El.setAttribute("position",new ba(l,3,0,!1)),El.setAttribute("uv",new ba(l,2,3,!1))}this.geometry=El,this.material=e,this.center=new Ye(.5,.5)}raycast(e,s){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),vc.setFromMatrixScale(this.matrixWorld),_0.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Kl.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&vc.multiplyScalar(-Kl.z);const l=this.material.rotation;let c,d;0!==l&&(d=Math.cos(l),c=Math.sin(l));const g=this.center;kf(dp.set(-.5,-.5,0),Kl,g,vc,c,d),kf(pp.set(.5,-.5,0),Kl,g,vc,c,d),kf(hu.set(.5,.5,0),Kl,g,vc,c,d),bg.set(0,0),Va.set(1,0),k0.set(1,1);let v=e.ray.intersectTriangle(dp,pp,hu,!1,_f);if(null===v&&(kf(pp.set(-.5,.5,0),Kl,g,vc,c,d),Va.set(0,1),v=e.ray.intersectTriangle(dp,hu,pp,!1,_f),null===v))return;const x=e.ray.origin.distanceTo(_f);x<e.near||x>e.far||s.push({distance:x,point:_f.clone(),uv:Re.getInterpolation(_f,dp,pp,hu,bg,Va,k0,new Ye),face:null,object:this})}copy(e,s){return super.copy(e,s),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}}function kf(A,e,s,l,c,d){qh.subVectors(A,s).addScalar(.5).multiply(l),void 0!==c?(hp.x=d*qh.x-c*qh.y,hp.y=c*qh.x+d*qh.y):hp.copy(qh),A.copy(e),A.x+=hp.x,A.y+=hp.y,A.applyMatrix4(_0)}const Rf=new Dt,bc=new Dt;class Bf extends hi{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const s=e.levels;for(let l=0,c=s.length;l<c;l++){const d=s[l];this.addLevel(d.object.clone(),d.distance,d.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,s=0,l=0){s=Math.abs(s);const c=this.levels;let d;for(d=0;d<c.length&&!(s<c[d].distance);d++);return c.splice(d,0,{distance:s,hysteresis:l,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const s=this.levels;if(s.length>0){let l,c;for(l=1,c=s.length;l<c;l++){let d=s[l].distance;if(s[l].object.visible&&(d-=d*s[l].hysteresis),e<d)break}return s[l-1].object}return null}raycast(e,s){if(this.levels.length>0){Rf.setFromMatrixPosition(this.matrixWorld);const l=e.ray.origin.distanceTo(Rf);this.getObjectForDistance(l).raycast(e,s)}}update(e){const s=this.levels;if(s.length>1){Rf.setFromMatrixPosition(e.matrixWorld),bc.setFromMatrixPosition(this.matrixWorld);const l=Rf.distanceTo(bc)/e.zoom;let c,d;for(s[0].object.visible=!0,c=1,d=s.length;c<d;c++){let g=s[c].distance;if(s[c].object.visible&&(g-=g*s[c].hysteresis),!(l>=g))break;s[c-1].object.visible=!1,s[c].object.visible=!0}for(this._currentLevel=c-1;c<d;c++)s[c].object.visible=!1}}toJSON(e){const s=super.toJSON(e);!1===this.autoUpdate&&(s.object.autoUpdate=!1),s.object.levels=[];const l=this.levels;for(let c=0,d=l.length;c<d;c++){const g=l[c];s.object.levels.push({object:g.object.uuid,distance:g.distance,hysteresis:g.hysteresis})}return s}}const xg=new Dt,Nf=new li,wg=new li,U1=new Dt,B0=new Yn,Ju=new Dt,fp=new Ls,Df=new Yn,Eg=new hc;class Lf extends os{constructor(e,s){super(e,s),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=hn,this.bindMatrix=new Yn,this.bindMatrixInverse=new Yn,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;null===this.boundingBox&&(this.boundingBox=new ta),this.boundingBox.makeEmpty();const s=e.getAttribute("position");for(let l=0;l<s.count;l++)this.getVertexPosition(l,Ju),this.boundingBox.expandByPoint(Ju)}computeBoundingSphere(){const e=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new Ls),this.boundingSphere.makeEmpty();const s=e.getAttribute("position");for(let l=0;l<s.count;l++)this.getVertexPosition(l,Ju),this.boundingSphere.expandByPoint(Ju)}copy(e,s){return super.copy(e,s),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,s){const c=this.matrixWorld;void 0!==this.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),fp.copy(this.boundingSphere),fp.applyMatrix4(c),!1!==e.ray.intersectsSphere(fp)&&(Df.copy(c).invert(),Eg.copy(e.ray).applyMatrix4(Df),null!==this.boundingBox&&!1===Eg.intersectsBox(this.boundingBox)||this._computeIntersections(e,s,Eg)))}getVertexPosition(e,s){return super.getVertexPosition(e,s),this.applyBoneTransform(e,s),s}bind(e,s){this.skeleton=e,void 0===s&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),s=this.matrixWorld),this.bindMatrix.copy(s),this.bindMatrixInverse.copy(s).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new li,s=this.geometry.attributes.skinWeight;for(let l=0,c=s.count;l<c;l++){e.fromBufferAttribute(s,l);const d=1/e.manhattanLength();d!==1/0?e.multiplyScalar(d):e.set(1,0,0,0),s.setXYZW(l,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===hn?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===kn?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,s){const l=this.skeleton,c=this.geometry;Nf.fromBufferAttribute(c.attributes.skinIndex,e),wg.fromBufferAttribute(c.attributes.skinWeight,e),xg.copy(s).applyMatrix4(this.bindMatrix),s.set(0,0,0);for(let d=0;d<4;d++){const g=wg.getComponent(d);if(0!==g){const v=Nf.getComponent(d);B0.multiplyMatrices(l.bones[v].matrixWorld,l.boneInverses[v]),s.addScaledVector(U1.copy(xg).applyMatrix4(B0),g)}}return s.applyMatrix4(this.bindMatrixInverse)}}class du extends hi{constructor(){super(),this.isBone=!0,this.type="Bone"}}class pu extends Vi{constructor(e=null,s=1,l=1,c,d,g,v,x,w=be,S=be,P,z){super(null,g,v,x,w,S,c,d,P,z),this.isDataTexture=!0,this.image={data:e,width:s,height:l},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const Cg=new Yn,Bo=new Yn;class Us{constructor(e=[],s=[]){this.uuid=Ua(),this.bones=e.slice(0),this.boneInverses=s,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,s=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===s.length)this.calculateInverses();else if(e.length!==s.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let l=0,c=this.bones.length;l<c;l++)this.boneInverses.push(new Yn)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,s=this.bones.length;e<s;e++){const l=new Yn;this.bones[e]&&l.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(l)}}pose(){for(let e=0,s=this.bones.length;e<s;e++){const l=this.bones[e];l&&l.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,s=this.bones.length;e<s;e++){const l=this.bones[e];l&&(l.parent&&l.parent.isBone?(l.matrix.copy(l.parent.matrixWorld).invert(),l.matrix.multiply(l.matrixWorld)):l.matrix.copy(l.matrixWorld),l.matrix.decompose(l.position,l.quaternion,l.scale))}}update(){const e=this.bones,s=this.boneInverses,l=this.boneMatrices,c=this.boneTexture;for(let d=0,g=e.length;d<g;d++)Cg.multiplyMatrices(e[d]?e[d].matrixWorld:Bo,s[d]),Cg.toArray(l,16*d);null!==c&&(c.needsUpdate=!0)}clone(){return new Us(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=4*Math.ceil(e/4),e=Math.max(e,4);const s=new Float32Array(e*e*4);s.set(this.boneMatrices);const l=new pu(s,e,e,de,wn);return l.needsUpdate=!0,this.boneMatrices=s,this.boneTexture=l,this}getBoneByName(e){for(let s=0,l=this.bones.length;s<l;s++){const c=this.bones[s];if(c.name===e)return c}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,s){this.uuid=e.uuid;for(let l=0,c=e.bones.length;l<c;l++){const d=e.bones[l];let g=s[d];void 0===g&&(console.warn("THREE.Skeleton: No bone found with UUID:",d),g=new du),this.bones.push(g),this.boneInverses.push((new Yn).fromArray(e.boneInverses[l]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const s=this.bones,l=this.boneInverses;for(let c=0,d=s.length;c<d;c++)e.bones.push(s[c].uuid),e.boneInverses.push(l[c].toArray());return e}}class Jl extends wr{constructor(e,s,l,c=1){super(e,s,l),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=c}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Xh=new Yn,N0=new Yn,fu=[],Ig=new ta,No=new Yn,xa=new os,Yh=new Ls;class xo extends os{constructor(e,s,l){super(e,s),this.isInstancedMesh=!0,this.instanceMatrix=new Jl(new Float32Array(16*l),16),this.instanceColor=null,this.morphTexture=null,this.count=l,this.boundingBox=null,this.boundingSphere=null;for(let c=0;c<l;c++)this.setMatrixAt(c,No)}computeBoundingBox(){const e=this.geometry,s=this.count;null===this.boundingBox&&(this.boundingBox=new ta),null===e.boundingBox&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let l=0;l<s;l++)this.getMatrixAt(l,Xh),Ig.copy(e.boundingBox).applyMatrix4(Xh),this.boundingBox.union(Ig)}computeBoundingSphere(){const e=this.geometry,s=this.count;null===this.boundingSphere&&(this.boundingSphere=new Ls),null===e.boundingSphere&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let l=0;l<s;l++)this.getMatrixAt(l,Xh),Yh.copy(e.boundingSphere).applyMatrix4(Xh),this.boundingSphere.union(Yh)}copy(e,s){return super.copy(e,s),this.instanceMatrix.copy(e.instanceMatrix),null!==e.morphTexture&&(this.morphTexture=e.morphTexture.clone()),null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,s){s.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,s){s.fromArray(this.instanceMatrix.array,16*e)}getMorphAt(e,s){const l=s.morphTargetInfluences,c=this.morphTexture.source.data.data,d=e*(l.length+1)+1;for(let g=0;g<l.length;g++)l[g]=c[d+g]}raycast(e,s){const l=this.matrixWorld,c=this.count;if(xa.geometry=this.geometry,xa.material=this.material,void 0!==xa.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),Yh.copy(this.boundingSphere),Yh.applyMatrix4(l),!1!==e.ray.intersectsSphere(Yh)))for(let d=0;d<c;d++){this.getMatrixAt(d,Xh),N0.multiplyMatrices(l,Xh),xa.matrixWorld=N0,xa.raycast(e,fu);for(let g=0,v=fu.length;g<v;g++){const x=fu[g];x.instanceId=d,x.object=this,s.push(x)}fu.length=0}}setColorAt(e,s){null===this.instanceColor&&(this.instanceColor=new Jl(new Float32Array(3*this.instanceMatrix.count),3)),s.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,s){s.toArray(this.instanceMatrix.array,16*e)}setMorphAt(e,s){const l=s.morphTargetInfluences,c=l.length+1;null===this.morphTexture&&(this.morphTexture=new pu(new Float32Array(c*this.count),c,this.count,da,wn));const d=this.morphTexture.source.data.data;let g=0;for(let w=0;w<l.length;w++)g+=l[w];const x=c*e;d[x]=this.geometry.morphTargetsRelative?1:1-g,d.set(l,x+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null),this}}function D0(A,e){return A.z-e.z}function mp(A,e){return e.z-A.z}const ia="batchId",wo=new Yn,Ff=new Yn,z1=new Yn,L0=new Yn,Of=new Ra,Zu=new ta,xc=new Ls,Cl=new Dt,Sg=new class Kh{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,s){const l=this.pool,c=this.list;this.index>=l.length&&l.push({start:-1,count:-1,z:-1});const d=l[this.index];c.push(d),this.index++,d.start=e.start,d.count=e.count,d.z=s}reset(){this.list.length=0,this.index=0}},Da=new os,Ga=[];function Pf(A,e,s=0){const l=e.itemSize;if(A.isInterleavedBufferAttribute||A.array.constructor!==e.array.constructor){const c=A.count;for(let d=0;d<c;d++)for(let g=0;g<l;g++)e.setComponent(d+s,g,A.getComponent(d,g))}else e.array.set(A.array,s*l);e.needsUpdate=!0}class Ji extends os{get maxGeometryCount(){return this._maxGeometryCount}constructor(e,s,l=2*s,c){super(new gr,c),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=e,this._maxVertexCount=s,this._maxIndexCount=l,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._multiDrawInstances=null,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let e=Math.sqrt(4*this._maxGeometryCount);e=4*Math.ceil(e/4),e=Math.max(e,4);const s=new Float32Array(e*e*4),l=new pu(s,e,e,de,wn);this._matricesTexture=l}_initializeGeometry(e){const s=this.geometry,l=this._maxVertexCount,c=this._maxGeometryCount,d=this._maxIndexCount;if(!1===this._geometryInitialized){for(const v in e.attributes){const x=e.getAttribute(v),{array:w,itemSize:S,normalized:P}=x,z=new w.constructor(l*S),W=new wr(z,S,P);s.setAttribute(v,W)}if(null!==e.getIndex()){const v=l>65536?new Uint32Array(d):new Uint16Array(d);s.setIndex(new wr(v,1))}const g=c>65536?new Uint32Array(l):new Uint16Array(l);s.setAttribute(ia,new wr(g,1)),this._geometryInitialized=!0}}_validateGeometry(e){if(e.getAttribute(ia))throw new Error(`BatchedMesh: Geometry cannot use attribute "${ia}"`);const s=this.geometry;if(!!e.getIndex()!=!!s.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const l in s.attributes){if(l===ia)continue;if(!e.hasAttribute(l))throw new Error(`BatchedMesh: Added geometry missing "${l}". All geometries must have consistent attributes.`);const c=e.getAttribute(l),d=s.getAttribute(l);if(c.itemSize!==d.itemSize||c.normalized!==d.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new ta);const e=this._geometryCount,s=this.boundingBox,l=this._active;s.makeEmpty();for(let c=0;c<e;c++)!1!==l[c]&&(this.getMatrixAt(c,wo),this.getBoundingBoxAt(c,Zu).applyMatrix4(wo),s.union(Zu))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Ls);const e=this._geometryCount,s=this.boundingSphere,l=this._active;s.makeEmpty();for(let c=0;c<e;c++)!1!==l[c]&&(this.getMatrixAt(c,wo),this.getBoundingSphereAt(c,xc).applyMatrix4(wo),s.union(xc))}addGeometry(e,s=-1,l=-1){if(this._initializeGeometry(e),this._validateGeometry(e),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const c={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let d=null;const g=this._reservedRanges,v=this._drawRanges,x=this._bounds;0!==this._geometryCount&&(d=g[g.length-1]),c.vertexCount=-1===s?e.getAttribute("position").count:s,c.vertexStart=null===d?0:d.vertexStart+d.vertexCount;const w=e.getIndex(),S=null!==w;if(S&&(c.indexCount=-1===l?w.count:l,c.indexStart=null===d?0:d.indexStart+d.indexCount),-1!==c.indexStart&&c.indexStart+c.indexCount>this._maxIndexCount||c.vertexStart+c.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const z=this._active,W=this._matricesTexture,Y=this._matricesTexture.image.data;this._visibility.push(!0),z.push(!0);const tt=this._geometryCount;this._geometryCount++,z1.toArray(Y,16*tt),W.needsUpdate=!0,g.push(c),v.push({start:S?c.indexStart:c.vertexStart,count:-1}),x.push({boxInitialized:!1,box:new ta,sphereInitialized:!1,sphere:new Ls});const J=this.geometry.getAttribute(ia);for(let at=0;at<c.vertexCount;at++)J.setX(c.vertexStart+at,tt);return J.needsUpdate=!0,this.setGeometryAt(tt,e),tt}setGeometryAt(e,s){if(e>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(s);const l=this.geometry,c=null!==l.getIndex(),d=l.getIndex(),g=s.getIndex(),v=this._reservedRanges[e];if(c&&g.count>v.indexCount||s.attributes.position.count>v.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const x=v.vertexStart,w=v.vertexCount;for(const W in l.attributes){if(W===ia)continue;const Y=s.getAttribute(W),tt=l.getAttribute(W);Pf(Y,tt,x);const J=Y.itemSize;for(let at=Y.count,it=w;at<it;at++){const ct=x+at;for(let At=0;At<J;At++)tt.setComponent(ct,At,0)}tt.needsUpdate=!0,tt.addUpdateRange(x*J,w*J)}if(c){const W=v.indexStart;for(let Y=0;Y<g.count;Y++)d.setX(W+Y,x+g.getX(Y));for(let Y=g.count,tt=v.indexCount;Y<tt;Y++)d.setX(W+Y,x);d.needsUpdate=!0,d.addUpdateRange(W,v.indexCount)}const S=this._bounds[e];null!==s.boundingBox?(S.box.copy(s.boundingBox),S.boxInitialized=!0):S.boxInitialized=!1,null!==s.boundingSphere?(S.sphere.copy(s.boundingSphere),S.sphereInitialized=!0):S.sphereInitialized=!1;const P=this._drawRanges[e],z=s.getAttribute("position");return P.count=c?g.count:z.count,this._visibilityChanged=!0,e}deleteGeometry(e){const s=this._active;return e>=s.length||!1===s[e]||(s[e]=!1,this._visibilityChanged=!0),this}getInstanceCountAt(e){return null===this._multiDrawInstances?null:this._multiDrawInstances[e]}setInstanceCountAt(e,s){return null===this._multiDrawInstances&&(this._multiDrawInstances=new Int32Array(this._maxGeometryCount).fill(1)),this._multiDrawInstances[e]=s,e}getBoundingBoxAt(e,s){if(!1===this._active[e])return null;const l=this._bounds[e],c=l.box,d=this.geometry;if(!1===l.boxInitialized){c.makeEmpty();const g=d.index,v=d.attributes.position,x=this._drawRanges[e];for(let w=x.start,S=x.start+x.count;w<S;w++){let P=w;g&&(P=g.getX(P)),c.expandByPoint(Cl.fromBufferAttribute(v,P))}l.boxInitialized=!0}return s.copy(c),s}getBoundingSphereAt(e,s){if(!1===this._active[e])return null;const l=this._bounds[e],c=l.sphere,d=this.geometry;if(!1===l.sphereInitialized){c.makeEmpty(),this.getBoundingBoxAt(e,Zu),Zu.getCenter(c.center);const g=d.index,v=d.attributes.position,x=this._drawRanges[e];let w=0;for(let S=x.start,P=x.start+x.count;S<P;S++){let z=S;g&&(z=g.getX(z)),Cl.fromBufferAttribute(v,z),w=Math.max(w,c.center.distanceToSquared(Cl))}c.radius=Math.sqrt(w),l.sphereInitialized=!0}return s.copy(c),s}setMatrixAt(e,s){const c=this._matricesTexture;return e>=this._geometryCount||!1===this._active[e]||(s.toArray(this._matricesTexture.image.data,16*e),c.needsUpdate=!0),this}getMatrixAt(e,s){return e>=this._geometryCount||!1===this._active[e]?null:s.fromArray(this._matricesTexture.image.data,16*e)}setVisibleAt(e,s){const l=this._visibility;return e>=this._geometryCount||!1===this._active[e]||l[e]===s||(l[e]=s,this._visibilityChanged=!0),this}getVisibleAt(e){return!(e>=this._geometryCount||!1===this._active[e])&&this._visibility[e]}raycast(e,s){const l=this._visibility,c=this._active,d=this._drawRanges,g=this._geometryCount,v=this.matrixWorld,x=this.geometry;Da.material=this.material,Da.geometry.index=x.index,Da.geometry.attributes=x.attributes,null===Da.geometry.boundingBox&&(Da.geometry.boundingBox=new ta),null===Da.geometry.boundingSphere&&(Da.geometry.boundingSphere=new Ls);for(let w=0;w<g;w++){if(!l[w]||!c[w])continue;const S=d[w];Da.geometry.setDrawRange(S.start,S.count),this.getMatrixAt(w,Da.matrixWorld).premultiply(v),this.getBoundingBoxAt(w,Da.geometry.boundingBox),this.getBoundingSphereAt(w,Da.geometry.boundingSphere),Da.raycast(e,Ga);for(let P=0,z=Ga.length;P<z;P++){const W=Ga[P];W.object=this,W.batchId=w,s.push(W)}Ga.length=0}Da.material=null,Da.geometry.index=null,Da.geometry.attributes={},Da.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=null!==e.boundingBox?e.boundingBox.clone():null,this.boundingSphere=null!==e.boundingSphere?e.boundingSphere.clone():null,this._drawRanges=e._drawRanges.map(s=>({...s})),this._reservedRanges=e._reservedRanges.map(s=>({...s})),this._visibility=e._visibility.slice(),this._active=e._active.slice(),this._bounds=e._bounds.map(s=>({boxInitialized:s.boxInitialized,box:s.box.clone(),sphereInitialized:s.sphereInitialized,sphere:s.sphere.clone()})),this._maxGeometryCount=e._maxGeometryCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(e,s,l,c,d){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const g=c.getIndex(),v=null===g?1:g.array.BYTES_PER_ELEMENT,x=this._active,w=this._visibility,S=this._multiDrawStarts,P=this._multiDrawCounts,z=this._drawRanges,W=this.perObjectFrustumCulled;W&&(L0.multiplyMatrices(l.projectionMatrix,l.matrixWorldInverse).multiply(this.matrixWorld),Of.setFromProjectionMatrix(L0,e.coordinateSystem));let Y=0;if(this.sortObjects){Ff.copy(this.matrixWorld).invert(),Cl.setFromMatrixPosition(l.matrixWorld).applyMatrix4(Ff);for(let at=0,it=w.length;at<it;at++)if(w[at]&&x[at]){this.getMatrixAt(at,wo),this.getBoundingSphereAt(at,xc).applyMatrix4(wo);let ct=!1;if(W&&(ct=!Of.intersectsSphere(xc)),!ct){const At=Cl.distanceTo(xc.center);Sg.push(z[at],At)}}const tt=Sg.list,J=this.customSort;null===J?tt.sort(d.transparent?mp:D0):J.call(this,tt,l);for(let at=0,it=tt.length;at<it;at++){const ct=tt[at];S[Y]=ct.start*v,P[Y]=ct.count,Y++}Sg.reset()}else for(let tt=0,J=w.length;tt<J;tt++)if(w[tt]&&x[tt]){let at=!1;if(W&&(this.getMatrixAt(tt,wo),this.getBoundingSphereAt(tt,xc).applyMatrix4(wo),at=!Of.intersectsSphere(xc)),!at){const it=z[tt];S[Y]=it.start*v,P[Y]=it.count,Y++}}this._multiDrawCount=Y,this._visibilityChanged=!1}onBeforeShadow(e,s,l,c,d,g){this.onBeforeRender(e,null,c,d,g)}}class ls extends di{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new En(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const Uf=new Dt,Eo=new Dt,Vn=new Yn,th=new hc,gp=new Ls,Mg=new Dt,sa=new Dt;class Ni extends hi{constructor(e=new gr,s=new ls){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=s,this.updateMorphTargets()}copy(e,s){return super.copy(e,s),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(null===e.index){const s=e.attributes.position,l=[0];for(let c=1,d=s.count;c<d;c++)Uf.fromBufferAttribute(s,c-1),Eo.fromBufferAttribute(s,c),l[c]=l[c-1],l[c]+=Uf.distanceTo(Eo);e.setAttribute("lineDistance",new Tn(l,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,s){const l=this.geometry,c=this.matrixWorld,d=e.params.Line.threshold,g=l.drawRange;if(null===l.boundingSphere&&l.computeBoundingSphere(),gp.copy(l.boundingSphere),gp.applyMatrix4(c),gp.radius+=d,!1===e.ray.intersectsSphere(gp))return;Vn.copy(c).invert(),th.copy(e.ray).applyMatrix4(Vn);const v=d/((this.scale.x+this.scale.y+this.scale.z)/3),x=v*v,w=this.isLineSegments?2:1,S=l.index,P=l.attributes.position;if(null!==S){const z=Math.max(0,g.start),W=Math.min(S.count,g.start+g.count);for(let Y=z,tt=W-1;Y<tt;Y+=w){const J=S.getX(Y),at=S.getX(Y+1),it=zs(this,e,th,x,J,at);it&&s.push(it)}if(this.isLineLoop){const Y=S.getX(W-1),tt=S.getX(z),J=zs(this,e,th,x,Y,tt);J&&s.push(J)}}else{const z=Math.max(0,g.start),W=Math.min(P.count,g.start+g.count);for(let Y=z,tt=W-1;Y<tt;Y+=w){const J=zs(this,e,th,x,Y,Y+1);J&&s.push(J)}if(this.isLineLoop){const Y=zs(this,e,th,x,W-1,z);Y&&s.push(Y)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,s=Object.keys(e);if(s.length>0){const l=e[s[0]];if(void 0!==l){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,d=l.length;c<d;c++){const g=l[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[g]=c}}}}}function zs(A,e,s,l,c,d){const g=A.geometry.attributes.position;if(Uf.fromBufferAttribute(g,c),Eo.fromBufferAttribute(g,d),s.distanceSqToSegment(Uf,Eo,Mg,sa)>l)return;Mg.applyMatrix4(A.matrixWorld);const v=e.ray.origin.distanceTo(Mg);return v<e.near||v>e.far?void 0:{distance:v,point:sa.clone().applyMatrix4(A.matrixWorld),index:c,face:null,faceIndex:null,object:A}}const vs=new Dt,Jh=new Dt;class Ai extends Ni{constructor(e,s){super(e,s),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(null===e.index){const s=e.attributes.position,l=[];for(let c=0,d=s.count;c<d;c+=2)vs.fromBufferAttribute(s,c),Jh.fromBufferAttribute(s,c+1),l[c]=0===c?0:l[c-1],l[c+1]=l[c]+vs.distanceTo(Jh);e.setAttribute("lineDistance",new Tn(l,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class zf extends Ni{constructor(e,s){super(e,s),this.isLineLoop=!0,this.type="LineLoop"}}class wa extends di{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new En(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const Ap=new Yn,yp=new hc,$f=new Ls,eh=new Dt;class nh extends hi{constructor(e=new gr,s=new wa){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=s,this.updateMorphTargets()}copy(e,s){return super.copy(e,s),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,s){const l=this.geometry,c=this.matrixWorld,d=e.params.Points.threshold,g=l.drawRange;if(null===l.boundingSphere&&l.computeBoundingSphere(),$f.copy(l.boundingSphere),$f.applyMatrix4(c),$f.radius+=d,!1===e.ray.intersectsSphere($f))return;Ap.copy(c).invert(),yp.copy(e.ray).applyMatrix4(Ap);const v=d/((this.scale.x+this.scale.y+this.scale.z)/3),x=v*v,w=l.index,S=l.attributes.position;if(null!==w)for(let P=Math.max(0,g.start),z=Math.min(w.count,g.start+g.count);P<z;P++){const W=w.getX(P);eh.fromBufferAttribute(S,W),F0(eh,W,x,c,e,s,this)}else for(let P=Math.max(0,g.start),z=Math.min(S.count,g.start+g.count);P<z;P++)eh.fromBufferAttribute(S,P),F0(eh,P,x,c,e,s,this)}updateMorphTargets(){const e=this.geometry.morphAttributes,s=Object.keys(e);if(s.length>0){const l=e[s[0]];if(void 0!==l){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,d=l.length;c<d;c++){const g=l[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[g]=c}}}}}function F0(A,e,s,l,c,d,g){const v=yp.distanceSqToPoint(A);if(v<s){const x=new Dt;yp.closestPointToPoint(A,x),x.applyMatrix4(l);const w=c.ray.origin.distanceTo(x);if(w<c.near||w>c.far)return;d.push({distance:w,distanceToRay:Math.sqrt(v),point:x,index:e,face:null,object:g})}}class fs extends Vi{constructor(e,s,l,c,d,g,v,x,w){super(e,s,l,c,d,g,v,x,w),this.isVideoTexture=!0,this.minFilter=void 0!==g?g:cn,this.magFilter=void 0!==d?d:cn,this.generateMipmaps=!1;const S=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(function P(){S.needsUpdate=!0,e.requestVideoFrameCallback(P)})}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;!("requestVideoFrameCallback"in e)&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class $s extends Vi{constructor(e,s){super({width:e,height:s}),this.isFramebufferTexture=!0,this.magFilter=be,this.minFilter=be,this.generateMipmaps=!1,this.needsUpdate=!0}}class Ea extends Vi{constructor(e,s,l,c,d,g,v,x,w,S,P,z){super(null,g,v,x,w,S,c,d,P,z),this.isCompressedTexture=!0,this.image={width:s,height:l},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class $1 extends Ea{constructor(e,s,l,c,d,g){super(e,s,l,d,g),this.isCompressedArrayTexture=!0,this.image.depth=c,this.wrapR=Ut}}class vp extends Ea{constructor(e,s,l){super(void 0,e[0].width,e[0].height,s,l,Wr),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class bp extends Vi{constructor(e,s,l,c,d,g,v,x,w){super(e,s,l,c,d,g,v,x,w),this.isCanvasTexture=!0,this.needsUpdate=!0}}class nl{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,s){const l=this.getUtoTmapping(e);return this.getPoint(l,s)}getPoints(e=5){const s=[];for(let l=0;l<=e;l++)s.push(this.getPoint(l/e));return s}getSpacedPoints(e=5){const s=[];for(let l=0;l<=e;l++)s.push(this.getPointAt(l/e));return s}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const s=[];let l,c=this.getPoint(0),d=0;s.push(0);for(let g=1;g<=e;g++)l=this.getPoint(g/e),d+=l.distanceTo(c),s.push(d),c=l;return this.cacheArcLengths=s,s}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,s){const l=this.getLengths();let c=0;const d=l.length;let g;g=s||e*l[d-1];let v,x=0,w=d-1;for(;x<=w;)if(c=Math.floor(x+(w-x)/2),v=l[c]-g,v<0)x=c+1;else{if(!(v>0)){w=c;break}w=c-1}if(c=w,l[c]===g)return c/(d-1);const S=l[c];return(c+(g-S)/(l[c+1]-S))/(d-1)}getTangent(e,s){let c=e-1e-4,d=e+1e-4;c<0&&(c=0),d>1&&(d=1);const g=this.getPoint(c),v=this.getPoint(d),x=s||(g.isVector2?new Ye:new Dt);return x.copy(v).sub(g).normalize(),x}getTangentAt(e,s){const l=this.getUtoTmapping(e);return this.getTangent(l,s)}computeFrenetFrames(e,s){const l=new Dt,c=[],d=[],g=[],v=new Dt,x=new Yn;for(let W=0;W<=e;W++)c[W]=this.getTangentAt(W/e,new Dt);d[0]=new Dt,g[0]=new Dt;let w=Number.MAX_VALUE;const S=Math.abs(c[0].x),P=Math.abs(c[0].y),z=Math.abs(c[0].z);S<=w&&(w=S,l.set(1,0,0)),P<=w&&(w=P,l.set(0,1,0)),z<=w&&l.set(0,0,1),v.crossVectors(c[0],l).normalize(),d[0].crossVectors(c[0],v),g[0].crossVectors(c[0],d[0]);for(let W=1;W<=e;W++){if(d[W]=d[W-1].clone(),g[W]=g[W-1].clone(),v.crossVectors(c[W-1],c[W]),v.length()>Number.EPSILON){v.normalize();const Y=Math.acos(Ki(c[W-1].dot(c[W]),-1,1));d[W].applyMatrix4(x.makeRotationAxis(v,Y))}g[W].crossVectors(c[W],d[W])}if(!0===s){let W=Math.acos(Ki(d[0].dot(d[e]),-1,1));W/=e,c[0].dot(v.crossVectors(d[0],d[e]))>0&&(W=-W);for(let Y=1;Y<=e;Y++)d[Y].applyMatrix4(x.makeRotationAxis(c[Y],W*Y)),g[Y].crossVectors(c[Y],d[Y])}return{tangents:c,normals:d,binormals:g}}clone(){return(new this.constructor).copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class xp extends nl{constructor(e=0,s=0,l=1,c=1,d=0,g=2*Math.PI,v=!1,x=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=s,this.xRadius=l,this.yRadius=c,this.aStartAngle=d,this.aEndAngle=g,this.aClockwise=v,this.aRotation=x}getPoint(e,s=new Ye){const l=s,c=2*Math.PI;let d=this.aEndAngle-this.aStartAngle;const g=Math.abs(d)<Number.EPSILON;for(;d<0;)d+=c;for(;d>c;)d-=c;d<Number.EPSILON&&(d=g?0:c),!0!==this.aClockwise||g||(d===c?d=-c:d-=c);const v=this.aStartAngle+e*d;let x=this.aX+this.xRadius*Math.cos(v),w=this.aY+this.yRadius*Math.sin(v);if(0!==this.aRotation){const S=Math.cos(this.aRotation),P=Math.sin(this.aRotation),z=x-this.aX,W=w-this.aY;x=z*S-W*P+this.aX,w=z*P+W*S+this.aY}return l.set(x,w)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class Vf extends xp{constructor(e,s,l,c,d,g){super(e,s,l,l,c,d,g),this.isArcCurve=!0,this.type="ArcCurve"}}function O0(){let A=0,e=0,s=0,l=0;function c(d,g,v,x){A=d,e=v,s=-3*d+3*g-2*v-x,l=2*d-2*g+v+x}return{initCatmullRom:function(d,g,v,x,w){c(g,v,w*(v-d),w*(x-g))},initNonuniformCatmullRom:function(d,g,v,x,w,S,P){let z=(g-d)/w-(v-d)/(w+S)+(v-g)/S,W=(v-g)/S-(x-g)/(S+P)+(x-v)/P;z*=S,W*=S,c(g,v,z,W)},calc:function(d){const g=d*d;return A+e*d+s*g+l*(g*d)}}}const Gf=new Dt,mu=new O0,so=new O0,P0=new O0;class wc extends nl{constructor(e=[],s=!1,l="centripetal",c=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=s,this.curveType=l,this.tension=c}getPoint(e,s=new Dt){const l=s,c=this.points,d=c.length,g=(d-(this.closed?0:1))*e;let v,x,w=Math.floor(g),S=g-w;this.closed?w+=w>0?0:(Math.floor(Math.abs(w)/d)+1)*d:0===S&&w===d-1&&(w=d-2,S=1),this.closed||w>0?v=c[(w-1)%d]:(Gf.subVectors(c[0],c[1]).add(c[0]),v=Gf);const P=c[w%d],z=c[(w+1)%d];if(this.closed||w+2<d?x=c[(w+2)%d]:(Gf.subVectors(c[d-1],c[d-2]).add(c[d-1]),x=Gf),"centripetal"===this.curveType||"chordal"===this.curveType){const W="chordal"===this.curveType?.5:.25;let Y=Math.pow(v.distanceToSquared(P),W),tt=Math.pow(P.distanceToSquared(z),W),J=Math.pow(z.distanceToSquared(x),W);tt<1e-4&&(tt=1),Y<1e-4&&(Y=tt),J<1e-4&&(J=tt),mu.initNonuniformCatmullRom(v.x,P.x,z.x,x.x,Y,tt,J),so.initNonuniformCatmullRom(v.y,P.y,z.y,x.y,Y,tt,J),P0.initNonuniformCatmullRom(v.z,P.z,z.z,x.z,Y,tt,J)}else"catmullrom"===this.curveType&&(mu.initCatmullRom(v.x,P.x,z.x,x.x,this.tension),so.initCatmullRom(v.y,P.y,z.y,x.y,this.tension),P0.initCatmullRom(v.z,P.z,z.z,x.z,this.tension));return l.set(mu.calc(S),so.calc(S),P0.calc(S)),l}copy(e){super.copy(e),this.points=[];for(let s=0,l=e.points.length;s<l;s++)this.points.push(e.points[s].clone());return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let s=0,l=this.points.length;s<l;s++)e.points.push(this.points[s].toArray());return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let s=0,l=e.points.length;s<l;s++){const c=e.points[s];this.points.push((new Dt).fromArray(c))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function V1(A,e,s,l,c){const d=.5*(l-e),g=.5*(c-s),v=A*A;return(2*s-2*l+d+g)*(A*v)+(-3*s+3*l-2*d-g)*v+d*A+s}function Qf(A,e,s,l){return function(c,d){const g=1-c;return g*g*d}(A,e)+2*(1-(c=A))*c*s+function(c,d){return c*c*d}(A,l);var c}function Hf(A,e,s,l,c){return function(d,g){const v=1-d;return v*v*v*g}(A,e)+function(d,g){const v=1-d;return 3*v*v*d*g}(A,s)+3*(1-(d=A))*d*d*l+function(d,g){return d*d*d*g}(A,c);var d}class U0 extends nl{constructor(e=new Ye,s=new Ye,l=new Ye,c=new Ye){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=s,this.v2=l,this.v3=c}getPoint(e,s=new Ye){const l=s,c=this.v0,d=this.v1,g=this.v2,v=this.v3;return l.set(Hf(e,c.x,d.x,g.x,v.x),Hf(e,c.y,d.y,g.y,v.y)),l}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class wp extends nl{constructor(e=new Dt,s=new Dt,l=new Dt,c=new Dt){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=s,this.v2=l,this.v3=c}getPoint(e,s=new Dt){const l=s,c=this.v0,d=this.v1,g=this.v2,v=this.v3;return l.set(Hf(e,c.x,d.x,g.x,v.x),Hf(e,c.y,d.y,g.y,v.y),Hf(e,c.z,d.z,g.z,v.z)),l}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class Tg extends nl{constructor(e=new Ye,s=new Ye){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=s}getPoint(e,s=new Ye){const l=s;return 1===e?l.copy(this.v2):(l.copy(this.v2).sub(this.v1),l.multiplyScalar(e).add(this.v1)),l}getPointAt(e,s){return this.getPoint(e,s)}getTangent(e,s=new Ye){return s.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,s){return this.getTangent(e,s)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Ep extends nl{constructor(e=new Dt,s=new Dt){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=s}getPoint(e,s=new Dt){const l=s;return 1===e?l.copy(this.v2):(l.copy(this.v2).sub(this.v1),l.multiplyScalar(e).add(this.v1)),l}getPointAt(e,s){return this.getPoint(e,s)}getTangent(e,s=new Dt){return s.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,s){return this.getTangent(e,s)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Cp extends nl{constructor(e=new Ye,s=new Ye,l=new Ye){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=s,this.v2=l}getPoint(e,s=new Ye){const l=s,c=this.v0,d=this.v1,g=this.v2;return l.set(Qf(e,c.x,d.x,g.x),Qf(e,c.y,d.y,g.y)),l}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class z0 extends nl{constructor(e=new Dt,s=new Dt,l=new Dt){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=s,this.v2=l}getPoint(e,s=new Dt){const l=s,c=this.v0,d=this.v1,g=this.v2;return l.set(Qf(e,c.x,d.x,g.x),Qf(e,c.y,d.y,g.y),Qf(e,c.z,d.z,g.z)),l}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class rh extends nl{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,s=new Ye){const l=s,c=this.points,d=(c.length-1)*e,g=Math.floor(d),v=d-g,x=c[0===g?g:g-1],w=c[g],S=c[g>c.length-2?c.length-1:g+1],P=c[g>c.length-3?c.length-1:g+2];return l.set(V1(v,x.x,w.x,S.x,P.x),V1(v,x.y,w.y,S.y,P.y)),l}copy(e){super.copy(e),this.points=[];for(let s=0,l=e.points.length;s<l;s++)this.points.push(e.points[s].clone());return this}toJSON(){const e=super.toJSON();e.points=[];for(let s=0,l=this.points.length;s<l;s++)e.points.push(this.points[s].toArray());return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let s=0,l=e.points.length;s<l;s++){const c=e.points[s];this.points.push((new Ye).fromArray(c))}return this}}var Ip=Object.freeze({__proto__:null,ArcCurve:Vf,CatmullRomCurve3:wc,CubicBezierCurve:U0,CubicBezierCurve3:wp,EllipseCurve:xp,LineCurve:Tg,LineCurve3:Ep,QuadraticBezierCurve:Cp,QuadraticBezierCurve3:z0,SplineCurve:rh});class G1 extends nl{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),s=this.curves[this.curves.length-1].getPoint(1);return e.equals(s)||this.curves.push(new Ip[!0===e.isVector2?"LineCurve":"LineCurve3"](s,e)),this}getPoint(e,s){const l=e*this.getLength(),c=this.getCurveLengths();let d=0;for(;d<c.length;){if(c[d]>=l){const g=c[d]-l,v=this.curves[d],x=v.getLength();return v.getPointAt(0===x?0:1-g/x,s)}d++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let s=0;for(let l=0,c=this.curves.length;l<c;l++)s+=this.curves[l].getLength(),e.push(s);return this.cacheLengths=e,e}getSpacedPoints(e=40){const s=[];for(let l=0;l<=e;l++)s.push(this.getPoint(l/e));return this.autoClose&&s.push(s[0]),s}getPoints(e=12){const s=[];let l;for(let c=0,d=this.curves;c<d.length;c++){const g=d[c],x=g.getPoints(g.isEllipseCurve?2*e:g.isLineCurve||g.isLineCurve3?1:g.isSplineCurve?e*g.points.length:e);for(let w=0;w<x.length;w++){const S=x[w];l&&l.equals(S)||(s.push(S),l=S)}}return this.autoClose&&s.length>1&&!s[s.length-1].equals(s[0])&&s.push(s[0]),s}copy(e){super.copy(e),this.curves=[];for(let s=0,l=e.curves.length;s<l;s++)this.curves.push(e.curves[s].clone());return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let s=0,l=this.curves.length;s<l;s++)e.curves.push(this.curves[s].toJSON());return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let s=0,l=e.curves.length;s<l;s++){const c=e.curves[s];this.curves.push((new Ip[c.type]).fromJSON(c))}return this}}class Wf extends G1{constructor(e){super(),this.type="Path",this.currentPoint=new Ye,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let s=1,l=e.length;s<l;s++)this.lineTo(e[s].x,e[s].y);return this}moveTo(e,s){return this.currentPoint.set(e,s),this}lineTo(e,s){const l=new Tg(this.currentPoint.clone(),new Ye(e,s));return this.curves.push(l),this.currentPoint.set(e,s),this}quadraticCurveTo(e,s,l,c){const d=new Cp(this.currentPoint.clone(),new Ye(e,s),new Ye(l,c));return this.curves.push(d),this.currentPoint.set(l,c),this}bezierCurveTo(e,s,l,c,d,g){const v=new U0(this.currentPoint.clone(),new Ye(e,s),new Ye(l,c),new Ye(d,g));return this.curves.push(v),this.currentPoint.set(d,g),this}splineThru(e){const s=[this.currentPoint.clone()].concat(e),l=new rh(s);return this.curves.push(l),this.currentPoint.copy(e[e.length-1]),this}arc(e,s,l,c,d,g){return this.absarc(e+this.currentPoint.x,s+this.currentPoint.y,l,c,d,g),this}absarc(e,s,l,c,d,g){return this.absellipse(e,s,l,l,c,d,g),this}ellipse(e,s,l,c,d,g,v,x){return this.absellipse(e+this.currentPoint.x,s+this.currentPoint.y,l,c,d,g,v,x),this}absellipse(e,s,l,c,d,g,v,x){const w=new xp(e,s,l,c,d,g,v,x);if(this.curves.length>0){const P=w.getPoint(0);P.equals(this.currentPoint)||this.lineTo(P.x,P.y)}this.curves.push(w);const S=w.getPoint(1);return this.currentPoint.copy(S),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class jf extends gr{constructor(e=[new Ye(0,-.5),new Ye(.5,0),new Ye(0,.5)],s=12,l=0,c=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:s,phiStart:l,phiLength:c},s=Math.floor(s),c=Ki(c,0,2*Math.PI);const d=[],g=[],v=[],x=[],w=[],S=1/s,P=new Dt,z=new Ye,W=new Dt,Y=new Dt,tt=new Dt;let J=0,at=0;for(let it=0;it<=e.length-1;it++)switch(it){case 0:J=e[it+1].x-e[it].x,at=e[it+1].y-e[it].y,W.x=1*at,W.y=-J,W.z=0*at,tt.copy(W),W.normalize(),x.push(W.x,W.y,W.z);break;case e.length-1:x.push(tt.x,tt.y,tt.z);break;default:J=e[it+1].x-e[it].x,at=e[it+1].y-e[it].y,W.x=1*at,W.y=-J,W.z=0*at,Y.copy(W),W.x+=tt.x,W.y+=tt.y,W.z+=tt.z,W.normalize(),x.push(W.x,W.y,W.z),tt.copy(Y)}for(let it=0;it<=s;it++){const ct=l+it*S*c,At=Math.sin(ct),Ft=Math.cos(ct);for(let Tt=0;Tt<=e.length-1;Tt++)P.x=e[Tt].x*At,P.y=e[Tt].y,P.z=e[Tt].x*Ft,g.push(P.x,P.y,P.z),z.x=it/s,z.y=Tt/(e.length-1),v.push(z.x,z.y),w.push(x[3*Tt+0]*At,x[3*Tt+1],x[3*Tt+0]*Ft)}for(let it=0;it<s;it++)for(let ct=0;ct<e.length-1;ct++){const At=ct+it*e.length,Tt=At+e.length,Pt=At+e.length+1,zt=At+1;d.push(At,Tt,zt),d.push(Pt,zt,Tt)}this.setIndex(d),this.setAttribute("position",new Tn(g,3)),this.setAttribute("uv",new Tn(v,2)),this.setAttribute("normal",new Tn(w,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new jf(e.points,e.segments,e.phiStart,e.phiLength)}}class qf extends jf{constructor(e=1,s=1,l=4,c=8){const d=new Wf;d.absarc(0,-s/2,e,1.5*Math.PI,0),d.absarc(0,s/2,e,0,.5*Math.PI),super(d.getPoints(l),c),this.type="CapsuleGeometry",this.parameters={radius:e,length:s,capSegments:l,radialSegments:c}}static fromJSON(e){return new qf(e.radius,e.length,e.capSegments,e.radialSegments)}}class gu extends gr{constructor(e=1,s=32,l=0,c=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:s,thetaStart:l,thetaLength:c},s=Math.max(3,s);const d=[],g=[],v=[],x=[],w=new Dt,S=new Ye;g.push(0,0,0),v.push(0,0,1),x.push(.5,.5);for(let P=0,z=3;P<=s;P++,z+=3){const W=l+P/s*c;w.x=e*Math.cos(W),w.y=e*Math.sin(W),g.push(w.x,w.y,w.z),v.push(0,0,1),S.x=(g[z]/e+1)/2,S.y=(g[z+1]/e+1)/2,x.push(S.x,S.y)}for(let P=1;P<=s;P++)d.push(P,P+1,0);this.setIndex(d),this.setAttribute("position",new Tn(g,3)),this.setAttribute("normal",new Tn(v,3)),this.setAttribute("uv",new Tn(x,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new gu(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Zl extends gr{constructor(e=1,s=1,l=1,c=32,d=1,g=!1,v=0,x=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:s,height:l,radialSegments:c,heightSegments:d,openEnded:g,thetaStart:v,thetaLength:x};const w=this;c=Math.floor(c),d=Math.floor(d);const S=[],P=[],z=[],W=[];let Y=0;const tt=[],J=l/2;let at=0;function it(ct){const At=Y,Ft=new Ye,Tt=new Dt;let Pt=0;const zt=!0===ct?e:s,ee=!0===ct?1:-1;for(let ne=1;ne<=c;ne++)P.push(0,J*ee,0),z.push(0,ee,0),W.push(.5,.5),Y++;const ce=Y;for(let ne=0;ne<=c;ne++){const ge=ne/c*x+v,ie=Math.cos(ge),pe=Math.sin(ge);Tt.x=zt*pe,Tt.y=J*ee,Tt.z=zt*ie,P.push(Tt.x,Tt.y,Tt.z),z.push(0,ee,0),Ft.x=.5*ie+.5,Ft.y=.5*pe*ee+.5,W.push(Ft.x,Ft.y),Y++}for(let ne=0;ne<c;ne++){const ge=At+ne,ie=ce+ne;!0===ct?S.push(ie,ie+1,ge):S.push(ie+1,ie,ge),Pt+=3}w.addGroup(at,Pt,!0===ct?1:2),at+=Pt}(function(){const ct=new Dt,At=new Dt;let Ft=0;const Tt=(s-e)/l;for(let Pt=0;Pt<=d;Pt++){const zt=[],ee=Pt/d,ce=ee*(s-e)+e;for(let ne=0;ne<=c;ne++){const ge=ne/c,ie=ge*x+v,pe=Math.sin(ie),Oe=Math.cos(ie);At.x=ce*pe,At.y=-ee*l+J,At.z=ce*Oe,P.push(At.x,At.y,At.z),ct.set(pe,Tt,Oe).normalize(),z.push(ct.x,ct.y,ct.z),W.push(ge,1-ee),zt.push(Y++)}tt.push(zt)}for(let Pt=0;Pt<c;Pt++)for(let zt=0;zt<d;zt++){const ce=tt[zt+1][Pt],ne=tt[zt+1][Pt+1],ge=tt[zt][Pt+1];S.push(tt[zt][Pt],ce,ge),S.push(ce,ne,ge),Ft+=6}w.addGroup(at,Ft,0),at+=Ft})(),!1===g&&(e>0&&it(!0),s>0&&it(!1)),this.setIndex(S),this.setAttribute("position",new Tn(P,3)),this.setAttribute("normal",new Tn(z,3)),this.setAttribute("uv",new Tn(W,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Zl(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class ih extends Zl{constructor(e=1,s=1,l=32,c=1,d=!1,g=0,v=2*Math.PI){super(0,e,s,l,c,d,g,v),this.type="ConeGeometry",this.parameters={radius:e,height:s,radialSegments:l,heightSegments:c,openEnded:d,thetaStart:g,thetaLength:v}}static fromJSON(e){return new ih(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Ec extends gr{constructor(e=[],s=[],l=1,c=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:s,radius:l,detail:c};const d=[],g=[];function v(z,W,Y,tt){const J=tt+1,at=[];for(let it=0;it<=J;it++){at[it]=[];const ct=z.clone().lerp(Y,it/J),At=W.clone().lerp(Y,it/J),Ft=J-it;for(let Tt=0;Tt<=Ft;Tt++)at[it][Tt]=0===Tt&&it===J?ct:ct.clone().lerp(At,Tt/Ft)}for(let it=0;it<J;it++)for(let ct=0;ct<2*(J-it)-1;ct++){const At=Math.floor(ct/2);ct%2==0?(x(at[it][At+1]),x(at[it+1][At]),x(at[it][At])):(x(at[it][At+1]),x(at[it+1][At+1]),x(at[it+1][At]))}}function x(z){d.push(z.x,z.y,z.z)}function w(z,W){const Y=3*z;W.x=e[Y+0],W.y=e[Y+1],W.z=e[Y+2]}function S(z,W,Y,tt){tt<0&&1===z.x&&(g[W]=z.x-1),0===Y.x&&0===Y.z&&(g[W]=tt/2/Math.PI+.5)}function P(z){return Math.atan2(z.z,-z.x)}(function(z){const W=new Dt,Y=new Dt,tt=new Dt;for(let J=0;J<s.length;J+=3)w(s[J+0],W),w(s[J+1],Y),w(s[J+2],tt),v(W,Y,tt,z)})(c),function(z){const W=new Dt;for(let Y=0;Y<d.length;Y+=3)W.x=d[Y+0],W.y=d[Y+1],W.z=d[Y+2],W.normalize().multiplyScalar(z),d[Y+0]=W.x,d[Y+1]=W.y,d[Y+2]=W.z}(l),function(){const z=new Dt;for(let Y=0;Y<d.length;Y+=3){z.x=d[Y+0],z.y=d[Y+1],z.z=d[Y+2];const tt=P(z)/2/Math.PI+.5,J=(W=z,Math.atan2(-W.y,Math.sqrt(W.x*W.x+W.z*W.z))/Math.PI+.5);g.push(tt,1-J)}var W;(function(){const Y=new Dt,tt=new Dt,J=new Dt,at=new Dt,it=new Ye,ct=new Ye,At=new Ye;for(let Ft=0,Tt=0;Ft<d.length;Ft+=9,Tt+=6){Y.set(d[Ft+0],d[Ft+1],d[Ft+2]),tt.set(d[Ft+3],d[Ft+4],d[Ft+5]),J.set(d[Ft+6],d[Ft+7],d[Ft+8]),it.set(g[Tt+0],g[Tt+1]),ct.set(g[Tt+2],g[Tt+3]),At.set(g[Tt+4],g[Tt+5]),at.copy(Y).add(tt).add(J).divideScalar(3);const Pt=P(at);S(it,Tt+0,Y,Pt),S(ct,Tt+2,tt,Pt),S(At,Tt+4,J,Pt)}})(),function(){for(let Y=0;Y<g.length;Y+=6){const tt=g[Y+0],J=g[Y+2],at=g[Y+4],it=Math.max(tt,J,at),ct=Math.min(tt,J,at);it>.9&&ct<.1&&(tt<.2&&(g[Y+0]+=1),J<.2&&(g[Y+2]+=1),at<.2&&(g[Y+4]+=1))}}()}(),this.setAttribute("position",new Tn(d,3)),this.setAttribute("normal",new Tn(d.slice(),3)),this.setAttribute("uv",new Tn(g,2)),0===c?this.computeVertexNormals():this.normalizeNormals()}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Ec(e.vertices,e.indices,e.radius,e.details)}}class Do extends Ec{constructor(e=1,s=0){const l=(1+Math.sqrt(5))/2,c=1/l;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-c,-l,0,-c,l,0,c,-l,0,c,l,-c,-l,0,-c,l,0,c,-l,0,c,l,0,-l,0,-c,l,0,-c,-l,0,c,l,0,c],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,s),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:s}}static fromJSON(e){return new Do(e.radius,e.detail)}}const Zh=new Dt,Qa=new Dt,$0=new Dt,_g=new Re;class Q1 extends gr{constructor(e=null,s=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:s},null!==e){const c=Math.pow(10,4),d=Math.cos(zl*s),g=e.getIndex(),v=e.getAttribute("position"),x=g?g.count:v.count,w=[0,0,0],S=["a","b","c"],P=new Array(3),z={},W=[];for(let Y=0;Y<x;Y+=3){g?(w[0]=g.getX(Y),w[1]=g.getX(Y+1),w[2]=g.getX(Y+2)):(w[0]=Y,w[1]=Y+1,w[2]=Y+2);const{a:tt,b:J,c:at}=_g;if(tt.fromBufferAttribute(v,w[0]),J.fromBufferAttribute(v,w[1]),at.fromBufferAttribute(v,w[2]),_g.getNormal($0),P[0]=`${Math.round(tt.x*c)},${Math.round(tt.y*c)},${Math.round(tt.z*c)}`,P[1]=`${Math.round(J.x*c)},${Math.round(J.y*c)},${Math.round(J.z*c)}`,P[2]=`${Math.round(at.x*c)},${Math.round(at.y*c)},${Math.round(at.z*c)}`,P[0]!==P[1]&&P[1]!==P[2]&&P[2]!==P[0])for(let it=0;it<3;it++){const ct=(it+1)%3,At=P[it],Ft=P[ct],Tt=_g[S[it]],Pt=_g[S[ct]],zt=`${At}_${Ft}`,ee=`${Ft}_${At}`;ee in z&&z[ee]?($0.dot(z[ee].normal)<=d&&(W.push(Tt.x,Tt.y,Tt.z),W.push(Pt.x,Pt.y,Pt.z)),z[ee]=null):zt in z||(z[zt]={index0:w[it],index1:w[ct],normal:$0.clone()})}}for(const Y in z)if(z[Y]){const{index0:tt,index1:J}=z[Y];Zh.fromBufferAttribute(v,tt),Qa.fromBufferAttribute(v,J),W.push(Zh.x,Zh.y,Zh.z),W.push(Qa.x,Qa.y,Qa.z)}this.setAttribute("position",new Tn(W,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class td extends Wf{constructor(e){super(e),this.uuid=Ua(),this.type="Shape",this.holes=[]}getPointsHoles(e){const s=[];for(let l=0,c=this.holes.length;l<c;l++)s[l]=this.holes[l].getPoints(e);return s}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let s=0,l=e.holes.length;s<l;s++)this.holes.push(e.holes[s].clone());return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let s=0,l=this.holes.length;s<l;s++)e.holes.push(this.holes[s].toJSON());return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let s=0,l=e.holes.length;s<l;s++){const c=e.holes[s];this.holes.push((new Wf).fromJSON(c))}return this}}function Xf(A,e,s,l,c){let d,g;if(c===function(v,x,w,S){let P=0;for(let z=x,W=w-S;z<w;z+=S)P+=(v[W]-v[z])*(v[z+1]+v[W+1]),W=z;return P}(A,e,s,l)>0)for(d=e;d<s;d+=l)g=rd(d,A[d],A[d+1],g);else for(d=s-l;d>=e;d-=l)g=rd(d,A[d],A[d+1],g);return g&&ed(g,g.next)&&(id(g),g=g.next),g}function Cc(A,e){if(!A)return A;e||(e=A);let s,l=A;do{if(s=!1,l.steiner||!ed(l,l.next)&&0!==Hi(l.prev,l,l.next))l=l.next;else{if(id(l),l=e=l.prev,l===l.next)break;s=!0}}while(s||l!==e);return e}function sh(A,e,s,l,c,d,g){if(!A)return;!g&&d&&function(S,P,z,W){let Y=S;do{0===Y.z&&(Y.z=Sp(Y.x,Y.y,P,z,W)),Y.prevZ=Y.prev,Y.nextZ=Y.next,Y=Y.next}while(Y!==S);Y.prevZ.nextZ=null,Y.prevZ=null,function(tt){let J,at,it,ct,At,Ft,Tt,Pt,zt=1;do{for(at=tt,tt=null,At=null,Ft=0;at;){for(Ft++,it=at,Tt=0,J=0;J<zt&&(Tt++,it=it.nextZ,it);J++);for(Pt=zt;Tt>0||Pt>0&&it;)0!==Tt&&(0===Pt||!it||at.z<=it.z)?(ct=at,at=at.nextZ,Tt--):(ct=it,it=it.nextZ,Pt--),At?At.nextZ=ct:tt=ct,ct.prevZ=At,At=ct;at=it}At.nextZ=null,zt*=2}while(Ft>1)}(Y)}(A,l,c,d);let v,x,w=A;for(;A.prev!==A.next;)if(v=A.prev,x=A.next,d?H1(A,l,c,d):V0(A))e.push(v.i/s|0),e.push(A.i/s|0),e.push(x.i/s|0),id(A),A=x.next,w=x.next;else if((A=x)===w){g?1===g?sh(A=G0(Cc(A),e,s),e,s,l,c,d,2):2===g&&kg(A,e,s,l,c,d):sh(Cc(A),e,s,l,c,d,1);break}}function V0(A){const e=A.prev,s=A,l=A.next;if(Hi(e,s,l)>=0)return!1;const c=e.x,d=s.x,g=l.x,v=e.y,x=s.y,w=l.y,S=c<d?c<g?c:g:d<g?d:g,P=v<x?v<w?v:w:x<w?x:w,z=c>d?c>g?c:g:d>g?d:g,W=v>x?v>w?v:w:x>w?x:w;let Y=l.next;for(;Y!==e;){if(Y.x>=S&&Y.x<=z&&Y.y>=P&&Y.y<=W&&Ic(c,v,d,x,g,w,Y.x,Y.y)&&Hi(Y.prev,Y,Y.next)>=0)return!1;Y=Y.next}return!0}function H1(A,e,s,l){const c=A.prev,d=A,g=A.next;if(Hi(c,d,g)>=0)return!1;const v=c.x,x=d.x,w=g.x,S=c.y,P=d.y,z=g.y,W=v<x?v<w?v:w:x<w?x:w,Y=S<P?S<z?S:z:P<z?P:z,tt=v>x?v>w?v:w:x>w?x:w,J=S>P?S>z?S:z:P>z?P:z,at=Sp(W,Y,e,s,l),it=Sp(tt,J,e,s,l);let ct=A.prevZ,At=A.nextZ;for(;ct&&ct.z>=at&&At&&At.z<=it;){if(ct.x>=W&&ct.x<=tt&&ct.y>=Y&&ct.y<=J&&ct!==c&&ct!==g&&Ic(v,S,x,P,w,z,ct.x,ct.y)&&Hi(ct.prev,ct,ct.next)>=0||(ct=ct.prevZ,At.x>=W&&At.x<=tt&&At.y>=Y&&At.y<=J&&At!==c&&At!==g&&Ic(v,S,x,P,w,z,At.x,At.y)&&Hi(At.prev,At,At.next)>=0))return!1;At=At.nextZ}for(;ct&&ct.z>=at;){if(ct.x>=W&&ct.x<=tt&&ct.y>=Y&&ct.y<=J&&ct!==c&&ct!==g&&Ic(v,S,x,P,w,z,ct.x,ct.y)&&Hi(ct.prev,ct,ct.next)>=0)return!1;ct=ct.prevZ}for(;At&&At.z<=it;){if(At.x>=W&&At.x<=tt&&At.y>=Y&&At.y<=J&&At!==c&&At!==g&&Ic(v,S,x,P,w,z,At.x,At.y)&&Hi(At.prev,At,At.next)>=0)return!1;At=At.nextZ}return!0}function G0(A,e,s){let l=A;do{const c=l.prev,d=l.next.next;!ed(c,d)&&ao(c,l,l.next,d)&&Lo(c,d)&&Lo(d,c)&&(e.push(c.i/s|0),e.push(l.i/s|0),e.push(d.i/s|0),id(l),id(l.next),l=A=d),l=l.next}while(l!==A);return Cc(l)}function kg(A,e,s,l,c,d){let g=A;do{let v=g.next.next;for(;v!==g.prev;){if(g.i!==v.i&&Kf(g,v)){let x=Co(g,v);return g=Cc(g,g.next),x=Cc(x,x.next),sh(g,e,s,l,c,d,0),void sh(x,e,s,l,c,d,0)}v=v.next}g=g.next}while(g!==A)}function Rg(A,e){return A.x-e.x}function Bg(A,e){const s=function(c,d){let g,v=d,x=-1/0;const w=c.x,S=c.y;do{if(S<=v.y&&S>=v.next.y&&v.next.y!==v.y){const J=v.x+(S-v.y)*(v.next.x-v.x)/(v.next.y-v.y);if(J<=w&&J>x&&(x=J,g=v.x<v.next.x?v:v.next,J===w))return g}v=v.next}while(v!==d);if(!g)return null;const P=g,z=g.x,W=g.y;let Y,tt=1/0;v=g;do{w>=v.x&&v.x>=z&&w!==v.x&&Ic(S<W?w:x,S,z,W,S<W?x:w,S,v.x,v.y)&&(Y=Math.abs(S-v.y)/(w-v.x),Lo(v,c)&&(Y<tt||Y===tt&&(v.x>g.x||v.x===g.x&&Q0(g,v)))&&(g=v,tt=Y)),v=v.next}while(v!==P);return g}(A,e);if(!s)return e;const l=Co(s,A);return Cc(l,l.next),Cc(s,s.next)}function Q0(A,e){return Hi(A.prev,A,e.prev)<0&&Hi(e.next,A,A.next)<0}function Sp(A,e,s,l,c){return(A=1431655765&((A=858993459&((A=252645135&((A=16711935&((A=(A-s)*c|0)|A<<8))|A<<4))|A<<2))|A<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-l)*c|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Yf(A){let e=A,s=A;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==A);return s}function Ic(A,e,s,l,c,d,g,v){return(c-g)*(e-v)>=(A-g)*(d-v)&&(A-g)*(l-v)>=(s-g)*(e-v)&&(s-g)*(d-v)>=(c-g)*(l-v)}function Kf(A,e){return A.next.i!==e.i&&A.prev.i!==e.i&&!function(s,l){let c=s;do{if(c.i!==s.i&&c.next.i!==s.i&&c.i!==l.i&&c.next.i!==l.i&&ao(c,c.next,s,l))return!0;c=c.next}while(c!==s);return!1}(A,e)&&(Lo(A,e)&&Lo(e,A)&&function(s,l){let c=s,d=!1;const g=(s.x+l.x)/2,v=(s.y+l.y)/2;do{c.y>v!=c.next.y>v&&c.next.y!==c.y&&g<(c.next.x-c.x)*(v-c.y)/(c.next.y-c.y)+c.x&&(d=!d),c=c.next}while(c!==s);return d}(A,e)&&(Hi(A.prev,A,e.prev)||Hi(A,e.prev,e))||ed(A,e)&&Hi(A.prev,A,A.next)>0&&Hi(e.prev,e,e.next)>0)}function Hi(A,e,s){return(e.y-A.y)*(s.x-e.x)-(e.x-A.x)*(s.y-e.y)}function ed(A,e){return A.x===e.x&&A.y===e.y}function ao(A,e,s,l){const c=nd(Hi(A,e,s)),d=nd(Hi(A,e,l)),g=nd(Hi(s,l,A)),v=nd(Hi(s,l,e));return c!==d&&g!==v||!(0!==c||!ah(A,s,e))||!(0!==d||!ah(A,l,e))||!(0!==g||!ah(s,A,l))||!(0!==v||!ah(s,e,l))}function ah(A,e,s){return e.x<=Math.max(A.x,s.x)&&e.x>=Math.min(A.x,s.x)&&e.y<=Math.max(A.y,s.y)&&e.y>=Math.min(A.y,s.y)}function nd(A){return A>0?1:A<0?-1:0}function Lo(A,e){return Hi(A.prev,A,A.next)<0?Hi(A,e,A.next)>=0&&Hi(A,A.prev,e)>=0:Hi(A,e,A.prev)<0||Hi(A,A.next,e)<0}function Co(A,e){const s=new Jf(A.i,A.x,A.y),l=new Jf(e.i,e.x,e.y),c=A.next,d=e.prev;return A.next=e,e.prev=A,s.next=c,c.prev=s,l.next=s,s.prev=l,d.next=l,l.prev=d,l}function rd(A,e,s,l){const c=new Jf(A,e,s);return l?(c.next=l.next,c.prev=l,l.next.prev=c,l.next=c):(c.prev=c,c.next=c),c}function id(A){A.next.prev=A.prev,A.prev.next=A.next,A.prevZ&&(A.prevZ.nextZ=A.nextZ),A.nextZ&&(A.nextZ.prevZ=A.prevZ)}function Jf(A,e,s){this.i=A,this.x=e,this.y=s,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}class Yi{static area(e){const s=e.length;let l=0;for(let c=s-1,d=0;d<s;c=d++)l+=e[c].x*e[d].y-e[d].x*e[c].y;return.5*l}static isClockWise(e){return Yi.area(e)<0}static triangulateShape(e,s){const l=[],c=[],d=[];oh(e),W1(l,e);let g=e.length;s.forEach(oh);for(let x=0;x<s.length;x++)c.push(g),g+=s[x].length,W1(l,s[x]);const v=function(x,w,S=2){const P=w&&w.length,z=P?w[0]*S:x.length;let W=Xf(x,0,z,S,!0);const Y=[];if(!W||W.next===W.prev)return Y;let tt,J,at,it,ct,At,Ft;if(P&&(W=function(Tt,Pt,zt,ee){const ce=[];let ne,ge,ie,pe,Oe;for(ne=0,ge=Pt.length;ne<ge;ne++)ie=Pt[ne]*ee,pe=ne<ge-1?Pt[ne+1]*ee:Tt.length,Oe=Xf(Tt,ie,pe,ee,!1),Oe===Oe.next&&(Oe.steiner=!0),ce.push(Yf(Oe));for(ce.sort(Rg),ne=0;ne<ce.length;ne++)zt=Bg(ce[ne],zt);return zt}(x,w,W,S)),x.length>80*S){tt=at=x[0],J=it=x[1];for(let Tt=S;Tt<z;Tt+=S)ct=x[Tt],At=x[Tt+1],ct<tt&&(tt=ct),At<J&&(J=At),ct>at&&(at=ct),At>it&&(it=At);Ft=Math.max(at-tt,it-J),Ft=0!==Ft?32767/Ft:0}return sh(W,Y,S,tt,J,Ft,0),Y}(l,c);for(let x=0;x<v.length;x+=3)d.push(v.slice(x,x+3));return d}}function oh(A){const e=A.length;e>2&&A[e-1].equals(A[0])&&A.pop()}function W1(A,e){for(let s=0;s<e.length;s++)A.push(e[s].x),A.push(e[s].y)}class Ng extends gr{constructor(e=new td([new Ye(.5,.5),new Ye(-.5,.5),new Ye(-.5,-.5),new Ye(.5,-.5)]),s={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:s},e=Array.isArray(e)?e:[e];const l=this,c=[],d=[];for(let v=0,x=e.length;v<x;v++)g(e[v]);function g(v){const x=[],w=void 0!==s.curveSegments?s.curveSegments:12,S=void 0!==s.steps?s.steps:1,P=void 0!==s.depth?s.depth:1;let z=void 0===s.bevelEnabled||s.bevelEnabled,W=void 0!==s.bevelThickness?s.bevelThickness:.2,Y=void 0!==s.bevelSize?s.bevelSize:W-.1,tt=void 0!==s.bevelOffset?s.bevelOffset:0,J=void 0!==s.bevelSegments?s.bevelSegments:3;const at=s.extrudePath,it=void 0!==s.UVGenerator?s.UVGenerator:Kb;let ct,At,Ft,Tt,Pt,zt=!1;at&&(ct=at.getSpacedPoints(S),zt=!0,z=!1,At=at.computeFrenetFrames(S,!1),Ft=new Dt,Tt=new Dt,Pt=new Dt),z||(J=0,W=0,Y=0,tt=0);const ee=v.extractPoints(w);let ce=ee.shape;const ne=ee.holes;if(!Yi.isClockWise(ce)){ce=ce.reverse();for(let Lt=0,St=ne.length;Lt<St;Lt++){const Et=ne[Lt];Yi.isClockWise(Et)&&(ne[Lt]=Et.reverse())}}const ge=Yi.triangulateShape(ce,ne),ie=ce;for(let Lt=0,St=ne.length;Lt<St;Lt++)ce=ce.concat(ne[Lt]);function pe(Lt,St,Et){return St||console.error("THREE.ExtrudeGeometry: vec does not exist"),Lt.clone().addScaledVector(St,Et)}const Oe=ce.length,Pe=ge.length;function ze(Lt,St,Et){let re,$t,oe;const fe=Lt.x-St.x,ye=Lt.y-St.y,Xe=Et.x-Lt.x,Fn=Et.y-Lt.y,An=fe*fe+ye*ye;if(Math.abs(fe*Fn-ye*Xe)>Number.EPSILON){const ar=Math.sqrt(An),$n=Math.sqrt(Xe*Xe+Fn*Fn),sr=St.x-ye/ar,Xr=St.y+fe/ar,Ir=((Et.x-Fn/$n-sr)*Fn-(Et.y+Xe/$n-Xr)*Xe)/(fe*Fn-ye*Xe);re=sr+fe*Ir-Lt.x,$t=Xr+ye*Ir-Lt.y;const kr=re*re+$t*$t;if(kr<=2)return new Ye(re,$t);oe=Math.sqrt(kr/2)}else{let ar=!1;fe>Number.EPSILON?Xe>Number.EPSILON&&(ar=!0):fe<-Number.EPSILON?Xe<-Number.EPSILON&&(ar=!0):Math.sign(ye)===Math.sign(Fn)&&(ar=!0),ar?(re=-ye,$t=fe,oe=Math.sqrt(An)):(re=fe,$t=ye,oe=Math.sqrt(An/2))}return new Ye(re/oe,$t/oe)}const Fe=[];for(let Lt=0,St=ie.length,Et=St-1,re=Lt+1;Lt<St;Lt++,Et++,re++)Et===St&&(Et=0),re===St&&(re=0),Fe[Lt]=ze(ie[Lt],ie[Et],ie[re]);const Dn=[];let Nn,fn=Fe.concat();for(let Lt=0,St=ne.length;Lt<St;Lt++){const Et=ne[Lt];Nn=[];for(let re=0,$t=Et.length,oe=$t-1,fe=re+1;re<$t;re++,oe++,fe++)oe===$t&&(oe=0),fe===$t&&(fe=0),Nn[re]=ze(Et[re],Et[oe],Et[fe]);Dn.push(Nn),fn=fn.concat(Nn)}for(let Lt=0;Lt<J;Lt++){const St=Lt/J,Et=W*Math.cos(St*Math.PI/2),re=Y*Math.sin(St*Math.PI/2)+tt;for(let $t=0,oe=ie.length;$t<oe;$t++){const fe=pe(ie[$t],Fe[$t],re);Mn(fe.x,fe.y,-Et)}for(let $t=0,oe=ne.length;$t<oe;$t++){const fe=ne[$t];Nn=Dn[$t];for(let ye=0,Xe=fe.length;ye<Xe;ye++){const Fn=pe(fe[ye],Nn[ye],re);Mn(Fn.x,Fn.y,-Et)}}}const xn=Y+tt;for(let Lt=0;Lt<Oe;Lt++){const St=z?pe(ce[Lt],fn[Lt],xn):ce[Lt];zt?(Tt.copy(At.normals[0]).multiplyScalar(St.x),Ft.copy(At.binormals[0]).multiplyScalar(St.y),Pt.copy(ct[0]).add(Tt).add(Ft),Mn(Pt.x,Pt.y,Pt.z)):Mn(St.x,St.y,0)}for(let Lt=1;Lt<=S;Lt++)for(let St=0;St<Oe;St++){const Et=z?pe(ce[St],fn[St],xn):ce[St];zt?(Tt.copy(At.normals[Lt]).multiplyScalar(Et.x),Ft.copy(At.binormals[Lt]).multiplyScalar(Et.y),Pt.copy(ct[Lt]).add(Tt).add(Ft),Mn(Pt.x,Pt.y,Pt.z)):Mn(Et.x,Et.y,P/S*Lt)}for(let Lt=J-1;Lt>=0;Lt--){const St=Lt/J,Et=W*Math.cos(St*Math.PI/2),re=Y*Math.sin(St*Math.PI/2)+tt;for(let $t=0,oe=ie.length;$t<oe;$t++){const fe=pe(ie[$t],Fe[$t],re);Mn(fe.x,fe.y,P+Et)}for(let $t=0,oe=ne.length;$t<oe;$t++){const fe=ne[$t];Nn=Dn[$t];for(let ye=0,Xe=fe.length;ye<Xe;ye++){const Fn=pe(fe[ye],Nn[ye],re);zt?Mn(Fn.x,Fn.y+ct[S-1].y,ct[S-1].x+Et):Mn(Fn.x,Fn.y,P+Et)}}}function In(Lt,St){let Et=Lt.length;for(;--Et>=0;){const re=Et;let $t=Et-1;$t<0&&($t=Lt.length-1);for(let oe=0,fe=S+2*J;oe<fe;oe++){const ye=Oe*oe,Xe=Oe*(oe+1);rn(St+re+ye,St+$t+ye,St+$t+Xe,St+re+Xe)}}}function Mn(Lt,St,Et){x.push(Lt),x.push(St),x.push(Et)}function Ce(Lt,St,Et){On(Lt),On(St),On(Et);const re=c.length/3,$t=it.generateTopUV(l,c,re-3,re-2,re-1);ln($t[0]),ln($t[1]),ln($t[2])}function rn(Lt,St,Et,re){On(Lt),On(St),On(re),On(St),On(Et),On(re);const $t=c.length/3,oe=it.generateSideWallUV(l,c,$t-6,$t-3,$t-2,$t-1);ln(oe[0]),ln(oe[1]),ln(oe[3]),ln(oe[1]),ln(oe[2]),ln(oe[3])}function On(Lt){c.push(x[3*Lt+0]),c.push(x[3*Lt+1]),c.push(x[3*Lt+2])}function ln(Lt){d.push(Lt.x),d.push(Lt.y)}(function(){const Lt=c.length/3;if(z){let St=0,Et=Oe*St;for(let re=0;re<Pe;re++){const $t=ge[re];Ce($t[2]+Et,$t[1]+Et,$t[0]+Et)}St=S+2*J,Et=Oe*St;for(let re=0;re<Pe;re++){const $t=ge[re];Ce($t[0]+Et,$t[1]+Et,$t[2]+Et)}}else{for(let St=0;St<Pe;St++){const Et=ge[St];Ce(Et[2],Et[1],Et[0])}for(let St=0;St<Pe;St++){const Et=ge[St];Ce(Et[0]+Oe*S,Et[1]+Oe*S,Et[2]+Oe*S)}}l.addGroup(Lt,c.length/3-Lt,0)})(),function(){const Lt=c.length/3;let St=0;In(ie,St),St+=ie.length;for(let Et=0,re=ne.length;Et<re;Et++){const $t=ne[Et];In($t,St),St+=$t.length}l.addGroup(Lt,c.length/3-Lt,1)}()}this.setAttribute("position",new Tn(c,3)),this.setAttribute("uv",new Tn(d,2)),this.computeVertexNormals()}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return function(s,l,c){if(c.shapes=[],Array.isArray(s))for(let d=0,g=s.length;d<g;d++)c.shapes.push(s[d].uuid);else c.shapes.push(s.uuid);return c.options=Object.assign({},l),void 0!==l.extrudePath&&(c.options.extrudePath=l.extrudePath.toJSON()),c}(this.parameters.shapes,this.parameters.options,e)}static fromJSON(e,s){const l=[];for(let d=0,g=e.shapes.length;d<g;d++)l.push(s[e.shapes[d]]);const c=e.options.extrudePath;return void 0!==c&&(e.options.extrudePath=(new Ip[c.type]).fromJSON(c)),new Ng(l,e.options)}}const Kb={generateTopUV:function(A,e,s,l,c){const v=e[3*l],x=e[3*l+1],w=e[3*c],S=e[3*c+1];return[new Ye(e[3*s],e[3*s+1]),new Ye(v,x),new Ye(w,S)]},generateSideWallUV:function(A,e,s,l,c,d){const g=e[3*s],v=e[3*s+1],x=e[3*s+2],w=e[3*l],S=e[3*l+1],P=e[3*l+2],z=e[3*c],W=e[3*c+1],Y=e[3*c+2],tt=e[3*d],J=e[3*d+1],at=e[3*d+2];return Math.abs(v-S)<Math.abs(g-w)?[new Ye(g,1-x),new Ye(w,1-P),new Ye(z,1-Y),new Ye(tt,1-at)]:[new Ye(v,1-x),new Ye(S,1-P),new Ye(W,1-Y),new Ye(J,1-at)]}};class Mp extends Ec{constructor(e=1,s=0){const l=(1+Math.sqrt(5))/2;super([-1,l,0,1,l,0,-1,-l,0,1,-l,0,0,-1,l,0,1,l,0,-1,-l,0,1,-l,l,0,-1,l,0,1,-l,0,-1,-l,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,s),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:s}}static fromJSON(e){return new Mp(e.radius,e.detail)}}class lh extends Ec{constructor(e=1,s=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,s),this.type="OctahedronGeometry",this.parameters={radius:e,detail:s}}static fromJSON(e){return new lh(e.radius,e.detail)}}class sd extends gr{constructor(e=.5,s=1,l=32,c=1,d=0,g=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:s,thetaSegments:l,phiSegments:c,thetaStart:d,thetaLength:g},l=Math.max(3,l);const v=[],x=[],w=[],S=[];let P=e;const z=(s-e)/(c=Math.max(1,c)),W=new Dt,Y=new Ye;for(let tt=0;tt<=c;tt++){for(let J=0;J<=l;J++){const at=d+J/l*g;W.x=P*Math.cos(at),W.y=P*Math.sin(at),x.push(W.x,W.y,W.z),w.push(0,0,1),Y.x=(W.x/s+1)/2,Y.y=(W.y/s+1)/2,S.push(Y.x,Y.y)}P+=z}for(let tt=0;tt<c;tt++){const J=tt*(l+1);for(let at=0;at<l;at++){const it=at+J,At=it+l+1,Ft=it+l+2,Tt=it+1;v.push(it,At,Tt),v.push(At,Ft,Tt)}}this.setIndex(v),this.setAttribute("position",new Tn(x,3)),this.setAttribute("normal",new Tn(w,3)),this.setAttribute("uv",new Tn(S,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new sd(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class Tp extends gr{constructor(e=new td([new Ye(0,.5),new Ye(-.5,-.5),new Ye(.5,-.5)]),s=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:s};const l=[],c=[],d=[],g=[];let v=0,x=0;if(!1===Array.isArray(e))w(e);else for(let S=0;S<e.length;S++)w(e[S]),this.addGroup(v,x,S),v+=x,x=0;function w(S){const P=c.length/3,z=S.extractPoints(s);let W=z.shape;const Y=z.holes;!1===Yi.isClockWise(W)&&(W=W.reverse());for(let J=0,at=Y.length;J<at;J++){const it=Y[J];!0===Yi.isClockWise(it)&&(Y[J]=it.reverse())}const tt=Yi.triangulateShape(W,Y);for(let J=0,at=Y.length;J<at;J++)W=W.concat(Y[J]);for(let J=0,at=W.length;J<at;J++){const it=W[J];c.push(it.x,it.y,0),d.push(0,0,1),g.push(it.x,it.y)}for(let J=0,at=tt.length;J<at;J++){const it=tt[J];l.push(it[0]+P,it[1]+P,it[2]+P),x+=3}}this.setIndex(l),this.setAttribute("position",new Tn(c,3)),this.setAttribute("normal",new Tn(d,3)),this.setAttribute("uv",new Tn(g,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return function(s,l){if(l.shapes=[],Array.isArray(s))for(let c=0,d=s.length;c<d;c++)l.shapes.push(s[c].uuid);else l.shapes.push(s.uuid);return l}(this.parameters.shapes,e)}static fromJSON(e,s){const l=[];for(let c=0,d=e.shapes.length;c<d;c++)l.push(s[e.shapes[c]]);return new Tp(l,e.curveSegments)}}class oo extends gr{constructor(e=1,s=32,l=16,c=0,d=2*Math.PI,g=0,v=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:s,heightSegments:l,phiStart:c,phiLength:d,thetaStart:g,thetaLength:v},s=Math.max(3,Math.floor(s)),l=Math.max(2,Math.floor(l));const x=Math.min(g+v,Math.PI);let w=0;const S=[],P=new Dt,z=new Dt,W=[],Y=[],tt=[],J=[];for(let at=0;at<=l;at++){const it=[],ct=at/l;let At=0;0===at&&0===g?At=.5/s:at===l&&x===Math.PI&&(At=-.5/s);for(let Ft=0;Ft<=s;Ft++){const Tt=Ft/s;P.x=-e*Math.cos(c+Tt*d)*Math.sin(g+ct*v),P.y=e*Math.cos(g+ct*v),P.z=e*Math.sin(c+Tt*d)*Math.sin(g+ct*v),Y.push(P.x,P.y,P.z),z.copy(P).normalize(),tt.push(z.x,z.y,z.z),J.push(Tt+At,1-ct),it.push(w++)}S.push(it)}for(let at=0;at<l;at++)for(let it=0;it<s;it++){const At=S[at][it],Ft=S[at+1][it],Tt=S[at+1][it+1];(0!==at||g>0)&&W.push(S[at][it+1],At,Tt),(at!==l-1||x<Math.PI)&&W.push(At,Ft,Tt)}this.setIndex(W),this.setAttribute("position",new Tn(Y,3)),this.setAttribute("normal",new Tn(tt,3)),this.setAttribute("uv",new Tn(J,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new oo(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class Zf extends Ec{constructor(e=1,s=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,s),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:s}}static fromJSON(e){return new Zf(e.radius,e.detail)}}class ad extends gr{constructor(e=1,s=.4,l=12,c=48,d=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:s,radialSegments:l,tubularSegments:c,arc:d},l=Math.floor(l),c=Math.floor(c);const g=[],v=[],x=[],w=[],S=new Dt,P=new Dt,z=new Dt;for(let W=0;W<=l;W++)for(let Y=0;Y<=c;Y++){const tt=Y/c*d,J=W/l*Math.PI*2;P.x=(e+s*Math.cos(J))*Math.cos(tt),P.y=(e+s*Math.cos(J))*Math.sin(tt),P.z=s*Math.sin(J),v.push(P.x,P.y,P.z),S.x=e*Math.cos(tt),S.y=e*Math.sin(tt),z.subVectors(P,S).normalize(),x.push(z.x,z.y,z.z),w.push(Y/c),w.push(W/l)}for(let W=1;W<=l;W++)for(let Y=1;Y<=c;Y++){const J=(c+1)*(W-1)+Y-1,at=(c+1)*(W-1)+Y,it=(c+1)*W+Y;g.push((c+1)*W+Y-1,J,it),g.push(J,at,it)}this.setIndex(g),this.setAttribute("position",new Tn(v,3)),this.setAttribute("normal",new Tn(x,3)),this.setAttribute("uv",new Tn(w,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new ad(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class _p extends gr{constructor(e=1,s=.4,l=64,c=8,d=2,g=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:s,tubularSegments:l,radialSegments:c,p:d,q:g},l=Math.floor(l),c=Math.floor(c);const v=[],x=[],w=[],S=[],P=new Dt,z=new Dt,W=new Dt,Y=new Dt,tt=new Dt,J=new Dt,at=new Dt;for(let ct=0;ct<=l;++ct){const At=ct/l*d*Math.PI*2;it(At,d,g,e,W),it(At+.01,d,g,e,Y),J.subVectors(Y,W),at.addVectors(Y,W),tt.crossVectors(J,at),at.crossVectors(tt,J),tt.normalize(),at.normalize();for(let Ft=0;Ft<=c;++Ft){const Tt=Ft/c*Math.PI*2,Pt=-s*Math.cos(Tt),zt=s*Math.sin(Tt);P.x=W.x+(Pt*at.x+zt*tt.x),P.y=W.y+(Pt*at.y+zt*tt.y),P.z=W.z+(Pt*at.z+zt*tt.z),x.push(P.x,P.y,P.z),z.subVectors(P,W).normalize(),w.push(z.x,z.y,z.z),S.push(ct/l),S.push(Ft/c)}}for(let ct=1;ct<=l;ct++)for(let At=1;At<=c;At++){const Tt=(c+1)*ct+(At-1),Pt=(c+1)*ct+At,zt=(c+1)*(ct-1)+At;v.push((c+1)*(ct-1)+(At-1),Tt,zt),v.push(Tt,Pt,zt)}function it(ct,At,Ft,Tt,Pt){const zt=Math.cos(ct),ee=Math.sin(ct),ce=Ft/At*ct,ne=Math.cos(ce);Pt.x=Tt*(2+ne)*.5*zt,Pt.y=Tt*(2+ne)*ee*.5,Pt.z=Tt*Math.sin(ce)*.5}this.setIndex(v),this.setAttribute("position",new Tn(x,3)),this.setAttribute("normal",new Tn(w,3)),this.setAttribute("uv",new Tn(S,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new _p(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class Dg extends gr{constructor(e=new z0(new Dt(-1,-1,0),new Dt(-1,1,0),new Dt(1,1,0)),s=64,l=1,c=8,d=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:s,radius:l,radialSegments:c,closed:d};const g=e.computeFrenetFrames(s,d);this.tangents=g.tangents,this.normals=g.normals,this.binormals=g.binormals;const v=new Dt,x=new Dt,w=new Ye;let S=new Dt;const P=[],z=[],W=[],Y=[];function tt(J){S=e.getPointAt(J/s,S);const at=g.normals[J],it=g.binormals[J];for(let ct=0;ct<=c;ct++){const At=ct/c*Math.PI*2,Ft=Math.sin(At),Tt=-Math.cos(At);x.x=Tt*at.x+Ft*it.x,x.y=Tt*at.y+Ft*it.y,x.z=Tt*at.z+Ft*it.z,x.normalize(),z.push(x.x,x.y,x.z),v.x=S.x+l*x.x,v.y=S.y+l*x.y,v.z=S.z+l*x.z,P.push(v.x,v.y,v.z)}}(function(){for(let J=0;J<s;J++)tt(J);tt(!1===d?s:0),function(){for(let J=0;J<=s;J++)for(let at=0;at<=c;at++)w.x=J/s,w.y=at/c,W.push(w.x,w.y)}(),function(){for(let J=1;J<=s;J++)for(let at=1;at<=c;at++){const ct=(c+1)*J+(at-1),At=(c+1)*J+at,Ft=(c+1)*(J-1)+at;Y.push((c+1)*(J-1)+(at-1),ct,Ft),Y.push(ct,At,Ft)}}()})(),this.setIndex(Y),this.setAttribute("position",new Tn(P,3)),this.setAttribute("normal",new Tn(z,3)),this.setAttribute("uv",new Tn(W,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new Dg((new Ip[e.path.type]).fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class H0 extends gr{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},null!==e){const s=[],l=new Set,c=new Dt,d=new Dt;if(null!==e.index){const g=e.attributes.position,v=e.index;let x=e.groups;0===x.length&&(x=[{start:0,count:v.count,materialIndex:0}]);for(let w=0,S=x.length;w<S;++w){const P=x[w],z=P.start;for(let W=z,Y=z+P.count;W<Y;W+=3)for(let tt=0;tt<3;tt++){const J=v.getX(W+tt),at=v.getX(W+(tt+1)%3);c.fromBufferAttribute(g,J),d.fromBufferAttribute(g,at),!0===tm(c,d,l)&&(s.push(c.x,c.y,c.z),s.push(d.x,d.y,d.z))}}}else{const g=e.attributes.position;for(let v=0,x=g.count/3;v<x;v++)for(let w=0;w<3;w++){const P=3*v+(w+1)%3;c.fromBufferAttribute(g,3*v+w),d.fromBufferAttribute(g,P),!0===tm(c,d,l)&&(s.push(c.x,c.y,c.z),s.push(d.x,d.y,d.z))}}this.setAttribute("position",new Tn(s,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function tm(A,e,s){const l=`${A.x},${A.y},${A.z}-${e.x},${e.y},${e.z}`,c=`${e.x},${e.y},${e.z}-${A.x},${A.y},${A.z}`;return!0!==s.has(l)&&!0!==s.has(c)&&(s.add(l),s.add(c),!0)}var j1=Object.freeze({__proto__:null,BoxGeometry:Ko,CapsuleGeometry:qf,CircleGeometry:gu,ConeGeometry:ih,CylinderGeometry:Zl,DodecahedronGeometry:Do,EdgesGeometry:Q1,ExtrudeGeometry:Ng,IcosahedronGeometry:Mp,LatheGeometry:jf,OctahedronGeometry:lh,PlaneGeometry:ap,PolyhedronGeometry:Ec,RingGeometry:sd,ShapeGeometry:Tp,SphereGeometry:oo,TetrahedronGeometry:Zf,TorusGeometry:ad,TorusKnotGeometry:_p,TubeGeometry:Dg,WireframeGeometry:H0});class W0 extends di{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new En(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class Lg extends xl{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class kp extends di{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new En(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new En(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wi,this.normalScale=new Ye(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Gi,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class rl extends kp{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ye(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ki(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(s){this.ior=(1+.4*s)/(1-.4*s)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new En(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new En(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new En(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class em extends di{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new En(16777215),this.specular=new En(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new En(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wi,this.normalScale=new Ye(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Gi,this.combine=Ct,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Fg extends di{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new En(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new En(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wi,this.normalScale=new Ye(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class q1 extends di{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wi,this.normalScale=new Ye(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class Og extends di{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new En(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new En(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wi,this.normalScale=new Ye(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Gi,this.combine=Ct,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class nm extends di{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new En(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=wi,this.normalScale=new Ye(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class rm extends ls{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function Sc(A,e,s){return!A||!s&&A.constructor===e?A:"number"==typeof e.BYTES_PER_ELEMENT?new e(A):Array.prototype.slice.call(A)}function im(A){return ArrayBuffer.isView(A)&&!(A instanceof DataView)}function Pg(A){const e=A.length,s=new Array(e);for(let l=0;l!==e;++l)s[l]=l;return s.sort(function(l,c){return A[l]-A[c]}),s}function Ug(A,e,s){const l=A.length,c=new A.constructor(l);for(let d=0,g=0;g!==l;++d){const v=s[d]*e;for(let x=0;x!==e;++x)c[g++]=A[v+x]}return c}function zg(A,e,s,l){let c=1,d=A[0];for(;void 0!==d&&void 0===d[l];)d=A[c++];if(void 0===d)return;let g=d[l];if(void 0!==g)if(Array.isArray(g))do{g=d[l],void 0!==g&&(e.push(d.time),s.push.apply(s,g)),d=A[c++]}while(void 0!==d);else if(void 0!==g.toArray)do{g=d[l],void 0!==g&&(e.push(d.time),g.toArray(s,s.length)),d=A[c++]}while(void 0!==d);else do{g=d[l],void 0!==g&&(e.push(d.time),s.push(g)),d=A[c++]}while(void 0!==d)}const X1={convertArray:Sc,isTypedArray:im,getKeyframeOrder:Pg,sortedArray:Ug,flattenJSON:zg,subclip:function(A,e,s,l,c=30){const d=A.clone();d.name=e;const g=[];for(let x=0;x<d.tracks.length;++x){const w=d.tracks[x],S=w.getValueSize(),P=[],z=[];for(let W=0;W<w.times.length;++W){const Y=w.times[W]*c;if(!(Y<s||Y>=l)){P.push(w.times[W]);for(let tt=0;tt<S;++tt)z.push(w.values[W*S+tt])}}0!==P.length&&(w.times=Sc(P,w.times.constructor),w.values=Sc(z,w.values.constructor),g.push(w))}d.tracks=g;let v=1/0;for(let x=0;x<d.tracks.length;++x)v>d.tracks[x].times[0]&&(v=d.tracks[x].times[0]);for(let x=0;x<d.tracks.length;++x)d.tracks[x].shift(-1*v);return d.resetDuration(),d},makeClipAdditive:function(A,e=0,s=A,l=30){l<=0&&(l=30);const c=s.tracks.length,d=e/l;for(let g=0;g<c;++g){const v=s.tracks[g],x=v.ValueTypeName;if("bool"===x||"string"===x)continue;const w=A.tracks.find(function(at){return at.name===v.name&&at.ValueTypeName===x});if(void 0===w)continue;let S=0;const P=v.getValueSize();v.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(S=P/3);let z=0;const W=w.getValueSize();w.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(z=W/3);const Y=v.times.length-1;let tt;if(d<=v.times[0])tt=v.values.slice(S,P-S);else if(d>=v.times[Y]){const at=Y*P+S;tt=v.values.slice(at,at+P-S)}else{const at=v.createInterpolant(),it=S,ct=P-S;at.evaluate(d),tt=at.resultBuffer.slice(it,ct)}"quaternion"===x&&(new _s).fromArray(tt).normalize().conjugate().toArray(tt);const J=w.times.length;for(let at=0;at<J;++at){const it=at*W+z;if("quaternion"===x)_s.multiplyQuaternionsFlat(w.values,it,tt,0,w.values,it);else{const ct=W-2*z;for(let At=0;At<ct;++At)w.values[it+At]-=tt[At]}}}return A.blendMode=dl,A}};class Au{constructor(e,s,l,c){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==c?c:new s.constructor(l),this.sampleValues=s,this.valueSize=l,this.settings=null,this.DefaultSettings_={}}evaluate(e){const s=this.parameterPositions;let l=this._cachedIndex,c=s[l],d=s[l-1];t:{e:{let g;n:{r:if(!(e<c)){for(let v=l+2;;){if(void 0===c){if(e<d)break r;return l=s.length,this._cachedIndex=l,this.copySampleValue_(l-1)}if(l===v)break;if(d=c,c=s[++l],e<c)break e}g=s.length;break n}if(e>=d)break t;{const v=s[1];e<v&&(l=2,d=v);for(let x=l-2;;){if(void 0===d)return this._cachedIndex=0,this.copySampleValue_(0);if(l===x)break;if(c=d,d=s[--l-1],e>=d)break e}g=l,l=0}}for(;l<g;){const v=l+g>>>1;e<s[v]?g=v:l=v+1}if(c=s[l],d=s[l-1],void 0===d)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===c)return l=s.length,this._cachedIndex=l,this.copySampleValue_(l-1)}this._cachedIndex=l,this.intervalChanged_(l,d,c)}return this.interpolate_(l,d,e,c)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const s=this.resultBuffer,l=this.sampleValues,c=this.valueSize,d=e*c;for(let g=0;g!==c;++g)s[g]=l[d+g];return s}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Y1 extends Au{constructor(e,s,l,c){super(e,s,l,c),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Ja,endingEnd:Ja}}intervalChanged_(e,s,l){const c=this.parameterPositions;let d=e-2,g=e+1,v=c[d],x=c[g];if(void 0===v)switch(this.getSettings_().endingStart){case Za:d=e,v=2*s-l;break;case Ao:d=c.length-2,v=s+c[d]-c[d+1];break;default:d=e,v=l}if(void 0===x)switch(this.getSettings_().endingEnd){case Za:g=e,x=2*l-s;break;case Ao:g=1,x=l+c[1]-c[0];break;default:g=e-1,x=s}const w=.5*(l-s),S=this.valueSize;this._weightPrev=w/(s-v),this._weightNext=w/(x-l),this._offsetPrev=d*S,this._offsetNext=g*S}interpolate_(e,s,l,c){const d=this.resultBuffer,g=this.sampleValues,v=this.valueSize,x=e*v,w=x-v,S=this._offsetPrev,P=this._offsetNext,z=this._weightPrev,W=this._weightNext,Y=(l-s)/(c-s),tt=Y*Y,J=tt*Y,at=-z*J+2*z*tt-z*Y,it=(1+z)*J+(-1.5-2*z)*tt+(-.5+z)*Y+1,ct=(-1-W)*J+(1.5+W)*tt+.5*Y,At=W*J-W*tt;for(let Ft=0;Ft!==v;++Ft)d[Ft]=at*g[S+Ft]+it*g[w+Ft]+ct*g[x+Ft]+At*g[P+Ft];return d}}class $g extends Au{constructor(e,s,l,c){super(e,s,l,c)}interpolate_(e,s,l,c){const d=this.resultBuffer,g=this.sampleValues,v=this.valueSize,x=e*v,w=x-v,S=(l-s)/(c-s),P=1-S;for(let z=0;z!==v;++z)d[z]=g[w+z]*P+g[x+z]*S;return d}}class j0 extends Au{constructor(e,s,l,c){super(e,s,l,c)}interpolate_(e){return this.copySampleValue_(e-1)}}class tc{constructor(e,s,l,c){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===s||0===s.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Sc(s,this.TimeBufferType),this.values=Sc(l,this.ValueBufferType),this.setInterpolation(c||this.DefaultInterpolation)}static toJSON(e){const s=e.constructor;let l;if(s.toJSON!==this.toJSON)l=s.toJSON(e);else{l={name:e.name,times:Sc(e.times,Array),values:Sc(e.values,Array)};const c=e.getInterpolation();c!==e.DefaultInterpolation&&(l.interpolation=c)}return l.type=e.ValueTypeName,l}InterpolantFactoryMethodDiscrete(e){return new j0(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new $g(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new Y1(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let s;switch(e){case $i:s=this.InterpolantFactoryMethodDiscrete;break;case Zs:s=this.InterpolantFactoryMethodLinear;break;case Qo:s=this.InterpolantFactoryMethodSmooth}if(void 0===s){const l="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(l);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",l),this}return this.createInterpolant=s,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return $i;case this.InterpolantFactoryMethodLinear:return Zs;case this.InterpolantFactoryMethodSmooth:return Qo}}getValueSize(){return this.values.length/this.times.length}shift(e){if(0!==e){const s=this.times;for(let l=0,c=s.length;l!==c;++l)s[l]+=e}return this}scale(e){if(1!==e){const s=this.times;for(let l=0,c=s.length;l!==c;++l)s[l]*=e}return this}trim(e,s){const l=this.times,c=l.length;let d=0,g=c-1;for(;d!==c&&l[d]<e;)++d;for(;-1!==g&&l[g]>s;)--g;if(++g,0!==d||g!==c){d>=g&&(g=Math.max(g,1),d=g-1);const v=this.getValueSize();this.times=l.slice(d,g),this.values=this.values.slice(d*v,g*v)}return this}validate(){let e=!0;const s=this.getValueSize();s-Math.floor(s)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const l=this.times,c=this.values,d=l.length;0===d&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let g=null;for(let v=0;v!==d;v++){const x=l[v];if("number"==typeof x&&isNaN(x)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,v,x),e=!1;break}if(null!==g&&g>x){console.error("THREE.KeyframeTrack: Out of order keys.",this,v,x,g),e=!1;break}g=x}if(void 0!==c&&im(c))for(let v=0,x=c.length;v!==x;++v){const w=c[v];if(isNaN(w)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,v,w),e=!1;break}}return e}optimize(){const e=this.times.slice(),s=this.values.slice(),l=this.getValueSize(),c=this.getInterpolation()===Qo,d=e.length-1;let g=1;for(let v=1;v<d;++v){let x=!1;const w=e[v];if(w!==e[v+1]&&(1!==v||w!==e[0]))if(c)x=!0;else{const S=v*l,P=S-l,z=S+l;for(let W=0;W!==l;++W){const Y=s[S+W];if(Y!==s[P+W]||Y!==s[z+W]){x=!0;break}}}if(x){if(v!==g){e[g]=e[v];const S=v*l,P=g*l;for(let z=0;z!==l;++z)s[P+z]=s[S+z]}++g}}if(d>0){e[g]=e[d];for(let v=d*l,x=g*l,w=0;w!==l;++w)s[x+w]=s[v+w];++g}return g!==e.length?(this.times=e.slice(0,g),this.values=s.slice(0,g*l)):(this.times=e,this.values=s),this}clone(){const e=this.times.slice(),s=this.values.slice(),l=new this.constructor(this.name,e,s);return l.createInterpolant=this.createInterpolant,l}}tc.prototype.TimeBufferType=Float32Array,tc.prototype.ValueBufferType=Float32Array,tc.prototype.DefaultInterpolation=Zs;class od extends tc{}od.prototype.ValueTypeName="bool",od.prototype.ValueBufferType=Array,od.prototype.DefaultInterpolation=$i,od.prototype.InterpolantFactoryMethodLinear=void 0,od.prototype.InterpolantFactoryMethodSmooth=void 0;class q0 extends tc{}q0.prototype.ValueTypeName="color";class ld extends tc{}ld.prototype.ValueTypeName="number";class K1 extends Au{constructor(e,s,l,c){super(e,s,l,c)}interpolate_(e,s,l,c){const d=this.resultBuffer,g=this.sampleValues,v=this.valueSize,x=(l-s)/(c-s);let w=e*v;for(let S=w+v;w!==S;w+=4)_s.slerpFlat(d,0,g,w-v,g,w,x);return d}}class il extends tc{InterpolantFactoryMethodLinear(e){return new K1(this.times,this.values,this.getValueSize(),e)}}il.prototype.ValueTypeName="quaternion",il.prototype.DefaultInterpolation=Zs,il.prototype.InterpolantFactoryMethodSmooth=void 0;class cd extends tc{}cd.prototype.ValueTypeName="string",cd.prototype.ValueBufferType=Array,cd.prototype.DefaultInterpolation=$i,cd.prototype.InterpolantFactoryMethodLinear=void 0,cd.prototype.InterpolantFactoryMethodSmooth=void 0;class ud extends tc{}ud.prototype.ValueTypeName="vector";class Rp{constructor(e="",s=-1,l=[],c=hl){this.name=e,this.tracks=l,this.duration=s,this.blendMode=c,this.uuid=Ua(),this.duration<0&&this.resetDuration()}static parse(e){const s=[],l=e.tracks,c=1/(e.fps||1);for(let g=0,v=l.length;g!==v;++g)s.push(Vg(l[g]).scale(c));const d=new this(e.name,e.duration,s,e.blendMode);return d.uuid=e.uuid,d}static toJSON(e){const s=[],l=e.tracks,c={name:e.name,duration:e.duration,tracks:s,uuid:e.uuid,blendMode:e.blendMode};for(let d=0,g=l.length;d!==g;++d)s.push(tc.toJSON(l[d]));return c}static CreateFromMorphTargetSequence(e,s,l,c){const d=s.length,g=[];for(let v=0;v<d;v++){let x=[],w=[];x.push((v+d-1)%d,v,(v+1)%d),w.push(0,1,0);const S=Pg(x);x=Ug(x,1,S),w=Ug(w,1,S),c||0!==x[0]||(x.push(d),w.push(w[0])),g.push(new ld(".morphTargetInfluences["+s[v].name+"]",x,w).scale(1/l))}return new this(e,-1,g)}static findByName(e,s){let l=e;Array.isArray(e)||(l=e.geometry&&e.geometry.animations||e.animations);for(let c=0;c<l.length;c++)if(l[c].name===s)return l[c];return null}static CreateClipsFromMorphTargetSequences(e,s,l){const c={},d=/^([\w-]*?)([\d]+)$/;for(let v=0,x=e.length;v<x;v++){const w=e[v],S=w.name.match(d);if(S&&S.length>1){const P=S[1];let z=c[P];z||(c[P]=z=[]),z.push(w)}}const g=[];for(const v in c)g.push(this.CreateFromMorphTargetSequence(v,c[v],s,l));return g}static parseAnimation(e,s){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const l=function(S,P,z,W,Y){if(0!==z.length){const tt=[],J=[];zg(z,tt,J,W),0!==tt.length&&Y.push(new S(P,tt,J))}},c=[],d=e.name||"default",g=e.fps||30,v=e.blendMode;let x=e.length||-1;const w=e.hierarchy||[];for(let S=0;S<w.length;S++){const P=w[S].keys;if(P&&0!==P.length)if(P[0].morphTargets){const z={};let W;for(W=0;W<P.length;W++)if(P[W].morphTargets)for(let Y=0;Y<P[W].morphTargets.length;Y++)z[P[W].morphTargets[Y]]=-1;for(const Y in z){const tt=[],J=[];for(let at=0;at!==P[W].morphTargets.length;++at){const it=P[W];tt.push(it.time),J.push(it.morphTarget===Y?1:0)}c.push(new ld(".morphTargetInfluence["+Y+"]",tt,J))}x=z.length*g}else{const z=".bones["+s[S].name+"]";l(ud,z+".position",P,"pos",c),l(il,z+".quaternion",P,"rot",c),l(ud,z+".scale",P,"scl",c)}}return 0===c.length?null:new this(d,x,c,v)}resetDuration(){let e=0;for(let s=0,l=this.tracks.length;s!==l;++s){const c=this.tracks[s];e=Math.max(e,c.times[c.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let s=0;s<this.tracks.length;s++)e=e&&this.tracks[s].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let s=0;s<this.tracks.length;s++)e.push(this.tracks[s].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Vg(A){if(void 0===A.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(s){switch(s.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ld;case"vector":case"vector2":case"vector3":case"vector4":return ud;case"color":return q0;case"quaternion":return il;case"bool":case"boolean":return od;case"string":return cd}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+s)}(A.type);if(void 0===A.times){const s=[],l=[];zg(A.keys,s,l,"value"),A.times=s,A.values=l}return void 0!==e.parse?e.parse(A):new e(A.name,A.times,A.values,A.interpolation)}const Il={enabled:!1,files:{},add:function(A,e){!1!==this.enabled&&(this.files[A]=e)},get:function(A){if(!1!==this.enabled)return this.files[A]},remove:function(A){delete this.files[A]},clear:function(){this.files={}}};class Bp{constructor(e,s,l){const c=this;let d,g=!1,v=0,x=0;const w=[];this.onStart=void 0,this.onLoad=e,this.onProgress=s,this.onError=l,this.itemStart=function(S){x++,!1===g&&void 0!==c.onStart&&c.onStart(S,v,x),g=!0},this.itemEnd=function(S){v++,void 0!==c.onProgress&&c.onProgress(S,v,x),v===x&&(g=!1,void 0!==c.onLoad&&c.onLoad())},this.itemError=function(S){void 0!==c.onError&&c.onError(S)},this.resolveURL=function(S){return d?d(S):S},this.setURLModifier=function(S){return d=S,this},this.addHandler=function(S,P){return w.push(S,P),this},this.removeHandler=function(S){const P=w.indexOf(S);return-1!==P&&w.splice(P,2),this},this.getHandler=function(S){for(let P=0,z=w.length;P<z;P+=2){const W=w[P],Y=w[P+1];if(W.global&&(W.lastIndex=0),W.test(S))return Y}return null}}}const sm=new Bp;class Ca{constructor(e){this.manager=void 0!==e?e:sm,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,s){const l=this;return new Promise(function(c,d){l.load(e,c,s,d)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Ca.DEFAULT_MATERIAL_NAME="__DEFAULT";const yu={};class J1 extends Error{constructor(e,s){super(e),this.response=s}}class La extends Ca{constructor(e){super(e)}load(e,s,l,c){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const d=Il.get(e);if(void 0!==d)return this.manager.itemStart(e),setTimeout(()=>{s&&s(d),this.manager.itemEnd(e)},0),d;if(void 0!==yu[e])return void yu[e].push({onLoad:s,onProgress:l,onError:c});yu[e]=[],yu[e].push({onLoad:s,onProgress:l,onError:c});const g=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),v=this.mimeType,x=this.responseType;fetch(g).then(w=>{if(200===w.status||0===w.status){if(0===w.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||void 0===w.body||void 0===w.body.getReader)return w;const S=yu[e],P=w.body.getReader(),z=w.headers.get("X-File-Size")||w.headers.get("Content-Length"),W=z?parseInt(z):0,Y=0!==W;let tt=0;const J=new ReadableStream({start(at){!function it(){P.read().then(({done:ct,value:At})=>{if(ct)at.close();else{tt+=At.byteLength;const Ft=new ProgressEvent("progress",{lengthComputable:Y,loaded:tt,total:W});for(let Tt=0,Pt=S.length;Tt<Pt;Tt++){const zt=S[Tt];zt.onProgress&&zt.onProgress(Ft)}at.enqueue(At),it()}})}()}});return new Response(J)}throw new J1(`fetch for "${w.url}" responded with ${w.status}: ${w.statusText}`,w)}).then(w=>{switch(x){case"arraybuffer":return w.arrayBuffer();case"blob":return w.blob();case"document":return w.text().then(S=>(new DOMParser).parseFromString(S,v));case"json":return w.json();default:if(void 0===v)return w.text();{const S=/charset="?([^;"\s]*)"?/i.exec(v),P=S&&S[1]?S[1].toLowerCase():void 0,z=new TextDecoder(P);return w.arrayBuffer().then(W=>z.decode(W))}}}).then(w=>{Il.add(e,w);const S=yu[e];delete yu[e];for(let P=0,z=S.length;P<z;P++){const W=S[P];W.onLoad&&W.onLoad(w)}}).catch(w=>{const S=yu[e];if(void 0===S)throw this.manager.itemError(e),w;delete yu[e];for(let P=0,z=S.length;P<z;P++){const W=S[P];W.onError&&W.onError(w)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Jb extends Ca{constructor(e){super(e)}load(e,s,l,c){const d=this,g=new La(this.manager);g.setPath(this.path),g.setRequestHeader(this.requestHeader),g.setWithCredentials(this.withCredentials),g.load(e,function(v){try{s(d.parse(JSON.parse(v)))}catch(x){c?c(x):console.error(x),d.manager.itemError(e)}},l,c)}parse(e){const s=[];for(let l=0;l<e.length;l++){const c=Rp.parse(e[l]);s.push(c)}return s}}class Z1 extends Ca{constructor(e){super(e)}load(e,s,l,c){const d=this,g=[],v=new Ea,x=new La(this.manager);x.setPath(this.path),x.setResponseType("arraybuffer"),x.setRequestHeader(this.requestHeader),x.setWithCredentials(d.withCredentials);let w=0;function S(P){x.load(e[P],function(z){const W=d.parse(z,!0);g[P]={width:W.width,height:W.height,format:W.format,mipmaps:W.mipmaps},w+=1,6===w&&(1===W.mipmapCount&&(v.minFilter=cn),v.image=g,v.format=W.format,v.needsUpdate=!0,s&&s(v))},l,c)}if(Array.isArray(e))for(let P=0,z=e.length;P<z;++P)S(P);else x.load(e,function(P){const z=d.parse(P,!0);if(z.isCubemap){const W=z.mipmaps.length/z.mipmapCount;for(let Y=0;Y<W;Y++){g[Y]={mipmaps:[]};for(let tt=0;tt<z.mipmapCount;tt++)g[Y].mipmaps.push(z.mipmaps[Y*z.mipmapCount+tt]),g[Y].format=z.format,g[Y].width=z.width,g[Y].height=z.height}v.image=g}else v.image.width=z.width,v.image.height=z.height,v.mipmaps=z.mipmaps;1===z.mipmapCount&&(v.minFilter=cn),v.format=z.format,v.needsUpdate=!0,s&&s(v)},l,c);return v}}class Np extends Ca{constructor(e){super(e)}load(e,s,l,c){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const d=this,g=Il.get(e);if(void 0!==g)return d.manager.itemStart(e),setTimeout(function(){s&&s(g),d.manager.itemEnd(e)},0),g;const v=Qc("img");function x(){S(),Il.add(e,this),s&&s(this),d.manager.itemEnd(e)}function w(P){S(),c&&c(P),d.manager.itemError(e),d.manager.itemEnd(e)}function S(){v.removeEventListener("load",x,!1),v.removeEventListener("error",w,!1)}return v.addEventListener("load",x,!1),v.addEventListener("error",w,!1),"data:"!==e.slice(0,5)&&void 0!==this.crossOrigin&&(v.crossOrigin=this.crossOrigin),d.manager.itemStart(e),v.src=e,v}}class Zb extends Ca{constructor(e){super(e)}load(e,s,l,c){const d=new vf;d.colorSpace=qi;const g=new Np(this.manager);g.setCrossOrigin(this.crossOrigin),g.setPath(this.path);let v=0;function x(w){g.load(e[w],function(S){d.images[w]=S,v++,6===v&&(d.needsUpdate=!0,s&&s(d))},void 0,c)}for(let w=0;w<e.length;++w)x(w);return d}}class tx extends Ca{constructor(e){super(e)}load(e,s,l,c){const d=this,g=new pu,v=new La(this.manager);return v.setResponseType("arraybuffer"),v.setRequestHeader(this.requestHeader),v.setPath(this.path),v.setWithCredentials(d.withCredentials),v.load(e,function(x){let w;try{w=d.parse(x)}catch(S){if(void 0===c)return void console.error(S);c(S)}void 0!==w.image?g.image=w.image:void 0!==w.data&&(g.image.width=w.width,g.image.height=w.height,g.image.data=w.data),g.wrapS=void 0!==w.wrapS?w.wrapS:Ut,g.wrapT=void 0!==w.wrapT?w.wrapT:Ut,g.magFilter=void 0!==w.magFilter?w.magFilter:cn,g.minFilter=void 0!==w.minFilter?w.minFilter:cn,g.anisotropy=void 0!==w.anisotropy?w.anisotropy:1,void 0!==w.colorSpace&&(g.colorSpace=w.colorSpace),void 0!==w.flipY&&(g.flipY=w.flipY),void 0!==w.format&&(g.format=w.format),void 0!==w.type&&(g.type=w.type),void 0!==w.mipmaps&&(g.mipmaps=w.mipmaps,g.minFilter=Sn),1===w.mipmapCount&&(g.minFilter=cn),void 0!==w.generateMipmaps&&(g.generateMipmaps=w.generateMipmaps),g.needsUpdate=!0,s&&s(g,w)},l,c),g}}class X0 extends Ca{constructor(e){super(e)}load(e,s,l,c){const d=new Vi,g=new Np(this.manager);return g.setCrossOrigin(this.crossOrigin),g.setPath(this.path),g.load(e,function(v){d.image=v,d.needsUpdate=!0,void 0!==s&&s(d)},l,c),d}}class ch extends hi{constructor(e,s=1){super(),this.isLight=!0,this.type="Light",this.color=new En(e),this.intensity=s}dispose(){}copy(e,s){return super.copy(e,s),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const s=super.toJSON(e);return s.object.color=this.color.getHex(),s.object.intensity=this.intensity,void 0!==this.groundColor&&(s.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(s.object.distance=this.distance),void 0!==this.angle&&(s.object.angle=this.angle),void 0!==this.decay&&(s.object.decay=this.decay),void 0!==this.penumbra&&(s.object.penumbra=this.penumbra),void 0!==this.shadow&&(s.object.shadow=this.shadow.toJSON()),s}}class Y0 extends ch{constructor(e,s,l){super(e,l),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(hi.DEFAULT_UP),this.updateMatrix(),this.groundColor=new En(s)}copy(e,s){return super.copy(e,s),this.groundColor.copy(e.groundColor),this}}const K0=new Yn,Ha=new Dt,Mc=new Dt;class J0{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ye(512,512),this.map=null,this.mapPass=null,this.matrix=new Yn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ra,this._frameExtents=new Ye(1,1),this._viewportCount=1,this._viewports=[new li(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const s=this.camera,l=this.matrix;Ha.setFromMatrixPosition(e.matrixWorld),s.position.copy(Ha),Mc.setFromMatrixPosition(e.target.matrixWorld),s.lookAt(Mc),s.updateMatrixWorld(),K0.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(K0),l.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),l.multiply(K0)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class ex extends J0{constructor(){super(new ea(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const s=this.camera,l=2*oc*e.angle*this.focus,c=this.mapSize.width/this.mapSize.height,d=e.distance||s.far;l===s.fov&&c===s.aspect&&d===s.far||(s.fov=l,s.aspect=c,s.far=d,s.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class Z0 extends ch{constructor(e,s,l=0,c=Math.PI/3,d=0,g=2){super(e,s),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(hi.DEFAULT_UP),this.updateMatrix(),this.target=new hi,this.distance=l,this.angle=c,this.penumbra=d,this.decay=g,this.map=null,this.shadow=new ex}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,s){return super.copy(e,s),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const tv=new Yn,am=new Dt,ty=new Dt;class nx extends J0{constructor(){super(new ea(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Ye(4,2),this._viewportCount=6,this._viewports=[new li(2,1,1,1),new li(0,1,1,1),new li(3,1,1,1),new li(1,1,1,1),new li(3,0,1,1),new li(1,0,1,1)],this._cubeDirections=[new Dt(1,0,0),new Dt(-1,0,0),new Dt(0,0,1),new Dt(0,0,-1),new Dt(0,1,0),new Dt(0,-1,0)],this._cubeUps=[new Dt(0,1,0),new Dt(0,1,0),new Dt(0,1,0),new Dt(0,1,0),new Dt(0,0,1),new Dt(0,0,-1)]}updateMatrices(e,s=0){const l=this.camera,c=this.matrix,d=e.distance||l.far;d!==l.far&&(l.far=d,l.updateProjectionMatrix()),am.setFromMatrixPosition(e.matrixWorld),l.position.copy(am),ty.copy(l.position),ty.add(this._cubeDirections[s]),l.up.copy(this._cubeUps[s]),l.lookAt(ty),l.updateMatrixWorld(),c.makeTranslation(-am.x,-am.y,-am.z),tv.multiplyMatrices(l.projectionMatrix,l.matrixWorldInverse),this._frustum.setFromProjectionMatrix(tv)}}class ey extends ch{constructor(e,s,l=0,c=2){super(e,s),this.isPointLight=!0,this.type="PointLight",this.distance=l,this.decay=c,this.shadow=new nx}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,s){return super.copy(e,s),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class rx extends J0{constructor(){super(new bf(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class ny extends ch{constructor(e,s){super(e,s),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(hi.DEFAULT_UP),this.updateMatrix(),this.target=new hi,this.shadow=new rx}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class ev extends ch{constructor(e,s){super(e,s),this.isAmbientLight=!0,this.type="AmbientLight"}}class nv extends ch{constructor(e,s,l=10,c=10){super(e,s),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=l,this.height=c}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const s=super.toJSON(e);return s.object.width=this.width,s.object.height=this.height,s}}class Dp{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Dt)}set(e){for(let s=0;s<9;s++)this.coefficients[s].copy(e[s]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,s){const l=e.x,c=e.y,d=e.z,g=this.coefficients;return s.copy(g[0]).multiplyScalar(.282095),s.addScaledVector(g[1],.488603*c),s.addScaledVector(g[2],.488603*d),s.addScaledVector(g[3],.488603*l),s.addScaledVector(g[4],l*c*1.092548),s.addScaledVector(g[5],c*d*1.092548),s.addScaledVector(g[6],.315392*(3*d*d-1)),s.addScaledVector(g[7],l*d*1.092548),s.addScaledVector(g[8],.546274*(l*l-c*c)),s}getIrradianceAt(e,s){const l=e.x,c=e.y,d=e.z,g=this.coefficients;return s.copy(g[0]).multiplyScalar(.886227),s.addScaledVector(g[1],1.023328*c),s.addScaledVector(g[2],1.023328*d),s.addScaledVector(g[3],1.023328*l),s.addScaledVector(g[4],.858086*l*c),s.addScaledVector(g[5],.858086*c*d),s.addScaledVector(g[6],.743125*d*d-.247708),s.addScaledVector(g[7],.858086*l*d),s.addScaledVector(g[8],.429043*(l*l-c*c)),s}add(e){for(let s=0;s<9;s++)this.coefficients[s].add(e.coefficients[s]);return this}addScaledSH(e,s){for(let l=0;l<9;l++)this.coefficients[l].addScaledVector(e.coefficients[l],s);return this}scale(e){for(let s=0;s<9;s++)this.coefficients[s].multiplyScalar(e);return this}lerp(e,s){for(let l=0;l<9;l++)this.coefficients[l].lerp(e.coefficients[l],s);return this}equals(e){for(let s=0;s<9;s++)if(!this.coefficients[s].equals(e.coefficients[s]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(e,s=0){const l=this.coefficients;for(let c=0;c<9;c++)l[c].fromArray(e,s+3*c);return this}toArray(e=[],s=0){const l=this.coefficients;for(let c=0;c<9;c++)l[c].toArray(e,s+3*c);return e}static getBasisAt(e,s){const l=e.x,c=e.y,d=e.z;s[0]=.282095,s[1]=.488603*c,s[2]=.488603*d,s[3]=.488603*l,s[4]=1.092548*l*c,s[5]=1.092548*c*d,s[6]=.315392*(3*d*d-1),s[7]=1.092548*l*d,s[8]=.546274*(l*l-c*c)}}class Gg extends ch{constructor(e=new Dp,s=1){super(void 0,s),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const s=super.toJSON(e);return s.object.sh=this.sh.toArray(),s}}class Qg extends Ca{constructor(e){super(e),this.textures={}}load(e,s,l,c){const d=this,g=new La(d.manager);g.setPath(d.path),g.setRequestHeader(d.requestHeader),g.setWithCredentials(d.withCredentials),g.load(e,function(v){try{s(d.parse(JSON.parse(v)))}catch(x){c?c(x):console.error(x),d.manager.itemError(e)}},l,c)}parse(e){const s=this.textures;function l(d){return void 0===s[d]&&console.warn("THREE.MaterialLoader: Undefined texture",d),s[d]}const c=Qg.createMaterialFromType(e.type);if(void 0!==e.uuid&&(c.uuid=e.uuid),void 0!==e.name&&(c.name=e.name),void 0!==e.color&&void 0!==c.color&&c.color.setHex(e.color),void 0!==e.roughness&&(c.roughness=e.roughness),void 0!==e.metalness&&(c.metalness=e.metalness),void 0!==e.sheen&&(c.sheen=e.sheen),void 0!==e.sheenColor&&(c.sheenColor=(new En).setHex(e.sheenColor)),void 0!==e.sheenRoughness&&(c.sheenRoughness=e.sheenRoughness),void 0!==e.emissive&&void 0!==c.emissive&&c.emissive.setHex(e.emissive),void 0!==e.specular&&void 0!==c.specular&&c.specular.setHex(e.specular),void 0!==e.specularIntensity&&(c.specularIntensity=e.specularIntensity),void 0!==e.specularColor&&void 0!==c.specularColor&&c.specularColor.setHex(e.specularColor),void 0!==e.shininess&&(c.shininess=e.shininess),void 0!==e.clearcoat&&(c.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(c.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.dispersion&&(c.dispersion=e.dispersion),void 0!==e.iridescence&&(c.iridescence=e.iridescence),void 0!==e.iridescenceIOR&&(c.iridescenceIOR=e.iridescenceIOR),void 0!==e.iridescenceThicknessRange&&(c.iridescenceThicknessRange=e.iridescenceThicknessRange),void 0!==e.transmission&&(c.transmission=e.transmission),void 0!==e.thickness&&(c.thickness=e.thickness),void 0!==e.attenuationDistance&&(c.attenuationDistance=e.attenuationDistance),void 0!==e.attenuationColor&&void 0!==c.attenuationColor&&c.attenuationColor.setHex(e.attenuationColor),void 0!==e.anisotropy&&(c.anisotropy=e.anisotropy),void 0!==e.anisotropyRotation&&(c.anisotropyRotation=e.anisotropyRotation),void 0!==e.fog&&(c.fog=e.fog),void 0!==e.flatShading&&(c.flatShading=e.flatShading),void 0!==e.blending&&(c.blending=e.blending),void 0!==e.combine&&(c.combine=e.combine),void 0!==e.side&&(c.side=e.side),void 0!==e.shadowSide&&(c.shadowSide=e.shadowSide),void 0!==e.opacity&&(c.opacity=e.opacity),void 0!==e.transparent&&(c.transparent=e.transparent),void 0!==e.alphaTest&&(c.alphaTest=e.alphaTest),void 0!==e.alphaHash&&(c.alphaHash=e.alphaHash),void 0!==e.depthFunc&&(c.depthFunc=e.depthFunc),void 0!==e.depthTest&&(c.depthTest=e.depthTest),void 0!==e.depthWrite&&(c.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(c.colorWrite=e.colorWrite),void 0!==e.blendSrc&&(c.blendSrc=e.blendSrc),void 0!==e.blendDst&&(c.blendDst=e.blendDst),void 0!==e.blendEquation&&(c.blendEquation=e.blendEquation),void 0!==e.blendSrcAlpha&&(c.blendSrcAlpha=e.blendSrcAlpha),void 0!==e.blendDstAlpha&&(c.blendDstAlpha=e.blendDstAlpha),void 0!==e.blendEquationAlpha&&(c.blendEquationAlpha=e.blendEquationAlpha),void 0!==e.blendColor&&void 0!==c.blendColor&&c.blendColor.setHex(e.blendColor),void 0!==e.blendAlpha&&(c.blendAlpha=e.blendAlpha),void 0!==e.stencilWriteMask&&(c.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(c.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(c.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(c.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(c.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(c.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(c.stencilZPass=e.stencilZPass),void 0!==e.stencilWrite&&(c.stencilWrite=e.stencilWrite),void 0!==e.wireframe&&(c.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(c.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(c.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(c.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(c.rotation=e.rotation),void 0!==e.linewidth&&(c.linewidth=e.linewidth),void 0!==e.dashSize&&(c.dashSize=e.dashSize),void 0!==e.gapSize&&(c.gapSize=e.gapSize),void 0!==e.scale&&(c.scale=e.scale),void 0!==e.polygonOffset&&(c.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(c.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(c.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.dithering&&(c.dithering=e.dithering),void 0!==e.alphaToCoverage&&(c.alphaToCoverage=e.alphaToCoverage),void 0!==e.premultipliedAlpha&&(c.premultipliedAlpha=e.premultipliedAlpha),void 0!==e.forceSinglePass&&(c.forceSinglePass=e.forceSinglePass),void 0!==e.visible&&(c.visible=e.visible),void 0!==e.toneMapped&&(c.toneMapped=e.toneMapped),void 0!==e.userData&&(c.userData=e.userData),void 0!==e.vertexColors&&(c.vertexColors="number"==typeof e.vertexColors?e.vertexColors>0:e.vertexColors),void 0!==e.uniforms)for(const d in e.uniforms){const g=e.uniforms[d];switch(c.uniforms[d]={},g.type){case"t":c.uniforms[d].value=l(g.value);break;case"c":c.uniforms[d].value=(new En).setHex(g.value);break;case"v2":c.uniforms[d].value=(new Ye).fromArray(g.value);break;case"v3":c.uniforms[d].value=(new Dt).fromArray(g.value);break;case"v4":c.uniforms[d].value=(new li).fromArray(g.value);break;case"m3":c.uniforms[d].value=(new yr).fromArray(g.value);break;case"m4":c.uniforms[d].value=(new Yn).fromArray(g.value);break;default:c.uniforms[d].value=g.value}}if(void 0!==e.defines&&(c.defines=e.defines),void 0!==e.vertexShader&&(c.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(c.fragmentShader=e.fragmentShader),void 0!==e.glslVersion&&(c.glslVersion=e.glslVersion),void 0!==e.extensions)for(const d in e.extensions)c.extensions[d]=e.extensions[d];if(void 0!==e.lights&&(c.lights=e.lights),void 0!==e.clipping&&(c.clipping=e.clipping),void 0!==e.size&&(c.size=e.size),void 0!==e.sizeAttenuation&&(c.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(c.map=l(e.map)),void 0!==e.matcap&&(c.matcap=l(e.matcap)),void 0!==e.alphaMap&&(c.alphaMap=l(e.alphaMap)),void 0!==e.bumpMap&&(c.bumpMap=l(e.bumpMap)),void 0!==e.bumpScale&&(c.bumpScale=e.bumpScale),void 0!==e.normalMap&&(c.normalMap=l(e.normalMap)),void 0!==e.normalMapType&&(c.normalMapType=e.normalMapType),void 0!==e.normalScale){let d=e.normalScale;!1===Array.isArray(d)&&(d=[d,d]),c.normalScale=(new Ye).fromArray(d)}return void 0!==e.displacementMap&&(c.displacementMap=l(e.displacementMap)),void 0!==e.displacementScale&&(c.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(c.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(c.roughnessMap=l(e.roughnessMap)),void 0!==e.metalnessMap&&(c.metalnessMap=l(e.metalnessMap)),void 0!==e.emissiveMap&&(c.emissiveMap=l(e.emissiveMap)),void 0!==e.emissiveIntensity&&(c.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(c.specularMap=l(e.specularMap)),void 0!==e.specularIntensityMap&&(c.specularIntensityMap=l(e.specularIntensityMap)),void 0!==e.specularColorMap&&(c.specularColorMap=l(e.specularColorMap)),void 0!==e.envMap&&(c.envMap=l(e.envMap)),void 0!==e.envMapRotation&&c.envMapRotation.fromArray(e.envMapRotation),void 0!==e.envMapIntensity&&(c.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(c.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(c.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(c.lightMap=l(e.lightMap)),void 0!==e.lightMapIntensity&&(c.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(c.aoMap=l(e.aoMap)),void 0!==e.aoMapIntensity&&(c.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(c.gradientMap=l(e.gradientMap)),void 0!==e.clearcoatMap&&(c.clearcoatMap=l(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(c.clearcoatRoughnessMap=l(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(c.clearcoatNormalMap=l(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(c.clearcoatNormalScale=(new Ye).fromArray(e.clearcoatNormalScale)),void 0!==e.iridescenceMap&&(c.iridescenceMap=l(e.iridescenceMap)),void 0!==e.iridescenceThicknessMap&&(c.iridescenceThicknessMap=l(e.iridescenceThicknessMap)),void 0!==e.transmissionMap&&(c.transmissionMap=l(e.transmissionMap)),void 0!==e.thicknessMap&&(c.thicknessMap=l(e.thicknessMap)),void 0!==e.anisotropyMap&&(c.anisotropyMap=l(e.anisotropyMap)),void 0!==e.sheenColorMap&&(c.sheenColorMap=l(e.sheenColorMap)),void 0!==e.sheenRoughnessMap&&(c.sheenRoughnessMap=l(e.sheenRoughnessMap)),c}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){return new{ShadowMaterial:W0,SpriteMaterial:Gr,RawShaderMaterial:Lg,ShaderMaterial:xl,PointsMaterial:wa,MeshPhysicalMaterial:rl,MeshStandardMaterial:kp,MeshPhongMaterial:em,MeshToonMaterial:Fg,MeshNormalMaterial:q1,MeshLambertMaterial:Og,MeshDepthMaterial:Wh,MeshDistanceMaterial:cu,MeshBasicMaterial:no,MeshMatcapMaterial:nm,LineDashedMaterial:rm,LineBasicMaterial:ls,Material:di}[e]}}class vu{static decodeText(e){if(typeof TextDecoder<"u")return(new TextDecoder).decode(e);let s="";for(let l=0,c=e.length;l<c;l++)s+=String.fromCharCode(e[l]);try{return decodeURIComponent(escape(s))}catch{return s}}static extractUrlBase(e){const s=e.lastIndexOf("/");return-1===s?"./":e.slice(0,s+1)}static resolveURL(e,s){return"string"!=typeof e||""===e?"":(/^https?:\/\//i.test(s)&&/^\//.test(e)&&(s=s.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:s+e)}}class rv extends gr{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class sl extends Ca{constructor(e){super(e)}load(e,s,l,c){const d=this,g=new La(d.manager);g.setPath(d.path),g.setRequestHeader(d.requestHeader),g.setWithCredentials(d.withCredentials),g.load(e,function(v){try{s(d.parse(JSON.parse(v)))}catch(x){c?c(x):console.error(x),d.manager.itemError(e)}},l,c)}parse(e){const s={},l={};function c(P,z){if(void 0!==s[z])return s[z];const W=P.interleavedBuffers[z],Y=function(at,it){if(void 0!==l[it])return l[it];const At=new Uint32Array(at.arrayBuffers[it]).buffer;return l[it]=At,At}(P,W.buffer),tt=Gc(W.type,Y),J=new Ku(tt,W.stride);return J.uuid=W.uuid,s[z]=J,J}const d=e.isInstancedBufferGeometry?new rv:new gr,g=e.data.index;if(void 0!==g){const P=Gc(g.type,g.array);d.setIndex(new wr(P,1))}const v=e.data.attributes;for(const P in v){const z=v[P];let W;if(z.isInterleavedBufferAttribute){const Y=c(e.data,z.data);W=new ba(Y,z.itemSize,z.offset,z.normalized)}else{const Y=Gc(z.type,z.array);W=new(z.isInstancedBufferAttribute?Jl:wr)(Y,z.itemSize,z.normalized)}void 0!==z.name&&(W.name=z.name),void 0!==z.usage&&W.setUsage(z.usage),d.setAttribute(P,W)}const x=e.data.morphAttributes;if(x)for(const P in x){const z=x[P],W=[];for(let Y=0,tt=z.length;Y<tt;Y++){const J=z[Y];let at;if(J.isInterleavedBufferAttribute){const it=c(e.data,J.data);at=new ba(it,J.itemSize,J.offset,J.normalized)}else{const it=Gc(J.type,J.array);at=new wr(it,J.itemSize,J.normalized)}void 0!==J.name&&(at.name=J.name),W.push(at)}d.morphAttributes[P]=W}e.data.morphTargetsRelative&&(d.morphTargetsRelative=!0);const w=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==w)for(let P=0,z=w.length;P!==z;++P){const W=w[P];d.addGroup(W.start,W.count,W.materialIndex)}const S=e.data.boundingSphere;if(void 0!==S){const P=new Dt;void 0!==S.center&&P.fromArray(S.center),d.boundingSphere=new Ls(P,S.radius)}return e.name&&(d.name=e.name),e.userData&&(d.userData=e.userData),d}}class iv extends Ca{constructor(e){super(e)}load(e,s,l,c){const d=this,g=""===this.path?vu.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||g;const v=new La(this.manager);v.setPath(this.path),v.setRequestHeader(this.requestHeader),v.setWithCredentials(this.withCredentials),v.load(e,function(x){let w=null;try{w=JSON.parse(x)}catch(P){return void 0!==c&&c(P),void console.error("THREE:ObjectLoader: Can't parse "+e+".",P.message)}const S=w.metadata;if(void 0===S||void 0===S.type||"geometry"===S.type.toLowerCase())return void 0!==c&&c(new Error("THREE.ObjectLoader: Can't load "+e)),void console.error("THREE.ObjectLoader: Can't load "+e);d.parse(w,s)},l,c)}async loadAsync(e,s){const l=""===this.path?vu.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||l;const c=new La(this.manager);c.setPath(this.path),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials);const d=await c.loadAsync(e,s),g=JSON.parse(d),v=g.metadata;if(void 0===v||void 0===v.type||"geometry"===v.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+e);return await this.parseAsync(g)}parse(e,s){const l=this.parseAnimations(e.animations),c=this.parseShapes(e.shapes),d=this.parseGeometries(e.geometries,c),g=this.parseImages(e.images,function(){void 0!==s&&s(w)}),v=this.parseTextures(e.textures,g),x=this.parseMaterials(e.materials,v),w=this.parseObject(e.object,d,x,v,l),S=this.parseSkeletons(e.skeletons,w);if(this.bindSkeletons(w,S),void 0!==s){let P=!1;for(const z in g)if(g[z].data instanceof HTMLImageElement){P=!0;break}!1===P&&s(w)}return w}async parseAsync(e){const s=this.parseAnimations(e.animations),l=this.parseShapes(e.shapes),c=this.parseGeometries(e.geometries,l),d=await this.parseImagesAsync(e.images),g=this.parseTextures(e.textures,d),v=this.parseMaterials(e.materials,g),x=this.parseObject(e.object,c,v,g,s),w=this.parseSkeletons(e.skeletons,x);return this.bindSkeletons(x,w),x}parseShapes(e){const s={};if(void 0!==e)for(let l=0,c=e.length;l<c;l++){const d=(new td).fromJSON(e[l]);s[d.uuid]=d}return s}parseSkeletons(e,s){const l={},c={};if(s.traverse(function(d){d.isBone&&(c[d.uuid]=d)}),void 0!==e)for(let d=0,g=e.length;d<g;d++){const v=(new Us).fromJSON(e[d],c);l[v.uuid]=v}return l}parseGeometries(e,s){const l={};if(void 0!==e){const c=new sl;for(let d=0,g=e.length;d<g;d++){let v;const x=e[d];switch(x.type){case"BufferGeometry":case"InstancedBufferGeometry":v=c.parse(x);break;case"Geometry":"THREE"in window&&"LegacyJSONLoader"in THREE?v=(new THREE.LegacyJSONLoader).parse(x,this.resourcePath).geometry:console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');break;default:x.type in j1?v=j1[x.type].fromJSON(x,s):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${x.type}"`)}v.uuid=x.uuid,void 0!==x.name&&(v.name=x.name),void 0!==x.userData&&(v.userData=x.userData),l[x.uuid]=v}}return l}parseMaterials(e,s){const l={},c={};if(void 0!==e){const d=new Qg;d.setTextures(s);for(let g=0,v=e.length;g<v;g++){const x=e[g];void 0===l[x.uuid]&&(l[x.uuid]=d.parse(x)),c[x.uuid]=l[x.uuid]}}return c}parseAnimations(e){const s={};if(void 0!==e)for(let l=0;l<e.length;l++){const d=Rp.parse(e[l]);s[d.uuid]=d}return s}parseImages(e,s){const l=this,c={};let d;function g(v){if("string"==typeof v){const x=v;return w=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(x)?x:l.resourcePath+x,l.manager.itemStart(w),d.load(w,function(){l.manager.itemEnd(w)},void 0,function(){l.manager.itemError(w),l.manager.itemEnd(w)})}var w;return v.data?{data:Gc(v.type,v.data),width:v.width,height:v.height}:null}if(void 0!==e&&e.length>0){const v=new Bp(s);d=new Np(v),d.setCrossOrigin(this.crossOrigin);for(let x=0,w=e.length;x<w;x++){const S=e[x],P=S.url;if(Array.isArray(P)){const z=[];for(let W=0,Y=P.length;W<Y;W++){const tt=g(P[W]);null!==tt&&(tt instanceof HTMLImageElement?z.push(tt):z.push(new pu(tt.data,tt.width,tt.height)))}c[S.uuid]=new fl(z)}else{const z=g(S.url);c[S.uuid]=new fl(z)}}}return c}async parseImagesAsync(e){const s=this,l={};let c;async function d(g){if("string"==typeof g){const v=g,x=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(v)?v:s.resourcePath+v;return await c.loadAsync(x)}return g.data?{data:Gc(g.type,g.data),width:g.width,height:g.height}:null}if(void 0!==e&&e.length>0){c=new Np(this.manager),c.setCrossOrigin(this.crossOrigin);for(let g=0,v=e.length;g<v;g++){const x=e[g],w=x.url;if(Array.isArray(w)){const S=[];for(let P=0,z=w.length;P<z;P++){const W=w[P],Y=await d(W);null!==Y&&(Y instanceof HTMLImageElement?S.push(Y):S.push(new pu(Y.data,Y.width,Y.height)))}l[x.uuid]=new fl(S)}else{const S=await d(x.url);l[x.uuid]=new fl(S)}}}return l}parseTextures(e,s){function l(d,g){return"number"==typeof d?d:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",d),g[d])}const c={};if(void 0!==e)for(let d=0,g=e.length;d<g;d++){const v=e[d];void 0===v.image&&console.warn('THREE.ObjectLoader: No "image" specified for',v.uuid),void 0===s[v.image]&&console.warn("THREE.ObjectLoader: Undefined image",v.image);const x=s[v.image],w=x.data;let S;Array.isArray(w)?(S=new vf,6===w.length&&(S.needsUpdate=!0)):(S=w&&w.data?new pu:new Vi,w&&(S.needsUpdate=!0)),S.source=x,S.uuid=v.uuid,void 0!==v.name&&(S.name=v.name),void 0!==v.mapping&&(S.mapping=l(v.mapping,ix)),void 0!==v.channel&&(S.channel=v.channel),void 0!==v.offset&&S.offset.fromArray(v.offset),void 0!==v.repeat&&S.repeat.fromArray(v.repeat),void 0!==v.center&&S.center.fromArray(v.center),void 0!==v.rotation&&(S.rotation=v.rotation),void 0!==v.wrap&&(S.wrapS=l(v.wrap[0],Lp),S.wrapT=l(v.wrap[1],Lp)),void 0!==v.format&&(S.format=v.format),void 0!==v.internalFormat&&(S.internalFormat=v.internalFormat),void 0!==v.type&&(S.type=v.type),void 0!==v.colorSpace&&(S.colorSpace=v.colorSpace),void 0!==v.minFilter&&(S.minFilter=l(v.minFilter,om)),void 0!==v.magFilter&&(S.magFilter=l(v.magFilter,om)),void 0!==v.anisotropy&&(S.anisotropy=v.anisotropy),void 0!==v.flipY&&(S.flipY=v.flipY),void 0!==v.generateMipmaps&&(S.generateMipmaps=v.generateMipmaps),void 0!==v.premultiplyAlpha&&(S.premultiplyAlpha=v.premultiplyAlpha),void 0!==v.unpackAlignment&&(S.unpackAlignment=v.unpackAlignment),void 0!==v.compareFunction&&(S.compareFunction=v.compareFunction),void 0!==v.userData&&(S.userData=v.userData),c[v.uuid]=S}return c}parseObject(e,s,l,c,d){let g,v,x;function w(z){return void 0===s[z]&&console.warn("THREE.ObjectLoader: Undefined geometry",z),s[z]}function S(z){if(void 0!==z){if(Array.isArray(z)){const W=[];for(let Y=0,tt=z.length;Y<tt;Y++){const J=z[Y];void 0===l[J]&&console.warn("THREE.ObjectLoader: Undefined material",J),W.push(l[J])}return W}return void 0===l[z]&&console.warn("THREE.ObjectLoader: Undefined material",z),l[z]}}function P(z){return void 0===c[z]&&console.warn("THREE.ObjectLoader: Undefined texture",z),c[z]}switch(e.type){case"Scene":g=new up,void 0!==e.background&&(g.background=Number.isInteger(e.background)?new En(e.background):P(e.background)),void 0!==e.environment&&(g.environment=P(e.environment)),void 0!==e.fog&&("Fog"===e.fog.type?g.fog=new le(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(g.fog=new va(e.fog.color,e.fog.density)),""!==e.fog.name&&(g.fog.name=e.fog.name)),void 0!==e.backgroundBlurriness&&(g.backgroundBlurriness=e.backgroundBlurriness),void 0!==e.backgroundIntensity&&(g.backgroundIntensity=e.backgroundIntensity),void 0!==e.backgroundRotation&&g.backgroundRotation.fromArray(e.backgroundRotation),void 0!==e.environmentIntensity&&(g.environmentIntensity=e.environmentIntensity),void 0!==e.environmentRotation&&g.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":g=new ea(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(g.focus=e.focus),void 0!==e.zoom&&(g.zoom=e.zoom),void 0!==e.filmGauge&&(g.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(g.filmOffset=e.filmOffset),void 0!==e.view&&(g.view=Object.assign({},e.view));break;case"OrthographicCamera":g=new bf(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(g.zoom=e.zoom),void 0!==e.view&&(g.view=Object.assign({},e.view));break;case"AmbientLight":g=new ev(e.color,e.intensity);break;case"DirectionalLight":g=new ny(e.color,e.intensity);break;case"PointLight":g=new ey(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":g=new nv(e.color,e.intensity,e.width,e.height);break;case"SpotLight":g=new Z0(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":g=new Y0(e.color,e.groundColor,e.intensity);break;case"LightProbe":g=(new Gg).fromJSON(e);break;case"SkinnedMesh":v=w(e.geometry),x=S(e.material),g=new Lf(v,x),void 0!==e.bindMode&&(g.bindMode=e.bindMode),void 0!==e.bindMatrix&&g.bindMatrix.fromArray(e.bindMatrix),void 0!==e.skeleton&&(g.skeleton=e.skeleton);break;case"Mesh":v=w(e.geometry),x=S(e.material),g=new os(v,x);break;case"InstancedMesh":v=w(e.geometry),x=S(e.material);const W=e.instanceMatrix,Y=e.instanceColor;g=new xo(v,x,e.count),g.instanceMatrix=new Jl(new Float32Array(W.array),16),void 0!==Y&&(g.instanceColor=new Jl(new Float32Array(Y.array),Y.itemSize));break;case"BatchedMesh":v=w(e.geometry),x=S(e.material),g=new Ji(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,x),g.geometry=v,g.perObjectFrustumCulled=e.perObjectFrustumCulled,g.sortObjects=e.sortObjects,g._drawRanges=e.drawRanges,g._reservedRanges=e.reservedRanges,g._visibility=e.visibility,g._active=e.active,g._bounds=e.bounds.map(tt=>{const J=new ta;J.min.fromArray(tt.boxMin),J.max.fromArray(tt.boxMax);const at=new Ls;return at.radius=tt.sphereRadius,at.center.fromArray(tt.sphereCenter),{boxInitialized:tt.boxInitialized,box:J,sphereInitialized:tt.sphereInitialized,sphere:at}}),g._maxGeometryCount=e.maxGeometryCount,g._maxVertexCount=e.maxVertexCount,g._maxIndexCount=e.maxIndexCount,g._geometryInitialized=e.geometryInitialized,g._geometryCount=e.geometryCount,g._matricesTexture=P(e.matricesTexture.uuid);break;case"LOD":g=new Bf;break;case"Line":g=new Ni(w(e.geometry),S(e.material));break;case"LineLoop":g=new zf(w(e.geometry),S(e.material));break;case"LineSegments":g=new Ai(w(e.geometry),S(e.material));break;case"PointCloud":case"Points":g=new nh(w(e.geometry),S(e.material));break;case"Sprite":g=new R0(S(e.material));break;case"Group":g=new tl;break;case"Bone":g=new du;break;default:g=new hi}if(g.uuid=e.uuid,void 0!==e.name&&(g.name=e.name),void 0!==e.matrix?(g.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(g.matrixAutoUpdate=e.matrixAutoUpdate),g.matrixAutoUpdate&&g.matrix.decompose(g.position,g.quaternion,g.scale)):(void 0!==e.position&&g.position.fromArray(e.position),void 0!==e.rotation&&g.rotation.fromArray(e.rotation),void 0!==e.quaternion&&g.quaternion.fromArray(e.quaternion),void 0!==e.scale&&g.scale.fromArray(e.scale)),void 0!==e.up&&g.up.fromArray(e.up),void 0!==e.castShadow&&(g.castShadow=e.castShadow),void 0!==e.receiveShadow&&(g.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(g.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(g.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(g.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&g.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(g.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(g.visible=e.visible),void 0!==e.frustumCulled&&(g.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(g.renderOrder=e.renderOrder),void 0!==e.userData&&(g.userData=e.userData),void 0!==e.layers&&(g.layers.mask=e.layers),void 0!==e.children){const z=e.children;for(let W=0;W<z.length;W++)g.add(this.parseObject(z[W],s,l,c,d))}if(void 0!==e.animations){const z=e.animations;for(let W=0;W<z.length;W++)g.animations.push(d[z[W]])}if("LOD"===e.type){void 0!==e.autoUpdate&&(g.autoUpdate=e.autoUpdate);const z=e.levels;for(let W=0;W<z.length;W++){const Y=z[W],tt=g.getObjectByProperty("uuid",Y.object);void 0!==tt&&g.addLevel(tt,Y.distance,Y.hysteresis)}}return g}bindSkeletons(e,s){0!==Object.keys(s).length&&e.traverse(function(l){if(!0===l.isSkinnedMesh&&void 0!==l.skeleton){const c=s[l.skeleton];void 0===c?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",l.skeleton):l.bind(c,l.bindMatrix)}})}}const ix={UVMapping:Hr,CubeReflectionMapping:Wr,CubeRefractionMapping:ii,EquirectangularReflectionMapping:mo,EquirectangularRefractionMapping:si,CubeUVReflectionMapping:lr},Lp={RepeatWrapping:ki,ClampToEdgeWrapping:Ut,MirroredRepeatWrapping:jt},om={NearestFilter:be,NearestMipmapNearestFilter:Ze,NearestMipmapLinearFilter:ke,LinearFilter:cn,LinearMipmapNearestFilter:bn,LinearMipmapLinearFilter:Sn};class uh extends Ca{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,s,l,c){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const d=this,g=Il.get(e);if(void 0!==g)return d.manager.itemStart(e),g.then?void g.then(w=>{s&&s(w),d.manager.itemEnd(e)}).catch(w=>{c&&c(w)}):(setTimeout(function(){s&&s(g),d.manager.itemEnd(e)},0),g);const v={};v.credentials="anonymous"===this.crossOrigin?"same-origin":"include",v.headers=this.requestHeader;const x=fetch(e,v).then(function(w){return w.blob()}).then(function(w){return createImageBitmap(w,Object.assign(d.options,{colorSpaceConversion:"none"}))}).then(function(w){return Il.add(e,w),s&&s(w),d.manager.itemEnd(e),w}).catch(function(w){c&&c(w),Il.remove(e),d.manager.itemError(e),d.manager.itemEnd(e)});Il.add(e,x),d.manager.itemStart(e)}}let Hg;class Wg{static getContext(){return void 0===Hg&&(Hg=new(window.AudioContext||window.webkitAudioContext)),Hg}static setContext(e){Hg=e}}class ry extends Ca{constructor(e){super(e)}load(e,s,l,c){const d=this,g=new La(this.manager);function v(x){c?c(x):console.error(x),d.manager.itemError(e)}g.setResponseType("arraybuffer"),g.setPath(this.path),g.setRequestHeader(this.requestHeader),g.setWithCredentials(this.withCredentials),g.load(e,function(x){try{const w=x.slice(0);Wg.getContext().decodeAudioData(w,function(S){s(S)}).catch(v)}catch(w){v(w)}},l,c)}}const ec=new Yn,jg=new Yn,Tc=new Yn;class iy{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ea,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ea,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const s=this._cache;if(s.focus!==e.focus||s.fov!==e.fov||s.aspect!==e.aspect*this.aspect||s.near!==e.near||s.far!==e.far||s.zoom!==e.zoom||s.eyeSep!==this.eyeSep){s.focus=e.focus,s.fov=e.fov,s.aspect=e.aspect*this.aspect,s.near=e.near,s.far=e.far,s.zoom=e.zoom,s.eyeSep=this.eyeSep,Tc.copy(e.projectionMatrix);const l=s.eyeSep/2,c=l*s.near/s.focus,d=s.near*Math.tan(zl*s.fov*.5)/s.zoom;let g,v;jg.elements[12]=-l,ec.elements[12]=l,g=-d*s.aspect+c,v=d*s.aspect+c,Tc.elements[0]=2*s.near/(v-g),Tc.elements[8]=(v+g)/(v-g),this.cameraL.projectionMatrix.copy(Tc),g=-d*s.aspect-c,v=d*s.aspect-c,Tc.elements[0]=2*s.near/(v-g),Tc.elements[8]=(v+g)/(v-g),this.cameraR.projectionMatrix.copy(Tc)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(jg),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(ec)}}class Fp{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Op(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const s=Op();e=(s-this.oldTime)/1e3,this.oldTime=s,this.elapsedTime+=e}return e}}function Op(){return(typeof performance>"u"?Date:performance).now()}const nc=new Dt,qg=new _s,sy=new Dt,_c=new Dt;class Xg extends hi{constructor(){super(),this.type="AudioListener",this.context=Wg.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Fp}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const s=this.context.listener,l=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(nc,qg,sy),_c.set(0,0,-1).applyQuaternion(qg),s.positionX){const c=this.context.currentTime+this.timeDelta;s.positionX.linearRampToValueAtTime(nc.x,c),s.positionY.linearRampToValueAtTime(nc.y,c),s.positionZ.linearRampToValueAtTime(nc.z,c),s.forwardX.linearRampToValueAtTime(_c.x,c),s.forwardY.linearRampToValueAtTime(_c.y,c),s.forwardZ.linearRampToValueAtTime(_c.z,c),s.upX.linearRampToValueAtTime(l.x,c),s.upY.linearRampToValueAtTime(l.y,c),s.upZ.linearRampToValueAtTime(l.z,c)}else s.setPosition(nc.x,nc.y,nc.z),s.setOrientation(_c.x,_c.y,_c.z,l.x,l.y,l.z)}}class Yg extends hi{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const s=this.context.createBufferSource();return s.buffer=this.buffer,s.loop=this.loop,s.loopStart=this.loopStart,s.loopEnd=this.loopEnd,s.onended=this.onEnded.bind(this),s.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=s,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,null!==this.source&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,s=this.filters.length;e<s;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(!1!==this._connected){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,s=this.filters.length;e<s;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),!0===this._connected?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,!0===this.isPlaying&&void 0!==this.source.detune&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const bu=new Dt,Kg=new _s,ay=new Dt,xu=new Dt;class oy extends Yg{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,s,l){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=s,this.panner.coneOuterGain=l,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(bu,Kg,ay),xu.set(0,0,1).applyQuaternion(Kg);const s=this.panner;if(s.positionX){const l=this.context.currentTime+this.listener.timeDelta;s.positionX.linearRampToValueAtTime(bu.x,l),s.positionY.linearRampToValueAtTime(bu.y,l),s.positionZ.linearRampToValueAtTime(bu.z,l),s.orientationX.linearRampToValueAtTime(xu.x,l),s.orientationY.linearRampToValueAtTime(xu.y,l),s.orientationZ.linearRampToValueAtTime(xu.z,l)}else s.setPosition(bu.x,bu.y,bu.z),s.setOrientation(xu.x,xu.y,xu.z)}}class wu{constructor(e,s=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=s,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const s=this.getFrequencyData();for(let l=0;l<s.length;l++)e+=s[l];return e/s.length}}class ly{constructor(e,s,l){let c,d,g;switch(this.binding=e,this.valueSize=l,s){case"quaternion":c=this._slerp,d=this._slerpAdditive,g=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*l),this._workIndex=5;break;case"string":case"bool":c=this._select,d=this._select,g=this._setAdditiveIdentityOther,this.buffer=new Array(5*l);break;default:c=this._lerp,d=this._lerpAdditive,g=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*l)}this._mixBufferRegion=c,this._mixBufferRegionAdditive=d,this._setIdentity=g,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,s){const l=this.buffer,c=this.valueSize,d=e*c+c;let g=this.cumulativeWeight;if(0===g){for(let v=0;v!==c;++v)l[d+v]=l[v];g=s}else g+=s,this._mixBufferRegion(l,d,0,s/g,c);this.cumulativeWeight=g}accumulateAdditive(e){const s=this.buffer,l=this.valueSize,c=l*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(s,c,0,e,l),this.cumulativeWeightAdditive+=e}apply(e){const s=this.valueSize,l=this.buffer,c=e*s+s,d=this.cumulativeWeight,g=this.cumulativeWeightAdditive,v=this.binding;this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,d<1&&this._mixBufferRegion(l,c,s*this._origIndex,1-d,s),g>0&&this._mixBufferRegionAdditive(l,c,this._addIndex*s,1,s);for(let x=s,w=s+s;x!==w;++x)if(l[x]!==l[x+s]){v.setValue(l,c);break}}saveOriginalState(){const s=this.buffer,l=this.valueSize,c=l*this._origIndex;this.binding.getValue(s,c);for(let d=l,g=c;d!==g;++d)s[d]=s[c+d%l];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){this.binding.setValue(this.buffer,3*this.valueSize)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,s=e+this.valueSize;for(let l=e;l<s;l++)this.buffer[l]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,s=this._addIndex*this.valueSize;for(let l=0;l<this.valueSize;l++)this.buffer[s+l]=this.buffer[e+l]}_select(e,s,l,c,d){if(c>=.5)for(let g=0;g!==d;++g)e[s+g]=e[l+g]}_slerp(e,s,l,c){_s.slerpFlat(e,s,e,s,e,l,c)}_slerpAdditive(e,s,l,c,d){const g=this._workIndex*d;_s.multiplyQuaternionsFlat(e,g,e,s,e,l),_s.slerpFlat(e,s,e,s,e,g,c)}_lerp(e,s,l,c,d){const g=1-c;for(let v=0;v!==d;++v){const x=s+v;e[x]=e[x]*g+e[l+v]*c}}_lerpAdditive(e,s,l,c,d){for(let g=0;g!==d;++g){const v=s+g;e[v]=e[v]+e[l+g]*c}}}const Jg="\\[\\]\\.:\\/",sv=new RegExp("["+Jg+"]","g"),lm="[^"+Jg+"]",av="[^"+Jg.replace("\\.","")+"]",ov=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",lm)+/(WCOD+)?/.source.replace("WCOD",av)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",lm)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",lm)+"$"),lv=["material","materials","bones","map"];class pi{constructor(e,s,l){this.path=s,this.parsedPath=l||pi.parseTrackName(s),this.node=pi.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,s,l){return e&&e.isAnimationObjectGroup?new pi.Composite(e,s,l):new pi(e,s,l)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(sv,"")}static parseTrackName(e){const s=ov.exec(e);if(null===s)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const l={nodeName:s[2],objectName:s[3],objectIndex:s[4],propertyName:s[5],propertyIndex:s[6]},c=l.nodeName&&l.nodeName.lastIndexOf(".");if(void 0!==c&&-1!==c){const d=l.nodeName.substring(c+1);-1!==lv.indexOf(d)&&(l.nodeName=l.nodeName.substring(0,c),l.objectName=d)}if(null===l.propertyName||0===l.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return l}static findNode(e,s){if(void 0===s||""===s||"."===s||-1===s||s===e.name||s===e.uuid)return e;if(e.skeleton){const l=e.skeleton.getBoneByName(s);if(void 0!==l)return l}if(e.children){const l=function(d){for(let g=0;g<d.length;g++){const v=d[g];if(v.name===s||v.uuid===s)return v;const x=l(v.children);if(x)return x}return null},c=l(e.children);if(c)return c}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,s){e[s]=this.targetObject[this.propertyName]}_getValue_array(e,s){const l=this.resolvedProperty;for(let c=0,d=l.length;c!==d;++c)e[s++]=l[c]}_getValue_arrayElement(e,s){e[s]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,s){this.resolvedProperty.toArray(e,s)}_setValue_direct(e,s){this.targetObject[this.propertyName]=e[s]}_setValue_direct_setNeedsUpdate(e,s){this.targetObject[this.propertyName]=e[s],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,s){this.targetObject[this.propertyName]=e[s],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,s){const l=this.resolvedProperty;for(let c=0,d=l.length;c!==d;++c)l[c]=e[s++]}_setValue_array_setNeedsUpdate(e,s){const l=this.resolvedProperty;for(let c=0,d=l.length;c!==d;++c)l[c]=e[s++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,s){const l=this.resolvedProperty;for(let c=0,d=l.length;c!==d;++c)l[c]=e[s++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,s){this.resolvedProperty[this.propertyIndex]=e[s]}_setValue_arrayElement_setNeedsUpdate(e,s){this.resolvedProperty[this.propertyIndex]=e[s],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,s){this.resolvedProperty[this.propertyIndex]=e[s],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,s){this.resolvedProperty.fromArray(e,s)}_setValue_fromArray_setNeedsUpdate(e,s){this.resolvedProperty.fromArray(e,s),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,s){this.resolvedProperty.fromArray(e,s),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,s){this.bind(),this.getValue(e,s)}_setValue_unbound(e,s){this.bind(),this.setValue(e,s)}bind(){let e=this.node;const s=this.parsedPath,l=s.objectName,c=s.propertyName;let d=s.propertyIndex;if(e||(e=pi.findNode(this.rootNode,s.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");if(l){let w=s.objectIndex;switch(l){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let S=0;S<e.length;S++)if(e[S].name===w){w=S;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);e=e.material.map;break;default:if(void 0===e[l])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[l]}if(void 0!==w){if(void 0===e[w])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[w]}}const g=e[c];if(void 0===g)return void console.error("THREE.PropertyBinding: Trying to update property for track: "+s.nodeName+"."+c+" but it wasn't found.",e);let v=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?v=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(v=this.Versioning.MatrixWorldNeedsUpdate);let x=this.BindingType.Direct;if(void 0!==d){if("morphTargetInfluences"===c){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[d]&&(d=e.morphTargetDictionary[d])}x=this.BindingType.ArrayElement,this.resolvedProperty=g,this.propertyIndex=d}else void 0!==g.fromArray&&void 0!==g.toArray?(x=this.BindingType.HasFromToArray,this.resolvedProperty=g):Array.isArray(g)?(x=this.BindingType.EntireArray,this.resolvedProperty=g):this.propertyName=c;this.getValue=this.GetterByBindingType[x],this.setValue=this.SetterByBindingTypeAndVersioning[x][v]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}pi.Composite=class{constructor(A,e,s){const l=s||pi.parseTrackName(e);this._targetGroup=A,this._bindings=A.subscribe_(e,l)}getValue(A,e){this.bind();const l=this._bindings[this._targetGroup.nCachedObjects_];void 0!==l&&l.getValue(A,e)}setValue(A,e){const s=this._bindings;for(let l=this._targetGroup.nCachedObjects_,c=s.length;l!==c;++l)s[l].setValue(A,e)}bind(){const A=this._bindings;for(let e=this._targetGroup.nCachedObjects_,s=A.length;e!==s;++e)A[e].bind()}unbind(){const A=this._bindings;for(let e=this._targetGroup.nCachedObjects_,s=A.length;e!==s;++e)A[e].unbind()}},pi.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},pi.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},pi.prototype.GetterByBindingType=[pi.prototype._getValue_direct,pi.prototype._getValue_array,pi.prototype._getValue_arrayElement,pi.prototype._getValue_toArray],pi.prototype.SetterByBindingTypeAndVersioning=[[pi.prototype._setValue_direct,pi.prototype._setValue_direct_setNeedsUpdate,pi.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[pi.prototype._setValue_array,pi.prototype._setValue_array_setNeedsUpdate,pi.prototype._setValue_array_setMatrixWorldNeedsUpdate],[pi.prototype._setValue_arrayElement,pi.prototype._setValue_arrayElement_setNeedsUpdate,pi.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[pi.prototype._setValue_fromArray,pi.prototype._setValue_fromArray_setNeedsUpdate,pi.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class cy{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Ua(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let l=0,c=arguments.length;l!==c;++l)e[arguments[l].uuid]=l;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const s=this;this.stats={objects:{get total(){return s._objects.length},get inUse(){return this.total-s.nCachedObjects_}},get bindingsPerObject(){return s._bindings.length}}}add(){const e=this._objects,s=this._indicesByUUID,l=this._paths,c=this._parsedPaths,d=this._bindings,g=d.length;let v,x=e.length,w=this.nCachedObjects_;for(let S=0,P=arguments.length;S!==P;++S){const z=arguments[S],W=z.uuid;let Y=s[W];if(void 0===Y){Y=x++,s[W]=Y,e.push(z);for(let tt=0,J=g;tt!==J;++tt)d[tt].push(new pi(z,l[tt],c[tt]))}else if(Y<w){v=e[Y];const tt=--w,J=e[tt];s[J.uuid]=Y,e[Y]=J,s[W]=tt,e[tt]=z;for(let at=0,it=g;at!==it;++at){const ct=d[at];let Ft=ct[Y];ct[Y]=ct[tt],void 0===Ft&&(Ft=new pi(z,l[at],c[at])),ct[tt]=Ft}}else e[Y]!==v&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=w}remove(){const e=this._objects,s=this._indicesByUUID,l=this._bindings,c=l.length;let d=this.nCachedObjects_;for(let g=0,v=arguments.length;g!==v;++g){const x=arguments[g],w=x.uuid,S=s[w];if(void 0!==S&&S>=d){const P=d++,z=e[P];s[z.uuid]=S,e[S]=z,s[w]=P,e[P]=x;for(let W=0,Y=c;W!==Y;++W){const tt=l[W],at=tt[S];tt[S]=tt[P],tt[P]=at}}}this.nCachedObjects_=d}uncache(){const e=this._objects,s=this._indicesByUUID,l=this._bindings,c=l.length;let d=this.nCachedObjects_,g=e.length;for(let v=0,x=arguments.length;v!==x;++v){const w=arguments[v].uuid,S=s[w];if(void 0!==S)if(delete s[w],S<d){const P=--d,z=e[P],W=--g,Y=e[W];s[z.uuid]=S,e[S]=z,s[Y.uuid]=P,e[P]=Y,e.pop();for(let tt=0,J=c;tt!==J;++tt){const at=l[tt],ct=at[W];at[S]=at[P],at[P]=ct,at.pop()}}else{const P=--g,z=e[P];P>0&&(s[z.uuid]=S),e[S]=z,e.pop();for(let W=0,Y=c;W!==Y;++W){const tt=l[W];tt[S]=tt[P],tt.pop()}}}this.nCachedObjects_=d}subscribe_(e,s){const l=this._bindingsIndicesByPath;let c=l[e];const d=this._bindings;if(void 0!==c)return d[c];const g=this._paths,v=this._parsedPaths,x=this._objects,S=this.nCachedObjects_,P=new Array(x.length);c=d.length,l[e]=c,g.push(e),v.push(s),d.push(P);for(let z=S,W=x.length;z!==W;++z)P[z]=new pi(x[z],e,s);return P}unsubscribe_(e){const s=this._bindingsIndicesByPath,l=s[e];if(void 0!==l){const c=this._paths,d=this._parsedPaths,g=this._bindings,v=g.length-1,x=g[v];s[e[v]]=l,g[l]=x,g.pop(),d[l]=d[v],d.pop(),c[l]=c[v],c.pop()}}}class Zg{constructor(e,s,l=null,c=s.blendMode){this._mixer=e,this._clip=s,this._localRoot=l,this.blendMode=c;const d=s.tracks,g=d.length,v=new Array(g),x={endingStart:Ja,endingEnd:Ja};for(let w=0;w!==g;++w){const S=d[w].createInterpolant(null);v[w]=S,S.settings=x}this._interpolantSettings=x,this._interpolants=v,this._propertyBindings=new Array(g),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=hs,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,s){return this.loop=e,this.repetitions=s,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,s,l){if(e.fadeOut(s),this.fadeIn(s),l){const c=this._clip.duration,d=e._clip.duration,v=c/d;e.warp(1,d/c,s),this.warp(v,1,s)}return this}crossFadeTo(e,s,l){return e.crossFadeFrom(this,s,l)}stopFading(){const e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,s,l){const c=this._mixer,d=c.time,g=this.timeScale;let v=this._timeScaleInterpolant;null===v&&(v=c._lendControlInterpolant(),this._timeScaleInterpolant=v);const x=v.parameterPositions,w=v.sampleValues;return x[0]=d,x[1]=d+l,w[0]=e/g,w[1]=s/g,this}stopWarping(){const e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,s,l,c){if(!this.enabled)return void this._updateWeight(e);const d=this._startTime;if(null!==d){const x=(e-d)*l;x<0||0===l?s=0:(this._startTime=null,s=l*x)}s*=this._updateTimeScale(e);const g=this._updateTime(s),v=this._updateWeight(e);if(v>0){const x=this._interpolants,w=this._propertyBindings;if(this.blendMode===dl)for(let S=0,P=x.length;S!==P;++S)x[S].evaluate(g),w[S].accumulateAdditive(v);else for(let S=0,P=x.length;S!==P;++S)x[S].evaluate(g),w[S].accumulate(c,v)}}_updateWeight(e){let s=0;if(this.enabled){s=this.weight;const l=this._weightInterpolant;if(null!==l){const c=l.evaluate(e)[0];s*=c,e>l.parameterPositions[1]&&(this.stopFading(),0===c&&(this.enabled=!1))}}return this._effectiveWeight=s,s}_updateTimeScale(e){let s=0;if(!this.paused){s=this.timeScale;const l=this._timeScaleInterpolant;null!==l&&(s*=l.evaluate(e)[0],e>l.parameterPositions[1]&&(this.stopWarping(),0===s?this.paused=!0:this.timeScale=s))}return this._effectiveTimeScale=s,s}_updateTime(e){const s=this._clip.duration,l=this.loop;let c=this.time+e,d=this._loopCount;const g=l===ds;if(0===e)return-1===d||!g||1&~d?c:s-c;if(l===Js){-1===d&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(c>=s)c=s;else{if(!(c<0)){this.time=c;break t}c=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=c,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===d&&(e>=0?(d=0,this._setEndings(!0,0===this.repetitions,g)):this._setEndings(0===this.repetitions,!0,g)),c>=s||c<0){const v=Math.floor(c/s);c-=s*v,d+=Math.abs(v);const x=this.repetitions-d;if(x<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,c=e>0?s:0,this.time=c,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===x){const w=e<0;this._setEndings(w,!w,g)}else this._setEndings(!1,!1,g);this._loopCount=d,this.time=c,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:v})}}else this.time=c;if(g&&!(1&~d))return s-c}return c}_setEndings(e,s,l){const c=this._interpolantSettings;l?(c.endingStart=Za,c.endingEnd=Za):(c.endingStart=e?this.zeroSlopeAtStart?Za:Ja:Ao,c.endingEnd=s?this.zeroSlopeAtEnd?Za:Ja:Ao)}_scheduleFading(e,s,l){const c=this._mixer,d=c.time;let g=this._weightInterpolant;null===g&&(g=c._lendControlInterpolant(),this._weightInterpolant=g);const v=g.parameterPositions,x=g.sampleValues;return v[0]=d,x[0]=s,v[1]=d+e,x[1]=l,this}}const uy=new Float32Array(1);class hy extends to{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,s){const l=e._localRoot||this._root,c=e._clip.tracks,d=c.length,g=e._propertyBindings,v=e._interpolants,x=l.uuid,w=this._bindingsByRootAndName;let S=w[x];void 0===S&&(S={},w[x]=S);for(let P=0;P!==d;++P){const z=c[P],W=z.name;let Y=S[W];if(void 0!==Y)++Y.referenceCount,g[P]=Y;else{if(Y=g[P],void 0!==Y){null===Y._cacheIndex&&(++Y.referenceCount,this._addInactiveBinding(Y,x,W));continue}Y=new ly(pi.create(l,W,s&&s._propertyBindings[P].binding.parsedPath),z.ValueTypeName,z.getValueSize()),++Y.referenceCount,this._addInactiveBinding(Y,x,W),g[P]=Y}v[P].resultBuffer=Y.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const l=(e._localRoot||this._root).uuid,c=e._clip.uuid,d=this._actionsByClip[c];this._bindAction(e,d&&d.knownActions[0]),this._addInactiveAction(e,c,l)}const s=e._propertyBindings;for(let l=0,c=s.length;l!==c;++l){const d=s[l];0==d.useCount++&&(this._lendBinding(d),d.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const s=e._propertyBindings;for(let l=0,c=s.length;l!==c;++l){const d=s[l];0==--d.useCount&&(d.restoreOriginalState(),this._takeBackBinding(d))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const s=e._cacheIndex;return null!==s&&s<this._nActiveActions}_addInactiveAction(e,s,l){const c=this._actions,d=this._actionsByClip;let g=d[s];if(void 0===g)g={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,d[s]=g;else{const v=g.knownActions;e._byClipCacheIndex=v.length,v.push(e)}e._cacheIndex=c.length,c.push(e),g.actionByRoot[l]=e}_removeInactiveAction(e){const s=this._actions,l=s[s.length-1],c=e._cacheIndex;l._cacheIndex=c,s[c]=l,s.pop(),e._cacheIndex=null;const d=e._clip.uuid,g=this._actionsByClip,v=g[d],x=v.knownActions,w=x[x.length-1],S=e._byClipCacheIndex;w._byClipCacheIndex=S,x[S]=w,x.pop(),e._byClipCacheIndex=null,delete v.actionByRoot[(e._localRoot||this._root).uuid],0===x.length&&delete g[d],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const s=e._propertyBindings;for(let l=0,c=s.length;l!==c;++l){const d=s[l];0==--d.referenceCount&&this._removeInactiveBinding(d)}}_lendAction(e){const s=this._actions,l=e._cacheIndex,c=this._nActiveActions++,d=s[c];e._cacheIndex=c,s[c]=e,d._cacheIndex=l,s[l]=d}_takeBackAction(e){const s=this._actions,l=e._cacheIndex,c=--this._nActiveActions,d=s[c];e._cacheIndex=c,s[c]=e,d._cacheIndex=l,s[l]=d}_addInactiveBinding(e,s,l){const c=this._bindingsByRootAndName,d=this._bindings;let g=c[s];void 0===g&&(g={},c[s]=g),g[l]=e,e._cacheIndex=d.length,d.push(e)}_removeInactiveBinding(e){const s=this._bindings,l=e.binding,c=l.rootNode.uuid,d=l.path,g=this._bindingsByRootAndName,v=g[c],x=s[s.length-1],w=e._cacheIndex;x._cacheIndex=w,s[w]=x,s.pop(),delete v[d],0===Object.keys(v).length&&delete g[c]}_lendBinding(e){const s=this._bindings,l=e._cacheIndex,c=this._nActiveBindings++,d=s[c];e._cacheIndex=c,s[c]=e,d._cacheIndex=l,s[l]=d}_takeBackBinding(e){const s=this._bindings,l=e._cacheIndex,c=--this._nActiveBindings,d=s[c];e._cacheIndex=c,s[c]=e,d._cacheIndex=l,s[l]=d}_lendControlInterpolant(){const e=this._controlInterpolants,s=this._nActiveControlInterpolants++;let l=e[s];return void 0===l&&(l=new $g(new Float32Array(2),new Float32Array(2),1,uy),l.__cacheIndex=s,e[s]=l),l}_takeBackControlInterpolant(e){const s=this._controlInterpolants,l=e.__cacheIndex,c=--this._nActiveControlInterpolants,d=s[c];e.__cacheIndex=c,s[c]=e,d.__cacheIndex=l,s[l]=d}clipAction(e,s,l){const c=s||this._root,d=c.uuid;let g="string"==typeof e?Rp.findByName(c,e):e;const v=null!==g?g.uuid:e,x=this._actionsByClip[v];let w=null;if(void 0===l&&(l=null!==g?g.blendMode:hl),void 0!==x){const P=x.actionByRoot[d];if(void 0!==P&&P.blendMode===l)return P;w=x.knownActions[0],null===g&&(g=w._clip)}if(null===g)return null;const S=new Zg(this,g,s,l);return this._bindAction(S,w),this._addInactiveAction(S,v,d),S}existingAction(e,s){const l=s||this._root,c=l.uuid,d="string"==typeof e?Rp.findByName(l,e):e,v=this._actionsByClip[d?d.uuid:e];return void 0!==v&&v.actionByRoot[c]||null}stopAllAction(){const e=this._actions;for(let s=this._nActiveActions-1;s>=0;--s)e[s].stop();return this}update(e){const s=this._actions,l=this._nActiveActions,c=this.time+=e*=this.timeScale,d=Math.sign(e),g=this._accuIndex^=1;for(let w=0;w!==l;++w)s[w]._update(c,e,d,g);const v=this._bindings,x=this._nActiveBindings;for(let w=0;w!==x;++w)v[w].apply(g);return this}setTime(e){this.time=0;for(let s=0;s<this._actions.length;s++)this._actions[s].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const s=this._actions,l=e.uuid,c=this._actionsByClip,d=c[l];if(void 0!==d){const g=d.knownActions;for(let v=0,x=g.length;v!==x;++v){const w=g[v];this._deactivateAction(w);const S=w._cacheIndex,P=s[s.length-1];w._cacheIndex=null,w._byClipCacheIndex=null,P._cacheIndex=S,s[S]=P,s.pop(),this._removeInactiveBindingsForAction(w)}delete c[l]}}uncacheRoot(e){const s=e.uuid,l=this._actionsByClip;for(const d in l){const g=l[d].actionByRoot[s];void 0!==g&&(this._deactivateAction(g),this._removeInactiveAction(g))}const c=this._bindingsByRootAndName[s];if(void 0!==c)for(const d in c){const g=c[d];g.restoreOriginalState(),this._removeInactiveBinding(g)}}uncacheAction(e,s){const l=this.existingAction(e,s);null!==l&&(this._deactivateAction(l),this._removeInactiveAction(l))}}class cm{constructor(e){this.value=e}clone(){return new cm(void 0===this.value.clone?this.value:this.value.clone())}}let sx=0;class dy extends to{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:sx++}),this.name="",this.usage=Du,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const s=this.uniforms.indexOf(e);return-1!==s&&this.uniforms.splice(s,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const s=e.uniforms;this.uniforms.length=0;for(let l=0,c=s.length;l<c;l++){const d=Array.isArray(s[l])?s[l]:[s[l]];for(let g=0;g<d.length;g++)this.uniforms.push(d[g].clone())}return this}clone(){return(new this.constructor).copy(this)}}class cv extends Ku{constructor(e,s,l=1){super(e,s),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=l}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const s=super.clone(e);return s.meshPerAttribute=this.meshPerAttribute,s}toJSON(e){const s=super.toJSON(e);return s.isInstancedInterleavedBuffer=!0,s.meshPerAttribute=this.meshPerAttribute,s}}class uv{constructor(e,s,l,c,d){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=s,this.itemSize=l,this.elementSize=c,this.count=d,this.version=0}set needsUpdate(e){!0===e&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,s){return this.type=e,this.elementSize=s,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const py=new Yn;class hv{constructor(e,s,l=0,c=1/0){this.ray=new hc(e,s),this.near=l,this.far=c,this.camera=null,this.layers=new qd,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,s){this.ray.set(e,s)}setFromCamera(e,s){s.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(s.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(s).sub(this.ray.origin).normalize(),this.camera=s):s.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(s.near+s.far)/(s.near-s.far)).unproject(s),this.ray.direction.set(0,0,-1).transformDirection(s.matrixWorld),this.camera=s):console.error("THREE.Raycaster: Unsupported camera type: "+s.type)}setFromXRController(e){return py.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(py),this}intersectObject(e,s=!0,l=[]){return my(e,this,l,s),l.sort(fy),l}intersectObjects(e,s=!0,l=[]){for(let c=0,d=e.length;c<d;c++)my(e[c],this,l,s);return l.sort(fy),l}}function fy(A,e){return A.distance-e.distance}function my(A,e,s,l){if(A.layers.test(e.layers)&&A.raycast(e,s),!0===l){const c=A.children;for(let d=0,g=c.length;d<g;d++)my(c[d],e,s,!0)}}class dv{constructor(e=1,s=0,l=0){return this.radius=e,this.phi=s,this.theta=l,this}set(e,s,l){return this.radius=e,this.phi=s,this.theta=l,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,s,l){return this.radius=Math.sqrt(e*e+s*s+l*l),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,l),this.phi=Math.acos(Ki(s/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class pv{constructor(e=1,s=0,l=0){return this.radius=e,this.theta=s,this.y=l,this}set(e,s,l){return this.radius=e,this.theta=s,this.y=l,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,s,l){return this.radius=Math.sqrt(e*e+l*l),this.theta=Math.atan2(e,l),this.y=s,this}clone(){return(new this.constructor).copy(this)}}const fv=new Ye;class ax{constructor(e=new Ye(1/0,1/0),s=new Ye(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=s}set(e,s){return this.min.copy(e),this.max.copy(s),this}setFromPoints(e){this.makeEmpty();for(let s=0,l=e.length;s<l;s++)this.expandByPoint(e[s]);return this}setFromCenterAndSize(e,s){const l=fv.copy(s).multiplyScalar(.5);return this.min.copy(e).sub(l),this.max.copy(e).add(l),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,s){return s.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,s){return s.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,fv).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const gy=new Dt,um=new Dt;class mv{constructor(e=new Dt,s=new Dt){this.start=e,this.end=s}set(e,s){return this.start.copy(e),this.end.copy(s),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,s){return this.delta(s).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,s){gy.subVectors(e,this.start),um.subVectors(this.end,this.start);const l=um.dot(um);let c=um.dot(gy)/l;return s&&(c=Ki(c,0,1)),c}closestPointToPoint(e,s,l){const c=this.closestPointToPointParameter(e,s);return this.delta(l).multiplyScalar(c).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const Ay=new Dt;class yy extends hi{constructor(e,s){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=s,this.type="SpotLightHelper";const l=new gr,c=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let g=0,v=1,x=32;g<x;g++,v++){const w=g/x*Math.PI*2,S=v/x*Math.PI*2;c.push(Math.cos(w),Math.sin(w),1,Math.cos(S),Math.sin(S),1)}l.setAttribute("position",new Tn(c,3));const d=new ls({fog:!1,toneMapped:!1});this.cone=new Ai(l,d),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,s=e*Math.tan(this.light.angle);this.cone.scale.set(s,s,e),Ay.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Ay),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Fo=new Dt,hm=new Yn,tA=new Yn;class ox extends Ai{constructor(e){const s=gv(e),l=new gr,c=[],d=[],g=new En(0,0,1),v=new En(0,1,0);for(let x=0;x<s.length;x++){const w=s[x];w.parent&&w.parent.isBone&&(c.push(0,0,0),c.push(0,0,0),d.push(g.r,g.g,g.b),d.push(v.r,v.g,v.b))}l.setAttribute("position",new Tn(c,3)),l.setAttribute("color",new Tn(d,3)),super(l,new ls({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=s,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const s=this.bones,l=this.geometry,c=l.getAttribute("position");tA.copy(this.root.matrixWorld).invert();for(let d=0,g=0;d<s.length;d++){const v=s[d];v.parent&&v.parent.isBone&&(hm.multiplyMatrices(tA,v.matrixWorld),Fo.setFromMatrixPosition(hm),c.setXYZ(g,Fo.x,Fo.y,Fo.z),hm.multiplyMatrices(tA,v.parent.matrixWorld),Fo.setFromMatrixPosition(hm),c.setXYZ(g+1,Fo.x,Fo.y,Fo.z),g+=2)}l.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function gv(A){const e=[];!0===A.isBone&&e.push(A);for(let s=0;s<A.children.length;s++)e.push.apply(e,gv(A.children[s]));return e}class lx extends os{constructor(e,s,l){super(new oo(s,4,2),new no({wireframe:!0,fog:!1,toneMapped:!1})),this.light=e,this.color=l,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const cx=new Dt,Av=new En,yv=new En;class ux extends hi{constructor(e,s,l){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=l,this.type="HemisphereLightHelper";const c=new lh(s);c.rotateY(.5*Math.PI),this.material=new no({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const d=c.getAttribute("position"),g=new Float32Array(3*d.count);c.setAttribute("color",new wr(g,3)),this.add(new os(c,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const s=e.geometry.getAttribute("color");Av.copy(this.light.color),yv.copy(this.light.groundColor);for(let l=0,c=s.count;l<c;l++){const d=l<c/2?Av:yv;s.setXYZ(l,d.r,d.g,d.b)}s.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(cx.setFromMatrixPosition(this.light.matrixWorld).negate())}}class hx extends Ai{constructor(e=10,s=10,l=4473924,c=8947848){l=new En(l),c=new En(c);const d=s/2,g=e/s,v=e/2,x=[],w=[];for(let P=0,z=0,W=-v;P<=s;P++,W+=g){x.push(-v,0,W,v,0,W),x.push(W,0,-v,W,0,v);const Y=P===d?l:c;Y.toArray(w,z),z+=3,Y.toArray(w,z),z+=3,Y.toArray(w,z),z+=3,Y.toArray(w,z),z+=3}const S=new gr;S.setAttribute("position",new Tn(x,3)),S.setAttribute("color",new Tn(w,3)),super(S,new ls({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class dx extends Ai{constructor(e=10,s=16,l=8,c=64,d=4473924,g=8947848){d=new En(d),g=new En(g);const v=[],x=[];if(s>1)for(let S=0;S<s;S++){const P=S/s*(2*Math.PI),z=Math.sin(P)*e,W=Math.cos(P)*e;v.push(0,0,0),v.push(z,0,W);const Y=1&S?d:g;x.push(Y.r,Y.g,Y.b),x.push(Y.r,Y.g,Y.b)}for(let S=0;S<l;S++){const P=1&S?d:g,z=e-e/l*S;for(let W=0;W<c;W++){let Y=W/c*(2*Math.PI),tt=Math.sin(Y)*z,J=Math.cos(Y)*z;v.push(tt,0,J),x.push(P.r,P.g,P.b),Y=(W+1)/c*(2*Math.PI),tt=Math.sin(Y)*z,J=Math.cos(Y)*z,v.push(tt,0,J),x.push(P.r,P.g,P.b)}}const w=new gr;w.setAttribute("position",new Tn(v,3)),w.setAttribute("color",new Tn(x,3)),super(w,new ls({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const vv=new Dt,eA=new Dt,bv=new Dt;class px extends hi{constructor(e,s,l){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=l,this.type="DirectionalLightHelper",void 0===s&&(s=1);let c=new gr;c.setAttribute("position",new Tn([-s,s,0,s,s,0,s,-s,0,-s,-s,0,-s,s,0],3));const d=new ls({fog:!1,toneMapped:!1});this.lightPlane=new Ni(c,d),this.add(this.lightPlane),c=new gr,c.setAttribute("position",new Tn([0,0,0,0,0,1],3)),this.targetLine=new Ni(c,d),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),vv.setFromMatrixPosition(this.light.matrixWorld),eA.setFromMatrixPosition(this.light.target.matrixWorld),bv.subVectors(eA,vv),this.lightPlane.lookAt(eA),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(eA),this.targetLine.scale.z=bv.length()}}const nA=new Dt,Rs=new Xm;class fx extends Ai{constructor(e){const s=new gr,l=new ls({color:16777215,vertexColors:!0,toneMapped:!1}),c=[],d=[],g={};function v(Y,tt){x(Y),x(tt)}function x(Y){c.push(0,0,0),d.push(0,0,0),void 0===g[Y]&&(g[Y]=[]),g[Y].push(c.length/3-1)}v("n1","n2"),v("n2","n4"),v("n4","n3"),v("n3","n1"),v("f1","f2"),v("f2","f4"),v("f4","f3"),v("f3","f1"),v("n1","f1"),v("n2","f2"),v("n3","f3"),v("n4","f4"),v("p","n1"),v("p","n2"),v("p","n3"),v("p","n4"),v("u1","u2"),v("u2","u3"),v("u3","u1"),v("c","t"),v("p","c"),v("cn1","cn2"),v("cn3","cn4"),v("cf1","cf2"),v("cf3","cf4"),s.setAttribute("position",new Tn(c,3)),s.setAttribute("color",new Tn(d,3)),super(s,l),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=g,this.update();const w=new En(16755200),S=new En(16711680),P=new En(43775),z=new En(16777215),W=new En(3355443);this.setColors(w,S,P,z,W)}setColors(e,s,l,c,d){const g=this.geometry.getAttribute("color");g.setXYZ(0,e.r,e.g,e.b),g.setXYZ(1,e.r,e.g,e.b),g.setXYZ(2,e.r,e.g,e.b),g.setXYZ(3,e.r,e.g,e.b),g.setXYZ(4,e.r,e.g,e.b),g.setXYZ(5,e.r,e.g,e.b),g.setXYZ(6,e.r,e.g,e.b),g.setXYZ(7,e.r,e.g,e.b),g.setXYZ(8,e.r,e.g,e.b),g.setXYZ(9,e.r,e.g,e.b),g.setXYZ(10,e.r,e.g,e.b),g.setXYZ(11,e.r,e.g,e.b),g.setXYZ(12,e.r,e.g,e.b),g.setXYZ(13,e.r,e.g,e.b),g.setXYZ(14,e.r,e.g,e.b),g.setXYZ(15,e.r,e.g,e.b),g.setXYZ(16,e.r,e.g,e.b),g.setXYZ(17,e.r,e.g,e.b),g.setXYZ(18,e.r,e.g,e.b),g.setXYZ(19,e.r,e.g,e.b),g.setXYZ(20,e.r,e.g,e.b),g.setXYZ(21,e.r,e.g,e.b),g.setXYZ(22,e.r,e.g,e.b),g.setXYZ(23,e.r,e.g,e.b),g.setXYZ(24,s.r,s.g,s.b),g.setXYZ(25,s.r,s.g,s.b),g.setXYZ(26,s.r,s.g,s.b),g.setXYZ(27,s.r,s.g,s.b),g.setXYZ(28,s.r,s.g,s.b),g.setXYZ(29,s.r,s.g,s.b),g.setXYZ(30,s.r,s.g,s.b),g.setXYZ(31,s.r,s.g,s.b),g.setXYZ(32,l.r,l.g,l.b),g.setXYZ(33,l.r,l.g,l.b),g.setXYZ(34,l.r,l.g,l.b),g.setXYZ(35,l.r,l.g,l.b),g.setXYZ(36,l.r,l.g,l.b),g.setXYZ(37,l.r,l.g,l.b),g.setXYZ(38,c.r,c.g,c.b),g.setXYZ(39,c.r,c.g,c.b),g.setXYZ(40,d.r,d.g,d.b),g.setXYZ(41,d.r,d.g,d.b),g.setXYZ(42,d.r,d.g,d.b),g.setXYZ(43,d.r,d.g,d.b),g.setXYZ(44,d.r,d.g,d.b),g.setXYZ(45,d.r,d.g,d.b),g.setXYZ(46,d.r,d.g,d.b),g.setXYZ(47,d.r,d.g,d.b),g.setXYZ(48,d.r,d.g,d.b),g.setXYZ(49,d.r,d.g,d.b),g.needsUpdate=!0}update(){const e=this.geometry,s=this.pointMap;Rs.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Vs("c",s,e,Rs,0,0,-1),Vs("t",s,e,Rs,0,0,1),Vs("n1",s,e,Rs,-1,-1,-1),Vs("n2",s,e,Rs,1,-1,-1),Vs("n3",s,e,Rs,-1,1,-1),Vs("n4",s,e,Rs,1,1,-1),Vs("f1",s,e,Rs,-1,-1,1),Vs("f2",s,e,Rs,1,-1,1),Vs("f3",s,e,Rs,-1,1,1),Vs("f4",s,e,Rs,1,1,1),Vs("u1",s,e,Rs,.7,1.1,-1),Vs("u2",s,e,Rs,-.7,1.1,-1),Vs("u3",s,e,Rs,0,2,-1),Vs("cf1",s,e,Rs,-1,0,1),Vs("cf2",s,e,Rs,1,0,1),Vs("cf3",s,e,Rs,0,-1,1),Vs("cf4",s,e,Rs,0,1,1),Vs("cn1",s,e,Rs,-1,0,-1),Vs("cn2",s,e,Rs,1,0,-1),Vs("cn3",s,e,Rs,0,-1,-1),Vs("cn4",s,e,Rs,0,1,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Vs(A,e,s,l,c,d,g){nA.set(c,d,g).unproject(l);const v=e[A];if(void 0!==v){const x=s.getAttribute("position");for(let w=0,S=v.length;w<S;w++)x.setXYZ(v[w],nA.x,nA.y,nA.z)}}const rA=new ta;class mx extends Ai{constructor(e,s=16776960){const l=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),c=new Float32Array(24),d=new gr;d.setIndex(new wr(l,1)),d.setAttribute("position",new wr(c,3)),super(d,new ls({color:s,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&rA.setFromObject(this.object),rA.isEmpty())return;const s=rA.min,l=rA.max,c=this.geometry.attributes.position,d=c.array;d[0]=l.x,d[1]=l.y,d[2]=l.z,d[3]=s.x,d[4]=l.y,d[5]=l.z,d[6]=s.x,d[7]=s.y,d[8]=l.z,d[9]=l.x,d[10]=s.y,d[11]=l.z,d[12]=l.x,d[13]=l.y,d[14]=s.z,d[15]=s.x,d[16]=l.y,d[17]=s.z,d[18]=s.x,d[19]=s.y,d[20]=s.z,d[21]=l.x,d[22]=s.y,d[23]=s.z,c.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,s){return super.copy(e,s),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class gx extends Ai{constructor(e,s=16776960){const l=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),c=new gr;c.setIndex(new wr(l,1)),c.setAttribute("position",new Tn([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(c,new ls({color:s,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const s=this.box;s.isEmpty()||(s.getCenter(this.position),s.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class Ax extends Ni{constructor(e,s=1,l=16776960){const c=l,d=new gr;d.setAttribute("position",new Tn([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),d.computeBoundingSphere(),super(d,new ls({color:c,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=s;const g=new gr;g.setAttribute("position",new Tn([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),g.computeBoundingSphere(),this.add(new os(g,new no({color:c,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const xv=new Dt;let iA,vy;class yx extends hi{constructor(e=new Dt(0,0,1),s=new Dt(0,0,0),l=1,c=16776960,d=.2*l,g=.2*d){super(),this.type="ArrowHelper",void 0===iA&&(iA=new gr,iA.setAttribute("position",new Tn([0,0,0,0,1,0],3)),vy=new Zl(0,.5,1,5,1),vy.translate(0,-.5,0)),this.position.copy(s),this.line=new Ni(iA,new ls({color:c,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new os(vy,new no({color:c,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(l,d,g)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{xv.set(e.z,0,-e.x).normalize();const s=Math.acos(e.y);this.quaternion.setFromAxisAngle(xv,s)}}setLength(e,s=.2*e,l=.2*s){this.line.scale.set(1,Math.max(1e-4,e-s),1),this.line.updateMatrix(),this.cone.scale.set(l,s,l),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class vx extends Ai{constructor(e=1){const s=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],l=new gr;l.setAttribute("position",new Tn(s,3)),l.setAttribute("color",new Tn([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(l,new ls({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(e,s,l){const c=new En,d=this.geometry.attributes.color.array;return c.set(e),c.toArray(d,0),c.toArray(d,3),c.set(s),c.toArray(d,6),c.toArray(d,9),c.set(l),c.toArray(d,12),c.toArray(d,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class bx{constructor(){this.type="ShapePath",this.color=new En,this.subPaths=[],this.currentPath=null}moveTo(e,s){return this.currentPath=new Wf,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,s),this}lineTo(e,s){return this.currentPath.lineTo(e,s),this}quadraticCurveTo(e,s,l,c){return this.currentPath.quadraticCurveTo(e,s,l,c),this}bezierCurveTo(e,s,l,c,d,g){return this.currentPath.bezierCurveTo(e,s,l,c,d,g),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function s(J,at){const it=at.length;let ct=!1;for(let At=it-1,Ft=0;Ft<it;At=Ft++){let Tt=at[At],Pt=at[Ft],zt=Pt.x-Tt.x,ee=Pt.y-Tt.y;if(Math.abs(ee)>Number.EPSILON){if(ee<0&&(Tt=at[Ft],zt=-zt,Pt=at[At],ee=-ee),J.y<Tt.y||J.y>Pt.y)continue;if(J.y===Tt.y){if(J.x===Tt.x)return!0}else{const ce=ee*(J.x-Tt.x)-zt*(J.y-Tt.y);if(0===ce)return!0;if(ce<0)continue;ct=!ct}}else{if(J.y!==Tt.y)continue;if(Pt.x<=J.x&&J.x<=Tt.x||Tt.x<=J.x&&J.x<=Pt.x)return!0}}return ct}const l=Yi.isClockWise,c=this.subPaths;if(0===c.length)return[];let d,g,v;const x=[];if(1===c.length)return g=c[0],v=new td,v.curves=g.curves,x.push(v),x;let w=!l(c[0].getPoints());w=e?!w:w;const S=[],P=[];let z,W,Y=[],tt=0;P[tt]=void 0,Y[tt]=[];for(let J=0,at=c.length;J<at;J++)g=c[J],z=g.getPoints(),d=l(z),d=e?!d:d,d?(!w&&P[tt]&&tt++,P[tt]={s:new td,p:z},P[tt].s.curves=g.curves,w&&tt++,Y[tt]=[]):Y[tt].push({h:g,p:z[0]});if(!P[0])return function(J){const at=[];for(let it=0,ct=J.length;it<ct;it++){const At=J[it],Ft=new td;Ft.curves=At.curves,at.push(Ft)}return at}(c);if(P.length>1){let J=!1,at=0;for(let it=0,ct=P.length;it<ct;it++)S[it]=[];for(let it=0,ct=P.length;it<ct;it++){const At=Y[it];for(let Ft=0;Ft<At.length;Ft++){const Tt=At[Ft];let Pt=!0;for(let zt=0;zt<P.length;zt++)s(Tt.p,P[zt].p)&&(it!==zt&&at++,Pt?(Pt=!1,S[zt].push(Tt)):J=!0);Pt&&S[it].push(Tt)}}at>0&&!1===J&&(Y=S)}for(let J=0,at=P.length;J<at;J++){v=P[J].s,x.push(v),W=Y[J];for(let it=0,ct=W.length;it<ct;it++)v.holes.push(W[it].h)}return x}}class xx extends bo{constructor(e=1,s=1,l=1,c={}){console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),super(e,s,{...c,count:l}),this.isWebGLMultipleRenderTargets=!0}get texture(){return this.textures}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:O}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=O);const by=new WeakMap;function wx(){let A,e;function s(l,c,d,g,v,x){const w=x.num_components(),S=d.num_points()*w,P=S*v.BYTES_PER_ELEMENT,z=function(tt,J){switch(J){case Float32Array:return tt.DT_FLOAT32;case Int8Array:return tt.DT_INT8;case Int16Array:return tt.DT_INT16;case Int32Array:return tt.DT_INT32;case Uint8Array:return tt.DT_UINT8;case Uint16Array:return tt.DT_UINT16;case Uint32Array:return tt.DT_UINT32}}(l,v),W=l._malloc(P);c.GetAttributeDataArrayForAllPoints(d,x,z,P,W);const Y=new v(l.HEAPF32.buffer,W,S).slice();return l._free(W),{name:g,array:Y,itemSize:w}}onmessage=function(l){const c=l.data;switch(c.type){case"init":A=c.decoderConfig,e=new Promise(function(v){A.onModuleLoaded=function(x){v({draco:x})},DracoDecoderModule(A)});break;case"decode":const d=c.buffer,g=c.taskConfig;e.then(v=>{const x=v.draco,w=new x.Decoder;try{const S=function(z,W,Y,tt){const J=tt.attributeIDs,at=tt.attributeTypes;let it,ct;const At=W.GetEncodedGeometryType(Y);if(At===z.TRIANGULAR_MESH)it=new z.Mesh,ct=W.DecodeArrayToMesh(Y,Y.byteLength,it);else{if(At!==z.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");it=new z.PointCloud,ct=W.DecodeArrayToPointCloud(Y,Y.byteLength,it)}if(!ct.ok()||0===it.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+ct.error_msg());const Ft={index:null,attributes:[]};for(const Tt in J){const Pt=self[at[Tt]];let zt,ee;if(tt.useUniqueIDs)ee=J[Tt],zt=W.GetAttributeByUniqueId(it,ee);else{if(ee=W.GetAttributeId(it,z[J[Tt]]),-1===ee)continue;zt=W.GetAttribute(it,ee)}const ce=s(z,W,it,Tt,Pt,zt);"color"===Tt&&(ce.vertexColorSpace=tt.vertexColorSpace),Ft.attributes.push(ce)}return At===z.TRIANGULAR_MESH&&(Ft.index=function(Tt,Pt,zt){const ee=3*zt.num_faces(),ce=4*ee,ne=Tt._malloc(ce);Pt.GetTrianglesUInt32Array(zt,ce,ne);const ge=new Uint32Array(Tt.HEAPF32.buffer,ne,ee).slice();return Tt._free(ne),{array:ge,itemSize:1}}(z,W,it)),z.destroy(it),Ft}(x,w,new Int8Array(d),g),P=S.attributes.map(z=>z.array.buffer);S.index&&P.push(S.index.array.buffer),self.postMessage({type:"decode",id:c.id,geometry:S},P)}catch(S){console.error(S),self.postMessage({type:"error",id:c.id,error:S.message})}finally{x.destroy(w)}})}}}function Ex(A,e,s=!0){if(!e||!e.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!A.hasAttribute("position")||!A.hasAttribute("normal")||!A.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function l(g){if(g.normalized||g.isInterleavedBufferAttribute){const v=new Float32Array(g.count*g.itemSize);for(let x=0,w=0;x<g.count;x++)v[w++]=g.getX(x),v[w++]=g.getY(x),g.itemSize>2&&(v[w++]=g.getZ(x));return v}return g.array instanceof Float32Array?g.array:new Float32Array(g.array)}const c=A.index?A.toNonIndexed():A,d=e.generateTangents(l(c.attributes.position),l(c.attributes.normal),l(c.attributes.uv));if(s)for(let g=3;g<d.length;g+=4)d[g]*=-1;return c.setAttribute("tangent",new wr(d,4)),A!==c&&A.copy(c),A}function Cx(A,e=!1){const s=null!==A[0].index,l=new Set(Object.keys(A[0].attributes)),c=new Set(Object.keys(A[0].morphAttributes)),d={},g={},v=A[0].morphTargetsRelative,x=new gr;let w=0;for(let S=0;S<A.length;++S){const P=A[S];let z=0;if(s!==(null!==P.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+S+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const W in P.attributes){if(!l.has(W))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+S+'. All geometries must have compatible attributes; make sure "'+W+'" attribute exists among all geometries, or in none of them.'),null;void 0===d[W]&&(d[W]=[]),d[W].push(P.attributes[W]),z++}if(z!==l.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+S+". Make sure all geometries have the same number of attributes."),null;if(v!==P.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+S+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const W in P.morphAttributes){if(!c.has(W))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+S+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===g[W]&&(g[W]=[]),g[W].push(P.morphAttributes[W])}if(e){let W;if(s)W=P.index.count;else{if(void 0===P.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+S+". The geometry must have either an index or a position attribute"),null;W=P.attributes.position.count}x.addGroup(w,W,S),w+=W}}if(s){let S=0;const P=[];for(let z=0;z<A.length;++z){const W=A[z].index;for(let Y=0;Y<W.count;++Y)P.push(W.getX(Y)+S);S+=A[z].attributes.position.count}x.setIndex(P)}for(const S in d){const P=xy(d[S]);if(!P)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+S+" attribute."),null;x.setAttribute(S,P)}for(const S in g){const P=g[S][0].length;if(0===P)break;x.morphAttributes=x.morphAttributes||{},x.morphAttributes[S]=[];for(let z=0;z<P;++z){const W=[];for(let tt=0;tt<g[S].length;++tt)W.push(g[S][tt][z]);const Y=xy(W);if(!Y)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+S+" morphAttribute."),null;x.morphAttributes[S].push(Y)}}return x}function xy(A){let e,s,l,c=-1,d=0;for(let w=0;w<A.length;++w){const S=A[w];if(void 0===e&&(e=S.array.constructor),e!==S.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===s&&(s=S.itemSize),s!==S.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===l&&(l=S.normalized),l!==S.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(-1===c&&(c=S.gpuType),c!==S.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;d+=S.count*s}const g=new e(d),v=new wr(g,s,l);let x=0;for(let w=0;w<A.length;++w){const S=A[w];if(S.isInterleavedBufferAttribute){const P=x/s;for(let z=0,W=S.count;z<W;z++)for(let Y=0;Y<s;Y++){const tt=S.getComponent(z,Y);v.setComponent(z+P,Y,tt)}}else g.set(S.array,x);x+=S.count*s}return void 0!==c&&(v.gpuType=c),v}function Ix(A){return A.isInstancedInterleavedBufferAttribute||A.isInterleavedBufferAttribute?sA(A):A.isInstancedBufferAttribute?(new Jl).copy(A):(new wr).copy(A)}function Sx(A){let e,s=0,l=0;for(let w=0,S=A.length;w<S;++w){const P=A[w];if(void 0===e&&(e=P.array.constructor),e!==P.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;s+=P.array.length,l+=P.itemSize}const c=new Ku(new e(s),l);let d=0;const g=[],v=["getX","getY","getZ","getW"],x=["setX","setY","setZ","setW"];for(let w=0,S=A.length;w<S;w++){const P=A[w],z=P.itemSize,W=P.count,Y=new ba(c,z,d,P.normalized);g.push(Y),d+=z;for(let tt=0;tt<W;tt++)for(let J=0;J<z;J++)Y[x[J]](tt,P[v[J]](tt))}return g}function sA(A){const s=A.count,l=A.itemSize,c=A.normalized,d=new(0,A.data.array.constructor)(s*l);let g;g=A.isInstancedInterleavedBufferAttribute?new Jl(d,l,c,A.meshPerAttribute):new wr(d,l,c);for(let v=0;v<s;v++)g.setX(v,A.getX(v)),l>=2&&g.setY(v,A.getY(v)),l>=3&&g.setZ(v,A.getZ(v)),l>=4&&g.setW(v,A.getW(v));return g}function Mx(A){const e=A.attributes,s=A.morphTargets,l=new Map;for(const c in e){const d=e[c];d.isInterleavedBufferAttribute&&(l.has(d)||l.set(d,sA(d)),e[c]=l.get(d))}for(const c in s){const d=s[c];d.isInterleavedBufferAttribute&&(l.has(d)||l.set(d,sA(d)),s[c]=l.get(d))}}function Tx(A){let e=0;for(const l in A.attributes){const c=A.getAttribute(l);e+=c.count*c.itemSize*c.array.BYTES_PER_ELEMENT}const s=A.getIndex();return e+=s?s.count*s.itemSize*s.array.BYTES_PER_ELEMENT:0,e}function _x(A,e=1e-4){e=Math.max(e,Number.EPSILON);const s={},l=A.getIndex(),c=A.getAttribute("position"),d=l?l.count:c.count;let g=0;const v=Object.keys(A.attributes),x={},w={},S=[],P=["getX","getY","getZ","getW"],z=["setX","setY","setZ","setW"];for(let it=0,ct=v.length;it<ct;it++){const At=v[it],Ft=A.attributes[At];x[At]=new wr(new Ft.array.constructor(Ft.count*Ft.itemSize),Ft.itemSize,Ft.normalized);const Tt=A.morphAttributes[At];Tt&&(w[At]=new wr(new Tt.array.constructor(Tt.count*Tt.itemSize),Tt.itemSize,Tt.normalized))}const W=.5*e,Y=Math.log10(1/e),tt=Math.pow(10,Y),J=W*tt;for(let it=0;it<d;it++){const ct=l?l.getX(it):it;let At="";for(let Ft=0,Tt=v.length;Ft<Tt;Ft++){const zt=A.getAttribute(v[Ft]),ee=zt.itemSize;for(let ce=0;ce<ee;ce++)At+=~~(zt[P[ce]](ct)*tt+J)+","}if(At in s)S.push(s[At]);else{for(let Ft=0,Tt=v.length;Ft<Tt;Ft++){const Pt=v[Ft],zt=A.getAttribute(Pt),ee=A.morphAttributes[Pt],ce=zt.itemSize,ne=x[Pt],ge=w[Pt];for(let ie=0;ie<ce;ie++){const pe=P[ie],Oe=z[ie];if(ne[Oe](g,zt[pe](ct)),ee)for(let Pe=0,ze=ee.length;Pe<ze;Pe++)ge[Pe][Oe](g,ee[Pe][pe](ct))}}s[At]=g,S.push(g),g++}}const at=A.clone();for(const it in A.attributes){const ct=x[it];if(at.setAttribute(it,new wr(ct.array.slice(0,g*ct.itemSize),ct.itemSize,ct.normalized)),it in w)for(let At=0;At<w[it].length;At++){const Ft=w[it][At];at.morphAttributes[it][At]=new wr(Ft.array.slice(0,g*Ft.itemSize),Ft.itemSize,Ft.normalized)}}return at.setIndex(S),at}function wy(A,e){if(e===Ho)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),A;if(e===yo||e===pl){let s=A.getIndex();if(null===s){const g=[],v=A.getAttribute("position");if(void 0===v)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),A;for(let x=0;x<v.count;x++)g.push(x);A.setIndex(g),s=A.getIndex()}const l=s.count-2,c=[];if(e===yo)for(let g=1;g<=l;g++)c.push(s.getX(0)),c.push(s.getX(g)),c.push(s.getX(g+1));else for(let g=0;g<l;g++)g%2==0?(c.push(s.getX(g)),c.push(s.getX(g+1)),c.push(s.getX(g+2))):(c.push(s.getX(g+2)),c.push(s.getX(g+1)),c.push(s.getX(g)));c.length/3!==l&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const d=A.clone();return d.setIndex(c),d.clearGroups(),d}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),A}function kx(A){const e=new Dt,s=new Dt,l=new Dt,c=new Dt,d=new Dt,g=new Dt,v=new Dt,x=new Dt,w=new Dt;function S(ze,Fe,Dn,Nn,fn,xn,In,Mn){e.fromBufferAttribute(Fe,fn),s.fromBufferAttribute(Fe,xn),l.fromBufferAttribute(Fe,In);const Ce=ze.morphTargetInfluences;if(Dn&&Ce){v.set(0,0,0),x.set(0,0,0),w.set(0,0,0);for(let rn=0,On=Dn.length;rn<On;rn++){const ln=Ce[rn],Lt=Dn[rn];0!==ln&&(c.fromBufferAttribute(Lt,fn),d.fromBufferAttribute(Lt,xn),g.fromBufferAttribute(Lt,In),Nn?(v.addScaledVector(c,ln),x.addScaledVector(d,ln),w.addScaledVector(g,ln)):(v.addScaledVector(c.sub(e),ln),x.addScaledVector(d.sub(s),ln),w.addScaledVector(g.sub(l),ln)))}e.add(v),s.add(x),l.add(w)}ze.isSkinnedMesh&&(ze.applyBoneTransform(fn,e),ze.applyBoneTransform(xn,s),ze.applyBoneTransform(In,l)),Mn[3*fn+0]=e.x,Mn[3*fn+1]=e.y,Mn[3*fn+2]=e.z,Mn[3*xn+0]=s.x,Mn[3*xn+1]=s.y,Mn[3*xn+2]=s.z,Mn[3*In+0]=l.x,Mn[3*In+1]=l.y,Mn[3*In+2]=l.z}const P=A.geometry,z=A.material;let W,Y,tt;const J=P.index,at=P.attributes.position,it=P.morphAttributes.position,ct=P.morphTargetsRelative,At=P.attributes.normal,Ft=P.morphAttributes.position,Tt=P.groups,Pt=P.drawRange;let zt,ee,ce,ne,ge,ie,pe;const Oe=new Float32Array(at.count*at.itemSize),Pe=new Float32Array(At.count*At.itemSize);if(null!==J)if(Array.isArray(z))for(zt=0,ce=Tt.length;zt<ce;zt++)for(ge=Tt[zt],ie=Math.max(ge.start,Pt.start),pe=Math.min(ge.start+ge.count,Pt.start+Pt.count),ee=ie,ne=pe;ee<ne;ee+=3)W=J.getX(ee),Y=J.getX(ee+1),tt=J.getX(ee+2),S(A,at,it,ct,W,Y,tt,Oe),S(A,At,Ft,ct,W,Y,tt,Pe);else for(ie=Math.max(0,Pt.start),pe=Math.min(J.count,Pt.start+Pt.count),zt=ie,ce=pe;zt<ce;zt+=3)W=J.getX(zt),Y=J.getX(zt+1),tt=J.getX(zt+2),S(A,at,it,ct,W,Y,tt,Oe),S(A,At,Ft,ct,W,Y,tt,Pe);else if(Array.isArray(z))for(zt=0,ce=Tt.length;zt<ce;zt++)for(ge=Tt[zt],ie=Math.max(ge.start,Pt.start),pe=Math.min(ge.start+ge.count,Pt.start+Pt.count),ee=ie,ne=pe;ee<ne;ee+=3)W=ee,Y=ee+1,tt=ee+2,S(A,at,it,ct,W,Y,tt,Oe),S(A,At,Ft,ct,W,Y,tt,Pe);else for(ie=Math.max(0,Pt.start),pe=Math.min(at.count,Pt.start+Pt.count),zt=ie,ce=pe;zt<ce;zt+=3)W=zt,Y=zt+1,tt=zt+2,S(A,at,it,ct,W,Y,tt,Oe),S(A,At,Ft,ct,W,Y,tt,Pe);return{positionAttribute:at,normalAttribute:At,morphedPositionAttribute:new Tn(Oe,3),morphedNormalAttribute:new Tn(Pe,3)}}function wv(A){if(0===A.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),A;let e=A.groups;if(e=e.sort((g,v)=>g.materialIndex!==v.materialIndex?g.materialIndex-v.materialIndex:g.start-v.start),null===A.getIndex()){const g=A.getAttribute("position"),v=[];for(let x=0;x<g.count;x+=3)v.push(x,x+1,x+2);A.setIndex(v)}const s=A.getIndex(),l=[];for(let g=0;g<e.length;g++){const v=e[g],x=v.start,w=x+v.count;for(let S=x;S<w;S++)l.push(s.getX(S))}A.dispose(),A.setIndex(l);let c=0;for(let g=0;g<e.length;g++){const v=e[g];v.start=c,c+=v.count}let d=e[0];A.groups=[d];for(let g=1;g<e.length;g++){const v=e[g];d.materialIndex===v.materialIndex?d.count+=v.count:(d=v,A.groups.push(d))}return A}function Ev(A,e=Math.PI/3){const s=Math.cos(e),l=100*(1+1e-10),c=[new Dt,new Dt,new Dt],d=new Dt,g=new Dt,v=new Dt,x=new Dt;function w(tt){return`${~~(tt.x*l)},${~~(tt.y*l)},${~~(tt.z*l)}`}const S=A.index?A.toNonIndexed():A,P=S.attributes.position,z={};for(let tt=0,J=P.count/3;tt<J;tt++){const at=3*tt,it=c[0].fromBufferAttribute(P,at+0),ct=c[1].fromBufferAttribute(P,at+1),At=c[2].fromBufferAttribute(P,at+2);d.subVectors(At,ct),g.subVectors(it,ct);const Ft=(new Dt).crossVectors(d,g).normalize();for(let Tt=0;Tt<3;Tt++){const Pt=w(c[Tt]);Pt in z||(z[Pt]=[]),z[Pt].push(Ft)}}const W=new Float32Array(3*P.count),Y=new wr(W,3,!1);for(let tt=0,J=P.count/3;tt<J;tt++){const at=3*tt,it=c[0].fromBufferAttribute(P,at+0),ct=c[1].fromBufferAttribute(P,at+1),At=c[2].fromBufferAttribute(P,at+2);d.subVectors(At,ct),g.subVectors(it,ct),v.crossVectors(d,g).normalize();for(let Ft=0;Ft<3;Ft++){const Tt=z[w(c[Ft])];x.set(0,0,0);for(let Pt=0,zt=Tt.length;Pt<zt;Pt++){const ee=Tt[Pt];v.dot(ee)>s&&x.add(ee)}x.normalize(),Y.setXYZ(at+Ft,x.x,x.y,x.z)}}return S.setAttribute("normal",Y),S}function Rx(){let A={};return{get:function(e){return A[e]},add:function(e,s){A[e]=s},remove:function(e){delete A[e]},removeAll:function(){A={}}}}const aA="KHR_binary_glTF",dm="KHR_draco_mesh_compression",pm="KHR_materials_unlit",fm="KHR_texture_transform",Iv="KHR_mesh_quantization";class kc{constructor(e){this.parser=e,this.name="KHR_lights_punctual",this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,s=this.parser.json.nodes||[];for(let l=0,c=s.length;l<c;l++){const d=s[l];d.extensions&&d.extensions[this.name]&&void 0!==d.extensions[this.name].light&&e._addNodeRef(this.cache,d.extensions[this.name].light)}}_loadLight(e){const s=this.parser,l="light:"+e;let c=s.cache.get(l);if(c)return c;const d=s.json,g=((d.extensions&&d.extensions[this.name]||{}).lights||[])[e];let v;const x=new En(16777215);void 0!==g.color&&x.setRGB(g.color[0],g.color[1],g.color[2],ps);const w=void 0!==g.range?g.range:0;switch(g.type){case"directional":v=new ny(x),v.target.position.set(0,0,-1),v.add(v.target);break;case"point":v=new ey(x),v.distance=w;break;case"spot":v=new Z0(x),v.distance=w,g.spot=g.spot||{},g.spot.innerConeAngle=void 0!==g.spot.innerConeAngle?g.spot.innerConeAngle:0,g.spot.outerConeAngle=void 0!==g.spot.outerConeAngle?g.spot.outerConeAngle:Math.PI/4,v.angle=g.spot.outerConeAngle,v.penumbra=1-g.spot.innerConeAngle/g.spot.outerConeAngle,v.target.position.set(0,0,-1),v.add(v.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+g.type)}return v.position.set(0,0,0),v.decay=2,ph(v,g),void 0!==g.intensity&&(v.intensity=g.intensity),v.name=s.createUniqueName(g.name||"light_"+e),c=Promise.resolve(v),s.cache.add(l,c),c}getDependency(e,s){if("light"===e)return this._loadLight(s)}createNodeAttachment(e){const s=this,l=this.parser,c=l.json.nodes[e],d=(c.extensions&&c.extensions[this.name]||{}).light;return void 0===d?null:this._loadLight(d).then(function(g){return l._getNodeRef(s.cache,d,g)})}}class Sl{constructor(){this.name=pm}getMaterialType(){return no}extendParams(e,s,l){const c=[];e.color=new En(1,1,1),e.opacity=1;const d=s.pbrMetallicRoughness;if(d){if(Array.isArray(d.baseColorFactor)){const g=d.baseColorFactor;e.color.setRGB(g[0],g[1],g[2],ps),e.opacity=g[3]}void 0!==d.baseColorTexture&&c.push(l.assignTexture(e,"map",d.baseColorTexture,qi))}return Promise.all(c)}}class he{constructor(e){this.parser=e,this.name="KHR_materials_emissive_strength"}extendMaterialParams(e,s){const l=this.parser.json.materials[e];if(!l.extensions||!l.extensions[this.name])return Promise.resolve();const c=l.extensions[this.name].emissiveStrength;return void 0!==c&&(s.emissiveIntensity=c),Promise.resolve()}}class Lr{constructor(e){this.parser=e,this.name="KHR_materials_clearcoat"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser,c=l.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const d=[],g=c.extensions[this.name];if(void 0!==g.clearcoatFactor&&(s.clearcoat=g.clearcoatFactor),void 0!==g.clearcoatTexture&&d.push(l.assignTexture(s,"clearcoatMap",g.clearcoatTexture)),void 0!==g.clearcoatRoughnessFactor&&(s.clearcoatRoughness=g.clearcoatRoughnessFactor),void 0!==g.clearcoatRoughnessTexture&&d.push(l.assignTexture(s,"clearcoatRoughnessMap",g.clearcoatRoughnessTexture)),void 0!==g.clearcoatNormalTexture&&(d.push(l.assignTexture(s,"clearcoatNormalMap",g.clearcoatNormalTexture)),void 0!==g.clearcoatNormalTexture.scale)){const v=g.clearcoatNormalTexture.scale;s.clearcoatNormalScale=new Ye(v,v)}return Promise.all(d)}}class Cy{constructor(e){this.parser=e,this.name="KHR_materials_dispersion"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser.json.materials[e];if(!l.extensions||!l.extensions[this.name])return Promise.resolve();const c=l.extensions[this.name];return s.dispersion=void 0!==c.dispersion?c.dispersion:0,Promise.resolve()}}class hd{constructor(e){this.parser=e,this.name="KHR_materials_iridescence"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser,c=l.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const d=[],g=c.extensions[this.name];return void 0!==g.iridescenceFactor&&(s.iridescence=g.iridescenceFactor),void 0!==g.iridescenceTexture&&d.push(l.assignTexture(s,"iridescenceMap",g.iridescenceTexture)),void 0!==g.iridescenceIor&&(s.iridescenceIOR=g.iridescenceIor),void 0===s.iridescenceThicknessRange&&(s.iridescenceThicknessRange=[100,400]),void 0!==g.iridescenceThicknessMinimum&&(s.iridescenceThicknessRange[0]=g.iridescenceThicknessMinimum),void 0!==g.iridescenceThicknessMaximum&&(s.iridescenceThicknessRange[1]=g.iridescenceThicknessMaximum),void 0!==g.iridescenceThicknessTexture&&d.push(l.assignTexture(s,"iridescenceThicknessMap",g.iridescenceThicknessTexture)),Promise.all(d)}}class Rc{constructor(e){this.parser=e,this.name="KHR_materials_sheen"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser,c=l.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const d=[];s.sheenColor=new En(0,0,0),s.sheenRoughness=0,s.sheen=1;const g=c.extensions[this.name];if(void 0!==g.sheenColorFactor){const v=g.sheenColorFactor;s.sheenColor.setRGB(v[0],v[1],v[2],ps)}return void 0!==g.sheenRoughnessFactor&&(s.sheenRoughness=g.sheenRoughnessFactor),void 0!==g.sheenColorTexture&&d.push(l.assignTexture(s,"sheenColorMap",g.sheenColorTexture,qi)),void 0!==g.sheenRoughnessTexture&&d.push(l.assignTexture(s,"sheenRoughnessMap",g.sheenRoughnessTexture)),Promise.all(d)}}class _v{constructor(e){this.parser=e,this.name="KHR_materials_transmission"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser,c=l.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const d=[],g=c.extensions[this.name];return void 0!==g.transmissionFactor&&(s.transmission=g.transmissionFactor),void 0!==g.transmissionTexture&&d.push(l.assignTexture(s,"transmissionMap",g.transmissionTexture)),Promise.all(d)}}class Io{constructor(e){this.parser=e,this.name="KHR_materials_volume"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser,c=l.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const d=[],g=c.extensions[this.name];s.thickness=void 0!==g.thicknessFactor?g.thicknessFactor:0,void 0!==g.thicknessTexture&&d.push(l.assignTexture(s,"thicknessMap",g.thicknessTexture)),s.attenuationDistance=g.attenuationDistance||1/0;const v=g.attenuationColor||[1,1,1];return s.attenuationColor=(new En).setRGB(v[0],v[1],v[2],ps),Promise.all(d)}}class Zi{constructor(e){this.parser=e,this.name="KHR_materials_ior"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser.json.materials[e];if(!l.extensions||!l.extensions[this.name])return Promise.resolve();const c=l.extensions[this.name];return s.ior=void 0!==c.ior?c.ior:1.5,Promise.resolve()}}class Eu{constructor(e){this.parser=e,this.name="KHR_materials_specular"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser,c=l.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const d=[],g=c.extensions[this.name];s.specularIntensity=void 0!==g.specularFactor?g.specularFactor:1,void 0!==g.specularTexture&&d.push(l.assignTexture(s,"specularIntensityMap",g.specularTexture));const v=g.specularColorFactor||[1,1,1];return s.specularColor=(new En).setRGB(v[0],v[1],v[2],ps),void 0!==g.specularColorTexture&&d.push(l.assignTexture(s,"specularColorMap",g.specularColorTexture,qi)),Promise.all(d)}}class dd{constructor(e){this.parser=e,this.name="EXT_materials_bump"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser,c=l.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const d=[],g=c.extensions[this.name];return s.bumpScale=void 0!==g.bumpFactor?g.bumpFactor:1,void 0!==g.bumpTexture&&d.push(l.assignTexture(s,"bumpMap",g.bumpTexture)),Promise.all(d)}}class Ml{constructor(e){this.parser=e,this.name="KHR_materials_anisotropy"}getMaterialType(e){const s=this.parser.json.materials[e];return s.extensions&&s.extensions[this.name]?rl:null}extendMaterialParams(e,s){const l=this.parser,c=l.json.materials[e];if(!c.extensions||!c.extensions[this.name])return Promise.resolve();const d=[],g=c.extensions[this.name];return void 0!==g.anisotropyStrength&&(s.anisotropy=g.anisotropyStrength),void 0!==g.anisotropyRotation&&(s.anisotropyRotation=g.anisotropyRotation),void 0!==g.anisotropyTexture&&d.push(l.assignTexture(s,"anisotropyMap",g.anisotropyTexture)),Promise.all(d)}}class Iy{constructor(e){this.parser=e,this.name="KHR_texture_basisu"}loadTexture(e){const s=this.parser,l=s.json,c=l.textures[e];if(!c.extensions||!c.extensions[this.name])return null;const d=c.extensions[this.name],g=s.options.ktx2Loader;if(!g){if(l.extensionsRequired&&l.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return s.loadTextureImage(e,d.source,g)}}class Sy{constructor(e){this.parser=e,this.name="EXT_texture_webp",this.isSupported=null}loadTexture(e){const s=this.name,l=this.parser,c=l.json,d=c.textures[e];if(!d.extensions||!d.extensions[s])return null;const g=d.extensions[s],v=c.images[g.source];let x=l.textureLoader;if(v.uri){const w=l.options.manager.getHandler(v.uri);null!==w&&(x=w)}return this.detectSupport().then(function(w){if(w)return l.loadTextureImage(e,g.source,x);if(c.extensionsRequired&&c.extensionsRequired.indexOf(s)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return l.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const s=new Image;s.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",s.onload=s.onerror=function(){e(1===s.height)}})),this.isSupported}}class mm{constructor(e){this.parser=e,this.name="EXT_texture_avif",this.isSupported=null}loadTexture(e){const s=this.name,l=this.parser,c=l.json,d=c.textures[e];if(!d.extensions||!d.extensions[s])return null;const g=d.extensions[s],v=c.images[g.source];let x=l.textureLoader;if(v.uri){const w=l.options.manager.getHandler(v.uri);null!==w&&(x=w)}return this.detectSupport().then(function(w){if(w)return l.loadTextureImage(e,g.source,x);if(c.extensionsRequired&&c.extensionsRequired.indexOf(s)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return l.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const s=new Image;s.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",s.onload=s.onerror=function(){e(1===s.height)}})),this.isSupported}}class oA{constructor(e){this.name="EXT_meshopt_compression",this.parser=e}loadBufferView(e){const s=this.parser.json,l=s.bufferViews[e];if(l.extensions&&l.extensions[this.name]){const c=l.extensions[this.name],d=this.parser.getDependency("buffer",c.buffer),g=this.parser.options.meshoptDecoder;if(!g||!g.supported){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return d.then(function(v){const S=c.count,P=c.byteStride,z=new Uint8Array(v,c.byteOffset||0,c.byteLength||0);return g.decodeGltfBufferAsync?g.decodeGltfBufferAsync(S,P,z,c.mode,c.filter).then(function(W){return W.buffer}):g.ready.then(function(){const W=new ArrayBuffer(S*P);return g.decodeGltfBuffer(new Uint8Array(W),S,P,z,c.mode,c.filter),W})})}return null}}class hh{constructor(e){this.name="EXT_mesh_gpu_instancing",this.parser=e}createNodeMesh(e){const s=this.parser.json,l=s.nodes[e];if(!l.extensions||!l.extensions[this.name]||void 0===l.mesh)return null;const c=s.meshes[l.mesh];for(const x of c.primitives)if(x.mode!==Oo.TRIANGLES&&x.mode!==Oo.TRIANGLE_STRIP&&x.mode!==Oo.TRIANGLE_FAN&&void 0!==x.mode)return null;const d=l.extensions[this.name].attributes,g=[],v={};for(const x in d)g.push(this.parser.getDependency("accessor",d[x]).then(w=>(v[x]=w,v[x])));return g.length<1?null:(g.push(this.parser.createNodeMesh(e)),Promise.all(g).then(x=>{const w=x.pop(),S=w.isGroup?w.children:[w],P=x[0].count,z=[];for(const W of S){const Y=new Yn,tt=new Dt,J=new _s,at=new Dt(1,1,1),it=new xo(W.geometry,W.material,P);for(let ct=0;ct<P;ct++)v.TRANSLATION&&tt.fromBufferAttribute(v.TRANSLATION,ct),v.ROTATION&&J.fromBufferAttribute(v.ROTATION,ct),v.SCALE&&at.fromBufferAttribute(v.SCALE,ct),it.setMatrixAt(ct,Y.compose(tt,J,at));for(const ct in v)if("_COLOR_0"===ct){const At=v[ct];it.instanceColor=new Jl(At.array,At.itemSize,At.normalized)}else"TRANSLATION"!==ct&&"ROTATION"!==ct&&"SCALE"!==ct&&W.geometry.setAttribute(ct,v[ct]);hi.prototype.copy.call(it,W),this.parser.assignFinalMaterial(it),z.push(it)}return w.isGroup?(w.clear(),w.add(...z),w):z[0]}))}}class pd{constructor(e){this.name=aA,this.content=null,this.body=null;const s=new DataView(e,0,12),l=new TextDecoder;if(this.header={magic:l.decode(new Uint8Array(e.slice(0,4))),version:s.getUint32(4,!0),length:s.getUint32(8,!0)},"glTF"!==this.header.magic)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const c=this.header.length-12,d=new DataView(e,12);let g=0;for(;g<c;){const v=d.getUint32(g,!0);g+=4;const x=d.getUint32(g,!0);if(g+=4,1313821514===x){const w=new Uint8Array(e,12+g,v);this.content=l.decode(w)}else if(5130562===x){const w=12+g;this.body=e.slice(w,w+v)}g+=v}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class My{constructor(e,s){if(!s)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=dm,this.json=e,this.dracoLoader=s,this.dracoLoader.preload()}decodePrimitive(e,s){const l=this.json,c=this.dracoLoader,d=e.extensions[this.name].bufferView,g=e.extensions[this.name].attributes,v={},x={},w={};for(const S in g){const P=Bs[S]||S.toLowerCase();v[P]=g[S]}for(const S in e.attributes){const P=Bs[S]||S.toLowerCase();if(void 0!==g[S]){const z=l.accessors[e.attributes[S]];w[P]=dh[z.componentType].name,x[P]=!0===z.normalized}}return s.getDependency("bufferView",d).then(function(S){return new Promise(function(P,z){c.decodeDracoFile(S,function(W){for(const Y in W.attributes){const J=x[Y];void 0!==J&&(W.attributes[Y].normalized=J)}P(W)},v,w,ps,z)})})}}class Ia{constructor(){this.name=fm}extendTexture(e,s){return(void 0!==s.texCoord&&s.texCoord!==e.channel||void 0!==s.offset||void 0!==s.rotation||void 0!==s.scale)&&(e=e.clone(),void 0!==s.texCoord&&(e.channel=s.texCoord),void 0!==s.offset&&e.offset.fromArray(s.offset),void 0!==s.rotation&&(e.rotation=s.rotation),void 0!==s.scale&&e.repeat.fromArray(s.scale),e.needsUpdate=!0),e}}class Rv{constructor(){this.name=Iv}}class Ty extends Au{constructor(e,s,l,c){super(e,s,l,c)}copySampleValue_(e){const s=this.resultBuffer,l=this.sampleValues,c=this.valueSize,d=e*c*3+c;for(let g=0;g!==c;g++)s[g]=l[d+g];return s}interpolate_(e,s,l,c){const d=this.resultBuffer,g=this.sampleValues,v=this.valueSize,x=2*v,w=3*v,S=c-s,P=(l-s)/S,z=P*P,W=z*P,Y=e*w,tt=Y-w,J=-2*W+3*z,at=W-z,it=1-J,ct=at-z+P;for(let At=0;At!==v;At++)d[At]=it*g[tt+At+v]+ct*(g[tt+At+x]*S)+J*g[Y+At+v]+at*(g[Y+At]*S);return d}}const _y=new _s;class gm extends Ty{interpolate_(e,s,l,c){const d=super.interpolate_(e,s,l,c);return _y.fromArray(d).normalize().toArray(d),d}}const Oo={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},dh={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},lA={9728:be,9729:cn,9984:Ze,9985:bn,9986:ke,9987:Sn},cA={33071:Ut,33648:jt,10497:ki},uA={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Bs={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Cu={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},oa={CUBICSPLINE:void 0,LINEAR:Zs,STEP:$i};function fd(A,e,s){for(const l in s.extensions)void 0===A[l]&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[l]=s.extensions[l])}function ph(A,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(A.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Gx(A,e){if(A.updateMorphTargets(),void 0!==e.weights)for(let s=0,l=e.weights.length;s<l;s++)A.morphTargetInfluences[s]=e.weights[s];if(e.extras&&Array.isArray(e.extras.targetNames)){const s=e.extras.targetNames;if(A.morphTargetInfluences.length===s.length){A.morphTargetDictionary={};for(let l=0,c=s.length;l<c;l++)A.morphTargetDictionary[s[l]]=l}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Qx(A){let e;const s=A.extensions&&A.extensions[dm];if(e=s?"draco:"+s.bufferView+":"+s.indices+":"+ky(s.attributes):A.indices+":"+ky(A.attributes)+":"+A.mode,void 0!==A.targets)for(let l=0,c=A.targets.length;l<c;l++)e+=":"+ky(A.targets[l]);return e}function ky(A){let e="";const s=Object.keys(A).sort();for(let l=0,c=s.length;l<c;l++)e+=s[l]+":"+A[s[l]]+";";return e}function Ry(A){switch(A){case Int8Array:return.007874015748031496;case Uint8Array:return.00392156862745098;case Int16Array:return 3051850947599719e-20;case Uint16Array:return 15259021896696422e-21;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const Hx=new Yn;class Wx{constructor(e={},s={}){this.json=e,this.extensions={},this.plugins={},this.options=s,this.cache=new Rx,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let l=!1,c=!1,d=-1;typeof navigator<"u"&&(l=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),c=navigator.userAgent.indexOf("Firefox")>-1,d=c?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),this.textureLoader=typeof createImageBitmap>"u"||l||c&&d<98?new X0(this.options.manager):new uh(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new La(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,s){const l=this,c=this.json,d=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(g){return g._markDefs&&g._markDefs()}),Promise.all(this._invokeAll(function(g){return g.beforeRoot&&g.beforeRoot()})).then(function(){return Promise.all([l.getDependencies("scene"),l.getDependencies("animation"),l.getDependencies("camera")])}).then(function(g){const v={scene:g[0][c.scene||0],scenes:g[0],animations:g[1],cameras:g[2],asset:c.asset,parser:l,userData:{}};return fd(d,v,c),ph(v,c),Promise.all(l._invokeAll(function(x){return x.afterRoot&&x.afterRoot(v)})).then(function(){for(const x of v.scenes)x.updateMatrixWorld();e(v)})}).catch(s)}_markDefs(){const e=this.json.nodes||[],s=this.json.skins||[],l=this.json.meshes||[];for(let c=0,d=s.length;c<d;c++){const g=s[c].joints;for(let v=0,x=g.length;v<x;v++)e[g[v]].isBone=!0}for(let c=0,d=e.length;c<d;c++){const g=e[c];void 0!==g.mesh&&(this._addNodeRef(this.meshCache,g.mesh),void 0!==g.skin&&(l[g.mesh].isSkinnedMesh=!0)),void 0!==g.camera&&this._addNodeRef(this.cameraCache,g.camera)}}_addNodeRef(e,s){void 0!==s&&(void 0===e.refs[s]&&(e.refs[s]=e.uses[s]=0),e.refs[s]++)}_getNodeRef(e,s,l){if(e.refs[s]<=1)return l;const c=l.clone(),d=(g,v)=>{const x=this.associations.get(g);null!=x&&this.associations.set(v,x);for(const[w,S]of g.children.entries())d(S,v.children[w])};return d(l,c),c.name+="_instance_"+e.uses[s]++,c}_invokeOne(e){const s=Object.values(this.plugins);s.push(this);for(let l=0;l<s.length;l++){const c=e(s[l]);if(c)return c}return null}_invokeAll(e){const s=Object.values(this.plugins);s.unshift(this);const l=[];for(let c=0;c<s.length;c++){const d=e(s[c]);d&&l.push(d)}return l}getDependency(e,s){const l=e+":"+s;let c=this.cache.get(l);if(!c){switch(e){case"scene":c=this.loadScene(s);break;case"node":c=this._invokeOne(function(d){return d.loadNode&&d.loadNode(s)});break;case"mesh":c=this._invokeOne(function(d){return d.loadMesh&&d.loadMesh(s)});break;case"accessor":c=this.loadAccessor(s);break;case"bufferView":c=this._invokeOne(function(d){return d.loadBufferView&&d.loadBufferView(s)});break;case"buffer":c=this.loadBuffer(s);break;case"material":c=this._invokeOne(function(d){return d.loadMaterial&&d.loadMaterial(s)});break;case"texture":c=this._invokeOne(function(d){return d.loadTexture&&d.loadTexture(s)});break;case"skin":c=this.loadSkin(s);break;case"animation":c=this._invokeOne(function(d){return d.loadAnimation&&d.loadAnimation(s)});break;case"camera":c=this.loadCamera(s);break;default:if(c=this._invokeOne(function(d){return d!=this&&d.getDependency&&d.getDependency(e,s)}),!c)throw new Error("Unknown type: "+e)}this.cache.add(l,c)}return c}getDependencies(e){let s=this.cache.get(e);if(!s){const l=this;s=Promise.all((this.json[e+("mesh"===e?"es":"s")]||[]).map(function(d,g){return l.getDependency(e,g)})),this.cache.add(e,s)}return s}loadBuffer(e){const s=this.json.buffers[e],l=this.fileLoader;if(s.type&&"arraybuffer"!==s.type)throw new Error("THREE.GLTFLoader: "+s.type+" buffer type is not supported.");if(void 0===s.uri&&0===e)return Promise.resolve(this.extensions[aA].body);const c=this.options;return new Promise(function(d,g){l.load(vu.resolveURL(s.uri,c.path),d,void 0,function(){g(new Error('THREE.GLTFLoader: Failed to load buffer "'+s.uri+'".'))})})}loadBufferView(e){const s=this.json.bufferViews[e];return this.getDependency("buffer",s.buffer).then(function(l){const d=s.byteOffset||0;return l.slice(d,d+(s.byteLength||0))})}loadAccessor(e){const s=this,l=this.json,c=this.json.accessors[e];if(void 0===c.bufferView&&void 0===c.sparse){const g=uA[c.type],x=!0===c.normalized,w=new(0,dh[c.componentType])(c.count*g);return Promise.resolve(new wr(w,g,x))}const d=[];return d.push(void 0!==c.bufferView?this.getDependency("bufferView",c.bufferView):null),void 0!==c.sparse&&(d.push(this.getDependency("bufferView",c.sparse.indices.bufferView)),d.push(this.getDependency("bufferView",c.sparse.values.bufferView))),Promise.all(d).then(function(g){const v=g[0],x=uA[c.type],w=dh[c.componentType],S=w.BYTES_PER_ELEMENT,z=c.byteOffset||0,W=void 0!==c.bufferView?l.bufferViews[c.bufferView].byteStride:void 0,Y=!0===c.normalized;let tt,J;if(W&&W!==S*x){const at=Math.floor(z/W),it="InterleavedBuffer:"+c.bufferView+":"+c.componentType+":"+at+":"+c.count;let ct=s.cache.get(it);ct||(tt=new w(v,at*W,c.count*W/S),ct=new Ku(tt,W/S),s.cache.add(it,ct)),J=new ba(ct,x,z%W/S,Y)}else tt=null===v?new w(c.count*x):new w(v,z,c.count*x),J=new wr(tt,x,Y);if(void 0!==c.sparse){const At=c.sparse.values.byteOffset||0,Ft=new(0,dh[c.sparse.indices.componentType])(g[1],c.sparse.indices.byteOffset||0,c.sparse.count*uA.SCALAR),Tt=new w(g[2],At,c.sparse.count*x);null!==v&&(J=new wr(J.array.slice(),J.itemSize,J.normalized));for(let Pt=0,zt=Ft.length;Pt<zt;Pt++){const ee=Ft[Pt];if(J.setX(ee,Tt[Pt*x]),x>=2&&J.setY(ee,Tt[Pt*x+1]),x>=3&&J.setZ(ee,Tt[Pt*x+2]),x>=4&&J.setW(ee,Tt[Pt*x+3]),x>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return J})}loadTexture(e){const s=this.json,c=s.textures[e].source,d=s.images[c];let g=this.textureLoader;if(d.uri){const v=this.options.manager.getHandler(d.uri);null!==v&&(g=v)}return this.loadTextureImage(e,c,g)}loadTextureImage(e,s,l){const c=this,d=this.json,g=d.textures[e],v=d.images[s],x=(v.uri||v.bufferView)+":"+g.sampler;if(this.textureCache[x])return this.textureCache[x];const w=this.loadImageSource(s,l).then(function(S){S.flipY=!1,S.name=g.name||v.name||"",""===S.name&&"string"==typeof v.uri&&!1===v.uri.startsWith("data:image/")&&(S.name=v.uri);const P=(d.samplers||{})[g.sampler]||{};return S.magFilter=lA[P.magFilter]||cn,S.minFilter=lA[P.minFilter]||Sn,S.wrapS=cA[P.wrapS]||ki,S.wrapT=cA[P.wrapT]||ki,c.associations.set(S,{textures:e}),S}).catch(function(){return null});return this.textureCache[x]=w,w}loadImageSource(e,s){const l=this.json,c=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then(S=>S.clone());const d=l.images[e],g=self.URL||self.webkitURL;let v=d.uri||"",x=!1;if(void 0!==d.bufferView)v=this.getDependency("bufferView",d.bufferView).then(function(S){x=!0;const P=new Blob([S],{type:d.mimeType});return v=g.createObjectURL(P),v});else if(void 0===d.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const w=Promise.resolve(v).then(function(S){return new Promise(function(P,z){let W=P;!0===s.isImageBitmapLoader&&(W=function(Y){const tt=new Vi(Y);tt.needsUpdate=!0,P(tt)}),s.load(vu.resolveURL(S,c.path),W,void 0,z)})}).then(function(S){var P;return!0===x&&g.revokeObjectURL(v),S.userData.mimeType=d.mimeType||((P=d.uri).search(/\.jpe?g($|\?)/i)>0||0===P.search(/^data\:image\/jpeg/)?"image/jpeg":P.search(/\.webp($|\?)/i)>0||0===P.search(/^data\:image\/webp/)?"image/webp":"image/png"),S}).catch(function(S){throw console.error("THREE.GLTFLoader: Couldn't load texture",v),S});return this.sourceCache[e]=w,w}assignTexture(e,s,l,c){const d=this;return this.getDependency("texture",l.index).then(function(g){if(!g)return null;if(void 0!==l.texCoord&&l.texCoord>0&&((g=g.clone()).channel=l.texCoord),d.extensions[fm]){const v=void 0!==l.extensions?l.extensions[fm]:void 0;if(v){const x=d.associations.get(g);g=d.extensions[fm].extendTexture(g,v),d.associations.set(g,x)}}return void 0!==c&&(g.colorSpace=c),e[s]=g,g})}assignFinalMaterial(e){const s=e.geometry;let l=e.material;const c=void 0===s.attributes.tangent,d=void 0!==s.attributes.color,g=void 0===s.attributes.normal;if(e.isPoints){const v="PointsMaterial:"+l.uuid;let x=this.cache.get(v);x||(x=new wa,di.prototype.copy.call(x,l),x.color.copy(l.color),x.map=l.map,x.sizeAttenuation=!1,this.cache.add(v,x)),l=x}else if(e.isLine){const v="LineBasicMaterial:"+l.uuid;let x=this.cache.get(v);x||(x=new ls,di.prototype.copy.call(x,l),x.color.copy(l.color),x.map=l.map,this.cache.add(v,x)),l=x}if(c||d||g){let v="ClonedMaterial:"+l.uuid+":";c&&(v+="derivative-tangents:"),d&&(v+="vertex-colors:"),g&&(v+="flat-shading:");let x=this.cache.get(v);x||(x=l.clone(),d&&(x.vertexColors=!0),g&&(x.flatShading=!0),c&&(x.normalScale&&(x.normalScale.y*=-1),x.clearcoatNormalScale&&(x.clearcoatNormalScale.y*=-1)),this.cache.add(v,x),this.associations.set(x,this.associations.get(l))),l=x}e.material=l}getMaterialType(){return kp}loadMaterial(e){const s=this,c=this.extensions,d=this.json.materials[e];let g;const v={},x=[];if((d.extensions||{})[pm]){const S=c[pm];g=S.getMaterialType(),x.push(S.extendParams(v,d,s))}else{const S=d.pbrMetallicRoughness||{};if(v.color=new En(1,1,1),v.opacity=1,Array.isArray(S.baseColorFactor)){const P=S.baseColorFactor;v.color.setRGB(P[0],P[1],P[2],ps),v.opacity=P[3]}void 0!==S.baseColorTexture&&x.push(s.assignTexture(v,"map",S.baseColorTexture,qi)),v.metalness=void 0!==S.metallicFactor?S.metallicFactor:1,v.roughness=void 0!==S.roughnessFactor?S.roughnessFactor:1,void 0!==S.metallicRoughnessTexture&&(x.push(s.assignTexture(v,"metalnessMap",S.metallicRoughnessTexture)),x.push(s.assignTexture(v,"roughnessMap",S.metallicRoughnessTexture))),g=this._invokeOne(function(P){return P.getMaterialType&&P.getMaterialType(e)}),x.push(Promise.all(this._invokeAll(function(P){return P.extendMaterialParams&&P.extendMaterialParams(e,v)})))}!0===d.doubleSided&&(v.side=lt);const w=d.alphaMode||"OPAQUE";if("BLEND"===w?(v.transparent=!0,v.depthWrite=!1):(v.transparent=!1,"MASK"===w&&(v.alphaTest=void 0!==d.alphaCutoff?d.alphaCutoff:.5)),void 0!==d.normalTexture&&g!==no&&(x.push(s.assignTexture(v,"normalMap",d.normalTexture)),v.normalScale=new Ye(1,1),void 0!==d.normalTexture.scale)){const S=d.normalTexture.scale;v.normalScale.set(S,S)}if(void 0!==d.occlusionTexture&&g!==no&&(x.push(s.assignTexture(v,"aoMap",d.occlusionTexture)),void 0!==d.occlusionTexture.strength&&(v.aoMapIntensity=d.occlusionTexture.strength)),void 0!==d.emissiveFactor&&g!==no){const S=d.emissiveFactor;v.emissive=(new En).setRGB(S[0],S[1],S[2],ps)}return void 0!==d.emissiveTexture&&g!==no&&x.push(s.assignTexture(v,"emissiveMap",d.emissiveTexture,qi)),Promise.all(x).then(function(){const S=new g(v);return d.name&&(S.name=d.name),ph(S,d),s.associations.set(S,{materials:e}),d.extensions&&fd(c,S,d),S})}createUniqueName(e){const s=pi.sanitizeNodeName(e||"");return s in this.nodeNamesUsed?s+"_"+ ++this.nodeNamesUsed[s]:(this.nodeNamesUsed[s]=0,s)}loadGeometries(e){const s=this,l=this.extensions,c=this.primitiveCache;function d(v){return l[dm].decodePrimitive(v,s).then(function(x){return Bv(x,v,s)})}const g=[];for(let v=0,x=e.length;v<x;v++){const w=e[v],S=Qx(w),P=c[S];if(P)g.push(P.promise);else{let z;z=w.extensions&&w.extensions[dm]?d(w):Bv(new gr,w,s),c[S]={primitive:w,promise:z},g.push(z)}}return Promise.all(g)}loadMesh(e){const s=this,c=this.extensions,d=this.json.meshes[e],g=d.primitives,v=[];for(let w=0,S=g.length;w<S;w++){const P=void 0===g[w].material?(void 0===(x=this.cache).DefaultMaterial&&(x.DefaultMaterial=new kp({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Q})),x.DefaultMaterial):this.getDependency("material",g[w].material);v.push(P)}var x;return v.push(s.loadGeometries(g)),Promise.all(v).then(function(w){const S=w.slice(0,w.length-1),P=w[w.length-1],z=[];for(let Y=0,tt=P.length;Y<tt;Y++){const J=P[Y],at=g[Y];let it;const ct=S[Y];if(at.mode===Oo.TRIANGLES||at.mode===Oo.TRIANGLE_STRIP||at.mode===Oo.TRIANGLE_FAN||void 0===at.mode)it=!0===d.isSkinnedMesh?new Lf(J,ct):new os(J,ct),!0===it.isSkinnedMesh&&it.normalizeSkinWeights(),at.mode===Oo.TRIANGLE_STRIP?it.geometry=wy(it.geometry,pl):at.mode===Oo.TRIANGLE_FAN&&(it.geometry=wy(it.geometry,yo));else if(at.mode===Oo.LINES)it=new Ai(J,ct);else if(at.mode===Oo.LINE_STRIP)it=new Ni(J,ct);else if(at.mode===Oo.LINE_LOOP)it=new zf(J,ct);else{if(at.mode!==Oo.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+at.mode);it=new nh(J,ct)}Object.keys(it.geometry.morphAttributes).length>0&&Gx(it,d),it.name=s.createUniqueName(d.name||"mesh_"+e),ph(it,d),at.extensions&&fd(c,it,at),s.assignFinalMaterial(it),z.push(it)}for(let Y=0,tt=z.length;Y<tt;Y++)s.associations.set(z[Y],{meshes:e,primitives:Y});if(1===z.length)return d.extensions&&fd(c,z[0],d),z[0];const W=new tl;d.extensions&&fd(c,W,d),s.associations.set(W,{meshes:e});for(let Y=0,tt=z.length;Y<tt;Y++)W.add(z[Y]);return W})}loadCamera(e){let s;const l=this.json.cameras[e],c=l[l.type];if(c)return"perspective"===l.type?s=new ea(Fu.radToDeg(c.yfov),c.aspectRatio||1,c.znear||1,c.zfar||2e6):"orthographic"===l.type&&(s=new bf(-c.xmag,c.xmag,c.ymag,-c.ymag,c.znear,c.zfar)),l.name&&(s.name=this.createUniqueName(l.name)),ph(s,l),Promise.resolve(s);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const s=this.json.skins[e],l=[];for(let c=0,d=s.joints.length;c<d;c++)l.push(this._loadNodeShallow(s.joints[c]));return l.push(void 0!==s.inverseBindMatrices?this.getDependency("accessor",s.inverseBindMatrices):null),Promise.all(l).then(function(c){const d=c.pop(),g=c,v=[],x=[];for(let w=0,S=g.length;w<S;w++){const P=g[w];if(P){v.push(P);const z=new Yn;null!==d&&z.fromArray(d.array,16*w),x.push(z)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',s.joints[w])}return new Us(v,x)})}loadAnimation(e){const l=this,c=this.json.animations[e],d=c.name?c.name:"animation_"+e,g=[],v=[],x=[],w=[],S=[];for(let P=0,z=c.channels.length;P<z;P++){const W=c.channels[P],Y=c.samplers[W.sampler],tt=W.target,at=void 0!==c.parameters?c.parameters[Y.input]:Y.input,it=void 0!==c.parameters?c.parameters[Y.output]:Y.output;void 0!==tt.node&&(g.push(this.getDependency("node",tt.node)),v.push(this.getDependency("accessor",at)),x.push(this.getDependency("accessor",it)),w.push(Y),S.push(tt))}return Promise.all([Promise.all(g),Promise.all(v),Promise.all(x),Promise.all(w),Promise.all(S)]).then(function(P){const z=P[0],W=P[1],Y=P[2],tt=P[3],J=P[4],at=[];for(let it=0,ct=z.length;it<ct;it++){const At=z[it],Ft=W[it],Tt=Y[it],Pt=tt[it],zt=J[it];if(void 0===At)continue;At.updateMatrix&&At.updateMatrix();const ee=l._createAnimationTracks(At,Ft,Tt,Pt,zt);if(ee)for(let ce=0;ce<ee.length;ce++)at.push(ee[ce])}return new Rp(d,void 0,at)})}createNodeMesh(e){const l=this,c=this.json.nodes[e];return void 0===c.mesh?null:l.getDependency("mesh",c.mesh).then(function(d){const g=l._getNodeRef(l.meshCache,c.mesh,d);return void 0!==c.weights&&g.traverse(function(v){if(v.isMesh)for(let x=0,w=c.weights.length;x<w;x++)v.morphTargetInfluences[x]=c.weights[x]}),g})}loadNode(e){const s=this,l=this.json.nodes[e],c=s._loadNodeShallow(e),d=[],g=l.children||[];for(let x=0,w=g.length;x<w;x++)d.push(s.getDependency("node",g[x]));const v=void 0===l.skin?Promise.resolve(null):s.getDependency("skin",l.skin);return Promise.all([c,Promise.all(d),v]).then(function(x){const w=x[0],S=x[1],P=x[2];null!==P&&w.traverse(function(z){z.isSkinnedMesh&&z.bind(P,Hx)});for(let z=0,W=S.length;z<W;z++)w.add(S[z]);return w})}_loadNodeShallow(e){const l=this.extensions,c=this;if(void 0!==this.nodeCache[e])return this.nodeCache[e];const d=this.json.nodes[e],g=d.name?c.createUniqueName(d.name):"",v=[],x=c._invokeOne(function(w){return w.createNodeMesh&&w.createNodeMesh(e)});return x&&v.push(x),void 0!==d.camera&&v.push(c.getDependency("camera",d.camera).then(function(w){return c._getNodeRef(c.cameraCache,d.camera,w)})),c._invokeAll(function(w){return w.createNodeAttachment&&w.createNodeAttachment(e)}).forEach(function(w){v.push(w)}),this.nodeCache[e]=Promise.all(v).then(function(w){let S;if(S=!0===d.isBone?new du:w.length>1?new tl:1===w.length?w[0]:new hi,S!==w[0])for(let P=0,z=w.length;P<z;P++)S.add(w[P]);if(d.name&&(S.userData.name=d.name,S.name=g),ph(S,d),d.extensions&&fd(l,S,d),void 0!==d.matrix){const P=new Yn;P.fromArray(d.matrix),S.applyMatrix4(P)}else void 0!==d.translation&&S.position.fromArray(d.translation),void 0!==d.rotation&&S.quaternion.fromArray(d.rotation),void 0!==d.scale&&S.scale.fromArray(d.scale);return c.associations.has(S)||c.associations.set(S,{}),c.associations.get(S).nodes=e,S}),this.nodeCache[e]}loadScene(e){const s=this.extensions,l=this.json.scenes[e],c=this,d=new tl;l.name&&(d.name=c.createUniqueName(l.name)),ph(d,l),l.extensions&&fd(s,d,l);const g=l.nodes||[],v=[];for(let x=0,w=g.length;x<w;x++)v.push(c.getDependency("node",g[x]));return Promise.all(v).then(function(x){for(let w=0,S=x.length;w<S;w++)d.add(x[w]);return c.associations=(w=>{const S=new Map;for(const[P,z]of c.associations)(P instanceof di||P instanceof Vi)&&S.set(P,z);return w.traverse(P=>{const z=c.associations.get(P);null!=z&&S.set(P,z)}),S})(d),d})}_createAnimationTracks(e,s,l,c,d){const g=[],v=e.name?e.name:e.uuid,x=[];let w;switch(Cu[d.path]===Cu.weights?e.traverse(function(z){z.morphTargetInfluences&&x.push(z.name?z.name:z.uuid)}):x.push(v),Cu[d.path]){case Cu.weights:w=ld;break;case Cu.rotation:w=il;break;case Cu.position:case Cu.scale:w=ud;break;default:w=1===l.itemSize?ld:ud}const S=void 0!==c.interpolation?oa[c.interpolation]:Zs,P=this._getArrayFromAccessor(l);for(let z=0,W=x.length;z<W;z++){const Y=new w(x[z]+"."+Cu[d.path],s.array,P,S);"CUBICSPLINE"===c.interpolation&&this._createCubicSplineTrackInterpolant(Y),g.push(Y)}return g}_getArrayFromAccessor(e){let s=e.array;if(e.normalized){const l=Ry(s.constructor),c=new Float32Array(s.length);for(let d=0,g=s.length;d<g;d++)c[d]=s[d]*l;s=c}return s}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){return new(this instanceof il?gm:Ty)(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Bv(A,e,s){const l=e.attributes,c=[];function d(g,v){return s.getDependency("accessor",g).then(function(x){A.setAttribute(v,x)})}for(const g in l){const v=Bs[g]||g.toLowerCase();v in A.attributes||c.push(d(l[g],v))}if(void 0!==e.indices&&!A.index){const g=s.getDependency("accessor",e.indices).then(function(v){A.setIndex(v)});c.push(g)}return Jr.workingColorSpace!==ps&&"COLOR_0"in l&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Jr.workingColorSpace}" not supported.`),ph(A,e),function(g,v,x){const w=v.attributes,S=new ta;if(void 0===w.POSITION)return;{const W=x.json.accessors[w.POSITION],Y=W.min,tt=W.max;if(void 0===Y||void 0===tt)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(S.set(new Dt(Y[0],Y[1],Y[2]),new Dt(tt[0],tt[1],tt[2])),W.normalized){const J=Ry(dh[W.componentType]);S.min.multiplyScalar(J),S.max.multiplyScalar(J)}}const P=v.targets;if(void 0!==P){const W=new Dt,Y=new Dt;for(let tt=0,J=P.length;tt<J;tt++){const at=P[tt];if(void 0!==at.POSITION){const it=x.json.accessors[at.POSITION],ct=it.min,At=it.max;if(void 0!==ct&&void 0!==At){if(Y.setX(Math.max(Math.abs(ct[0]),Math.abs(At[0]))),Y.setY(Math.max(Math.abs(ct[1]),Math.abs(At[1]))),Y.setZ(Math.max(Math.abs(ct[2]),Math.abs(At[2]))),it.normalized){const Ft=Ry(dh[it.componentType]);Y.multiplyScalar(Ft)}W.max(Y)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}S.expandByVector(W)}g.boundingBox=S;const z=new Ls;S.getCenter(z.center),z.radius=S.min.distanceTo(S.max)/2,g.boundingSphere=z}(A,e,s),Promise.all(c).then(function(){return void 0!==e.targets?function(g,v,x){let w=!1,S=!1,P=!1;for(let tt=0,J=v.length;tt<J;tt++){const at=v[tt];if(void 0!==at.POSITION&&(w=!0),void 0!==at.NORMAL&&(S=!0),void 0!==at.COLOR_0&&(P=!0),w&&S&&P)break}if(!w&&!S&&!P)return Promise.resolve(g);const z=[],W=[],Y=[];for(let tt=0,J=v.length;tt<J;tt++){const at=v[tt];if(w){const it=void 0!==at.POSITION?x.getDependency("accessor",at.POSITION):g.attributes.position;z.push(it)}if(S){const it=void 0!==at.NORMAL?x.getDependency("accessor",at.NORMAL):g.attributes.normal;W.push(it)}if(P){const it=void 0!==at.COLOR_0?x.getDependency("accessor",at.COLOR_0):g.attributes.color;Y.push(it)}}return Promise.all([Promise.all(z),Promise.all(W),Promise.all(Y)]).then(function(tt){const at=tt[1],it=tt[2];return w&&(g.morphAttributes.position=tt[0]),S&&(g.morphAttributes.normal=at),P&&(g.morphAttributes.color=it),g.morphTargetsRelative=!0,g})}(A,e.targets,s):A})}class Pp{constructor(e=4){this.pool=e,this.queue=[],this.workers=[],this.workersResolve=[],this.workerStatus=0}_initWorker(e){if(!this.workers[e]){const s=this.workerCreator();s.addEventListener("message",this._onMessage.bind(this,e)),this.workers[e]=s}}_getIdleWorker(){for(let e=0;e<this.pool;e++)if(!(this.workerStatus&1<<e))return e;return-1}_onMessage(e,s){const l=this.workersResolve[e];if(l&&l(s),this.queue.length){const{resolve:c,msg:d,transfer:g}=this.queue.shift();this.workersResolve[e]=c,this.workers[e].postMessage(d,g)}else this.workerStatus^=1<<e}setWorkerCreator(e){this.workerCreator=e}setWorkerLimit(e){this.pool=e}postMessage(e,s){return new Promise(l=>{const c=this._getIdleWorker();-1!==c?(this._initWorker(c),this.workerStatus|=1<<c,this.workersResolve[c]=l,this.workers[c].postMessage(e,s)):this.queue.push({resolve:l,msg:e,transfer:s})})}dispose(){this.workers.forEach(e=>e.terminate()),this.workersResolve.length=0,this.workers.length=0,this.queue.length=0,this.workerStatus=0}}var Ns=I(9922).hp;class al{constructor(){this.vkFormat=0,this.typeSize=1,this.pixelWidth=0,this.pixelHeight=0,this.pixelDepth=0,this.layerCount=0,this.faceCount=1,this.supercompressionScheme=0,this.levels=[],this.dataFormatDescriptor=[{vendorId:0,descriptorType:0,descriptorBlockSize:0,versionNumber:2,colorModel:0,colorPrimaries:1,transferFunction:2,flags:0,texelBlockDimension:[0,0,0,0],bytesPlane:[0,0,0,0,0,0,0,0],samples:[]}],this.keyValue={},this.globalData=null}}class Up{constructor(e,s,l,c){this._dataView=new DataView(e.buffer,e.byteOffset+s,l),this._littleEndian=c,this._offset=0}_nextUint8(){const e=this._dataView.getUint8(this._offset);return this._offset+=1,e}_nextUint16(){const e=this._dataView.getUint16(this._offset,this._littleEndian);return this._offset+=2,e}_nextUint32(){const e=this._dataView.getUint32(this._offset,this._littleEndian);return this._offset+=4,e}_nextUint64(){const e=this._dataView.getUint32(this._offset,this._littleEndian)+4294967296*this._dataView.getUint32(this._offset+4,this._littleEndian);return this._offset+=8,e}_nextInt32(){const e=this._dataView.getInt32(this._offset,this._littleEndian);return this._offset+=4,e}_skip(e){return this._offset+=e,this}_scan(e,s=0){const l=this._offset;let c=0;for(;this._dataView.getUint8(this._offset)!==s&&c<e;)c++,this._offset++;return c<e&&this._offset++,new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+l,c)}}new Uint8Array([0]);const Sa=[171,75,84,88,32,50,48,187,13,10,26,10];function fh(A){return typeof TextDecoder<"u"?(new TextDecoder).decode(A):Ns.from(A).toString("utf8")}var Nv=I(9922).hp;let hA,Iu,dA;const Bc={env:{emscripten_notify_memory_growth:function(A){dA=new Uint8Array(Iu.exports.memory.buffer)}}};class zp{init(){return hA||(hA=typeof fetch<"u"?fetch("data:application/wasm;base64,"+Su).then(e=>e.arrayBuffer()).then(e=>WebAssembly.instantiate(e,Bc)).then(this._init):WebAssembly.instantiate(Nv.from(Su,"base64"),Bc).then(this._init),hA)}_init(e){Iu=e.instance,Bc.env.emscripten_notify_memory_growth(0)}decode(e,s=0){if(!Iu)throw new Error("ZSTDDecoder: Await .init() before decoding.");const l=e.byteLength,c=Iu.exports.malloc(l);dA.set(e,c),s=s||Number(Iu.exports.ZSTD_findDecompressedSize(c,l));const d=Iu.exports.malloc(s),g=Iu.exports.ZSTD_decompress(d,s,c,l),v=dA.slice(d,d+g);return Iu.exports.free(c),Iu.exports.free(d),v}}const Su="AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",ol=new WeakMap;let $p,md=0;class lo extends Ca{constructor(e){super(e),this.transcoderPath="",this.transcoderBinary=null,this.transcoderPending=null,this.workerPool=new Pp,this.workerSourceURL="",this.workerConfig=null,typeof MSC_TRANSCODER<"u"&&console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')}setTranscoderPath(e){return this.transcoderPath=e,this}setWorkerLimit(e){return this.workerPool.setWorkerLimit(e),this}async detectSupportAsync(e){return this.workerConfig={astcSupported:await e.hasFeatureAsync("texture-compression-astc"),etc1Supported:await e.hasFeatureAsync("texture-compression-etc1"),etc2Supported:await e.hasFeatureAsync("texture-compression-etc2"),dxtSupported:await e.hasFeatureAsync("texture-compression-bc"),bptcSupported:await e.hasFeatureAsync("texture-compression-bptc"),pvrtcSupported:await e.hasFeatureAsync("texture-compression-pvrtc")},this}detectSupport(e){return this.workerConfig=!0===e.isWebGPURenderer?{astcSupported:e.hasFeature("texture-compression-astc"),etc1Supported:e.hasFeature("texture-compression-etc1"),etc2Supported:e.hasFeature("texture-compression-etc2"),dxtSupported:e.hasFeature("texture-compression-bc"),bptcSupported:e.hasFeature("texture-compression-bptc"),pvrtcSupported:e.hasFeature("texture-compression-pvrtc")}:{astcSupported:e.extensions.has("WEBGL_compressed_texture_astc"),etc1Supported:e.extensions.has("WEBGL_compressed_texture_etc1"),etc2Supported:e.extensions.has("WEBGL_compressed_texture_etc"),dxtSupported:e.extensions.has("WEBGL_compressed_texture_s3tc"),bptcSupported:e.extensions.has("EXT_texture_compression_bptc"),pvrtcSupported:e.extensions.has("WEBGL_compressed_texture_pvrtc")||e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")},this}init(){if(!this.transcoderPending){const e=new La(this.manager);e.setPath(this.transcoderPath),e.setWithCredentials(this.withCredentials);const s=e.loadAsync("basis_transcoder.js"),l=new La(this.manager);l.setPath(this.transcoderPath),l.setResponseType("arraybuffer"),l.setWithCredentials(this.withCredentials);const c=l.loadAsync("basis_transcoder.wasm");this.transcoderPending=Promise.all([s,c]).then(([d,g])=>{const v=lo.BasisWorker.toString(),x=["/* constants */","let _EngineFormat = "+JSON.stringify(lo.EngineFormat),"let _TranscoderFormat = "+JSON.stringify(lo.TranscoderFormat),"let _BasisFormat = "+JSON.stringify(lo.BasisFormat),"/* basis_transcoder.js */",d,"/* worker */",v.substring(v.indexOf("{")+1,v.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([x])),this.transcoderBinary=g,this.workerPool.setWorkerCreator(()=>{const w=new Worker(this.workerSourceURL),S=this.transcoderBinary.slice(0);return w.postMessage({type:"init",config:this.workerConfig,transcoderBinary:S},[S]),w})}),md>0&&console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),md++}return this.transcoderPending}load(e,s,l,c){if(null===this.workerConfig)throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");const d=new La(this.manager);d.setResponseType("arraybuffer"),d.setWithCredentials(this.withCredentials),d.load(e,g=>{if(ol.has(g))return ol.get(g).promise.then(s).catch(c);this._createTexture(g).then(v=>s?s(v):null).catch(c)},l,c)}_createTextureFrom(e,s){const{faces:l,width:c,height:d,format:g,type:v,error:x,dfdFlags:w}=e;if("error"===v)return Promise.reject(x);let S;if(6===s.faceCount)S=new vp(l,g,jn);else{const P=l[0].mipmaps;S=s.layerCount>1?new $1(P,c,d,s.layerCount,g,jn):new Ea(P,c,d,g,jn)}return S.minFilter=1===l[0].mipmaps.length?cn:Sn,S.magFilter=cn,S.generateMipmaps=!1,S.needsUpdate=!0,S.colorSpace=Ny(s),S.premultiplyAlpha=!!(1&w),S}async _createTexture(e,s={}){const l=function(g){const v=new Uint8Array(g.buffer,g.byteOffset,Sa.length);if(v[0]!==Sa[0]||v[1]!==Sa[1]||v[2]!==Sa[2]||v[3]!==Sa[3]||v[4]!==Sa[4]||v[5]!==Sa[5]||v[6]!==Sa[6]||v[7]!==Sa[7]||v[8]!==Sa[8]||v[9]!==Sa[9]||v[10]!==Sa[10]||v[11]!==Sa[11])throw new Error("Missing KTX 2.0 identifier.");const x=new al,w=17*Uint32Array.BYTES_PER_ELEMENT,S=new Up(g,Sa.length,w,!0);x.vkFormat=S._nextUint32(),x.typeSize=S._nextUint32(),x.pixelWidth=S._nextUint32(),x.pixelHeight=S._nextUint32(),x.pixelDepth=S._nextUint32(),x.layerCount=S._nextUint32(),x.faceCount=S._nextUint32();const P=S._nextUint32();x.supercompressionScheme=S._nextUint32();const z=S._nextUint32(),W=S._nextUint32(),Y=S._nextUint32(),tt=S._nextUint32(),J=S._nextUint64(),at=S._nextUint64(),it=new Up(g,Sa.length+w,3*P*8,!0);for(let In=0;In<P;In++)x.levels.push({levelData:new Uint8Array(g.buffer,g.byteOffset+it._nextUint64(),it._nextUint64()),uncompressedByteLength:it._nextUint64()});const ct=new Up(g,z,W,!0),At={vendorId:ct._skip(4)._nextUint16(),descriptorType:ct._nextUint16(),versionNumber:ct._nextUint16(),descriptorBlockSize:ct._nextUint16(),colorModel:ct._nextUint8(),colorPrimaries:ct._nextUint8(),transferFunction:ct._nextUint8(),flags:ct._nextUint8(),texelBlockDimension:[ct._nextUint8(),ct._nextUint8(),ct._nextUint8(),ct._nextUint8()],bytesPlane:[ct._nextUint8(),ct._nextUint8(),ct._nextUint8(),ct._nextUint8(),ct._nextUint8(),ct._nextUint8(),ct._nextUint8(),ct._nextUint8()],samples:[]},Ft=(At.descriptorBlockSize/4-6)/4;for(let In=0;In<Ft;In++){const Mn={bitOffset:ct._nextUint16(),bitLength:ct._nextUint8(),channelType:ct._nextUint8(),samplePosition:[ct._nextUint8(),ct._nextUint8(),ct._nextUint8(),ct._nextUint8()],sampleLower:-1/0,sampleUpper:1/0};64&Mn.channelType?(Mn.sampleLower=ct._nextInt32(),Mn.sampleUpper=ct._nextInt32()):(Mn.sampleLower=ct._nextUint32(),Mn.sampleUpper=ct._nextUint32()),At.samples[In]=Mn}x.dataFormatDescriptor.length=0,x.dataFormatDescriptor.push(At);const Tt=new Up(g,Y,tt,!0);for(;Tt._offset<tt;){const In=Tt._nextUint32(),Mn=Tt._scan(In),Ce=fh(Mn),rn=Tt._scan(In-Mn.byteLength);x.keyValue[Ce]=Ce.match(/^ktx/i)?fh(rn):rn,Tt._offset%4&&Tt._skip(4-Tt._offset%4)}if(at<=0)return x;const Pt=new Up(g,J,at,!0),zt=Pt._nextUint16(),ee=Pt._nextUint16(),ce=Pt._nextUint32(),ne=Pt._nextUint32(),ge=Pt._nextUint32(),ie=Pt._nextUint32(),pe=[];for(let In=0;In<P;In++)pe.push({imageFlags:Pt._nextUint32(),rgbSliceByteOffset:Pt._nextUint32(),rgbSliceByteLength:Pt._nextUint32(),alphaSliceByteOffset:Pt._nextUint32(),alphaSliceByteLength:Pt._nextUint32()});const Oe=J+Pt._offset,Pe=Oe+ce,ze=Pe+ne,Fe=ze+ge,Dn=new Uint8Array(g.buffer,g.byteOffset+Oe,ce),Nn=new Uint8Array(g.buffer,g.byteOffset+Pe,ne),fn=new Uint8Array(g.buffer,g.byteOffset+ze,ge),xn=new Uint8Array(g.buffer,g.byteOffset+Fe,ie);return x.globalData={endpointCount:zt,selectorCount:ee,imageDescs:pe,endpointsData:Dn,selectorsData:Nn,tablesData:fn,extendedData:xn},x}(new Uint8Array(e));if(0!==l.vkFormat)return async function(g){const{vkFormat:v}=g;if(void 0===Vp[v])throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");let x;2===g.supercompressionScheme&&($p||($p=new Promise(async P=>{const z=new zp;await z.init(),P(z)})),x=await $p);const w=[];for(let P=0;P<g.levels.length;P++){const z=Math.max(1,g.pixelWidth>>P),W=Math.max(1,g.pixelHeight>>P),Y=g.pixelDepth?Math.max(1,g.pixelDepth>>P):0,tt=g.levels[P];let J,at;if(0===g.supercompressionScheme)J=tt.levelData;else{if(2!==g.supercompressionScheme)throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");J=x.decode(tt.levelData,tt.uncompressedByteLength)}at=Am[v]===wn?new Float32Array(J.buffer,J.byteOffset,J.byteLength/Float32Array.BYTES_PER_ELEMENT):Am[v]===br?new Uint16Array(J.buffer,J.byteOffset,J.byteLength/Uint16Array.BYTES_PER_ELEMENT):J,w.push({data:at,width:z,height:W,depth:Y})}let S;if(By.has(Vp[v]))S=0===g.pixelDepth?new pu(w[0].data,g.pixelWidth,g.pixelHeight):new Rh(w[0].data,g.pixelWidth,g.pixelHeight,g.pixelDepth);else{if(g.pixelDepth>0)throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");S=new Ea(w,g.pixelWidth,g.pixelHeight)}return S.mipmaps=w,S.type=Am[v],S.format=Vp[v],S.colorSpace=Ny(g),S.needsUpdate=!0,Promise.resolve(S)}(l);const c=s,d=this.init().then(()=>this.workerPool.postMessage({type:"transcode",buffer:e,taskConfig:c},[e])).then(g=>this._createTextureFrom(g.data,l));return ol.set(e,{promise:d}),d}dispose(){return this.workerPool.dispose(),this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),md--,this}}lo.BasisFormat={ETC1S:0,UASTC_4x4:1},lo.TranscoderFormat={ETC1:0,ETC2:1,BC1:2,BC3:3,BC4:4,BC5:5,BC7_M6_OPAQUE_ONLY:6,BC7_M5:7,PVRTC1_4_RGB:8,PVRTC1_4_RGBA:9,ASTC_4x4:10,ATC_RGB:11,ATC_RGBA_INTERPOLATED_ALPHA:12,RGBA32:13,RGB565:14,BGR565:15,RGBA4444:16},lo.EngineFormat={RGBAFormat:de,RGBA_ASTC_4x4_Format:It,RGBA_BPTC_Format:_r,RGBA_ETC2_EAC_Format:mt,RGBA_PVRTC_4BPPV1_Format:Ol,RGBA_S3TC_DXT5_Format:Ks,RGB_ETC1_Format:Li,RGB_ETC2_Format:K,RGB_PVRTC_4BPPV1_Format:Ka,RGBA_S3TC_DXT1_Format:Pa},lo.BasisWorker=function(){let A,e,s;const l=_EngineFormat,c=_TranscoderFormat,d=_BasisFormat;self.addEventListener("message",function(P){const z=P.data;switch(z.type){case"init":A=z.config,W=z.transcoderBinary,e=new Promise(Y=>{s={wasmBinary:W,onRuntimeInitialized:Y},BASIS(s)}).then(()=>{s.initializeBasis(),void 0===s.KTX2File&&console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")});break;case"transcode":e.then(()=>{try{const{faces:Y,buffers:tt,width:J,height:at,hasAlpha:it,format:ct,dfdFlags:At}=function(Ft){const Tt=new s.KTX2File(new Uint8Array(Ft));function Pt(){Tt.close(),Tt.delete()}if(!Tt.isValid())throw Pt(),new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");const zt=Tt.isUASTC()?d.UASTC_4x4:d.ETC1S,ee=Tt.getWidth(),ce=Tt.getHeight(),ne=Tt.getLayers()||1,ge=Tt.getLevels(),ie=Tt.getFaces(),pe=Tt.getHasAlpha(),Oe=Tt.getDFDFlags(),{transcoderFormat:Pe,engineFormat:ze}=function(Nn,fn,xn,In){let Mn,Ce;const rn=Nn===d.ETC1S?v:x;for(let On=0;On<rn.length;On++){const ln=rn[On];if(A[ln.if]&&ln.basisFormat.includes(Nn)&&!(In&&ln.transcoderFormat.length<2)&&(!ln.needsPowerOfTwo||w(fn)&&w(xn)))return Mn=ln.transcoderFormat[In?1:0],Ce=ln.engineFormat[In?1:0],{transcoderFormat:Mn,engineFormat:Ce}}return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."),Mn=c.RGBA32,Ce=l.RGBAFormat,{transcoderFormat:Mn,engineFormat:Ce}}(zt,ee,ce,pe);if(!ee||!ce||!ge)throw Pt(),new Error("THREE.KTX2Loader:\tInvalid texture");if(!Tt.startTranscoding())throw Pt(),new Error("THREE.KTX2Loader: .startTranscoding failed");const Fe=[],Dn=[];for(let Nn=0;Nn<ie;Nn++){const fn=[];for(let xn=0;xn<ge;xn++){const In=[];let Mn,Ce;for(let On=0;On<ne;On++){const ln=Tt.getImageLevelInfo(xn,On,Nn);0!==Nn||0!==xn||0!==On||ln.origWidth%4==0&&ln.origHeight%4==0||console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),ge>1?(Mn=ln.origWidth,Ce=ln.origHeight):(Mn=ln.width,Ce=ln.height);const Lt=new Uint8Array(Tt.getImageTranscodedSizeInBytes(xn,On,0,Pe));if(!Tt.transcodeImage(Lt,xn,On,Nn,Pe,0,-1,-1))throw Pt(),new Error("THREE.KTX2Loader: .transcodeImage failed.");In.push(Lt)}const rn=S(In);fn.push({data:rn,width:Mn,height:Ce}),Dn.push(rn.buffer)}Fe.push({mipmaps:fn,width:ee,height:ce,format:ze})}return Pt(),{faces:Fe,buffers:Dn,width:ee,height:ce,hasAlpha:pe,format:ze,dfdFlags:Oe}}(z.buffer);self.postMessage({type:"transcode",id:z.id,faces:Y,width:J,height:at,hasAlpha:it,format:ct,dfdFlags:At},tt)}catch(Y){console.error(Y),self.postMessage({type:"error",id:z.id,error:Y.message})}})}var W});const g=[{if:"astcSupported",basisFormat:[d.UASTC_4x4],transcoderFormat:[c.ASTC_4x4,c.ASTC_4x4],engineFormat:[l.RGBA_ASTC_4x4_Format,l.RGBA_ASTC_4x4_Format],priorityETC1S:1/0,priorityUASTC:1,needsPowerOfTwo:!1},{if:"bptcSupported",basisFormat:[d.ETC1S,d.UASTC_4x4],transcoderFormat:[c.BC7_M5,c.BC7_M5],engineFormat:[l.RGBA_BPTC_Format,l.RGBA_BPTC_Format],priorityETC1S:3,priorityUASTC:2,needsPowerOfTwo:!1},{if:"dxtSupported",basisFormat:[d.ETC1S,d.UASTC_4x4],transcoderFormat:[c.BC1,c.BC3],engineFormat:[l.RGBA_S3TC_DXT1_Format,l.RGBA_S3TC_DXT5_Format],priorityETC1S:4,priorityUASTC:5,needsPowerOfTwo:!1},{if:"etc2Supported",basisFormat:[d.ETC1S,d.UASTC_4x4],transcoderFormat:[c.ETC1,c.ETC2],engineFormat:[l.RGB_ETC2_Format,l.RGBA_ETC2_EAC_Format],priorityETC1S:1,priorityUASTC:3,needsPowerOfTwo:!1},{if:"etc1Supported",basisFormat:[d.ETC1S,d.UASTC_4x4],transcoderFormat:[c.ETC1],engineFormat:[l.RGB_ETC1_Format],priorityETC1S:2,priorityUASTC:4,needsPowerOfTwo:!1},{if:"pvrtcSupported",basisFormat:[d.ETC1S,d.UASTC_4x4],transcoderFormat:[c.PVRTC1_4_RGB,c.PVRTC1_4_RGBA],engineFormat:[l.RGB_PVRTC_4BPPV1_Format,l.RGBA_PVRTC_4BPPV1_Format],priorityETC1S:5,priorityUASTC:6,needsPowerOfTwo:!0}],v=g.sort(function(P,z){return P.priorityETC1S-z.priorityETC1S}),x=g.sort(function(P,z){return P.priorityUASTC-z.priorityUASTC});function w(P){return P<=2||!(P&P-1)&&0!==P}function S(P){if(1===P.length)return P[0];let z=0;for(let tt=0;tt<P.length;tt++)z+=P[tt].byteLength;const W=new Uint8Array(z);let Y=0;for(let tt=0;tt<P.length;tt++){const J=P[tt];W.set(J,Y),Y+=J.byteLength}return W}};const By=new Set([de,Ss,da]),Vp={109:de,97:de,37:de,43:de,103:Ss,83:Ss,16:Ss,22:Ss,100:da,76:da,15:da,9:da,166:Me,165:Me},Am={109:wn,97:br,37:jn,43:jn,103:wn,83:br,16:jn,22:jn,100:wn,76:br,15:jn,9:jn,166:jn,165:jn};function Ny(A){const e=A.dataFormatDescriptor[0];return 1===e.colorPrimaries?2===e.transferFunction?qi:ps:10===e.colorPrimaries?2===e.transferFunction?Nu:Uc:(0===e.colorPrimaries||console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`),vo)}const ei={c:null,u:[new Dt,new Dt,new Dt],e:[]},fi={c:null,u:[new Dt,new Dt,new Dt],e:[]},Si=[[],[],[]],Fr=[[],[],[]],Pi=[],Mu=new Dt,Wa=new Dt,mh=new Dt,bs=new Dt,Dv=new Dt,Lv=new Dt,Ds=new yr,pA=new ta,gd=new Yn,fA=new Yn,mA=new hc;class gA{constructor(e=new Dt,s=new Dt,l=new yr){this.center=e,this.halfSize=s,this.rotation=l}set(e,s,l){return this.center=e,this.halfSize=s,this.rotation=l,this}copy(e){return this.center.copy(e.center),this.halfSize.copy(e.halfSize),this.rotation.copy(e.rotation),this}clone(){return(new this.constructor).copy(this)}getSize(e){return e.copy(this.halfSize).multiplyScalar(2)}clampPoint(e,s){const l=this.halfSize;bs.subVectors(e,this.center),this.rotation.extractBasis(Mu,Wa,mh),s.copy(this.center);const c=Fu.clamp(bs.dot(Mu),-l.x,l.x);s.add(Mu.multiplyScalar(c));const d=Fu.clamp(bs.dot(Wa),-l.y,l.y);s.add(Wa.multiplyScalar(d));const g=Fu.clamp(bs.dot(mh),-l.z,l.z);return s.add(mh.multiplyScalar(g)),s}containsPoint(e){return bs.subVectors(e,this.center),this.rotation.extractBasis(Mu,Wa,mh),Math.abs(bs.dot(Mu))<=this.halfSize.x&&Math.abs(bs.dot(Wa))<=this.halfSize.y&&Math.abs(bs.dot(mh))<=this.halfSize.z}intersectsBox3(e){return this.intersectsOBB(Dy.fromBox3(e))}intersectsSphere(e){return this.clampPoint(e.center,Lv),Lv.distanceToSquared(e.center)<=e.radius*e.radius}intersectsOBB(e,s=Number.EPSILON){ei.c=this.center,ei.e[0]=this.halfSize.x,ei.e[1]=this.halfSize.y,ei.e[2]=this.halfSize.z,this.rotation.extractBasis(ei.u[0],ei.u[1],ei.u[2]),fi.c=e.center,fi.e[0]=e.halfSize.x,fi.e[1]=e.halfSize.y,fi.e[2]=e.halfSize.z,e.rotation.extractBasis(fi.u[0],fi.u[1],fi.u[2]);for(let d=0;d<3;d++)for(let g=0;g<3;g++)Si[d][g]=ei.u[d].dot(fi.u[g]);bs.subVectors(fi.c,ei.c),Pi[0]=bs.dot(ei.u[0]),Pi[1]=bs.dot(ei.u[1]),Pi[2]=bs.dot(ei.u[2]);for(let d=0;d<3;d++)for(let g=0;g<3;g++)Fr[d][g]=Math.abs(Si[d][g])+s;let l,c;for(let d=0;d<3;d++)if(l=ei.e[d],c=fi.e[0]*Fr[d][0]+fi.e[1]*Fr[d][1]+fi.e[2]*Fr[d][2],Math.abs(Pi[d])>l+c)return!1;for(let d=0;d<3;d++)if(l=ei.e[0]*Fr[0][d]+ei.e[1]*Fr[1][d]+ei.e[2]*Fr[2][d],c=fi.e[d],Math.abs(Pi[0]*Si[0][d]+Pi[1]*Si[1][d]+Pi[2]*Si[2][d])>l+c)return!1;return l=ei.e[1]*Fr[2][0]+ei.e[2]*Fr[1][0],c=fi.e[1]*Fr[0][2]+fi.e[2]*Fr[0][1],!(Math.abs(Pi[2]*Si[1][0]-Pi[1]*Si[2][0])>l+c||(l=ei.e[1]*Fr[2][1]+ei.e[2]*Fr[1][1],c=fi.e[0]*Fr[0][2]+fi.e[2]*Fr[0][0],Math.abs(Pi[2]*Si[1][1]-Pi[1]*Si[2][1])>l+c||(l=ei.e[1]*Fr[2][2]+ei.e[2]*Fr[1][2],c=fi.e[0]*Fr[0][1]+fi.e[1]*Fr[0][0],Math.abs(Pi[2]*Si[1][2]-Pi[1]*Si[2][2])>l+c||(l=ei.e[0]*Fr[2][0]+ei.e[2]*Fr[0][0],c=fi.e[1]*Fr[1][2]+fi.e[2]*Fr[1][1],Math.abs(Pi[0]*Si[2][0]-Pi[2]*Si[0][0])>l+c||(l=ei.e[0]*Fr[2][1]+ei.e[2]*Fr[0][1],c=fi.e[0]*Fr[1][2]+fi.e[2]*Fr[1][0],Math.abs(Pi[0]*Si[2][1]-Pi[2]*Si[0][1])>l+c||(l=ei.e[0]*Fr[2][2]+ei.e[2]*Fr[0][2],c=fi.e[0]*Fr[1][1]+fi.e[1]*Fr[1][0],Math.abs(Pi[0]*Si[2][2]-Pi[2]*Si[0][2])>l+c||(l=ei.e[0]*Fr[1][0]+ei.e[1]*Fr[0][0],c=fi.e[1]*Fr[2][2]+fi.e[2]*Fr[2][1],Math.abs(Pi[1]*Si[0][0]-Pi[0]*Si[1][0])>l+c||(l=ei.e[0]*Fr[1][1]+ei.e[1]*Fr[0][1],c=fi.e[0]*Fr[2][2]+fi.e[2]*Fr[2][0],Math.abs(Pi[1]*Si[0][1]-Pi[0]*Si[1][1])>l+c||(l=ei.e[0]*Fr[1][2]+ei.e[1]*Fr[0][2],c=fi.e[0]*Fr[2][1]+fi.e[1]*Fr[2][0],Math.abs(Pi[1]*Si[0][2]-Pi[0]*Si[1][2])>l+c)))))))))}intersectsPlane(e){this.rotation.extractBasis(Mu,Wa,mh);const s=this.halfSize.x*Math.abs(e.normal.dot(Mu))+this.halfSize.y*Math.abs(e.normal.dot(Wa))+this.halfSize.z*Math.abs(e.normal.dot(mh)),l=e.normal.dot(this.center)-e.constant;return Math.abs(l)<=s}intersectRay(e,s){return this.getSize(Dv),pA.setFromCenterAndSize(bs.set(0,0,0),Dv),gd.setFromMatrix3(this.rotation),gd.setPosition(this.center),fA.copy(gd).invert(),mA.copy(e).applyMatrix4(fA),mA.intersectBox(pA,s)?s.applyMatrix4(gd):null}intersectsRay(e){return null!==this.intersectRay(e,bs)}fromBox3(e){return e.getCenter(this.center),e.getSize(this.halfSize).multiplyScalar(.5),this.rotation.identity(),this}equals(e){return e.center.equals(this.center)&&e.halfSize.equals(this.halfSize)&&e.rotation.equals(this.rotation)}applyMatrix4(e){const s=e.elements;let l=bs.set(s[0],s[1],s[2]).length();const c=bs.set(s[4],s[5],s[6]).length(),d=bs.set(s[8],s[9],s[10]).length();e.determinant()<0&&(l=-l),Ds.setFromMatrix4(e);const g=1/l,v=1/c,x=1/d;return Ds.elements[0]*=g,Ds.elements[1]*=g,Ds.elements[2]*=g,Ds.elements[3]*=v,Ds.elements[4]*=v,Ds.elements[5]*=v,Ds.elements[6]*=x,Ds.elements[7]*=x,Ds.elements[8]*=x,this.rotation.multiply(Ds),this.halfSize.x*=l,this.halfSize.y*=c,this.halfSize.z*=d,bs.setFromMatrixPosition(e),this.center.add(bs),this}}const Dy=new gA,Ly=/^[og]\s*(.+)?/,So=/^mtllib /,AA=/^usemtl /,yA=/^usemap /,ym=/\s+/,vm=new Dt,Gp=new Dt,bm=new Dt,vA=new Dt,ll=new Dt,xm=new En;function ms(){const A={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,s){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==s);const l=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==s,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(c,d){const g=this._finalize(!1);g&&(g.inherited||g.groupCount<=0)&&this.materials.splice(g.index,1);const v={index:this.materials.length,name:c||"",mtllib:Array.isArray(d)&&d.length>0?d[d.length-1]:"",smooth:void 0!==g?g.smooth:this.smooth,groupStart:void 0!==g?g.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(x){const w={index:"number"==typeof x?x:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return w.clone=this.clone.bind(w),w}};return this.materials.push(v),v},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(c){const d=this.currentMaterial();if(d&&-1===d.groupEnd&&(d.groupEnd=this.geometry.vertices.length/3,d.groupCount=d.groupEnd-d.groupStart,d.inherited=!1),c&&this.materials.length>1)for(let g=this.materials.length-1;g>=0;g--)this.materials[g].groupCount<=0&&this.materials.splice(g,1);return c&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),d}},l&&l.name&&"function"==typeof l.clone){const c=l.clone(0);c.inherited=!0,this.object.materials.push(c)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,s){const l=parseInt(e,10);return 3*(l>=0?l-1:l+s/3)},parseNormalIndex:function(e,s){const l=parseInt(e,10);return 3*(l>=0?l-1:l+s/3)},parseUVIndex:function(e,s){const l=parseInt(e,10);return 2*(l>=0?l-1:l+s/2)},addVertex:function(e,s,l){const c=this.vertices,d=this.object.geometry.vertices;d.push(c[e+0],c[e+1],c[e+2]),d.push(c[s+0],c[s+1],c[s+2]),d.push(c[l+0],c[l+1],c[l+2])},addVertexPoint:function(e){const s=this.vertices;this.object.geometry.vertices.push(s[e+0],s[e+1],s[e+2])},addVertexLine:function(e){const s=this.vertices;this.object.geometry.vertices.push(s[e+0],s[e+1],s[e+2])},addNormal:function(e,s,l){const c=this.normals,d=this.object.geometry.normals;d.push(c[e+0],c[e+1],c[e+2]),d.push(c[s+0],c[s+1],c[s+2]),d.push(c[l+0],c[l+1],c[l+2])},addFaceNormal:function(e,s,l){const c=this.vertices,d=this.object.geometry.normals;vm.fromArray(c,e),Gp.fromArray(c,s),bm.fromArray(c,l),ll.subVectors(bm,Gp),vA.subVectors(vm,Gp),ll.cross(vA),ll.normalize(),d.push(ll.x,ll.y,ll.z),d.push(ll.x,ll.y,ll.z),d.push(ll.x,ll.y,ll.z)},addColor:function(e,s,l){const c=this.colors,d=this.object.geometry.colors;void 0!==c[e]&&d.push(c[e+0],c[e+1],c[e+2]),void 0!==c[s]&&d.push(c[s+0],c[s+1],c[s+2]),void 0!==c[l]&&d.push(c[l+0],c[l+1],c[l+2])},addUV:function(e,s,l){const c=this.uvs,d=this.object.geometry.uvs;d.push(c[e+0],c[e+1]),d.push(c[s+0],c[s+1]),d.push(c[l+0],c[l+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const s=this.uvs;this.object.geometry.uvs.push(s[e+0],s[e+1])},addFace:function(e,s,l,c,d,g,v,x,w){const S=this.vertices.length;let P=this.parseVertexIndex(e,S),z=this.parseVertexIndex(s,S),W=this.parseVertexIndex(l,S);if(this.addVertex(P,z,W),this.addColor(P,z,W),void 0!==v&&""!==v){const Y=this.normals.length;P=this.parseNormalIndex(v,Y),z=this.parseNormalIndex(x,Y),W=this.parseNormalIndex(w,Y),this.addNormal(P,z,W)}else this.addFaceNormal(P,z,W);if(void 0!==c&&""!==c){const Y=this.uvs.length;P=this.parseUVIndex(c,Y),z=this.parseUVIndex(d,Y),W=this.parseUVIndex(g,Y),this.addUV(P,z,W),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const s=this.vertices.length;for(let l=0,c=e.length;l<c;l++){const d=this.parseVertexIndex(e[l],s);this.addVertexPoint(d),this.addColor(d)}},addLineGeometry:function(e,s){this.object.geometry.type="Line";const l=this.vertices.length,c=this.uvs.length;for(let d=0,g=e.length;d<g;d++)this.addVertexLine(this.parseVertexIndex(e[d],l));for(let d=0,g=s.length;d<g;d++)this.addUVLine(this.parseUVIndex(s[d],c))}};return A.startObject("",!1),A}class cs{constructor(e="",s={}){this.baseUrl=e,this.options=s,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.side=void 0!==this.options.side?this.options.side:Q,this.wrap=void 0!==this.options.wrap?this.options.wrap:ki}setCrossOrigin(e){return this.crossOrigin=e,this}setManager(e){this.manager=e}setMaterials(e){this.materialsInfo=this.convert(e),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(e){if(!this.options)return e;const s={};for(const l in e){const c=e[l],d={};s[l]=d;for(const g in c){let v=!0,x=c[g];const w=g.toLowerCase();switch(w){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(x=[x[0]/255,x[1]/255,x[2]/255]),this.options&&this.options.ignoreZeroRGBs&&0===x[0]&&0===x[1]&&0===x[2]&&(v=!1)}v&&(d[w]=x)}}return s}preload(){for(const e in this.materialsInfo)this.create(e)}getIndex(e){return this.nameLookup[e]}getAsArray(){let e=0;for(const s in this.materialsInfo)this.materialsArray[e]=this.create(s),this.nameLookup[s]=e,e++;return this.materialsArray}create(e){return void 0===this.materials[e]&&this.createMaterial_(e),this.materials[e]}createMaterial_(e){const s=this,l=this.materialsInfo[e],c={name:e,side:this.side};function d(g,v){if(c[g])return;const x=s.getTextureParams(v,c),w=s.loadTexture((S=s.baseUrl,"string"!=typeof(P=x.url)||""===P?"":/^https?:\/\//i.test(P)?P:S+P));var S,P;w.repeat.copy(x.scale),w.offset.copy(x.offset),w.wrapS=s.wrap,w.wrapT=s.wrap,"map"!==g&&"emissiveMap"!==g||(w.colorSpace=qi),c[g]=w}for(const g in l){const v=l[g];let x;if(""!==v)switch(g.toLowerCase()){case"kd":c.color=(new En).fromArray(v).convertSRGBToLinear();break;case"ks":c.specular=(new En).fromArray(v).convertSRGBToLinear();break;case"ke":c.emissive=(new En).fromArray(v).convertSRGBToLinear();break;case"map_kd":d("map",v);break;case"map_ks":d("specularMap",v);break;case"map_ke":d("emissiveMap",v);break;case"norm":d("normalMap",v);break;case"map_bump":case"bump":d("bumpMap",v);break;case"map_d":d("alphaMap",v),c.transparent=!0;break;case"ns":c.shininess=parseFloat(v);break;case"d":x=parseFloat(v),x<1&&(c.opacity=x,c.transparent=!0);break;case"tr":x=parseFloat(v),this.options&&this.options.invertTrProperty&&(x=1-x),x>0&&(c.opacity=1-x,c.transparent=!0)}}return this.materials[e]=new em(c),this.materials[e]}getTextureParams(e,s){const l={scale:new Ye(1,1),offset:new Ye(0,0)},c=e.split(/\s+/);let d;return d=c.indexOf("-bm"),d>=0&&(s.bumpScale=parseFloat(c[d+1]),c.splice(d,2)),d=c.indexOf("-s"),d>=0&&(l.scale.set(parseFloat(c[d+1]),parseFloat(c[d+2])),c.splice(d,4)),d=c.indexOf("-o"),d>=0&&(l.offset.set(parseFloat(c[d+1]),parseFloat(c[d+2])),c.splice(d,4)),l.url=c.join(" ").trim(),l}loadTexture(e,s,l,c,d){const g=void 0!==this.manager?this.manager:sm;let v=g.getHandler(e);null===v&&(v=new X0(g)),v.setCrossOrigin&&v.setCrossOrigin(this.crossOrigin);const x=v.load(e,l,c,d);return void 0!==s&&(x.mapping=s),x}}function Fv(A,e){switch(e){case qi:A.convertSRGBToLinear();break;case ps:case vo:break;default:console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported color space.")}return A}var Tu={...U};Tu.DRACOLoader=class extends Ca{constructor(A){super(A),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(A){return this.decoderPath=A,this}setDecoderConfig(A){return this.decoderConfig=A,this}setWorkerLimit(A){return this.workerLimit=A,this}load(A,e,s,l){const c=new La(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(A,d=>{this.parse(d,e,l)},s,l)}parse(A,e,s=(()=>{})){this.decodeDracoFile(A,e,null,null,qi).catch(s)}decodeDracoFile(A,e,s,l,c=ps,d=(()=>{})){return this.decodeGeometry(A,{attributeIDs:s||this.defaultAttributeIDs,attributeTypes:l||this.defaultAttributeTypes,useUniqueIDs:!!s,vertexColorSpace:c}).then(e).catch(d)}decodeGeometry(A,e){const s=JSON.stringify(e);if(by.has(A)){const v=by.get(A);if(v.key===s)return v.promise;if(0===A.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let l;const c=this.workerNextTaskID++,g=this._getWorker(c,A.byteLength).then(v=>(l=v,new Promise((x,w)=>{l._callbacks[c]={resolve:x,reject:w},l.postMessage({type:"decode",id:c,taskConfig:e,buffer:A},[A])}))).then(v=>this._createGeometry(v.geometry));return g.catch(()=>!0).then(()=>{l&&c&&this._releaseTask(l,c)}),by.set(A,{key:s,promise:g}),g}_createGeometry(A){const e=new gr;A.index&&e.setIndex(new wr(A.index.array,1));for(let s=0;s<A.attributes.length;s++){const l=A.attributes[s],c=l.name,d=l.array,v=new wr(d,l.itemSize);"color"===c&&(this._assignVertexColorSpace(v,l.vertexColorSpace),v.normalized=d instanceof Float32Array==0),e.setAttribute(c,v)}return e}_assignVertexColorSpace(A,e){if(e!==qi)return;const s=new En;for(let l=0,c=A.count;l<c;l++)s.fromBufferAttribute(A,l).convertSRGBToLinear(),A.setXYZ(l,s.r,s.g,s.b)}_loadLibrary(A,e){const s=new La(this.manager);return s.setPath(this.decoderPath),s.setResponseType(e),s.setWithCredentials(this.withCredentials),new Promise((l,c)=>{s.load(A,l,void 0,c)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const A="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,e=[];return A?e.push(this._loadLibrary("draco_decoder.js","text")):(e.push(this._loadLibrary("draco_wasm_wrapper.js","text")),e.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(e).then(s=>{const l=s[0];A||(this.decoderConfig.wasmBinary=s[1]);const c=wx.toString(),d=["/* draco decoder */",l,"","/* worker */",c.substring(c.indexOf("{")+1,c.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([d]))}),this.decoderPending}_getWorker(A,e){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const l=new Worker(this.workerSourceURL);l._callbacks={},l._taskCosts={},l._taskLoad=0,l.postMessage({type:"init",decoderConfig:this.decoderConfig}),l.onmessage=function(c){const d=c.data;switch(d.type){case"decode":l._callbacks[d.id].resolve(d);break;case"error":l._callbacks[d.id].reject(d);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+d.type+'"')}},this.workerPool.push(l)}else this.workerPool.sort(function(l,c){return l._taskLoad>c._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[A]=e,s._taskLoad+=e,s})}_releaseTask(A,e){A._taskLoad-=A._taskCosts[e],delete A._callbacks[e],delete A._taskCosts[e]}debug(){console.log("Task load: ",this.workerPool.map(A=>A._taskLoad))}dispose(){for(let A=0;A<this.workerPool.length;++A)this.workerPool[A].terminate();return this.workerPool.length=0,""!==this.workerSourceURL&&URL.revokeObjectURL(this.workerSourceURL),this}},Tu.GLTFLoader=class extends Ca{constructor(A){super(A),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new Lr(e)}),this.register(function(e){return new Cy(e)}),this.register(function(e){return new Iy(e)}),this.register(function(e){return new Sy(e)}),this.register(function(e){return new mm(e)}),this.register(function(e){return new Rc(e)}),this.register(function(e){return new _v(e)}),this.register(function(e){return new Io(e)}),this.register(function(e){return new Zi(e)}),this.register(function(e){return new he(e)}),this.register(function(e){return new Eu(e)}),this.register(function(e){return new hd(e)}),this.register(function(e){return new Ml(e)}),this.register(function(e){return new dd(e)}),this.register(function(e){return new kc(e)}),this.register(function(e){return new oA(e)}),this.register(function(e){return new hh(e)})}load(A,e,s,l){const c=this;let d;if(""!==this.resourcePath)d=this.resourcePath;else if(""!==this.path){const x=vu.extractUrlBase(A);d=vu.resolveURL(x,this.path)}else d=vu.extractUrlBase(A);this.manager.itemStart(A);const g=function(x){l?l(x):console.error(x),c.manager.itemError(A),c.manager.itemEnd(A)},v=new La(this.manager);v.setPath(this.path),v.setResponseType("arraybuffer"),v.setRequestHeader(this.requestHeader),v.setWithCredentials(this.withCredentials),v.load(A,function(x){try{c.parse(x,d,function(w){e(w),c.manager.itemEnd(A)},g)}catch(w){g(w)}},s,g)}setDRACOLoader(A){return this.dracoLoader=A,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(A){return this.ktx2Loader=A,this}setMeshoptDecoder(A){return this.meshoptDecoder=A,this}register(A){return-1===this.pluginCallbacks.indexOf(A)&&this.pluginCallbacks.push(A),this}unregister(A){return-1!==this.pluginCallbacks.indexOf(A)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(A),1),this}parse(A,e,s,l){let c;const d={},g={},v=new TextDecoder;if("string"==typeof A)c=JSON.parse(A);else if(A instanceof ArrayBuffer)if("glTF"===v.decode(new Uint8Array(A,0,4))){try{d[aA]=new pd(A)}catch(w){return void(l&&l(w))}c=JSON.parse(d[aA].content)}else c=JSON.parse(v.decode(A));else c=A;if(void 0===c.asset||c.asset.version[0]<2)return void(l&&l(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const x=new Wx(c,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});x.fileLoader.setRequestHeader(this.requestHeader);for(let w=0;w<this.pluginCallbacks.length;w++){const S=this.pluginCallbacks[w](x);S.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),g[S.name]=S,d[S.name]=!0}if(c.extensionsUsed)for(let w=0;w<c.extensionsUsed.length;++w){const S=c.extensionsUsed[w],P=c.extensionsRequired||[];switch(S){case pm:d[S]=new Sl;break;case dm:d[S]=new My(c,this.dracoLoader);break;case fm:d[S]=new Ia;break;case Iv:d[S]=new Rv;break;default:P.indexOf(S)>=0&&void 0===g[S]&&console.warn('THREE.GLTFLoader: Unknown extension "'+S+'".')}}x.setExtensions(d),x.setPlugins(g),x.parse(s,l)}parseAsync(A,e){const s=this;return new Promise(function(l,c){s.parse(A,e,l,c)})}},Tu.KTX2Loader=lo,Tu.OBJLoader=class extends Ca{constructor(A){super(A),this.materials=null}load(A,e,s,l){const c=this,d=new La(this.manager);d.setPath(this.path),d.setRequestHeader(this.requestHeader),d.setWithCredentials(this.withCredentials),d.load(A,function(g){try{e(c.parse(g))}catch(v){l?l(v):console.error(v),c.manager.itemError(A)}},s,l)}setMaterials(A){return this.materials=A,this}parse(A){const e=new ms;-1!==A.indexOf("\r\n")&&(A=A.replace(/\r\n/g,"\n")),-1!==A.indexOf("\\\n")&&(A=A.replace(/\\\n/g,""));const s=A.split("\n");let l=[];for(let d=0,g=s.length;d<g;d++){const v=s[d].trimStart();if(0===v.length)continue;const x=v.charAt(0);if("#"!==x)if("v"===x){const w=v.split(ym);switch(w[0]){case"v":e.vertices.push(parseFloat(w[1]),parseFloat(w[2]),parseFloat(w[3])),w.length>=7?(xm.setRGB(parseFloat(w[4]),parseFloat(w[5]),parseFloat(w[6])).convertSRGBToLinear(),e.colors.push(xm.r,xm.g,xm.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(w[1]),parseFloat(w[2]),parseFloat(w[3]));break;case"vt":e.uvs.push(parseFloat(w[1]),parseFloat(w[2]))}}else if("f"===x){const w=v.slice(1).trim().split(ym),S=[];for(let z=0,W=w.length;z<W;z++){const Y=w[z];if(Y.length>0){const tt=Y.split("/");S.push(tt)}}const P=S[0];for(let z=1,W=S.length-1;z<W;z++){const Y=S[z],tt=S[z+1];e.addFace(P[0],Y[0],tt[0],P[1],Y[1],tt[1],P[2],Y[2],tt[2])}}else if("l"===x){const w=v.substring(1).trim().split(" ");let S=[];const P=[];if(-1===v.indexOf("/"))S=w;else for(let z=0,W=w.length;z<W;z++){const Y=w[z].split("/");""!==Y[0]&&S.push(Y[0]),""!==Y[1]&&P.push(Y[1])}e.addLineGeometry(S,P)}else if("p"===x){const w=v.slice(1).trim().split(" ");e.addPointGeometry(w)}else if(null!==(l=Ly.exec(v))){const w=(" "+l[0].slice(1).trim()).slice(1);e.startObject(w)}else if(AA.test(v))e.object.startMaterial(v.substring(7).trim(),e.materialLibraries);else if(So.test(v))e.materialLibraries.push(v.substring(7).trim());else if(yA.test(v))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===x){if(l=v.split(" "),l.length>1){const S=l[1].trim().toLowerCase();e.object.smooth="0"!==S&&"off"!==S}else e.object.smooth=!0;const w=e.object.currentMaterial();w&&(w.smooth=e.object.smooth)}else{if("\0"===v)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+v+'"')}}e.finalize();const c=new tl;if(c.materialLibraries=[].concat(e.materialLibraries),1!==e.objects.length||0!==e.objects[0].geometry.vertices.length)for(let d=0,g=e.objects.length;d<g;d++){const v=e.objects[d],x=v.geometry,w=v.materials,S="Line"===x.type,P="Points"===x.type;let z=!1;if(0===x.vertices.length)continue;const W=new gr;W.setAttribute("position",new Tn(x.vertices,3)),x.normals.length>0&&W.setAttribute("normal",new Tn(x.normals,3)),x.colors.length>0&&(z=!0,W.setAttribute("color",new Tn(x.colors,3))),!0===x.hasUVIndices&&W.setAttribute("uv",new Tn(x.uvs,2));const Y=[];for(let J=0,at=w.length;J<at;J++){const it=w[J],ct=it.name+"_"+it.smooth+"_"+z;let At=e.materials[ct];if(null!==this.materials)if(At=this.materials.create(it.name),!S||!At||At instanceof ls){if(P&&At&&!(At instanceof wa)){const Ft=new wa({size:10,sizeAttenuation:!1});di.prototype.copy.call(Ft,At),Ft.color.copy(At.color),Ft.map=At.map,At=Ft}}else{const Ft=new ls;di.prototype.copy.call(Ft,At),Ft.color.copy(At.color),At=Ft}void 0===At&&(At=S?new ls:P?new wa({size:1,sizeAttenuation:!1}):new em,At.name=it.name,At.flatShading=!it.smooth,At.vertexColors=z,e.materials[ct]=At),Y.push(At)}let tt;if(Y.length>1){for(let J=0,at=w.length;J<at;J++){const it=w[J];W.addGroup(it.groupStart,it.groupCount,J)}tt=S?new Ai(W,Y):P?new nh(W,Y):new os(W,Y)}else tt=S?new Ai(W,Y[0]):P?new nh(W,Y[0]):new os(W,Y[0]);tt.name=v.name,c.add(tt)}else if(e.vertices.length>0){const d=new wa({size:1,sizeAttenuation:!1}),g=new gr;g.setAttribute("position",new Tn(e.vertices,3)),e.colors.length>0&&void 0!==e.colors[0]&&(g.setAttribute("color",new Tn(e.colors,3)),d.vertexColors=!0);const v=new nh(g,d);c.add(v)}return c}},Tu.MTLLoader=class extends Ca{constructor(A){super(A)}load(A,e,s,l){const c=this,d=""===this.path?vu.extractUrlBase(A):this.path,g=new La(this.manager);g.setPath(this.path),g.setRequestHeader(this.requestHeader),g.setWithCredentials(this.withCredentials),g.load(A,function(v){try{e(c.parse(v,d))}catch(x){l?l(x):console.error(x),c.manager.itemError(A)}},s,l)}setMaterialOptions(A){return this.materialOptions=A,this}parse(A,e){const s=A.split("\n");let l={};const c=/\s+/,d={};for(let v=0;v<s.length;v++){let x=s[v];if(x=x.trim(),0===x.length||"#"===x.charAt(0))continue;const w=x.indexOf(" ");let S=w>=0?x.substring(0,w):x;S=S.toLowerCase();let P=w>=0?x.substring(w+1):"";if(P=P.trim(),"newmtl"===S)l={name:P},d[P]=l;else if("ka"===S||"kd"===S||"ks"===S||"ke"===S){const z=P.split(c,3);l[S]=[parseFloat(z[0]),parseFloat(z[1]),parseFloat(z[2])]}else l[S]=P}const g=new cs(this.resourcePath||e,this.materialOptions);return g.setCrossOrigin(this.crossOrigin),g.setManager(this.manager),g.setMaterials(d),g}},Tu.OBB=gA,Tu.BufferGeometryUtils=$,Tu.LightProbeGenerator=class{static fromCubeTexture(A){let e=0;const s=new Dt,l=new Dt,c=new En,d=[0,0,0,0,0,0,0,0,0],g=new Dp,v=g.coefficients;for(let w=0;w<6;w++){const S=A.image[w],P=S.width,z=S.height,W=document.createElement("canvas");W.width=P,W.height=z;const Y=W.getContext("2d");Y.drawImage(S,0,0,P,z);const tt=Y.getImageData(0,0,P,z),J=tt.data,at=tt.width,it=2/at;for(let ct=0,At=J.length;ct<At;ct+=4){c.setRGB(J[ct]/255,J[ct+1]/255,J[ct+2]/255),Fv(c,A.colorSpace);const Ft=ct/4,Tt=(Ft%at+.5)*it-1,Pt=1-(Math.floor(Ft/at)+.5)*it;switch(w){case 0:s.set(-1,Pt,-Tt);break;case 1:s.set(1,Pt,Tt);break;case 2:s.set(-Tt,1,-Pt);break;case 3:s.set(-Tt,-1,Pt);break;case 4:s.set(-Tt,Pt,1);break;case 5:s.set(Tt,Pt,-1)}const zt=s.lengthSq(),ee=4/(Math.sqrt(zt)*zt);e+=ee,l.copy(s).normalize(),Dp.getBasisAt(l,d);for(let ce=0;ce<9;ce++)v[ce].x+=d[ce]*c.r*ee,v[ce].y+=d[ce]*c.g*ee,v[ce].z+=d[ce]*c.b*ee}}const x=4*Math.PI/e;for(let w=0;w<9;w++)v[w].x*=x,v[w].y*=x,v[w].z*=x;return new Gg(g)}static fromCubeRenderTarget(A,e){let s=0;const l=new Dt,c=new Dt,d=new En,g=[0,0,0,0,0,0,0,0,0],v=new Dp,x=v.coefficients,w=e.texture.type;for(let P=0;P<6;P++){const z=e.width;let W;W=w===br?new Uint16Array(z*z*4):new Uint8Array(z*z*4),A.readRenderTargetPixels(e,0,0,z,z,W,P);const Y=2/z;for(let tt=0,J=W.length;tt<J;tt+=4){let at,it,ct;w===br?(at=pf.fromHalfFloat(W[tt]),it=pf.fromHalfFloat(W[tt+1]),ct=pf.fromHalfFloat(W[tt+2])):(at=W[tt]/255,it=W[tt+1]/255,ct=W[tt+2]/255),d.setRGB(at,it,ct),Fv(d,e.texture.colorSpace);const At=tt/4,Ft=(At%z+.5)*Y-1,Tt=1-(Math.floor(At/z)+.5)*Y;switch(P){case 0:l.set(1,Tt,-Ft);break;case 1:l.set(-1,Tt,Ft);break;case 2:l.set(Ft,1,-Tt);break;case 3:l.set(Ft,-1,Tt);break;case 4:l.set(Ft,Tt,1);break;case 5:l.set(-Ft,Tt,-1)}const Pt=l.lengthSq(),zt=4/(Math.sqrt(Pt)*Pt);s+=zt,c.copy(l).normalize(),Dp.getBasisAt(c,g);for(let ee=0;ee<9;ee++)x[ee].x+=g[ee]*d.r*zt,x[ee].y+=g[ee]*d.g*zt,x[ee].z+=g[ee]*d.b*zt}}const S=4*Math.PI/s;for(let P=0;P<9;P++)x[P].x*=S,x[P].y*=S,x[P].z*=S;return new Gg(v)}};const jx=Tu},8330:ot=>{"use strict";ot.exports=JSON.parse('{"name":"aframe","version":"1.6.0","description":"A web framework for building virtual reality experiences.","homepage":"https://aframe.io/","main":"dist/aframe-master.js","scripts":{"dev":"cross-env INSPECTOR_VERSION=dev webpack serve --port 8080","dist":"node scripts/updateVersionLog.js && npm run dist:min && npm run dist:max","dist:max":"webpack --config webpack.config.js","dist:min":"webpack --config webpack.prod.config.js","docs":"markserv --dir docs --port 9001","preghpages":"node ./scripts/preghpages.js","ghpages":"ghpages -p gh-pages/","lint":"standardx -v | snazzy","lint:fix":"standardx --fix","precommit":"npm run lint","prepush":"node scripts/testOnlyCheck.js","prerelease":"node scripts/release.js 1.5.0 1.6.0","start":"npm run dev","start:https":"npm run dev -- --server-type https","test":"karma start ./tests/karma.conf.js","test:docs":"node scripts/docsLint.js","test:firefox":"npm test -- --browsers Firefox","test:chrome":"npm test -- --browsers Chrome","test:nobrowser":"NO_BROWSER=true npm test","test:node":"node --experimental-require-module ./node_modules/mocha/bin/mocha --ui tdd tests/node"},"repository":"aframevr/aframe","license":"MIT","files":["dist/*","docs/**/*","src/**/*","vendor/**/*"],"dependencies":{"buffer":"^6.0.3","debug":"^4.3.4","deep-assign":"^2.0.0","load-bmfont":"^1.2.3","super-animejs":"^3.1.0","three":"npm:super-three@0.164.0","three-bmfont-text":"dmarcos/three-bmfont-text#eed4878795be9b3e38cf6aec6b903f56acd1f695","webvr-polyfill":"^0.10.12"},"devDependencies":{"@babel/core":"^7.17.10","babel-loader":"^8.2.5","babel-plugin-istanbul":"^6.1.1","chai":"^4.3.6","chai-shallow-deep-equal":"^1.4.0","chalk":"^1.1.3","cross-env":"^7.0.3","css-loader":"^6.7.1","eslint":"^8.45.0","eslint-config-semistandard":"^17.0.0","eslint-config-standard-jsx":"^11.0.0","ghpages":"0.0.8","git-rev":"^0.2.1","glob":"^8.0.3","husky":"^0.11.7","jsdom":"^24.0.0","jsdom-global":"^3.0.2","karma":"^6.4.0","karma-chai-shallow-deep-equal":"0.0.4","karma-chrome-launcher":"^3.1.1","karma-coverage":"^2.2.0","karma-env-preprocessor":"^0.1.1","karma-firefox-launcher":"^2.1.2","karma-mocha":"^2.0.1","karma-mocha-reporter":"^2.2.5","karma-sinon-chai":"^2.0.2","karma-webpack":"^5.0.0","markserv":"github:sukima/markserv#feature/fix-broken-websoketio-link","mocha":"^10.0.0","replace-in-file":"^2.5.3","shelljs":"^0.7.7","shx":"^0.2.2","sinon":"<12.0.0","sinon-chai":"^3.7.0","snazzy":"^5.0.0","standardx":"^7.0.0","style-loader":"^3.3.1","too-wordy":"ngokevin/too-wordy","webpack":"^5.73.0","webpack-cli":"^4.10.0","webpack-dev-server":"^4.11.0","webpack-merge":"^5.8.0","write-good":"^1.0.8"},"link":true,"standardx":{"ignore":["build/**","dist/**","examples/**/shaders/*.js","**/vendor/**"]},"keywords":["3d","aframe","cardboard","components","oculus","three","three.js","rift","vive","vr","quest","meta","web-components","webvr","webxr"],"engines":{"node":">= 4.6.0","npm":">= 2.15.9"}}')}},Fl={};function Qn(ot){var ht=Fl[ot];if(void 0!==ht)return ht.exports;var I=Fl[ot]={id:ot,exports:{}};return Cd[ot].call(I.exports,I,I.exports,Qn),I.exports}return Qn.m=Cd,Qn.n=ot=>{var ht=ot&&ot.__esModule?()=>ot.default:()=>ot;return Qn.d(ht,{a:ht}),ht},Qn.d=(ot,ht)=>{for(var I in ht)Qn.o(ht,I)&&!Qn.o(ot,I)&&Object.defineProperty(ot,I,{enumerable:!0,get:ht[I]})},Qn.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch{if("object"==typeof window)return window}}(),Qn.o=(ot,ht)=>Object.prototype.hasOwnProperty.call(ot,ht),Qn.r=ot=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(ot,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(ot,"__esModule",{value:!0})},Qn.b=document.baseURI||self.location.href,Qn.nc=void 0,Qn(4497)})()),(()=>{var Cd={1113:function(ot){ot.exports=function(ht){var I={};function U($){if(I[$])return I[$].exports;var O=I[$]={i:$,l:!1,exports:{}};return ht[$].call(O.exports,O,O.exports,U),O.l=!0,O.exports}return U.m=ht,U.c=I,U.d=function($,O,N){U.o($,O)||Object.defineProperty($,O,{enumerable:!0,get:N})},U.r=function($){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty($,Symbol.toStringTag,{value:"Module"}),Object.defineProperty($,"__esModule",{value:!0})},U.t=function($,O){if(1&O&&($=U($)),8&O||4&O&&"object"==typeof $&&$&&$.__esModule)return $;var N=Object.create(null);if(U.r(N),Object.defineProperty(N,"default",{enumerable:!0,value:$}),2&O&&"string"!=typeof $)for(var _ in $)U.d(N,_,function(E){return $[E]}.bind(null,_));return N},U.n=function($){var O=$&&$.__esModule?function(){return $.default}:function(){return $};return U.d(O,"a",O),O},U.o=function($,O){return Object.prototype.hasOwnProperty.call($,O)},U.p="",U(U.s=0)}([function(ht,I,U){"use strict";U.r(I),U.d(I,"encode",function(){return ve}),U.d(I,"decode",function(){return Oa}),U.d(I,"decodeAsync",function(){return ys}),U.d(I,"decodeArrayStream",function(){return To}),U.d(I,"decodeStream",function(){return qs}),U.d(I,"Decoder",function(){return As}),U.d(I,"Encoder",function(){return Rt}),U.d(I,"ExtensionCodec",function(){return wt}),U.d(I,"ExtData",function(){return F}),U.d(I,"EXT_TIMESTAMP",function(){return X}),U.d(I,"encodeDateToTimeSpec",function(){return rt}),U.d(I,"encodeTimeSpecToTimestamp",function(){return lt}),U.d(I,"decodeTimestampToTimeSpec",function(){return vt}),U.d(I,"encodeTimestampExtension",function(){return pt}),U.d(I,"decodeTimestampExtension",function(){return bt});var $=function(se,Ct){var q="function"==typeof Symbol&&se[Symbol.iterator];if(!q)return se;var st,ut,Z=q.call(se),_t=[];try{for(;(void 0===Ct||Ct-- >0)&&!(st=Z.next()).done;)_t.push(st.value)}catch(Ht){ut={error:Ht}}finally{try{st&&!st.done&&(q=Z.return)&&q.call(Z)}finally{if(ut)throw ut.error}}return _t},O=function(){for(var se=[],Ct=0;Ct<arguments.length;Ct++)se=se.concat($(arguments[Ct]));return se},N=typeof process<"u"&&typeof TextEncoder<"u"&&typeof TextDecoder<"u";function _(se){for(var Ct=se.length,q=0,st=0;st<Ct;){var ut=se.charCodeAt(st++);if(4294967168&ut)if(4294965248&ut){if(ut>=55296&&ut<=56319&&st<Ct){var Z=se.charCodeAt(st);56320==(64512&Z)&&(++st,ut=((1023&ut)<<10)+(1023&Z)+65536)}q+=4294901760&ut?4:3}else q+=2;else q++}return q}var E=N?new TextEncoder:void 0,D=typeof process<"u"?200:0,B=E?.encodeInto?function(se,Ct,q){E.encodeInto(se,Ct.subarray(q))}:function(se,Ct,q){Ct.set(E.encode(se),q)};function C(se,Ct,q){for(var st=Ct,ut=st+q,Z=[],_t="";st<ut;){var Ht=se[st++];if(128&Ht)if(192==(224&Ht)){var Ae=63&se[st++];Z.push((31&Ht)<<6|Ae)}else if(224==(240&Ht)){Ae=63&se[st++];var Wt=63&se[st++];Z.push((31&Ht)<<12|Ae<<6|Wt)}else if(240==(248&Ht)){var _e=(7&Ht)<<18|(Ae=63&se[st++])<<12|(Wt=63&se[st++])<<6|63&se[st++];_e>65535&&(Z.push((_e-=65536)>>>10&1023|55296),_e=56320|1023&_e),Z.push(_e)}else Z.push(Ht);else Z.push(Ht);Z.length>=4096&&(_t+=String.fromCharCode.apply(String,O(Z)),Z.length=0)}return Z.length>0&&(_t+=String.fromCharCode.apply(String,O(Z))),_t}var M=N?new TextDecoder:null,k=typeof process<"u"?200:0,F=function(se,Ct){this.type=se,this.data=Ct};function G(se,Ct,q){var st=Math.floor(q/4294967296),ut=q;se.setUint32(Ct,st),se.setUint32(Ct+4,ut)}function Q(se,Ct){return 4294967296*se.getInt32(Ct)+se.getUint32(Ct+4)}var X=-1;function lt(se){var Ct,q=se.sec,st=se.nsec;if(q>=0&&st>=0&&q<=17179869183){if(0===st&&q<=4294967295){var ut=new Uint8Array(4);return(Ct=new DataView(ut.buffer)).setUint32(0,q),ut}var Z=q/4294967296,_t=4294967295&q;return ut=new Uint8Array(8),(Ct=new DataView(ut.buffer)).setUint32(0,st<<2|3&Z),Ct.setUint32(4,_t),ut}return ut=new Uint8Array(12),(Ct=new DataView(ut.buffer)).setUint32(0,st),G(Ct,4,q),ut}function rt(se){var Ct=se.getTime(),q=Math.floor(Ct/1e3),st=1e6*(Ct-1e3*q),ut=Math.floor(st/1e9);return{sec:q+ut,nsec:st-1e9*ut}}function pt(se){return se instanceof Date?lt(rt(se)):null}function vt(se){var Ct=new DataView(se.buffer,se.byteOffset,se.byteLength);switch(se.byteLength){case 4:return{sec:Ct.getUint32(0),nsec:0};case 8:var q=Ct.getUint32(0);return{sec:4294967296*(3&q)+Ct.getUint32(4),nsec:q>>>2};case 12:return{sec:Q(Ct,4),nsec:Ct.getUint32(0)};default:throw new Error("Unrecognized data size for timestamp: "+se.length)}}function bt(se){var Ct=vt(se);return new Date(1e3*Ct.sec+Ct.nsec/1e6)}var ft={type:X,encode:pt,decode:bt},wt=function(){function se(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(ft)}return se.prototype.register=function(Ct){var q=Ct.type,st=Ct.encode,ut=Ct.decode;if(q>=0)this.encoders[q]=st,this.decoders[q]=ut;else{var Z=1+q;this.builtInEncoders[Z]=st,this.builtInDecoders[Z]=ut}},se.prototype.tryToEncode=function(Ct,q){for(var st=0;st<this.builtInEncoders.length;st++)if(null!=(ut=this.builtInEncoders[st])&&null!=(Z=ut(Ct,q)))return new F(-1-st,Z);for(st=0;st<this.encoders.length;st++){var ut,Z;if(null!=(ut=this.encoders[st])&&null!=(Z=ut(Ct,q)))return new F(st,Z)}return Ct instanceof F?Ct:null},se.prototype.decode=function(Ct,q,st){var ut=q<0?this.builtInDecoders[-1-q]:this.decoders[q];return ut?ut(Ct,q,st):new F(q,Ct)},se.defaultCodec=new se,se}();function et(se){return se instanceof Uint8Array?se:ArrayBuffer.isView(se)?new Uint8Array(se.buffer,se.byteOffset,se.byteLength):se instanceof ArrayBuffer?new Uint8Array(se):Uint8Array.from(se)}var xt=function(se){var Ct="function"==typeof Symbol&&Symbol.iterator,q=Ct&&se[Ct],st=0;if(q)return q.call(se);if(se&&"number"==typeof se.length)return{next:function(){return se&&st>=se.length&&(se=void 0),{value:se&&se[st++],done:!se}}};throw new TypeError(Ct?"Object is not iterable.":"Symbol.iterator is not defined.")},Rt=function(){function se(Ct,q,st,ut,Z,_t,Ht){void 0===Ct&&(Ct=wt.defaultCodec),void 0===st&&(st=100),void 0===ut&&(ut=2048),void 0===Z&&(Z=!1),void 0===_t&&(_t=!1),void 0===Ht&&(Ht=!1),this.extensionCodec=Ct,this.context=q,this.maxDepth=st,this.initialBufferSize=ut,this.sortKeys=Z,this.forceFloat32=_t,this.ignoreUndefined=Ht,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return se.prototype.encode=function(Ct,q){if(q>this.maxDepth)throw new Error("Too deep objects in depth "+q);null==Ct?this.encodeNil():"boolean"==typeof Ct?this.encodeBoolean(Ct):"number"==typeof Ct?this.encodeNumber(Ct):"string"==typeof Ct?this.encodeString(Ct):this.encodeObject(Ct,q)},se.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},se.prototype.ensureBufferSizeToWrite=function(Ct){var q=this.pos+Ct;this.view.byteLength<q&&this.resizeBuffer(2*q)},se.prototype.resizeBuffer=function(Ct){var q=new ArrayBuffer(Ct),st=new Uint8Array(q),ut=new DataView(q);st.set(this.bytes),this.view=ut,this.bytes=st},se.prototype.encodeNil=function(){this.writeU8(192)},se.prototype.encodeBoolean=function(Ct){this.writeU8(!1===Ct?194:195)},se.prototype.encodeNumber=function(Ct){Number.isSafeInteger(Ct)?Ct>=0?Ct<128?this.writeU8(Ct):Ct<256?(this.writeU8(204),this.writeU8(Ct)):Ct<65536?(this.writeU8(205),this.writeU16(Ct)):Ct<4294967296?(this.writeU8(206),this.writeU32(Ct)):(this.writeU8(207),this.writeU64(Ct)):Ct>=-32?this.writeU8(224|Ct+32):Ct>=-128?(this.writeU8(208),this.writeI8(Ct)):Ct>=-32768?(this.writeU8(209),this.writeI16(Ct)):Ct>=-2147483648?(this.writeU8(210),this.writeI32(Ct)):(this.writeU8(211),this.writeI64(Ct)):this.forceFloat32?(this.writeU8(202),this.writeF32(Ct)):(this.writeU8(203),this.writeF64(Ct))},se.prototype.writeStringHeader=function(Ct){if(Ct<32)this.writeU8(160+Ct);else if(Ct<256)this.writeU8(217),this.writeU8(Ct);else if(Ct<65536)this.writeU8(218),this.writeU16(Ct);else{if(!(Ct<4294967296))throw new Error("Too long string: "+Ct+" bytes in UTF-8");this.writeU8(219),this.writeU32(Ct)}},se.prototype.encodeString=function(Ct){if(N&&Ct.length>D){var st=_(Ct);this.ensureBufferSizeToWrite(5+st),this.writeStringHeader(st),B(Ct,this.bytes,this.pos),this.pos+=st}else st=_(Ct),this.ensureBufferSizeToWrite(5+st),this.writeStringHeader(st),function(ut,Z,_t){for(var Ht=ut.length,Ae=_t,Wt=0;Wt<Ht;){var _e=ut.charCodeAt(Wt++);if(4294967168&_e){if(4294965248&_e){if(_e>=55296&&_e<=56319&&Wt<Ht){var We=ut.charCodeAt(Wt);56320==(64512&We)&&(++Wt,_e=((1023&_e)<<10)+(1023&We)+65536)}4294901760&_e?(Z[Ae++]=_e>>18&7|240,Z[Ae++]=_e>>12&63|128,Z[Ae++]=_e>>6&63|128):(Z[Ae++]=_e>>12&15|224,Z[Ae++]=_e>>6&63|128)}else Z[Ae++]=_e>>6&31|192;Z[Ae++]=63&_e|128}else Z[Ae++]=_e}}(Ct,this.bytes,this.pos),this.pos+=st},se.prototype.encodeObject=function(Ct,q){var st=this.extensionCodec.tryToEncode(Ct,this.context);if(null!=st)this.encodeExtension(st);else if(Array.isArray(Ct))this.encodeArray(Ct,q);else if(ArrayBuffer.isView(Ct))this.encodeBinary(Ct);else{if("object"!=typeof Ct)throw new Error("Unrecognized object: "+Object.prototype.toString.apply(Ct));this.encodeMap(Ct,q)}},se.prototype.encodeBinary=function(Ct){var q=Ct.byteLength;if(q<256)this.writeU8(196),this.writeU8(q);else if(q<65536)this.writeU8(197),this.writeU16(q);else{if(!(q<4294967296))throw new Error("Too large binary: "+q);this.writeU8(198),this.writeU32(q)}var st=et(Ct);this.writeU8a(st)},se.prototype.encodeArray=function(Ct,q){var st,ut,Z=Ct.length;if(Z<16)this.writeU8(144+Z);else if(Z<65536)this.writeU8(220),this.writeU16(Z);else{if(!(Z<4294967296))throw new Error("Too large array: "+Z);this.writeU8(221),this.writeU32(Z)}try{for(var _t=xt(Ct),Ht=_t.next();!Ht.done;Ht=_t.next())this.encode(Ht.value,q+1)}catch(Wt){st={error:Wt}}finally{try{Ht&&!Ht.done&&(ut=_t.return)&&ut.call(_t)}finally{if(st)throw st.error}}},se.prototype.countWithoutUndefined=function(Ct,q){var st,ut,Z=0;try{for(var _t=xt(q),Ht=_t.next();!Ht.done;Ht=_t.next())void 0!==Ct[Ht.value]&&Z++}catch(Ae){st={error:Ae}}finally{try{Ht&&!Ht.done&&(ut=_t.return)&&ut.call(_t)}finally{if(st)throw st.error}}return Z},se.prototype.encodeMap=function(Ct,q){var st,ut,Z=Object.keys(Ct);this.sortKeys&&Z.sort();var _t=this.ignoreUndefined?this.countWithoutUndefined(Ct,Z):Z.length;if(_t<16)this.writeU8(128+_t);else if(_t<65536)this.writeU8(222),this.writeU16(_t);else{if(!(_t<4294967296))throw new Error("Too large map object: "+_t);this.writeU8(223),this.writeU32(_t)}try{for(var Ht=xt(Z),Ae=Ht.next();!Ae.done;Ae=Ht.next()){var Wt=Ae.value,_e=Ct[Wt];this.ignoreUndefined&&void 0===_e||(this.encodeString(Wt),this.encode(_e,q+1))}}catch(We){st={error:We}}finally{try{Ae&&!Ae.done&&(ut=Ht.return)&&ut.call(Ht)}finally{if(st)throw st.error}}},se.prototype.encodeExtension=function(Ct){var q=Ct.data.length;if(1===q)this.writeU8(212);else if(2===q)this.writeU8(213);else if(4===q)this.writeU8(214);else if(8===q)this.writeU8(215);else if(16===q)this.writeU8(216);else if(q<256)this.writeU8(199),this.writeU8(q);else if(q<65536)this.writeU8(200),this.writeU16(q);else{if(!(q<4294967296))throw new Error("Too large extension object: "+q);this.writeU8(201),this.writeU32(q)}this.writeI8(Ct.type),this.writeU8a(Ct.data)},se.prototype.writeU8=function(Ct){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,Ct),this.pos++},se.prototype.writeU8a=function(Ct){var q=Ct.length;this.ensureBufferSizeToWrite(q),this.bytes.set(Ct,this.pos),this.pos+=q},se.prototype.writeI8=function(Ct){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,Ct),this.pos++},se.prototype.writeU16=function(Ct){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,Ct),this.pos+=2},se.prototype.writeI16=function(Ct){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,Ct),this.pos+=2},se.prototype.writeU32=function(Ct){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,Ct),this.pos+=4},se.prototype.writeI32=function(Ct){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,Ct),this.pos+=4},se.prototype.writeF32=function(Ct){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,Ct),this.pos+=4},se.prototype.writeF64=function(Ct){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,Ct),this.pos+=8},se.prototype.writeU64=function(Ct){var q,st,ut,_t;this.ensureBufferSizeToWrite(8),_t=ut=Ct,(q=this.view).setUint32(st=this.pos,ut/4294967296),q.setUint32(st+4,_t),this.pos+=8},se.prototype.writeI64=function(Ct){this.ensureBufferSizeToWrite(8),G(this.view,this.pos,Ct),this.pos+=8},se}(),Yt={};function ve(se,Ct){void 0===Ct&&(Ct=Yt);var q=new Rt(Ct.extensionCodec,Ct.context,Ct.maxDepth,Ct.initialBufferSize,Ct.sortKeys,Ct.forceFloat32,Ct.ignoreUndefined);return q.encode(se,1),q.getUint8Array()}function xe(se){return(se<0?"-":"")+"0x"+Math.abs(se).toString(16).padStart(2,"0")}var Ge=function(){function se(Ct,q){void 0===Ct&&(Ct=16),void 0===q&&(q=16),this.maxKeyLength=Ct,this.maxLengthPerKey=q,this.caches=[];for(var st=0;st<this.maxKeyLength;st++)this.caches.push([])}return se.prototype.canBeCached=function(Ct){return Ct>0&&Ct<=this.maxKeyLength},se.prototype.get=function(Ct,q,st){var ut=this.caches[st-1],Z=ut.length;t:for(var _t=0;_t<Z;_t++){for(var Ht=ut[_t],Ae=Ht.bytes,Wt=0;Wt<st;Wt++)if(Ae[Wt]!==Ct[q+Wt])continue t;return Ht.value}return null},se.prototype.store=function(Ct,q){var st=this.caches[Ct.length-1],ut={bytes:Ct,value:q};st.length>=this.maxLengthPerKey?st[Math.random()*st.length|0]=ut:st.push(ut)},se.prototype.decode=function(Ct,q,st){var ut=this.get(Ct,q,st);if(null!=ut)return ut;var Z=C(Ct,q,st),_t=Uint8Array.prototype.slice.call(Ct,q,q+st);return this.store(_t,Z),Z},se}(),en=function(se,Ct){var q,st,ut,Z,_t={label:0,sent:function(){if(1&ut[0])throw ut[1];return ut[1]},trys:[],ops:[]};return Z={next:Ht(0),throw:Ht(1),return:Ht(2)},"function"==typeof Symbol&&(Z[Symbol.iterator]=function(){return this}),Z;function Ht(Ae){return function(Wt){return function(_e){if(q)throw new TypeError("Generator is already executing.");for(;_t;)try{if(q=1,st&&(ut=2&_e[0]?st.return:_e[0]?st.throw||((ut=st.return)&&ut.call(st),0):st.next)&&!(ut=ut.call(st,_e[1])).done)return ut;switch(st=0,ut&&(_e=[2&_e[0],ut.value]),_e[0]){case 0:case 1:ut=_e;break;case 4:return _t.label++,{value:_e[1],done:!1};case 5:_t.label++,st=_e[1],_e=[0];continue;case 7:_e=_t.ops.pop(),_t.trys.pop();continue;default:if(!((ut=(ut=_t.trys).length>0&&ut[ut.length-1])||6!==_e[0]&&2!==_e[0])){_t=0;continue}if(3===_e[0]&&(!ut||_e[1]>ut[0]&&_e[1]<ut[3])){_t.label=_e[1];break}if(6===_e[0]&&_t.label<ut[1]){_t.label=ut[1],ut=_e;break}if(ut&&_t.label<ut[2]){_t.label=ut[2],_t.ops.push(_e);break}ut[2]&&_t.ops.pop(),_t.trys.pop();continue}_e=Ct.call(se,_t)}catch(We){_e=[6,We],st=0}finally{q=ut=0}if(5&_e[0])throw _e[1];return{value:_e[0]?_e[1]:void 0,done:!0}}([Ae,Wt])}}},nn=function(se){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var Ct,q=se[Symbol.asyncIterator];return q?q.call(se):(se="function"==typeof __values?__values(se):se[Symbol.iterator](),Ct={},st("next"),st("throw"),st("return"),Ct[Symbol.asyncIterator]=function(){return this},Ct);function st(ut){Ct[ut]=se[ut]&&function(Z){return new Promise(function(_t,Ht){var Ae,Wt,_e;Ae=_t,Wt=Ht,_e=(Z=se[ut](Z)).done,Promise.resolve(Z.value).then(function(hn){Ae({value:hn,done:_e})},Wt)})}}},vn=function(se){return this instanceof vn?(this.v=se,this):new vn(se)},nr=new DataView(new ArrayBuffer(0)),hr=new Uint8Array(nr.buffer),Cs=function(){try{nr.getInt8(0)}catch(se){return se.constructor}throw new Error("never reached")}(),Ti=new Cs("Insufficient data"),Is=new Ge,As=function(){function se(Ct,q,st,ut,Z,_t,Ht,Ae){void 0===Ct&&(Ct=wt.defaultCodec),void 0===st&&(st=4294967295),void 0===ut&&(ut=4294967295),void 0===Z&&(Z=4294967295),void 0===_t&&(_t=4294967295),void 0===Ht&&(Ht=4294967295),void 0===Ae&&(Ae=Is),this.extensionCodec=Ct,this.context=q,this.maxStrLength=st,this.maxBinLength=ut,this.maxArrayLength=Z,this.maxMapLength=_t,this.maxExtLength=Ht,this.cachedKeyDecoder=Ae,this.totalPos=0,this.pos=0,this.view=nr,this.bytes=hr,this.headByte=-1,this.stack=[]}return se.prototype.setBuffer=function(Ct){this.bytes=et(Ct),this.view=function(q){if(q instanceof ArrayBuffer)return new DataView(q);var st=et(q);return new DataView(st.buffer,st.byteOffset,st.byteLength)}(this.bytes),this.pos=0},se.prototype.appendBuffer=function(Ct){if(-1!==this.headByte||this.hasRemaining()){var q=this.bytes.subarray(this.pos),st=et(Ct),ut=new Uint8Array(q.length+st.length);ut.set(q),ut.set(st,q.length),this.setBuffer(ut)}else this.setBuffer(Ct)},se.prototype.hasRemaining=function(Ct){return void 0===Ct&&(Ct=1),this.view.byteLength-this.pos>=Ct},se.prototype.createNoExtraBytesError=function(Ct){return new RangeError("Extra "+(this.view.byteLength-this.pos)+" byte(s) found at buffer["+Ct+"]")},se.prototype.decodeSingleSync=function(){var Ct=this.decodeSync();if(this.hasRemaining())throw this.createNoExtraBytesError(this.pos);return Ct},se.prototype.decodeSingleAsync=function(Ct){var q,st,ut,Z,_t,Ae,Wt;return _t=this,Wt=function(){var _t,Ht,Ae,Wt,_e,We,hn,kn;return en(this,function(Hr){switch(Hr.label){case 0:_t=!1,Hr.label=1;case 1:Hr.trys.push([1,6,7,12]),q=nn(Ct),Hr.label=2;case 2:return[4,q.next()];case 3:if((st=Hr.sent()).done)return[3,5];if(Ae=st.value,_t)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(Ae);try{Ht=this.decodeSync(),_t=!0}catch(Wr){if(!(Wr instanceof Cs))throw Wr}this.totalPos+=this.pos,Hr.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return Wt=Hr.sent(),ut={error:Wt},[3,12];case 7:return Hr.trys.push([7,,10,11]),st&&!st.done&&(Z=q.return)?[4,Z.call(q)]:[3,9];case 8:Hr.sent(),Hr.label=9;case 9:return[3,11];case 10:if(ut)throw ut.error;return[7];case 11:return[7];case 12:if(_t){if(this.hasRemaining())throw this.createNoExtraBytesError(this.totalPos);return[2,Ht]}throw We=(_e=this).headByte,hn=_e.pos,kn=_e.totalPos,new RangeError("Insufficient data in parcing "+xe(We)+" at "+kn+" ("+hn+" in the current buffer)")}})},new((Ae=void 0)||(Ae=Promise))(function(_e,We){function hn(Wr){try{Hr(Wt.next(Wr))}catch(ii){We(ii)}}function kn(Wr){try{Hr(Wt.throw(Wr))}catch(ii){We(ii)}}function Hr(Wr){var ii;Wr.done?_e(Wr.value):(ii=Wr.value,ii instanceof Ae?ii:new Ae(function(mo){mo(ii)})).then(hn,kn)}Hr((Wt=Wt.apply(_t,[])).next())})},se.prototype.decodeArrayStream=function(Ct){return this.decodeMultiAsync(Ct,!0)},se.prototype.decodeStream=function(Ct){return this.decodeMultiAsync(Ct,!1)},se.prototype.decodeMultiAsync=function(Ct,q){return function(se,Ct,q){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var st,ut=q.apply(se,Ct||[]),Z=[];return st={},_t("next"),_t("throw"),_t("return"),st[Symbol.asyncIterator]=function(){return this},st;function _t(We){ut[We]&&(st[We]=function(hn){return new Promise(function(kn,Hr){Z.push([We,hn,kn,Hr])>1||Ht(We,hn)})})}function Ht(We,hn){try{(kn=ut[We](hn)).value instanceof vn?Promise.resolve(kn.value.v).then(Ae,Wt):_e(Z[0][2],kn)}catch(Hr){_e(Z[0][3],Hr)}var kn}function Ae(We){Ht("next",We)}function Wt(We){Ht("throw",We)}function _e(We,hn){We(hn),Z.shift(),Z.length&&Ht(Z[0][0],Z[0][1])}}(this,arguments,function(){var st,ut,Z,_t,Ht,Ae,Wt,_e,We;return en(this,function(hn){switch(hn.label){case 0:st=q,ut=-1,hn.label=1;case 1:hn.trys.push([1,13,14,19]),Z=nn(Ct),hn.label=2;case 2:return[4,vn(Z.next())];case 3:if((_t=hn.sent()).done)return[3,12];if(Ht=_t.value,q&&0===ut)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(Ht),st&&(ut=this.readArraySize(),st=!1,this.complete()),hn.label=4;case 4:hn.trys.push([4,9,,10]),hn.label=5;case 5:return[4,vn(this.decodeSync())];case 6:return[4,hn.sent()];case 7:return hn.sent(),0==--ut?[3,8]:[3,5];case 8:return[3,10];case 9:if(!((Ae=hn.sent())instanceof Cs))throw Ae;return[3,10];case 10:this.totalPos+=this.pos,hn.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return Wt=hn.sent(),_e={error:Wt},[3,19];case 14:return hn.trys.push([14,,17,18]),_t&&!_t.done&&(We=Z.return)?[4,vn(We.call(Z))]:[3,16];case 15:hn.sent(),hn.label=16;case 16:return[3,18];case 17:if(_e)throw _e.error;return[7];case 18:return[7];case 19:return[2]}})})},se.prototype.decodeSync=function(){t:for(;;){var Ct=this.readHeadByte(),q=void 0;if(Ct>=224)q=Ct-256;else if(Ct<192)if(Ct<128)q=Ct;else if(Ct<144){if(0!=(ut=Ct-128)){this.pushMapState(ut),this.complete();continue t}q={}}else if(Ct<160){if(0!=(ut=Ct-144)){this.pushArrayState(ut),this.complete();continue t}q=[]}else{var st=Ct-160;q=this.decodeUtf8String(st,0)}else if(192===Ct)q=null;else if(194===Ct)q=!1;else if(195===Ct)q=!0;else if(202===Ct)q=this.readF32();else if(203===Ct)q=this.readF64();else if(204===Ct)q=this.readU8();else if(205===Ct)q=this.readU16();else if(206===Ct)q=this.readU32();else if(207===Ct)q=this.readU64();else if(208===Ct)q=this.readI8();else if(209===Ct)q=this.readI16();else if(210===Ct)q=this.readI32();else if(211===Ct)q=this.readI64();else if(217===Ct)st=this.lookU8(),q=this.decodeUtf8String(st,1);else if(218===Ct)st=this.lookU16(),q=this.decodeUtf8String(st,2);else if(219===Ct)st=this.lookU32(),q=this.decodeUtf8String(st,4);else if(220===Ct){if(0!==(ut=this.readU16())){this.pushArrayState(ut),this.complete();continue t}q=[]}else if(221===Ct){if(0!==(ut=this.readU32())){this.pushArrayState(ut),this.complete();continue t}q=[]}else if(222===Ct){if(0!==(ut=this.readU16())){this.pushMapState(ut),this.complete();continue t}q={}}else if(223===Ct){if(0!==(ut=this.readU32())){this.pushMapState(ut),this.complete();continue t}q={}}else if(196===Ct){var ut=this.lookU8();q=this.decodeBinary(ut,1)}else if(197===Ct)ut=this.lookU16(),q=this.decodeBinary(ut,2);else if(198===Ct)ut=this.lookU32(),q=this.decodeBinary(ut,4);else if(212===Ct)q=this.decodeExtension(1,0);else if(213===Ct)q=this.decodeExtension(2,0);else if(214===Ct)q=this.decodeExtension(4,0);else if(215===Ct)q=this.decodeExtension(8,0);else if(216===Ct)q=this.decodeExtension(16,0);else if(199===Ct)ut=this.lookU8(),q=this.decodeExtension(ut,1);else if(200===Ct)ut=this.lookU16(),q=this.decodeExtension(ut,2);else{if(201!==Ct)throw new Error("Unrecognized type byte: "+xe(Ct));ut=this.lookU32(),q=this.decodeExtension(ut,4)}this.complete();for(var Z=this.stack;Z.length>0;){var _t=Z[Z.length-1];if(0===_t.type){if(_t.array[_t.position]=q,_t.position++,_t.position!==_t.size)continue t;Z.pop(),q=_t.array}else{if(1===_t.type){if("string"!=(Ht=typeof q)&&"number"!==Ht)throw new Error("The type of key must be string or number but "+typeof q);_t.key=q,_t.type=2;continue t}if(_t.map[_t.key]=q,_t.readCount++,_t.readCount!==_t.size){_t.key=null,_t.type=1;continue t}Z.pop(),q=_t.map}}return q}var Ht},se.prototype.readHeadByte=function(){return-1===this.headByte&&(this.headByte=this.readU8()),this.headByte},se.prototype.complete=function(){this.headByte=-1},se.prototype.readArraySize=function(){var Ct=this.readHeadByte();switch(Ct){case 220:return this.readU16();case 221:return this.readU32();default:if(Ct<160)return Ct-144;throw new Error("Unrecognized array type byte: "+xe(Ct))}},se.prototype.pushMapState=function(Ct){if(Ct>this.maxMapLength)throw new Error("Max length exceeded: map length ("+Ct+") > maxMapLengthLength ("+this.maxMapLength+")");this.stack.push({type:1,size:Ct,key:null,readCount:0,map:{}})},se.prototype.pushArrayState=function(Ct){if(Ct>this.maxArrayLength)throw new Error("Max length exceeded: array length ("+Ct+") > maxArrayLength ("+this.maxArrayLength+")");this.stack.push({type:0,size:Ct,array:new Array(Ct),position:0})},se.prototype.decodeUtf8String=function(Ct,q){var st;if(Ct>this.maxStrLength)throw new Error("Max length exceeded: UTF-8 byte length ("+Ct+") > maxStrLength ("+this.maxStrLength+")");if(this.bytes.byteLength<this.pos+q+Ct)throw Ti;var ut,Ht,Wt,Z=this.pos+q;return ut=this.stateIsMapKey()&&null!==(st=this.cachedKeyDecoder)&&void 0!==st&&st.canBeCached(Ct)?this.cachedKeyDecoder.decode(this.bytes,Z,Ct):N&&Ct>k?(Wt=this.bytes.subarray(Ht=Z,Ht+Ct),M.decode(Wt)):C(this.bytes,Z,Ct),this.pos+=q+Ct,ut},se.prototype.stateIsMapKey=function(){return this.stack.length>0&&1===this.stack[this.stack.length-1].type},se.prototype.decodeBinary=function(Ct,q){if(Ct>this.maxBinLength)throw new Error("Max length exceeded: bin length ("+Ct+") > maxBinLength ("+this.maxBinLength+")");if(!this.hasRemaining(Ct+q))throw Ti;var st=this.pos+q,ut=this.bytes.subarray(st,st+Ct);return this.pos+=q+Ct,ut},se.prototype.decodeExtension=function(Ct,q){if(Ct>this.maxExtLength)throw new Error("Max length exceeded: ext length ("+Ct+") > maxExtLength ("+this.maxExtLength+")");var st=this.view.getInt8(this.pos+q),ut=this.decodeBinary(Ct,q+1);return this.extensionCodec.decode(ut,st,this.context)},se.prototype.lookU8=function(){return this.view.getUint8(this.pos)},se.prototype.lookU16=function(){return this.view.getUint16(this.pos)},se.prototype.lookU32=function(){return this.view.getUint32(this.pos)},se.prototype.readU8=function(){var Ct=this.view.getUint8(this.pos);return this.pos++,Ct},se.prototype.readI8=function(){var Ct=this.view.getInt8(this.pos);return this.pos++,Ct},se.prototype.readU16=function(){var Ct=this.view.getUint16(this.pos);return this.pos+=2,Ct},se.prototype.readI16=function(){var Ct=this.view.getInt16(this.pos);return this.pos+=2,Ct},se.prototype.readU32=function(){var Ct=this.view.getUint32(this.pos);return this.pos+=4,Ct},se.prototype.readI32=function(){var Ct=this.view.getInt32(this.pos);return this.pos+=4,Ct},se.prototype.readU64=function(){var Ct,q,st=4294967296*(Ct=this.view).getUint32(q=this.pos)+Ct.getUint32(q+4);return this.pos+=8,st},se.prototype.readI64=function(){var Ct=Q(this.view,this.pos);return this.pos+=8,Ct},se.prototype.readF32=function(){var Ct=this.view.getFloat32(this.pos);return this.pos+=4,Ct},se.prototype.readF64=function(){var Ct=this.view.getFloat64(this.pos);return this.pos+=8,Ct},se}(),ua={};function Oa(se,Ct){void 0===Ct&&(Ct=ua);var q=new As(Ct.extensionCodec,Ct.context,Ct.maxStrLength,Ct.maxBinLength,Ct.maxArrayLength,Ct.maxMapLength,Ct.maxExtLength);return q.setBuffer(se),q.decodeSingleSync()}var ha=function(se,Ct){var q,st,ut,Z,_t={label:0,sent:function(){if(1&ut[0])throw ut[1];return ut[1]},trys:[],ops:[]};return Z={next:Ht(0),throw:Ht(1),return:Ht(2)},"function"==typeof Symbol&&(Z[Symbol.iterator]=function(){return this}),Z;function Ht(Ae){return function(Wt){return function(_e){if(q)throw new TypeError("Generator is already executing.");for(;_t;)try{if(q=1,st&&(ut=2&_e[0]?st.return:_e[0]?st.throw||((ut=st.return)&&ut.call(st),0):st.next)&&!(ut=ut.call(st,_e[1])).done)return ut;switch(st=0,ut&&(_e=[2&_e[0],ut.value]),_e[0]){case 0:case 1:ut=_e;break;case 4:return _t.label++,{value:_e[1],done:!1};case 5:_t.label++,st=_e[1],_e=[0];continue;case 7:_e=_t.ops.pop(),_t.trys.pop();continue;default:if(!((ut=(ut=_t.trys).length>0&&ut[ut.length-1])||6!==_e[0]&&2!==_e[0])){_t=0;continue}if(3===_e[0]&&(!ut||_e[1]>ut[0]&&_e[1]<ut[3])){_t.label=_e[1];break}if(6===_e[0]&&_t.label<ut[1]){_t.label=ut[1],ut=_e;break}if(ut&&_t.label<ut[2]){_t.label=ut[2],_t.ops.push(_e);break}ut[2]&&_t.ops.pop(),_t.trys.pop();continue}_e=Ct.call(se,_t)}catch(We){_e=[6,We],st=0}finally{q=ut=0}if(5&_e[0])throw _e[1];return{value:_e[0]?_e[1]:void 0,done:!0}}([Ae,Wt])}}},js=function(se){return this instanceof js?(this.v=se,this):new js(se)},Xa=function(se,Ct,q){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var st,ut=q.apply(se,Ct||[]),Z=[];return st={},_t("next"),_t("throw"),_t("return"),st[Symbol.asyncIterator]=function(){return this},st;function _t(We){ut[We]&&(st[We]=function(hn){return new Promise(function(kn,Hr){Z.push([We,hn,kn,Hr])>1||Ht(We,hn)})})}function Ht(We,hn){try{(kn=ut[We](hn)).value instanceof js?Promise.resolve(kn.value.v).then(Ae,Wt):_e(Z[0][2],kn)}catch(Hr){_e(Z[0][3],Hr)}var kn}function Ae(We){Ht("next",We)}function Wt(We){Ht("throw",We)}function _e(We,hn){We(hn),Z.shift(),Z.length&&Ht(Z[0][0],Z[0][1])}};function _i(se){return null!=se[Symbol.asyncIterator]?se:function(Ct){return Xa(this,arguments,function(){var q,st,Z;return ha(this,function(_t){switch(_t.label){case 0:q=Ct.getReader(),_t.label=1;case 1:_t.trys.push([1,,9,10]),_t.label=2;case 2:return[4,js(q.read())];case 3:return st=_t.sent(),Z=st.value,st.done?[4,js(void 0)]:[3,5];case 4:return[2,_t.sent()];case 5:return function Ya(se){if(null==se)throw new Error("Assertion Failure: value must not be null nor undefined")}(Z),[4,js(Z)];case 6:return[4,_t.sent()];case 7:return _t.sent(),[3,2];case 8:return[3,10];case 9:return q.releaseLock(),[7];case 10:return[2]}})})}(se)}function ys(se,Ct){return void 0===Ct&&(Ct=ua),q=this,Z=function(){var q;return function(st,ut){var Z,_t,Ht,Ae,Wt={label:0,sent:function(){if(1&Ht[0])throw Ht[1];return Ht[1]},trys:[],ops:[]};return Ae={next:_e(0),throw:_e(1),return:_e(2)},"function"==typeof Symbol&&(Ae[Symbol.iterator]=function(){return this}),Ae;function _e(We){return function(hn){return function(kn){if(Z)throw new TypeError("Generator is already executing.");for(;Wt;)try{if(Z=1,_t&&(Ht=2&kn[0]?_t.return:kn[0]?_t.throw||((Ht=_t.return)&&Ht.call(_t),0):_t.next)&&!(Ht=Ht.call(_t,kn[1])).done)return Ht;switch(_t=0,Ht&&(kn=[2&kn[0],Ht.value]),kn[0]){case 0:case 1:Ht=kn;break;case 4:return Wt.label++,{value:kn[1],done:!1};case 5:Wt.label++,_t=kn[1],kn=[0];continue;case 7:kn=Wt.ops.pop(),Wt.trys.pop();continue;default:if(!((Ht=(Ht=Wt.trys).length>0&&Ht[Ht.length-1])||6!==kn[0]&&2!==kn[0])){Wt=0;continue}if(3===kn[0]&&(!Ht||kn[1]>Ht[0]&&kn[1]<Ht[3])){Wt.label=kn[1];break}if(6===kn[0]&&Wt.label<Ht[1]){Wt.label=Ht[1],Ht=kn;break}if(Ht&&Wt.label<Ht[2]){Wt.label=Ht[2],Wt.ops.push(kn);break}Ht[2]&&Wt.ops.pop(),Wt.trys.pop();continue}kn=ut.call(st,Wt)}catch(Hr){kn=[6,Hr],_t=0}finally{Z=Ht=0}if(5&kn[0])throw kn[1];return{value:kn[0]?kn[1]:void 0,done:!0}}([We,hn])}}}(this,function(st){return q=_i(se),[2,new As(Ct.extensionCodec,Ct.context,Ct.maxStrLength,Ct.maxBinLength,Ct.maxArrayLength,Ct.maxMapLength,Ct.maxExtLength).decodeSingleAsync(q)]})},new((ut=void 0)||(ut=Promise))(function(_t,Ht){function Ae(We){try{_e(Z.next(We))}catch(hn){Ht(hn)}}function Wt(We){try{_e(Z.throw(We))}catch(hn){Ht(hn)}}function _e(We){var hn;We.done?_t(We.value):(hn=We.value,hn instanceof ut?hn:new ut(function(kn){kn(hn)})).then(Ae,Wt)}_e((Z=Z.apply(q,[])).next())});var q,ut,Z}function To(se,Ct){void 0===Ct&&(Ct=ua);var q=_i(se);return new As(Ct.extensionCodec,Ct.context,Ct.maxStrLength,Ct.maxBinLength,Ct.maxArrayLength,Ct.maxMapLength,Ct.maxExtLength).decodeArrayStream(q)}function qs(se,Ct){void 0===Ct&&(Ct=ua);var q=_i(se);return new As(Ct.extensionCodec,Ct.context,Ct.maxStrLength,Ct.maxBinLength,Ct.maxArrayLength,Ct.maxMapLength,Ct.maxExtLength).decodeStream(q)}}])},4563:(ot,ht,I)=>{"use strict";I.r(ht),I.d(ht,{Abs:()=>da,Acos:()=>pa,Acosh:()=>Ss,AdadeltaOptimizer:()=>If,AdagradOptimizer:()=>pg,AdamOptimizer:()=>fg,AdamaxOptimizer:()=>Sf,Add:()=>Xs,AddN:()=>Ms,All:()=>_a,Any:()=>Pa,ArgMax:()=>Ys,ArgMin:()=>Ks,Asin:()=>Ka,Asinh:()=>oi,Atan:()=>Ol,Atan2:()=>Li,Atanh:()=>Go,AvgPool:()=>K,AvgPool3D:()=>It,AvgPool3DGrad:()=>Mt,AvgPoolGrad:()=>mt,BatchMatMul:()=>Gt,BatchToSpaceND:()=>Xt,Bincount:()=>Me,BroadcastArgs:()=>un,BroadcastTo:()=>sn,Callback:()=>YE,CallbackList:()=>fn,Cast:()=>Ie,Ceil:()=>Be,ClipByValue:()=>Pn,Complex:()=>Xn,ComplexAbs:()=>dr,Concat:()=>Ar,Conv2D:()=>xr,Conv2DBackpropFilter:()=>_r,Conv2DBackpropInput:()=>Pr,Conv3D:()=>ui,Conv3DBackpropFilterV2:()=>us,Conv3DBackpropInputV2:()=>Fi,Cos:()=>rs,Cosh:()=>Ts,CropAndResize:()=>hs,Cumsum:()=>Js,CustomCallback:()=>Mn,DataStorage:()=>Xa,DenseBincount:()=>ds,DepthToSpace:()=>$i,DepthwiseConv2dNative:()=>Zs,DepthwiseConv2dNativeBackpropFilter:()=>Qo,DepthwiseConv2dNativeBackpropInput:()=>Ja,Diag:()=>Za,Dilation2D:()=>Ao,Dilation2DBackpropFilter:()=>dl,Dilation2DBackpropInput:()=>hl,ENV:()=>_o,EarlyStopping:()=>KE,Einsum:()=>pl,Elu:()=>yo,EluGrad:()=>Pl,Environment:()=>Ri,Equal:()=>wi,Erf:()=>Wo,Exp:()=>xh,ExpandDims:()=>vo,Expm1:()=>qi,FFT:()=>ps,Fill:()=>Nu,FlipLeftRight:()=>Uc,Floor:()=>ac,FloorDiv:()=>Ii,FromPixels:()=>Gd,FusedBatchNorm:()=>zc,FusedConv2D:()=>Bh,FusedDepthwiseConv2D:()=>Ls,GatherNd:()=>Fm,GatherV2:()=>$c,GraphModel:()=>u2,Greater:()=>Ul,GreaterEqual:()=>Id,History:()=>In,IFFT:()=>Om,Identity:()=>Sd,Imag:()=>Pm,InputSpec:()=>zt,IsFinite:()=>Md,IsInf:()=>Td,IsNan:()=>_d,KernelBackend:()=>Ya,LRN:()=>Eh,LRNGrad:()=>tf,LayerVariable:()=>Ft,LayersModel:()=>Cn,LeakyRelu:()=>Kp,Less:()=>Jp,LessEqual:()=>Zp,LinSpace:()=>Um,Log:()=>kd,Log1p:()=>Rd,LogSoftmax:()=>XA,LogicalAnd:()=>wh,LogicalNot:()=>Bd,LogicalOr:()=>Nd,Max:()=>Dd,MaxPool:()=>Ld,MaxPool3D:()=>ef,MaxPool3DGrad:()=>zm,MaxPoolGrad:()=>Du,MaxPoolWithArgmax:()=>$m,Maximum:()=>Ch,Mean:()=>nf,Min:()=>rf,Minimum:()=>Fd,MirrorPad:()=>sf,Mod:()=>Od,MomentumOptimizer:()=>mg,Multinomial:()=>Vm,Multiply:()=>Lu,Neg:()=>ko,NonMaxSuppressionV3:()=>to,NonMaxSuppressionV4:()=>fa,NonMaxSuppressionV5:()=>af,NotEqual:()=>Vc,OP_SCOPE_SUFFIX:()=>Ro,OneHot:()=>oc,OnesLike:()=>zl,Optimizer:()=>ou,OptimizerConstructors:()=>qu,Pack:()=>Ua,PadV2:()=>Ki,Pool:()=>YA,Pow:()=>lc,Prelu:()=>ma,Prod:()=>Br,RMSPropOptimizer:()=>gg,RNN:()=>ku,Range:()=>Fu,Rank:()=>fc,Real:()=>Ye,RealDiv:()=>Ho,Reciprocal:()=>yr,Reduction:()=>Ha,Relu:()=>Ou,Relu6:()=>Ih,Reshape:()=>Pd,ResizeBilinear:()=>Qc,ResizeBilinearGrad:()=>lf,ResizeNearestNeighbor:()=>of,ResizeNearestNeighborGrad:()=>Gc,Reverse:()=>Ud,RotateWithOffset:()=>Hm,Round:()=>Sh,Rsqrt:()=>Mh,SGDOptimizer:()=>lp,ScatterNd:()=>Th,Select:()=>cf,Selu:()=>Jr,Sequential:()=>Er,Sigmoid:()=>zd,Sign:()=>_h,Sin:()=>Pu,Sinh:()=>$l,Slice:()=>cc,Softmax:()=>$d,Softplus:()=>fl,SpaceToBatchND:()=>Vi,SparseFillEmptyRows:()=>bo,SparseReshape:()=>kh,SparseSegmentMean:()=>Gm,SparseSegmentSum:()=>Rh,SparseToDense:()=>Qm,SplitV:()=>li,Sqrt:()=>Uu,Square:()=>Dt,SquaredDifference:()=>_s,Step:()=>Al,StridedSlice:()=>Vd,StringNGrams:()=>hf,StringSplit:()=>ta,StringToHashBucketFast:()=>ml,Sub:()=>eo,Sum:()=>uf,SymbolicTensor:()=>ee,Tan:()=>Hc,Tanh:()=>Vl,Tensor:()=>Zr,TensorBuffer:()=>is,Tile:()=>Gl,TopK:()=>Wc,Transform:()=>Ql,Transpose:()=>gl,Unique:()=>uc,Unpack:()=>jc,UnsortedSegmentSum:()=>zu,Variable:()=>Yd,ZerosLike:()=>$u,_FusedMatMul:()=>qc,abs:()=>Ps,acos:()=>w0,acosh:()=>E0,add:()=>an,addN:()=>C0,all:()=>Ag,any:()=>Wh,argMax:()=>cu,argMin:()=>I0,asin:()=>S0,asinh:()=>M0,atan:()=>yg,atan2:()=>tl,atanh:()=>Mf,avgPool:()=>up,avgPool3d:()=>Ku,backend:()=>L1,backend_util:()=>X,basicLSTMCell:()=>_f,batchNorm:()=>Kl,batchNorm2d:()=>qh,batchNorm3d:()=>hp,batchNorm4d:()=>_0,batchToSpaceND:()=>vc,bincount:()=>dp,booleanMaskAsync:()=>Dg,broadcastArgs:()=>pp,broadcastTo:()=>hu,broadcast_util:()=>E,browser:()=>D,buffer:()=>$r,callbacks:()=>xM,cast:()=>yn,ceil:()=>bg,clipByValue:()=>Va,clone:()=>ru,complex:()=>ss,concat:()=>ti,concat1d:()=>k0,concat2d:()=>R0,concat3d:()=>kf,concat4d:()=>Rf,constraints:()=>rt,conv1d:()=>Bf,conv2d:()=>bc,conv2dTranspose:()=>Nf,conv3d:()=>wg,conv3dTranspose:()=>B0,copyRegisteredKernels:()=>Mb,cos:()=>Ju,cosh:()=>fp,cosineWindow:()=>Fg,cumsum:()=>Df,customGrad:()=>gc,data:()=>ha,denseBincount:()=>Eg,deprecationWarn:()=>D1,depthToSpace:()=>Lf,depthwiseConv2d:()=>du,deregisterOp:()=>EM,device_util:()=>O,diag:()=>pu,dilation2d:()=>Cg,disableDeprecationWarnings:()=>$b,dispose:()=>Dr,disposeVariables:()=>Vb,div:()=>qn,divNoNan:()=>Jl,dot:()=>Xh,dropout:()=>rl,einsum:()=>N0,elu:()=>fu,enableDebugMode:()=>zb,enableProdMode:()=>Ub,enclosingPowerOfTwo:()=>em,engine:()=>au,env:()=>de,equal:()=>Bo,erf:()=>Ig,exp:()=>No,expandDims:()=>xa,expm1:()=>Yh,eye:()=>D0,fft:()=>Kf,fill:()=>op,findBackend:()=>Xb,findBackendFactory:()=>b0,floor:()=>mp,floorDiv:()=>hg,fused:()=>G,gather:()=>Kh,gatherND:()=>kp,gather_util:()=>B,getBackend:()=>jb,getGradient:()=>Hd,getKernel:()=>Qd,getKernelsForBackend:()=>Wd,grad:()=>F1,grads:()=>O1,greater:()=>ia,greaterEqual:()=>wo,ifft:()=>Hi,imag:()=>Ff,image:()=>sl,inTopKAsync:()=>q1,initializers:()=>pt,input:()=>es,io:()=>N,irfft:()=>ed,isFinite:()=>z1,isInf:()=>L0,isNaN:()=>Of,keep:()=>ya,kernel_impls:()=>lt,layers:()=>vt,leakyRelu:()=>Zu,less:()=>xc,lessEqual:()=>Cl,linalg:()=>iv,linspace:()=>Sg,loadGraphModel:()=>JM,loadLayersModel:()=>mi,localResponseNormalization:()=>Da,log:()=>Ga,log1p:()=>Pf,logSigmoid:()=>Uf,logSoftmax:()=>th,logSumExp:()=>zf,logicalAnd:()=>wa,logicalNot:()=>Ap,logicalOr:()=>yp,logicalXor:()=>$f,losses:()=>ix,matMul:()=>Or,math:()=>_,max:()=>Eo,maxPool:()=>eh,maxPool3d:()=>nh,maxPoolWithArgmax:()=>F0,maximum:()=>Ac,mean:()=>fs,memory:()=>lg,meshgrid:()=>$1,metrics:()=>bt,min:()=>vp,minimum:()=>bp,mirrorPad:()=>nl,mod:()=>xp,model:()=>Yr,models:()=>ft,moments:()=>Vf,movingAverage:()=>j1,mul:()=>ae,multiRNNCell:()=>O0,multinomial:()=>Gf,neg:()=>Ji,nextFrame:()=>Wg,norm:()=>tm,notEqual:()=>mu,oneHot:()=>zh,ones:()=>Ea,onesLike:()=>so,op:()=>Jt,outerProduct:()=>P0,pad:()=>wc,pad1d:()=>V1,pad2d:()=>Qf,pad3d:()=>Hf,pad4d:()=>U0,pool:()=>Tg,pow:()=>lu,prelu:()=>Ep,print:()=>v1,prod:()=>Cp,profile:()=>Gb,rand:()=>z0,randomGamma:()=>jf,randomNormal:()=>qf,randomUniform:()=>gu,range:()=>Zl,ready:()=>Wb,real:()=>ih,reciprocal:()=>Ec,registerBackend:()=>cg,registerCallbackConstructor:()=>_l,registerGradient:()=>Yn,registerKernel:()=>hc,registerOp:()=>wM,regularizers:()=>wt,relu:()=>Do,relu6:()=>Zh,removeBackend:()=>qb,reshape:()=>le,reverse:()=>Qa,reverse1d:()=>$0,reverse2d:()=>_g,reverse3d:()=>Q1,reverse4d:()=>td,rfft:()=>ah,round:()=>Xf,rsqrt:()=>Cc,scalar:()=>Jn,scatterND:()=>W0,scatter_util:()=>C,selu:()=>sh,separableConv2d:()=>V0,sequential:()=>yi,serialization:()=>k,setBackend:()=>Hb,setPlatform:()=>ug,setdiff1dAsync:()=>H1,sigmoid:()=>ba,sign:()=>G0,signal:()=>rv,sin:()=>kg,sinh:()=>Rg,slice:()=>Gr,slice1d:()=>Bg,slice2d:()=>Q0,slice3d:()=>Sp,slice4d:()=>Yf,slice_util:()=>M,softmax:()=>Ic,softplus:()=>ls,spaceToBatchND:()=>wp,sparse:()=>Lp,sparseToDense:()=>Lg,spectral:()=>vu,split:()=>ao,sqrt:()=>Ba,square:()=>Oi,squaredDifference:()=>nd,squeeze:()=>Lo,stack:()=>Co,step:()=>rd,stridedSlice:()=>id,string:()=>om,sub:()=>zn,sum:()=>Vn,sumOutType:()=>no,tan:()=>Jf,tanh:()=>El,tensor:()=>Yo,tensor1d:()=>Yi,tensor2d:()=>oh,tensor3d:()=>w1,tensor4d:()=>W1,tensor5d:()=>Ng,tensor6d:()=>Kb,tensor_util:()=>$,test_util:()=>F,tidy:()=>me,tile:()=>xo,time:()=>Qb,topk:()=>Mp,train:()=>uh,transpose:()=>qr,truncatedNormal:()=>lh,unique:()=>sd,unregisterGradient:()=>Hl,unregisterKernel:()=>jd,unsortedSegmentSum:()=>Tp,unstack:()=>oo,upcastType:()=>di,util:()=>U,valueAndGrad:()=>Yb,valueAndGrads:()=>x0,variable:()=>Zf,variableGrads:()=>P1,version:()=>YF,version_converter:()=>h2,version_core:()=>N1,version_layers:()=>Nc,where:()=>Us,whereAsync:()=>_p,zeros:()=>$s,zerosLike:()=>zr});var U={};I.r(U),I.d(U,{arraysEqual:()=>We,assert:()=>Z,assertNonNegativeIntegerDimensions:()=>xi,assertNonNull:()=>Ht,assertShapesMatch:()=>_t,bytesFromStringArray:()=>cn,bytesPerElement:()=>pn,checkConversionForErrors:()=>be,clamp:()=>qs,computeStrides:()=>gn,createScalarValue:()=>Kc,createShuffledIndices:()=>Wr,decodeString:()=>Dh,distSquared:()=>ut,encodeString:()=>jl,fetch:()=>t0,fingerPrint64:()=>h1,flatten:()=>Ae,getArrayFromDType:()=>jt,getTypedArrayFromDType:()=>Ut,hasEncodingLoss:()=>tn,hexToLong:()=>za,indexToLoc:()=>ai,inferDtype:()=>Mr,inferFromImplicitShape:()=>si,isBoolean:()=>qe,isFunction:()=>jn,isInt:()=>hn,isNumber:()=>Sn,isPromise:()=>ci,isScalarShape:()=>_e,isString:()=>bn,isTypedArray:()=>ke,isValidDtype:()=>Ze,locToIndex:()=>cr,makeOnesTypedArray:()=>rr,makeZerosNestedTypedArray:()=>br,makeZerosTypedArray:()=>wn,nearestDivisor:()=>Kn,nearestLargerEven:()=>se,now:()=>ga,parseAxisParam:()=>lr,randUniform:()=>st,repeatedTry:()=>mo,rightPad:()=>ii,shuffle:()=>ys,shuffleCombo:()=>To,sizeFromShape:()=>Wt,sizeToSquarishShape:()=>Hr,squeezeShape:()=>ki,sum:()=>q,swap:()=>Ct,tanh:()=>kn,toNestedArray:()=>Tr,toTypedArray:()=>Jc});var $={};I.r($),I.d($,{assertTypesMatch:()=>d1,getTensorsInContainer:()=>qo,isTensorInList:()=>$a,makeTypesMatch:()=>Ei});var O={};I.r(O),I.d(O,{isBrowser:()=>mf,isMobile:()=>s0,mockIsMobile:()=>i0});var N={};I.r(N),I.d(N,{browserFiles:()=>bf,browserHTTPRequest:()=>su,concatenateArrayBuffers:()=>tp,copyModel:()=>Bn,decodeWeights:()=>gf,encodeWeights:()=>Jd,fromMemory:()=>x1,getLoadHandlers:()=>os,getModelArtifactsForJSON:()=>ep,getModelArtifactsInfoForJSON:()=>Wu,getSaveHandlers:()=>np,http:()=>iu,isHTTPScheme:()=>wf,listModels:()=>ap,loadWeights:()=>c0,moveModel:()=>Yl,registerLoadRouter:()=>jm,registerSaveRouter:()=>g1,removeModel:()=>Ur,weightsLoaderFactory:()=>Zm,withSaveHandler:()=>ng});var _={};I.r(_),I.d(_,{confusionMatrix:()=>Bb});var E={};I.r(E),I.d(E,{assertAndGetBroadcastShape:()=>Nr,getBroadcastDims:()=>$h,getReductionAxes:()=>Os});var D={};I.r(D),I.d(D,{fromPixels:()=>d0,fromPixelsAsync:()=>h0,toPixels:()=>C1});var B={};I.r(B),I.d(B,{prepareAndValidate:()=>Ef});var C={};I.r(C),I.d(C,{calculateShapes:()=>Gh,validateInput:()=>ig,validateUpdateShape:()=>rg});var M={};I.r(M),I.d(M,{assertParamsValid:()=>sg,computeFlatOffset:()=>m0,computeOutShape:()=>ag,getNormalizedAxes:()=>Aa,isSliceContinous:()=>f0,maskToAxes:()=>I1,parseSliceParams:()=>og,sliceInfo:()=>g0,startForAxis:()=>T1,startIndicesWithElidedDims:()=>Cf,stopForAxis:()=>_1,stopIndicesWithElidedDims:()=>S1,stridesForAxis:()=>M1,stridesWithElidedDims:()=>p0});var k={};I.r(k),I.d(k,{Serializable:()=>Hh,SerializationMap:()=>Zo,registerClass:()=>on});var F={};I.r(F),I.d(F,{TEST_EPSILON_FLOAT16:()=>R1,encodeStrings:()=>B1,expectArrayBuffersEqual:()=>Pb,expectArraysClose:()=>Nb,expectArraysEqual:()=>Lb,expectNumbersClose:()=>Fb,expectPromiseToFail:()=>Db,expectValuesInRange:()=>Ob,testEpsilon:()=>A0});var G={};I.r(G),I.d(G,{conv2d:()=>Pg,depthwiseConv2d:()=>X1,matMul:()=>Au});var Q={};I.r(Q),I.d(Q,{collectGatherOpShapeInfo:()=>yy,computeOutShape:()=>Ay,segOpComputeOptimalWindowSize:()=>mv});var X={};I.r(X),I.d(X,{ERF_A1:()=>bu,ERF_A2:()=>Kg,ERF_A3:()=>ay,ERF_A4:()=>xu,ERF_A5:()=>oy,ERF_P:()=>Yg,PARALLELIZE_THRESHOLD:()=>jg,SELU_SCALE:()=>Xg,SELU_SCALEALPHA:()=>_c,applyActivation:()=>Sc,assertAndGetBroadcastShape:()=>Nr,assertAxesAreInnerMostDims:()=>zs,assertParamsConsistent:()=>ry,assignToTypedArray:()=>av,axesAreInnerMostDims:()=>gp,calculateShapes:()=>Gh,checkEinsumDimSizes:()=>uy,checkPadOnDimRoundingMode:()=>va,combineLocations:()=>Mg,complexWithEvenIndex:()=>Jg,complexWithOddIndex:()=>sv,computeConv2DInfo:()=>ra,computeConv3DInfo:()=>Xu,computeDefaultPad:()=>Tf,computeDilation2DInfo:()=>cp,computeOptimalWindowSize:()=>Tc,computeOutAndReduceShapes:()=>sa,computeOutShape:()=>ec,computePool2DInfo:()=>el,computePool3DInfo:()=>yc,convertConv2DDataFormat:()=>uu,decodeEinsumEquation:()=>cy,eitherStridesOrDilationsAreOne:()=>Na,expandShapeToKeepDim:()=>Ni,exponent:()=>lv,exponents:()=>ov,fromStringArrayToUint8:()=>hm,fromUint8ToStringArray:()=>Fo,getAxesPermutation:()=>vs,getBroadcastDims:()=>$h,getComplexWithIndex:()=>lm,getEinsumComputePath:()=>hy,getEinsumPermutation:()=>Zg,getFusedBiasGradient:()=>rm,getFusedDyActivation:()=>nm,getImageCenter:()=>iy,getInnerMostAxes:()=>Ai,getPermuted:()=>Op,getReductionAxes:()=>Os,getReshaped:()=>Fp,getReshapedPermuted:()=>nc,getSliceBeginCoords:()=>qg,getSliceSize:()=>sy,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>cv,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>uv,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>py,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>my,getSparseReshapeInputOutputMismatchErrorMessage:()=>pv,getSparseReshapeInputOutputMultipleErrorMessage:()=>dv,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>hv,getSparseReshapeNegativeOutputDimErrorMessage:()=>fy,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>um,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>fv,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ax,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>gy,getUndoAxesPermutation:()=>Jh,isIdentityPermutation:()=>cm,log:()=>KA,mergeRealAndImagArrays:()=>wu,prepareAndValidate:()=>Ef,prepareSplitSize:()=>dy,segment_util:()=>Q,shouldFuse:()=>im,slice_util:()=>M,splitRealAndImagArrays:()=>ly,tupleValuesAreOne:()=>Yu,upcastType:()=>di,validateInput:()=>ig,validateUpdateShape:()=>rg,warn:()=>Fs});var lt={};I.r(lt),I.d(lt,{nonMaxSuppressionV3Impl:()=>Vg,nonMaxSuppressionV4Impl:()=>Il,nonMaxSuppressionV5Impl:()=>Bp,whereImpl:()=>ad});var rt={};I.r(rt),I.d(rt,{maxNorm:()=>fd,minMaxNorm:()=>Qx,nonNeg:()=>Gx,unitNorm:()=>ph});var pt={};I.r(pt),I.d(pt,{constant:()=>jx,glorotNormal:()=>g,glorotUniform:()=>d,heNormal:()=>v,heUniform:()=>x,identity:()=>l,leCunNormal:()=>w,leCunUniform:()=>S,ones:()=>Tu,orthogonal:()=>P,randomNormal:()=>e,randomUniform:()=>A,truncatedNormal:()=>s,varianceScaling:()=>c,zeros:()=>Fv});var vt={};I.r(vt),I.d(vt,{Layer:()=>ie,RNN:()=>ku,RNNCell:()=>Wy,activation:()=>lS,add:()=>AS,alphaDropout:()=>tM,average:()=>yS,averagePooling1d:()=>Pw,averagePooling2d:()=>Uw,averagePooling3d:()=>zw,avgPool1d:()=>MS,avgPool2d:()=>_S,avgPool3d:()=>RS,avgPooling1d:()=>TS,avgPooling2d:()=>kS,avgPooling3d:()=>BS,batchNormalization:()=>CS,bidirectional:()=>WS,concatenate:()=>vS,conv1d:()=>ZI,conv2d:()=>tS,conv2dTranspose:()=>eS,conv3d:()=>nS,conv3dTranspose:()=>rS,convLstm2d:()=>VS,convLstm2dCell:()=>GS,cropping2D:()=>sS,dense:()=>cS,depthwiseConv2d:()=>oS,dot:()=>ES,dropout:()=>uS,elu:()=>jI,embedding:()=>gS,flatten:()=>dS,gaussianDropout:()=>ZS,gaussianNoise:()=>JS,globalAveragePooling1d:()=>NS,globalAveragePooling2d:()=>DS,globalMaxPool1d:()=>qS,globalMaxPool2d:()=>XS,globalMaxPooling1d:()=>WE,globalMaxPooling2d:()=>jE,gru:()=>FS,gruCell:()=>OS,input:()=>es,inputLayer:()=>WI,layerNormalization:()=>IS,leakyReLU:()=>XI,lstm:()=>PS,lstmCell:()=>US,masking:()=>eM,maxPool1d:()=>YS,maxPool2d:()=>KS,maxPooling1d:()=>qE,maxPooling2d:()=>XE,maxPooling3d:()=>LS,maximum:()=>bS,minimum:()=>xS,multiply:()=>wS,permute:()=>mS,prelu:()=>YI,reLU:()=>qI,repeatVector:()=>pS,reshape:()=>fS,rnn:()=>QS,separableConv2d:()=>iS,simpleRNN:()=>zS,simpleRNNCell:()=>$S,softmax:()=>KI,spatialDropout1d:()=>hS,stackedRNNCells:()=>HS,thresholdedReLU:()=>JI,timeDistributed:()=>jS,upSampling2d:()=>aS,zeroPadding2d:()=>SS});var bt={};I.r(bt),I.d(bt,{MAPE:()=>dM,MSE:()=>mM,binaryAccuracy:()=>nM,binaryCrossentropy:()=>rM,categoricalAccuracy:()=>sM,categoricalCrossentropy:()=>aM,cosineProximity:()=>cM,mape:()=>pM,meanAbsoluteError:()=>uM,meanAbsolutePercentageError:()=>hM,meanSquaredError:()=>fM,mse:()=>gM,precision:()=>oM,recall:()=>lM,sparseCategoricalAccuracy:()=>iM});var ft={};I.r(ft),I.d(ft,{modelFromJSON:()=>fr});var wt={};I.r(wt),I.d(wt,{l1:()=>yM,l1l2:()=>AM,l2:()=>vM});var et={};I.r(et),I.d(et,{json:()=>CM});var xt={};I.r(xt),I.d(xt,{json:()=>IM});var Rt={};I.r(Rt),I.d(Rt,{json:()=>SM});var Yt={};I.r(Yt),I.d(Yt,{json:()=>MM});var ve={};I.r(ve),I.d(ve,{json:()=>TM});var xe={};I.r(xe),I.d(xe,{json:()=>_M});var Ge={};I.r(Ge),I.d(Ge,{json:()=>kM});var en={};I.r(en),I.d(en,{json:()=>RM});var nn={};I.r(nn),I.d(nn,{json:()=>BM});var vn={};I.r(vn),I.d(vn,{json:()=>NM});var _n={};I.r(_n),I.d(_n,{json:()=>DM});var nr={};I.r(nr),I.d(nr,{json:()=>LM});var hr={};I.r(hr),I.d(hr,{json:()=>FM});var Cs={};I.r(Cs),I.d(Cs,{json:()=>OM});var Ti={};I.r(Ti),I.d(Ti,{json:()=>PM});var Is={};I.r(Is),I.d(Is,{json:()=>UM});var As={};I.r(As),I.d(As,{json:()=>zM});var ua={};I.r(ua),I.d(ua,{json:()=>$M});var Oa={};I.r(Oa),I.d(Oa,{json:()=>VM});var ha={};I.r(ha),I.d(ha,{CSVDataset:()=>E2,Dataset:()=>NA,FileDataSource:()=>T2,TextLineDataset:()=>b2,URLDataSource:()=>_2,array:()=>pT,csv:()=>xT,func:()=>wT,generator:()=>ET,microphone:()=>IT,version_data:()=>k2,webcam:()=>CT,zip:()=>fT});var js={};I.r(js),I.d(js,{addImpl:()=>O2,bincountImpl:()=>uE,bincountReduceImpl:()=>G2,ceilImpl:()=>Q2,concatImpl:()=>H2,equalImpl:()=>q2,expImpl:()=>Y2,expm1Impl:()=>J2,floorImpl:()=>eC,gatherNdImpl:()=>nC,gatherV2Impl:()=>rC,greaterEqualImpl:()=>sC,greaterImpl:()=>iC,lessEqualImpl:()=>oC,lessImpl:()=>aC,linSpaceImpl:()=>lC,logImpl:()=>cC,maxImpl:()=>uC,maximumImpl:()=>dC,minimumImpl:()=>pC,multiplyImpl:()=>hE,negImpl:()=>mC,notEqualImpl:()=>gC,prodImpl:()=>vC,rangeImpl:()=>bC,rsqrtImpl:()=>xC,sigmoidImpl:()=>DT,simpleAbsImpl:()=>U2,sliceImpl:()=>V2,sparseFillEmptyRowsImpl:()=>CC,sparseReshapeImpl:()=>IC,sparseSegmentReductionImpl:()=>AE,sqrtImpl:()=>bR,squaredDifferenceImpl:()=>SC,stridedSliceImpl:()=>MC,stringNGramsImpl:()=>TC,stringSplitImpl:()=>_C,stringToHashBucketFastImpl:()=>kC,subImpl:()=>Z2,tileImpl:()=>RC,topKImpl:()=>NC,transposeImpl:()=>lE,uniqueImpl:()=>LC});class Xa{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Ya{refCount(t){return _i("refCount")}incRef(t){return _i("incRef")}timerAvailable(){return!0}time(t){return _i("time")}read(t){return _i("read")}readSync(t){return _i("readSync")}readToGPU(t,n){return _i("readToGPU")}numDataIds(){return _i("numDataIds")}disposeData(t,n){return _i("disposeData")}write(t,n,i){return _i("write")}move(t,n,i,a,o){return _i("move")}memory(){return _i("memory")}floatPrecision(){return _i("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return _i("dispose")}}function _i(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function ys(r){let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Ct(r,t,n)}function To(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let n=r.length,i=0;for(;n>0;)i=Math.random()*n|0,n--,Ct(r,n,i),Ct(t,n,i)}function qs(r,t,n){return Math.max(r,Math.min(t,n))}function se(r){return r%2==0?r:r+1}function Ct(r,t,n){const i=r[t];r[t]=r[n],r[n]=i}function q(r){let t=0;for(let n=0;n<r.length;n++)t+=r[n];return t}function st(r,t){const n=Math.random();return t*n+(1-n)*r}function ut(r,t){let n=0;for(let i=0;i<r.length;i++){const a=Number(r[i])-Number(t[i]);n+=a*a}return n}function Z(r,t){if(!r)throw new Error("string"==typeof t?t:t())}function _t(r,t,n=""){Z(We(r,t),()=>n+` Shapes ${r} and ${t} must match`)}function Ht(r){Z(null!=r,()=>"The input to the tensor constructor must be a non-null value.")}function Ae(r,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(r)||ke(r)&&!n)for(let i=0;i<r.length;++i)Ae(r[i],t,n);else t.push(r);return t}function Wt(r){if(0===r.length)return 1;let t=r[0];for(let n=1;n<r.length;n++)t*=r[n];return t}function _e(r){return 0===r.length}function We(r,t){if(r===t)return!0;if(null==r||null==t||r.length!==t.length)return!1;for(let n=0;n<r.length;n++)if(r[n]!==t[n])return!1;return!0}function hn(r){return r%1==0}function kn(r){if(null!=Math.tanh)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{const t=Math.exp(2*r);return(t-1)/(t+1)}}function Hr(r){const t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function Wr(r){const t=new Uint32Array(r);for(let n=0;n<r;++n)t[n]=n;return ys(t),t}function ii(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function mo(r,t=(i=>0),n){return new Promise((i,a)=>{let o=0;const u=()=>{if(r())return void i();o++;const h=t(o);null!=n&&o>=n?a():setTimeout(u,h)};u()})}function si(r,t){let n=1,i=-1;for(let o=0;o<r.length;++o)if(r[o]>=0)n*=r[o];else if(-1===r[o]){if(-1!==i)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${i} and dim ${o}`);i=o}else if(r[o]<0)throw Error(`Shapes can not be < 0. Found ${r[o]} at dim ${o}`);if(-1===i){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(0===n)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const a=r.slice();return a[i]=t/n,a}function lr(r,t){const n=t.length;return Z((r=null==r?t.map((i,a)=>a):[].concat(r)).every(i=>i>=-n&&i<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${r}`),Z(r.every(i=>hn(i)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(i=>i<0?n+i:i)}function ki(r,t){const n=[],i=[],a=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||a?null:lr(t,r).sort();let u=0;for(let h=0;h<r.length;++h){if(null!=o){if(o[u]===h&&1!==r[h])throw new Error(`Can't squeeze axis ${h} since its dim '${r[h]}' is not 1`);(null==o[u]||o[u]>h)&&1===r[h]&&(n.push(r[h]),i.push(h)),o[u]<=h&&u++}1!==r[h]&&(n.push(r[h]),i.push(h))}return{newShape:n,keptDims:i}}function Ut(r,t){let n=null;if(null==r||"float32"===r)n=new Float32Array(t);else if("int32"===r)n=new Int32Array(t);else{if("bool"!==r)throw new Error(`Unknown data type ${r}`);n=new Uint8Array(t)}return n}function jt(r,t){let n=null;if(null==r||"float32"===r)n=new Float32Array(t);else if("int32"===r)n=new Int32Array(t);else if("bool"===r)n=new Uint8Array(t);else{if("string"!==r)throw new Error(`Unknown data type ${r}`);n=new Array(t)}return n}function be(r,t){for(let n=0;n<r.length;n++){const i=r[n];if(isNaN(i)||!isFinite(i))throw Error(`A tensor of type ${t} being uploaded contains ${i}.`)}}function Ze(r){return"bool"===r||"complex64"===r||"float32"===r||"int32"===r||"string"===r}function tn(r,t){return!("complex64"===t||"float32"===t&&"complex64"!==r||"int32"===t&&"float32"!==r&&"complex64"!==r||"bool"===t&&"bool"===r)}function ke(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function pn(r){if("float32"===r||"int32"===r)return 4;if("complex64"===r)return 8;if("bool"===r)return 1;throw new Error(`Unknown dtype ${r}`)}function cn(r){if(null==r)return 0;let t=0;return r.forEach(n=>t+=n.length),t}function bn(r){return"string"==typeof r||r instanceof String}function qe(r){return"boolean"==typeof r}function Sn(r){return"number"==typeof r}function Mr(r){return Array.isArray(r)?Mr(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":Sn(r)?"float32":bn(r)?"string":qe(r)?"bool":"float32"}function jn(r){return!!(r&&r.constructor&&r.call&&r.apply)}function Kn(r,t){for(let n=t;n<r;++n)if(r%n==0)return n;return r}function gn(r){const t=r.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=r[t-1];for(let i=t-3;i>=0;--i)n[i]=n[i+1]*r[i+1];return n}function vr(r,t,n,i=!1){const a=new Array;if(1===t.length){const o=t[0]*(i?2:1);for(let u=0;u<o;u++)a[u]=n[r+u]}else{const o=t[0],u=t.slice(1),h=u.reduce((f,p)=>f*p)*(i?2:1);for(let f=0;f<o;f++)a[f]=vr(r+f*h,u,n,i)}return a}function Tr(r,t,n=!1){if(0===r.length)return t[0];const i=r.reduce((a,o)=>a*o)*(n?2:1);if(0===i)return[];if(i!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return vr(0,r,t,n)}function rr(r,t){const n=wn(r,t);for(let i=0;i<n.length;i++)n[i]=1;return n}function wn(r,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(r);if("int32"===t)return new Int32Array(r);if("bool"===t)return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function br(r,t){const n=r.reduce((i,a)=>i*a,1);if(null==t||"float32"===t)return Tr(r,new Float32Array(n));if("int32"===t)return Tr(r,new Int32Array(n));if("bool"===t)return Tr(r,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function xi(r){r.forEach(t=>{Z(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function cr(r,t,n){if(0===t)return 0;if(1===t)return r[0];let i=r[r.length-1];for(let a=0;a<r.length-1;++a)i+=n[a]*r[a];return i}function ai(r,t,n){if(0===t)return[];if(1===t)return[r];const i=new Array(t);for(let a=0;a<i.length-1;++a)i[a]=Math.floor(r/n[a]),r-=i[a]*n[a];return i[i.length-1]=r,i}function ci(r){return r&&r.then&&"function"==typeof r.then}class Ri{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=jr,this.populateURLFlags()}setPlatform(t,n){null!=this.platform&&(de().getBool("IS_TEST")||de().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,i){if(this.flagRegistry[t]={evaluationFn:n,setHook:i},null!=this.urlFlags[t]){const a=this.urlFlags[t];de().getBool("IS_TEST")||de().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${a}.`),this.set(t,a)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(ci(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach(n=>{const[i,a]=n.split(":");this.urlFlags[i]=function(o,u){if("true"===(u=u.toLowerCase())||"false"===u)return"true"===u;if(""+ +u===u)return+u;throw new Error(`Could not parse value flag value ${u} for flag ${o}.`)}(i,a)})}}function jr(r){const t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...i)=>{return u=i[1],t[decodeURIComponent(i[0])]=decodeURIComponent(u||""),i.join("=");var u}),t}function de(){return _o}let go,_o=null;function Bi(){if(null==go){let r;if(typeof window<"u")r=window;else if(void 0!==I.g)r=I.g;else if(typeof process<"u")r=process;else{if(typeof self>"u")throw new Error("Could not find a global object");r=self}go=r}return go}function Ta(r,t){const n=function(){const i=Bi();return null==i._tfGlobals&&(i._tfGlobals=new Map),i._tfGlobals}();if(n.has(r))return n.get(r);{const i=t();return n.set(r,i),n.get(r)}}const da="Abs",pa="Acos",Ss="Acosh",Xs="Add",Ms="AddN",_a="All",Pa="Any",Ys="ArgMax",Ks="ArgMin",Ka="Asin",oi="Asinh",Ol="Atan",Go="Atanh",Li="Atan2",K="AvgPool",mt="AvgPoolGrad",It="AvgPool3D",Mt="AvgPool3DGrad",Gt="BatchMatMul",Xt="BatchToSpaceND",Me="Bincount",sn="BroadcastTo",un="BroadcastArgs",Ie="Cast",Be="Ceil",Pn="ClipByValue",Xn="Complex",dr="ComplexAbs",Ar="Concat",xr="Conv2D",_r="Conv2DBackpropFilter",Pr="Conv2DBackpropInput",ui="Conv3D",us="Conv3DBackpropFilterV2",Fi="Conv3DBackpropInputV2",rs="Cos",Ts="Cosh",Js="Cumsum",hs="CropAndResize",ds="DenseBincount",$i="DepthToSpace",Zs="DepthwiseConv2dNative",Qo="DepthwiseConv2dNativeBackpropFilter",Ja="DepthwiseConv2dNativeBackpropInput",Za="Diag",Ao="Dilation2D",hl="Dilation2DBackpropInput",dl="Dilation2DBackpropFilter",Ho="RealDiv",pl="Einsum",yo="Elu",Pl="EluGrad",Wo="Erf",wi="Equal",xh="Exp",vo="ExpandDims",qi="Expm1",ps="FFT",Nu="Fill",Uc="FlipLeftRight",ac="Floor",Ii="FloorDiv",zc="FusedBatchNorm",$c="GatherV2",Fm="GatherNd",Ul="Greater",Id="GreaterEqual",Sd="Identity",Om="IFFT",Pm="Imag",Md="IsFinite",Td="IsInf",_d="IsNan",Kp="LeakyRelu",Jp="Less",Zp="LessEqual",Um="LinSpace",kd="Log",Rd="Log1p",wh="LogicalAnd",Bd="LogicalNot",Nd="LogicalOr",XA="LogSoftmax",Eh="LRN",tf="LRNGrad",Dd="Max",Ch="Maximum",Ld="MaxPool",Du="MaxPoolGrad",ef="MaxPool3D",zm="MaxPool3DGrad",$m="MaxPoolWithArgmax",nf="Mean",rf="Min",Fd="Minimum",sf="MirrorPad",Od="Mod",Vm="Multinomial",Lu="Multiply",ko="Neg",Vc="NotEqual",to="NonMaxSuppressionV3",fa="NonMaxSuppressionV4",af="NonMaxSuppressionV5",zl="OnesLike",oc="OneHot",Ua="Pack",Ki="PadV2",YA="Pool",lc="Pow",ma="Prelu",Br="Prod",Fu="Range",Ye="Real",yr="Reciprocal",Ou="Relu",Pd="Reshape",of="ResizeNearestNeighbor",Gc="ResizeNearestNeighborGrad",Qc="ResizeBilinear",lf="ResizeBilinearGrad",Ih="Relu6",Ud="Reverse",Sh="Round",Mh="Rsqrt",Th="ScatterNd",cf="Select",Jr="Selu",cc="Slice",Pu="Sin",$l="Sinh",_h="Sign",zd="Sigmoid",fl="Softplus",Uu="Sqrt",uf="Sum",Vi="SpaceToBatchND",li="SplitV",$d="Softmax",bo="SparseFillEmptyRows",kh="SparseReshape",Gm="SparseSegmentMean",Rh="SparseSegmentSum",Qm="SparseToDense",_s="SquaredDifference",Dt="Square",Vd="StridedSlice",hf="StringNGrams",ta="StringSplit",ml="StringToHashBucketFast",eo="Sub",Hc="Tan",Vl="Tanh",Gl="Tile",Wc="TopK",Ql="Transform",gl="Transpose",uc="Unique",jc="Unpack",zu="UnsortedSegmentSum",$u="ZerosLike",Al="Step",Gd="FromPixels",Hm="RotateWithOffset",qc="_FusedMatMul",Bh="FusedConv2D",Ls="FusedDepthwiseConv2D";function Fs(...r){de().getBool("IS_TEST")||de().getBool("PROD")||console.warn(...r)}function KA(...r){de().getBool("IS_TEST")||de().getBool("PROD")||console.log(...r)}const Xc=Ta("kernelRegistry",()=>new Map),yl=Ta("gradRegistry",()=>new Map);function Qd(r,t){const n=JA(r,t);return Xc.get(n)}function Hd(r){return yl.get(r)}function Wd(r){const t=Xc.entries(),n=[];for(;;){const{done:i,value:a}=t.next();if(i)break;const[o,u]=a,[h]=o.split("_");h===r&&n.push(u)}return n}function hc(r){const{kernelName:t,backendName:n}=r,i=JA(t,n);Xc.has(i)&&Fs(`The kernel '${t}' for backend '${n}' is already registered`),Xc.set(i,r)}function Yn(r){const{kernelName:t}=r;yl.has(t)&&de().getBool("DEBUG")&&Fs(`Overriding the gradient for '${t}'`),yl.set(t,r)}function jd(r,t){const n=JA(r,t);if(!Xc.has(n))throw new Error(`The kernel '${r}' for backend '${t}' is not registered`);Xc.delete(n)}function Hl(r){if(!yl.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);yl.delete(r)}function Mb(r,t){Wd(r).forEach(n=>{hc(Object.assign({},n,{backendName:t}))})}function JA(r,t){return`${t}_${r}`}var Yc=I(3720);const dc=I.n(Yc)()||Yc;function za(r){return dc.fromString(r,!0,16)}const ZA=za("c3a5c85c97cb3127"),Vu=za("b492b66fbe98f273"),Gi=za("9ae16a3b2f90404f");function qd(r){return r.xor(r.shru(47))}function u1(r,t,n){const i=r.slice(t,t+n);return dc.fromBytes(Array.from(i),!0,!0)}function Qi(r,t){return u1(r,t,8)}function Nh(r,t){return u1(r,t,4)}function Xi(r,t){return 0===t?r:r.shru(t).or(r.shl(64-t))}function Wl(r,t,n=za("9ddfea08eb382d69")){let i=r.xor(t).mul(n);i=i.xor(i.shru(47));let a=t.xor(i).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Gu(r,t,n,i){return function(a,o,u,h,f,p){f=f.add(a),p=Xi(p.add(f).add(h),21);const m=f;return f=(f=f.add(o)).add(u),p=p.add(Xi(f,44)),[f.add(h),p.add(m)]}(Qi(r,t),Qi(r,t+8),Qi(r,t+16),Qi(r,t+24),n,i)}function h1(r,t=r.length){const n=dc.fromNumber(81,!0);if(t<=32)return t<=16?function(b,T=b.length){if(T>=8){const R=Gi.add(2*T),L=Qi(b,0).add(Gi),V=Qi(b,T-8);return Wl(Xi(V,37).mul(R).add(L),Xi(L,25).add(V).mul(R),R)}if(T>=4){const R=Gi.add(2*T);return Wl(Nh(b,0).shl(3).add(T),Nh(b,T-4),R)}if(T>0){const L=T+(b[T-1]<<2);return qd(Gi.mul(b[0]+(b[T>>1]<<8)).xor(ZA.mul(L))).mul(Gi)}return Gi}(r,t):function(b,T=b.length){const R=Gi.add(2*T),L=Qi(b,0).mul(Vu),V=Qi(b,8),j=Qi(b,T-8).mul(R),H=Qi(b,T-16).mul(Gi);return Wl(Xi(L.add(V),43).add(Xi(j,30)).add(H),L.add(Xi(V.add(Gi),18)).add(j),R)}(r,t);if(t<=64)return function(b,T=b.length){const R=Gi.add(2*T),L=Qi(b,0).mul(Gi),V=Qi(b,8),j=Qi(b,T-8).mul(R),H=Qi(b,T-16).mul(Gi),nt=Xi(L.add(V),43).add(Xi(j,30)).add(H),dt=Wl(nt,L.add(Xi(V.add(Gi),18)).add(j),R),yt=Qi(b,16).mul(R),kt=Qi(b,24),Ot=nt.add(Qi(b,T-32)).mul(R),Nt=dt.add(Qi(b,T-24)).mul(R);return Wl(Xi(yt.add(kt),43).add(Xi(Ot,30)).add(Nt),yt.add(Xi(kt.add(L),18)).add(Ot),R)}(r,t);let i=n,a=n.mul(Vu).add(113),o=qd(a.mul(Gi).add(113)).mul(Gi),u=[dc.UZERO,dc.UZERO],h=[dc.UZERO,dc.UZERO];i=i.mul(Gi).add(Qi(r,0));let f=0;const p=64*(t-1>>6),m=p+(t-1&63)-63;do{i=Xi(i.add(a).add(u[0]).add(Qi(r,f+8)),37).mul(Vu),a=Xi(a.add(u[1]).add(Qi(r,f+48)),42).mul(Vu),i=i.xor(h[1]),a=a.add(u[0]).add(Qi(r,f+40)),o=Xi(o.add(h[0]),33).mul(Vu),u=Gu(r,f,u[1].mul(Vu),i.add(h[0])),h=Gu(r,f+32,o.add(h[1]),a.add(Qi(r,f+16))),[o,i]=[i,o],f+=64}while(f!==p);const y=Vu.add(o.and(255).shl(1));return f=m,h[0]=h[0].add(t-1&63),u[0]=u[0].add(h[0]),h[0]=h[0].add(u[0]),i=Xi(i.add(a).add(u[0]).add(Qi(r,f+8)),37).mul(y),a=Xi(a.add(u[1]).add(Qi(r,f+48)),42).mul(y),i=i.xor(h[1].mul(9)),a=a.add(u[0].mul(9).add(Qi(r,f+40))),o=Xi(o.add(h[0]),33).mul(y),u=Gu(r,f,u[1].mul(y),i.add(h[0])),h=Gu(r,f+32,o.add(h[1]),a.add(Qi(r,f+16))),[o,i]=[i,o],Wl(Wl(u[0],h[0],y).add(qd(a).mul(ZA)).add(o),Wl(u[1],h[1],y).add(i),y)}function Kc(r,t){return"string"===t?jl(r):Jc([r],t)}function Jc(r,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Ae(r)),de().getBool("DEBUG")&&be(r,t),i=t,(n=r)instanceof Float32Array&&"float32"===i||n instanceof Int32Array&&"int32"===i||n instanceof Uint8Array&&"bool"===i)return r;var n,i;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(r);if("int32"===t)return new Int32Array(r);if("bool"===t){const n=new Uint8Array(r.length);for(let i=0;i<n.length;++i)0!==Math.round(r[i])&&(n[i]=1);return n}throw new Error(`Unknown data type ${t}`)}function ga(){return de().platform.now()}function t0(r,t){return de().platform.fetch(r,t)}function jl(r,t="utf-8"){return t=t||"utf-8",de().platform.encode(r,t)}function Dh(r,t="utf-8"){return t=t||"utf-8",de().platform.decode(r,t)}class Xd{constructor(t,n){this.backendTimer=t,this.logger=n,null==n&&(this.logger=new hi)}profileKernel(t,n,i){let a;const o=()=>{a=i()};let u;const h=ga();if(this.backendTimer.timerAvailable())u=this.backendTimer.time(o);else{o();for(const f of a)f.dataSync();u=Promise.resolve({kernelMs:ga()-h})}if(de().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let f=0;f<a.length;f++){const p=a[f];p.data().then(m=>{e0(m,p.dtype,t)})}return{kernelName:t,outputs:a,inputs:n,timeMs:u.then(f=>f.kernelMs),extraInfo:u.then(f=>null!=f.getExtraProfileInfo?f.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:i,timeMs:a,inputs:o,extraInfo:u}=t;i.forEach(h=>{Promise.all([h.data(),a,u]).then(f=>{this.logger.logKernelProfile(n,h,f[0],f[1],o,f[2])})})}}function e0(r,t,n){if("float32"!==t)return!1;for(let i=0;i<r.length;i++){const a=r[i];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${n}'`),!0}return!1}class hi{logKernelProfile(t,n,i,a,o,u){const h="number"==typeof a?ii(`${a}ms`,9):a.error,f=ii(t,25),p=n.rank,m=n.size,y=ii(n.shape.toString(),14);let b="";for(const T in o){const R=o[T];if(null!=R){const L=R.shape||n.shape,V=L.length;b+=`${T}: ${V}D ${V>0?L:""} `}}console.log(`%c${f}\t%c${h}\t%c${p}D ${y}\t%c${m}\t%c${b}\t%c${u}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ql(r,t,n,i){const a=gn(t),o=function(p,m,y,b){const T=Wt(m),R=b[b.length-1],L=new Array(R).fill(0),V=m.length,j="complex64"===y?pc(p):p;if(V>1)for(let H=0;H<T/R;H++){const nt=H*R;for(let dt=0;dt<R;dt++)L[dt]=Math.max(L[dt],jo(j[nt+dt],0,y).length)}return L}(r,t,n,a),u=t.length,h=vl(r,t,n,a,o),f=["Tensor"];return i&&(f.push(`  dtype: ${n}`),f.push(`  rank: ${u}`),f.push(`  shape: [${t}]`),f.push("  values:")),f.push(h.map(p=>"    "+p).join("\n")),f.join("\n")}function jo(r,t,n){let i;return i=Array.isArray(r)?`${parseFloat(r[0].toFixed(7))} + ${parseFloat(r[1].toFixed(7))}j`:bn(r)?`'${r}'`:"bool"===n?Wm(r):parseFloat(r.toFixed(7)).toString(),ii(i,t)}function Wm(r){return 0===r?"false":"true"}function vl(r,t,n,i,a,o=!0){const u="complex64"===n?2:1,h=t[0],f=t.length;if(0===f)return"complex64"===n?[jo(pc(r)[0],0,n)]:"bool"===n?[Wm(r[0])]:[r[0].toString()];if(1===f){if(h>20){let V=Array.from(r.slice(0,3*u)),j=Array.from(r.slice((h-3)*u,h*u));return"complex64"===n&&(V=pc(V),j=pc(j)),["["+V.map((H,nt)=>jo(H,a[nt],n)).join(", ")+", ..., "+j.map((H,nt)=>jo(H,a[h-3+nt],n)).join(", ")+"]"]}return["["+("complex64"===n?pc(r):Array.from(r)).map((L,V)=>jo(L,a[V],n)).join(", ")+"]"]}const p=t.slice(1),m=i.slice(1),y=i[0]*u,b=[];if(h>20){for(let L=0;L<3;L++){const V=L*y;b.push(...vl(r.slice(V,V+y),p,n,m,a,!1))}b.push("...");for(let L=h-3;L<h;L++){const V=L*y;b.push(...vl(r.slice(V,V+y),p,n,m,a,L===h-1))}}else for(let L=0;L<h;L++){const V=L*y;b.push(...vl(r.slice(V,V+y),p,n,m,a,L===h-1))}const T=2===f?",":"";b[0]="["+b[0]+T;for(let L=1;L<b.length-1;L++)b[L]=" "+b[L]+T;let R=",\n";for(let L=2;L<f;L++)R+="\n";return b[b.length-1]=" "+b[b.length-1]+"]"+(o?"":R),b}function pc(r){const t=[];for(let n=0;n<r.length;n+=2)t.push([r[n],r[n+1]]);return t}class is{constructor(t,n,i){if(this.dtype=n,this.shape=t.slice(),this.size=Wt(t),null!=i){const a=i.length;Z(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===n)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=i||jt(n,this.size),this.strides=gn(t)}set(t,...n){0===n.length&&(n=[0]),Z(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const i=this.locToIndex(n);this.values[i]=t}get(...t){0===t.length&&(t=[0]);let n=0;for(const a of t){if(a<0||a>=this.shape[n])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);n++}let i=t[t.length-1];for(let a=0;a<t.length-1;++a)i+=this.strides[a]*t[a];return this.values[i]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let n=t[t.length-1];for(let i=0;i<t.length-1;++i)n+=this.strides[i]*t[i];return n}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const n=new Array(this.shape.length);for(let i=0;i<n.length-1;++i)n[i]=Math.floor(t/this.strides[i]),t-=n[i]*this.strides[i];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return bl().makeTensor(this.values,this.shape,this.dtype)}}let bl=null,Qu=null,n0=null;class Zr{constructor(t,n,i,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=Wt(t),this.strides=gn(t),this.dataId=i,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Qu.buffer(this.shape,this.dtype,t)}bufferSync(){return Qu.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Tr(this.shape,t,"complex64"===this.dtype)}arraySync(){return Tr(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=bl().read(this.dataId);if("string"===this.dtype){const n=await t;try{return n.map(i=>Dh(i))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),bl().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=bl().readSync(this.dataId);if("string"===this.dtype)try{return t.map(n=>Dh(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await bl().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(bl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Qu.print(this,t)}clone(){return this.throwIfDisposed(),Qu.clone(this)}toString(t=!1){return ql(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Qu.cast(this,t)}variable(t=!0,n,i){return this.throwIfDisposed(),bl().makeVariable(this,t,n,i)}}function Re(){return Ta("Tensor",()=>Zr)}Object.defineProperty(Zr,Symbol.hasInstance,{value:r=>!!r&&null!=r.data&&null!=r.dataSync&&null!=r.throwIfDisposed}),Re();class Yd extends Zr{constructor(t,n,i,a){super(t.shape,t.dtype,t.dataId,a),this.trainable=n,this.name=i}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!We(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);bl().disposeTensor(this),this.dataId=t.dataId,bl().incRef(this,null)}dispose(){bl().disposeVariable(this),this.isDisposedInternal=!0}}var fc,Kd,df,En,ka,r;Object.defineProperty(Yd,Symbol.hasInstance,{value:r=>r instanceof Zr&&null!=r.assign&&r.assign instanceof Function}),(r=fc||(fc={})).R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6",function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"}(Kd||(Kd={})),function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"}(df||(df={})),function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"}(En||(En={})),function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"}(ka||(ka={}));const Tb={float32:En,int32:Kd,bool:df,complex64:ka};function di(r,t){if("string"===r||"string"===t){if("string"===r&&"string"===t)return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return Tb[r][t]}function no(r){return di(r,"int32")}function Ei(r,t){if(r.dtype===t.dtype)return[r,t];const n=di(r.dtype,t.dtype);return[r.cast(n),t.cast(n)]}function d1(r,t){Z(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function $a(r,t){return t.some(n=>n.id===r.id)}function qo(r){const t=[];return pf(r,t,new Set),t}function pf(r,t,n){if(null==r)return;if(r instanceof Zr)return void t.push(r);if(i=r,!Array.isArray(i)&&"object"!=typeof i)return;var i;const a=r;for(const o in a){const u=a[o];n.has(u)||(n.add(u),pf(u,t,n))}}function ks(r){return null!=r.kernelName}class ff{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class wr{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ff}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const i=t[n];if(await this.initializeBackend(i).success)return void await this.setBackend(i)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:n}=this.initializeBackend(t);if(n)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,i=1){return t in this.registryFactory?(Fs(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:i},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:n,asyncInit:i}=this.initializeBackend(t);if(!(i?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Xd(this.backendInstance),!0}setupRegisteredKernels(){Wd(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Wd(t).forEach(n=>{null!=n.disposeFunc&&n.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(null==n)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const i=n.factory();if(!i||i instanceof Ya||"function"!=typeof i.then)return this.registry[t]=i,{success:!0,asyncInit:!1};{const a=++this.pendingBackendInitId,o=i.then(u=>!(a<this.pendingBackendInitId||(this.registry[t]=u,this.pendingBackendInit=null,0))).catch(u=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,Fs(`Initialization of backend ${t} failed`),Fs(u.stack||u.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(i){return Fs(`Initialization of backend ${t} failed`),Fs(i.stack||i.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const i=t[n],{success:a,asyncInit:o}=this.initializeBackend(i);if(o||a)return{name:i,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const i=this.state.tensorInfo.get(n),a=i.backend,o=this.readSync(n),u=a.refCount(n);a.disposeData(n,!0),i.backend=t,t.move(n,o,i.shape,i.dtype,u),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let i,a=null;if(null==n){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");n=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof n)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=t}return this.scopedRun(()=>this.startScope(a),()=>this.endScope(i),()=>(i=n(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(t,n,i){t();try{const a=i();return n(),a}catch(a){throw n(),a}}nextTensorId(){return wr.nextTensorId++}nextVariableId(){return wr.nextVariableId++}clone(t){const n=Kt.runKernel(Sd,{x:t});return this.addTapeNode(this.state.activeScope.name,{x:t},[n],a=>({x:()=>Kt.runKernel(Ie,{x:a},{dtype:"float32"})}),[],{}),n}runKernel(t,n,i){if(null==Qd(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:i})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,i){const a=this.backend.numDataIds();let o=0;i.forEach(f=>{o+="complex64"===f.dtype?3:1});const h=a-n-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(h>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${h} data ids) after running '${t}'`)}runKernelFunc(t){let n,i=[];const a=this.isTapeOn(),o=this.state.numBytes,u=this.state.numTensors;let h,f;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const p=ks(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(ks(t)){const{kernelName:R,inputs:L,attrs:V}=t,j=Qd(R,this.backendName);Z(null!=j,()=>`Cannot find registered kernel '${R}' for backend '${this.backendName}'`),h=()=>{const H=this.backend.numDataIds();f=j.kernelFunc({inputs:L,attrs:V,backend:this.backend});const nt=Array.isArray(f)?f:[f];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(R,H,nt);const dt=nt.map(yt=>{if(null!=yt.rank)return yt;const{dataId:kt,shape:Ot,dtype:Nt}=yt;return this.makeTensorFromDataId(kt,Ot,Nt)});if(a){const yt=this.getTensorsForGradient(R,L,dt);i=this.saveTensorsForBackwardMode(yt)}return dt}}else{const{forwardFunc:R}=t,L=V=>{a&&(i=V.map(j=>this.keep(this.clone(j))))};h=()=>{const V=this.backend.numDataIds();f=this.tidy(()=>R(this.backend,L));const j=Array.isArray(f)?f:[f];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,V,j),j}}const{inputs:m,attrs:y}=t,b=ks(t)?null:t.backwardsFunc;let T;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(T=this.profiler.profileKernel(p,m,()=>h()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(T),n=T.outputs):n=h()}),a&&this.addTapeNode(p,m,n,b,i,y),this.state.profiling&&this.state.activeProfile.kernels.push({name:p,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-u,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(m).map(R=>null!=m[R]?m[R].shape:null),outputShapes:n.map(R=>R.shape),kernelTimeMs:T.timeMs,extraInfo:T.extraInfo}),Array.isArray(f)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,i){const a=Hd(t);if(null!=a){const o=a.inputsToSave||[],u=a.outputsToSave||[];let h;a.saveAllInputs?(Z(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),h=Object.keys(n).map(p=>n[p])):h=o.map(p=>n[p]);const f=i.filter((p,m)=>u[m]);return h.concat(f)}return[]}makeTensor(t,n,i,a){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");a=a||this.backend;let o=t;"string"===(i=i||"float32")&&bn(t[0])&&(o=t.map(f=>jl(f)));const u=a.write(o,n,i),h=new Zr(n,i,u,this.nextTensorId());if(this.trackTensor(h,a),"string"===i){const f=this.state.tensorInfo.get(u),p=cn(o);this.state.numBytes+=p-f.bytes,f.bytes=p}return h}makeTensorFromDataId(t,n,i,a){const o=new Zr(n,i=i||"float32",t,this.nextTensorId());return this.trackTensor(o,a),o}makeVariable(t,n=!0,i,a){i=i||this.nextVariableId().toString(),null!=a&&a!==t.dtype&&(t=t.cast(a));const o=new Yd(t,n,i,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(t,n){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let i=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(i=t.size*pn(t.dtype)),this.state.numBytes+=i,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:i})),t instanceof Yd||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const i=t.size*pn(t.dtype);this.state.numBytes-=i}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,i=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-i;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,n,i,a,o,u){const h={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:i,saved:o},f=Hd(t);null!=f&&(a=f.gradFunc),null!=a&&(h.gradient=p=>(p=p.map((m,y)=>{if(null==m){const b=i[y],T=wn(b.size,b.dtype);return this.makeTensor(T,b.shape,b.dtype)}return m}),a(p.length>1?p:p[0],o,u))),this.state.activeTape.push(h)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=qo(t),i=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const u=this.state.activeScope.track[o];u.kept||i.has(u.id)||u.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{o.kept||o.scopeId!==a.id||this.track(o)})}gradients(t,n,i,a=!1){if(Z(n.length>0,()=>"gradients() received an empty list of xs."),null!=i&&"float32"!==i.dtype)throw new Error(`dy must have 'float32' dtype, but has '${i.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));Z(o instanceof Zr,()=>"The result y returned by f() must be a tensor.");const u=function(h,f,p){const m={},y={};for(let L=0;L<f.length;L++)m[f[L].id]=!0;for(let L=0;L<h.length;L++){const V=h[L],j=V.inputs;for(const H in j){const nt=j[H];let dt=!1;for(let yt=0;yt<f.length;yt++)if(m[nt.id]){V.outputs.forEach(kt=>m[kt.id]=!0),dt=!0,y[V.id]=!0;break}if(dt)break}}const b={};b[p.id]=!0;const T={};for(let L=h.length-1;L>=0;L--){const V=h[L],j=V.inputs;for(let H=0;H<V.outputs.length;H++)if(b[V.outputs[H].id]){for(const nt in j)b[j[nt].id]=!0,T[V.id]=!0;break}}const R=[];for(let L=0;L<h.length;L++){const V=h[L];if(y[V.id]&&T[V.id]){const j={};for(const nt in V.inputs){const dt=V.inputs[nt];m[dt.id]&&(j[nt]=dt)}const H=Object.assign({},V);H.inputs=j,H.outputs=V.outputs,R.push(H)}}return R}(this.state.activeTape,n,o);if(!a&&0===u.length&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const h={};h[o.id]=i??function(p){const m=rr(Wt(p),"float32");return Kt.makeTensor(m,p,"float32")}(o.shape),function(p,m,y,b){for(let T=m.length-1;T>=0;T--){const R=m[T],L=[];if(R.outputs.forEach(j=>{const H=p[j.id];L.push(null!=H?H:null)}),null==R.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${R.kernelName}.`);const V=R.gradient(L);for(const j in R.inputs){if(!(j in V))throw new Error(`Cannot backprop through input ${j}. Available gradients found: ${Object.keys(V)}.`);const H=y(()=>V[j]());if("float32"!==H.dtype)throw new Error(`Error in gradient for op ${R.kernelName}. The gradient of input ${j} must have 'float32' dtype, but has '${H.dtype}'`);const nt=R.inputs[j];if(!We(H.shape,nt.shape))throw new Error(`Error in gradient for op ${R.kernelName}. The gradient of input '${j}' has shape '${H.shape}', which does not match the shape of the input '${nt.shape}'`);if(null==p[nt.id])p[nt.id]=H;else{const dt=p[nt.id];p[nt.id]=b(dt,H),dt.dispose()}}}}(h,u,p=>this.tidy(p),_b);const f=n.map(p=>h[p.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(p=>{for(const m of p.saved)m.dispose()}),this.state.activeTape=null),{value:o,grads:f}})}customGrad(t){return Z(jn(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{let i;Z(n.every(o=>o instanceof Zr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const a={};return n.forEach((o,u)=>{a[u]=o}),this.runKernelFunc({forwardFunc:(o,u)=>(i=t(...n,u),Z(i.value instanceof Zr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Z(jn(i.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),i.value),backwardsFunc:(o,u)=>{const h=i.gradFunc(o,u),f=Array.isArray(h)?h:[h];Z(f.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Z(f.every(m=>m instanceof Zr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return f.forEach((m,y)=>{p[y]=()=>m}),p},inputs:a})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=ga(),i=await this.backend.time(t);return i.wallMs=ga()-n,i}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ff;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function p1(){const r=Bi();if(null==r._tfengine){const n=new Ri(r);r._tfengine=new wr(n)}return _o=r._tfengine.ENV,bl=()=>r._tfengine,r._tfengine}wr.nextTensorId=0,wr.nextVariableId=0;const Kt=p1();function _b(r,t){return Kt.runKernel(Xs,{a:r,b:t})}let r0;function i0(r){r0=r}function s0(r){if(void 0!==r0)return r0;if(r||typeof navigator<"u"&&null!=navigator){if(r||(r=navigator),"ReactNative"===r.product)return!0;const t=r.userAgent||r.vendor||(typeof window<"u"?window.opera:"");return t?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4)):r.userAgentData&&r.userAgentData.mobile}return!1}function mf(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const Xl=de();function Tn(r,t){let n=r;if(ke(r))return"string"===t?[]:[r.length];if(!Array.isArray(r))return[];const i=[];for(;Array.isArray(n)||ke(n)&&"string"!==t;)i.push(n.length),n=n[0];return Array.isArray(r)&&de().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&f1(r,i,[]),i}function f1(r,t,n){if(n=n||[],!Array.isArray(r)&&!ke(r))return void Z(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Z(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${r.length} elements`),Z(r.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);const i=t.slice(1);for(let a=0;a<r.length;++a)f1(r[a],i,n.concat(a))}function Xo(r,t,n,i){if("string_or_numeric"!==r){if(null==r)throw new Error("Expected dtype cannot be null.");if("numeric"!==r&&r!==t||"numeric"===r&&"string"===t)throw new Error(`Argument '${n}' passed to '${i}' must be ${r} tensor, but got ${t} tensor`)}}function Bt(r,t,n,i="numeric"){if(r instanceof Zr)return Xo(i,r.dtype,t,n),r;let a=Mr(r);if("string"!==a&&["bool","int32","float32"].indexOf(i)>=0&&(a=i),Xo(i,a,t,n),null==r||!ke(r)&&!Array.isArray(r)&&"number"!=typeof r&&"boolean"!=typeof r&&"string"!=typeof r)throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==r?"null":r.constructor.name}'`);const o=Tn(r,a);ke(r)||Array.isArray(r)||(r=[r]);const u="string"!==a?Jc(r,a):Ae(r,[],!0);return Kt.makeTensor(u,o,a)}function mc(r,t,n,i="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((a,o)=>Bt(a,`${t}[${o}]`,n,i))}Xl.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Xl.registerFlag("IS_BROWSER",()=>mf()),Xl.registerFlag("IS_NODE",()=>typeof process<"u"&&void 0!==process.versions&&void 0!==process.versions.node),Xl.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Xl.registerFlag("PROD",()=>!1),Xl.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Xl.getBool("DEBUG")),Xl.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Xl.registerFlag("IS_TEST",()=>!1),Xl.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),Xl.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const Ro="__op";function Jt(r){const t=Object.keys(r);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const i=r[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Ro;const a=(...o)=>{Kt.startScope(n);try{const u=i(...o);return ci(u)&&console.error("Cannot return a Promise inside of tidy."),Kt.endScope(u),u}catch(u){throw Kt.endScope(null),u}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}const ss=Jt({complex_:function(r,t){const n=Bt(r,"real","complex"),i=Bt(t,"imag","complex");return _t(n.shape,i.shape,`real and imag shapes, ${n.shape} and ${i.shape}, must match in call to tf.complex().`),Kt.runKernel(Xn,{real:n,imag:i})}});function gr(r,t,n,i){if(null==i&&(i=Mr(r)),"complex64"===i)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!ke(r)&&!Array.isArray(r)&&"number"!=typeof r&&"boolean"!=typeof r&&"string"!=typeof r)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){xi(t);const a=Wt(t),o=Wt(n);Z(a===o,()=>`Based on the provided shape, [${t}], the tensor should have ${a} values but has ${o}`);for(let u=0;u<n.length;++u){const f=u!==n.length-1||n[u]!==Wt(t.slice(u));Z(n[u]===t[u]||!f,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return ke(r)||Array.isArray(r)||(r=[r]),t=t||n,r="string"!==i?Jc(r,i):Ae(r,[],!0),Kt.makeTensor(r,t,i)}function Yo(r,t,n){return gr(r,t,Tn(r,n),n)}const Zc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function Jd(r,t){const n=[],i=[],a=Array.isArray(r)?r.map(o=>o.name):Object.keys(r);for(let o=0;o<a.length;++o){const u=a[o],h=Array.isArray(r)?r[o].tensor:r[u];if("float32"!==h.dtype&&"int32"!==h.dtype&&"bool"!==h.dtype&&"string"!==h.dtype&&"complex64"!==h.dtype)throw new Error(`Unsupported dtype in weight '${u}': ${h.dtype}`);const f={name:u,shape:h.shape,dtype:h.dtype};if("string"===h.dtype){const p=new Promise(async m=>{const y=await h.bytes(),b=y.reduce((L,V)=>L+V.length,0)+4*y.length,T=new Uint8Array(b);let R=0;for(let L=0;L<y.length;L++){const V=y[L],j=new Uint8Array(new Uint32Array([V.length]).buffer);T.set(j,R),R+=4,T.set(V,R),R+=V.length}m(T)});i.push(p)}else i.push(h.data());null!=t&&(f.group=t),n.push(f)}return{data:Zd(await Promise.all(i)),specs:n}}function gf(r,t){const n={};let i,a=0;for(const o of t){const u=o.name,h=o.dtype,f=o.shape,p=Wt(f);let m;if("quantization"in o){const y=o.quantization;if("uint8"===y.dtype||"uint16"===y.dtype){if(!("min"in y)||!("scale"in y))throw new Error(`Weight ${o.name} with quantization ${y.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==y.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${y.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==h)throw new Error(`Weight ${o.name} is quantized with ${y.dtype} which only supports weights of type float32 not ${h}.`)}const b=Zc[y.dtype],T=r.slice(a,a+p*b),R="uint8"===y.dtype?new Uint8Array(T):new Uint16Array(T);if("float32"===h)if("uint8"===y.dtype||"uint16"===y.dtype){m=new Float32Array(R.length);for(let L=0;L<R.length;L++)m[L]=R[L]*y.scale+y.min}else{if("float16"!==y.dtype)throw new Error(`Unsupported quantization type ${y.dtype} for weight type float32.`);void 0===i&&(i=m1()),m=i(R)}else{if("int32"!==h)throw new Error(`Unsupported dtype in weight '${u}': ${h}`);if("uint8"!==y.dtype&&"uint16"!==y.dtype)throw new Error(`Unsupported quantization type ${y.dtype} for weight type int32.`);m=new Int32Array(R.length);for(let L=0;L<R.length;L++)m[L]=Math.round(R[L]*y.scale+y.min)}a+=p*b}else if("string"===h){const y=Wt(o.shape);m=[];for(let b=0;b<y;b++){const T=new Uint32Array(r.slice(a,a+4))[0];a+=4;const R=new Uint8Array(r.slice(a,a+T));m.push(R),a+=T}}else{const y=Zc[h],b=r.slice(a,a+p*y);if("float32"===h)m=new Float32Array(b);else if("int32"===h)m=new Int32Array(b);else if("bool"===h)m=new Uint8Array(b);else{if("complex64"!==h)throw new Error(`Unsupported dtype in weight '${u}': ${h}`);{m=new Float32Array(b);const T=new Float32Array(m.length/2),R=new Float32Array(m.length/2);for(let j=0;j<T.length;j++)T[j]=m[2*j],R[j]=m[2*j+1];const L=Yo(T,f,"float32"),V=Yo(R,f,"float32");n[u]=ss(L,V),L.dispose(),V.dispose()}}a+=p*y}"complex64"!==h&&(n[u]=Yo(m,f,h))}return n}function Zd(r){if(null===r)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0;const n=[];r.forEach(o=>{if(t+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const i=new Uint8Array(t);let a=0;return n.forEach(o=>{i.set(new Uint8Array(o.buffer),a),a+=o.byteLength}),i.buffer}const Hu=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Lh(r){return Hu?Buffer.byteLength(r):new Blob([r]).size}function tp(r){if(1===r.length)return r[0];let t=0;r.forEach(a=>{t+=a.byteLength});const n=new Uint8Array(t);let i=0;return r.forEach(a=>{n.set(new Uint8Array(a),i),i+=a.byteLength}),n.buffer}function Af(r){for(r=r.trim();r.endsWith("/");)r=r.slice(0,r.length-1);const t=r.split("/");return t[t.length-1]}function yf(r,t){const n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return null!=r.signature&&(n.signature=r.signature),null!=r.userDefinedMetadata&&(n.userDefinedMetadata=r.userDefinedMetadata),null!=r.modelInitializer&&(n.modelInitializer=r.modelInitializer),null!=r.trainingConfig&&(n.trainingConfig=r.trainingConfig),n}async function ep(r,t){const n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(null!=r.trainingConfig&&(n.trainingConfig=r.trainingConfig),null!=r.weightsManifest){const[i,a]=await t(r.weightsManifest);n.weightSpecs=i,n.weightData=a}return null!=r.signature&&(n.signature=r.signature),null!=r.userDefinedMetadata&&(n.userDefinedMetadata=r.userDefinedMetadata),null!=r.modelInitializer&&(n.modelInitializer=r.modelInitializer),n}function Wu(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==r.modelTopology?0:Lh(JSON.stringify(r.modelTopology)),weightSpecsBytes:null==r.weightSpecs?0:Lh(JSON.stringify(r.weightSpecs)),weightDataBytes:null==r.weightData?0:r.weightData.byteLength}}function m1(){const r=function(){const i=o=>{let u=o<<13,h=0;for(;!(8388608&u);)h-=8388608,u<<=1;return u&=-8388609,h+=947912704,u|h},a=new Uint32Array(2048);a[0]=0;for(let o=1;o<1024;o++)a[o]=i(o);for(let o=1024;o<2048;o++)a[o]=939524096+(o-1024<<13);return a}(),t=function(){const i=new Uint32Array(64);i[0]=0,i[31]=1199570944,i[32]=2147483648,i[63]=3347054592;for(let a=1;a<31;a++)i[a]=a<<23;for(let a=33;a<63;a++)i[a]=2147483648+(a-32<<23);return i}(),n=function(){const i=new Uint32Array(64);for(let a=0;a<64;a++)i[a]=1024;return i[0]=i[32]=0,i}();return i=>{const a=new ArrayBuffer(4*i.length),o=new Uint32Array(a);for(let u=0;u<i.length;u++){const h=i[u];o[u]=r[n[h>>10]+(1023&h)]+t[h>>10]}return new Float32Array(a)}}class as{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==as.instance&&(as.instance=new as),as.instance}static registerSaveRouter(t){as.getInstance().saveRouters.push(t)}static registerLoadRouter(t){as.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return as.getHandlers(t,"save")}static getLoadHandlers(t,n){return as.getHandlers(t,"load",n)}static getHandlers(t,n,i){const a=[];return("load"===n?as.getInstance().loadRouters:as.getInstance().saveRouters).forEach(o=>{const u=o(t,i);null!==u&&a.push(u)}),a}}const g1=r=>as.registerSaveRouter(r),jm=r=>as.registerLoadRouter(r),np=r=>as.getSaveHandlers(r),os=(r,t)=>as.getLoadHandlers(r,t),rp="tensorflowjs",Ko="models_store",Jo="model_info_store";function ro(){if(!de().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const r=typeof window>"u"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function qm(r){const t=r.result;t.createObjectStore(Ko,{keyPath:"modelPath"}),t.createObjectStore(Jo,{keyPath:"modelPath"})}class ju{constructor(t){if(this.indexedDB=ro(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((i,a)=>{const o=this.indexedDB.open(rp,1);o.onupgradeneeded=()=>qm(o),o.onsuccess=()=>{const u=o.result;if(null==n){const h=u.transaction(Ko,"readonly"),f=h.objectStore(Ko).get(this.modelPath);f.onsuccess=()=>{if(null==f.result)return u.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));i(f.result.modelArtifacts)},f.onerror=p=>(u.close(),a(f.error)),h.oncomplete=()=>u.close()}else{const h=Wu(n),f=u.transaction(Jo,"readwrite");let p=f.objectStore(Jo);const m=p.put({modelPath:this.modelPath,modelArtifactsInfo:h});let y;m.onsuccess=()=>{y=u.transaction(Ko,"readwrite");const b=y.objectStore(Ko).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:h});b.onsuccess=()=>i({modelArtifactsInfo:h}),b.onerror=T=>{p=f.objectStore(Jo);const R=p.delete(this.modelPath);R.onsuccess=()=>(u.close(),a(b.error)),R.onerror=L=>(u.close(),a(b.error))}},m.onerror=b=>(u.close(),a(m.error)),f.oncomplete=()=>{null==y?u.close():y.oncomplete=()=>u.close()}}},o.onerror=u=>a(o.error)})}}ju.URL_SCHEME="indexeddb://";const xl=r=>{return de().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(ju.URL_SCHEME)?(t=r.slice(ju.URL_SCHEME.length),new ju(t)):null;var t};as.registerSaveRouter(xl),as.registerLoadRouter(xl);class Xm{constructor(){this.indexedDB=ro()}async listModels(){return new Promise((t,n)=>{const i=this.indexedDB.open(rp,1);i.onupgradeneeded=()=>qm(i),i.onsuccess=()=>{const a=i.result,o=a.transaction(Jo,"readonly"),u=o.objectStore(Jo).getAll();u.onsuccess=()=>{const h={};for(const f of u.result)h[f.modelPath]=f.modelArtifactsInfo;t(h)},u.onerror=h=>(a.close(),n(u.error)),o.oncomplete=()=>a.close()},i.onerror=a=>n(i.error)})}async removeModel(t){var n;return t=(n=t).startsWith(ju.URL_SCHEME)?n.slice(ju.URL_SCHEME.length):n,new Promise((i,a)=>{const o=this.indexedDB.open(rp,1);o.onupgradeneeded=()=>qm(o),o.onsuccess=()=>{const u=o.result,h=u.transaction(Jo,"readwrite"),f=h.objectStore(Jo),p=f.get(t);let m;p.onsuccess=()=>{if(null==p.result)return u.close(),a(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const y=f.delete(t),b=()=>{m=u.transaction(Ko,"readwrite");const T=m.objectStore(Ko).delete(t);T.onsuccess=()=>i(p.result.modelArtifactsInfo),T.onerror=R=>a(p.error)};y.onsuccess=b,y.onerror=T=>(b(),u.close(),a(p.error))}},p.onerror=y=>(u.close(),a(p.error)),h.oncomplete=()=>{null==m?u.close():m.oncomplete=()=>u.close()}},o.onerror=u=>a(o.error)})}}const io="/",Fh="tensorflowjs_models",a0="info",ea="model_topology",ip="weight_specs",A1="weight_data",vf="model_metadata";function o0(r){return{info:[Fh,r,a0].join(io),topology:[Fh,r,ea].join(io),weightSpecs:[Fh,r,ip].join(io),weightData:[Fh,r,A1].join(io),modelMetadata:[Fh,r,vf].join(io)}}function Ym(r){for(const t of Object.values(r))window.localStorage.removeItem(t)}function kb(r){const t=r.split(io);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(io)}class Oh{constructor(t){if(!de().getBool("IS_BROWSER")||typeof window>"u"||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=o0(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),i=JSON.stringify(t.weightSpecs),a=Wu(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,i),this.LS.setItem(this.keys.weightData,function(u){if(Hu)return Buffer.from(u).toString("base64");const h=new Uint8Array(u);let f="";for(let p=0,m=h.length;p<m;p++)f+=String.fromCharCode(h[p]);return btoa(f)}(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0})),{modelArtifactsInfo:a}}catch{throw Ym(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},i=JSON.parse(this.LS.getItem(this.keys.topology));if(null==i)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=i;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=a;const o=this.LS.getItem(this.keys.modelMetadata);if(null!=o){const h=JSON.parse(o);n.format=h.format,n.generatedBy=h.generatedBy,n.convertedBy=h.convertedBy,null!=h.signature&&(n.signature=h.signature),null!=h.userDefinedMetadata&&(n.userDefinedMetadata=h.userDefinedMetadata),null!=h.modelInitializer&&(n.modelInitializer=h.modelInitializer),null!=h.trainingConfig&&(n.trainingConfig=h.trainingConfig)}const u=this.LS.getItem(this.keys.weightData);if(null==u)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=function(h){if(Hu){const m=Buffer.from(h,"base64");return m.buffer.slice(m.byteOffset,m.byteOffset+m.byteLength)}const f=atob(h),p=new Uint8Array(f.length);for(let m=0;m<f.length;++m)p.set([f.charCodeAt(m)],m);return p.buffer}(u),n}}Oh.URL_SCHEME="localstorage://";const tu=r=>{return de().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Oh.URL_SCHEME)?(t=r.slice(Oh.URL_SCHEME.length),new Oh(t)):null;var t};as.registerSaveRouter(tu),as.registerLoadRouter(tu);class Ph{constructor(){Z(de().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Z(typeof window>"u"||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=Fh+io,i=io+a0;for(let a=0;a<this.LS.length;++a){const o=this.LS.key(a);o.startsWith(n)&&o.endsWith(i)&&(t[kb(o)]=JSON.parse(this.LS.getItem(o)))}return t}async removeModel(t){var n;const i=o0(t=(n=t).startsWith(Oh.URL_SCHEME)?n.slice(Oh.URL_SCHEME.length):n);if(null==this.LS.getItem(i.info))throw new Error(`Cannot find model at path '${t}'`);const a=JSON.parse(this.LS.getItem(i.info));return Ym(i),a}}const eu="://";class Ra{constructor(){this.managers={}}static getInstance(){return null==Ra.instance&&(Ra.instance=new Ra),Ra.instance}static registerManager(t,n){Z(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(eu)&&(t=t.slice(0,t.indexOf(eu))),Z(t.length>0,()=>"scheme must not be an empty string.");const i=Ra.getInstance();Z(null==i.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),i.managers[t]=n}static getManager(t){const n=this.getInstance().managers[t];if(null==n)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(this.getInstance().managers)}}function sp(r){if(-1===r.indexOf(eu))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ra.getSchemes().join(",")}`);return{scheme:r.split(eu)[0],path:r.split(eu)[1]}}async function y1(r,t,n=!1){Z(r!==t,()=>`Old path and new path are the same: '${r}'`);const i=as.getLoadHandlers(r);Z(i.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),Z(i.length<2,()=>`Copying failed because more than one (${i.length}) load handlers for source URL ${r}.`);const a=i[0],o=as.getSaveHandlers(t);Z(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),Z(o.length<2,()=>`Copying failed because more than one (${i.length}) save handlers for destination URL ${t}.`);const u=o[0],h=sp(r).scheme,f=sp(r).path,p=h===sp(r).scheme,m=await a.load();n&&p&&await Ra.getManager(h).removeModel(f);const y=await u.save(m);return n&&!p&&await Ra.getManager(h).removeModel(f),y.modelArtifactsInfo}async function ap(){const r=Ra.getSchemes(),t={};for(const n of r){const i=await Ra.getManager(n).listModels();for(const a in i)t[n+eu+a]=i[a]}return t}async function Ur(r){const t=sp(r);return Ra.getManager(t.scheme).removeModel(t.path)}async function Bn(r,t){return y1(r,t,!1)}async function Yl(r,t){return y1(r,t,!0)}class Km{fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if("utf-8"!==n&&"utf8"!==n)throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}}if(de().get("IS_BROWSER")){de().setPlatform("browser",new Km);try{Ra.registerManager(Oh.URL_SCHEME,new Ph)}catch{}try{Ra.registerManager(ju.URL_SCHEME,new Xm)}catch{}}let nu;function $r(r,t="float32",n){return t=t||"float32",xi(r),new is(r,t,n)}de().get("IS_NODE")&&de().setPlatform("node",new class{constructor(){this.util=I(1758),this.textEncoder=new this.util.TextEncoder}fetch(r,t){return null!=de().global.fetch?de().global.fetch(r,t):(null==nu&&(nu=I(8352)),nu(r,t))}now(){const r=process.hrtime();return 1e3*r[0]+r[1]/1e6}encode(r,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(r)}decode(r,t){return 0===r.length?"":new this.util.TextDecoder(t).decode(r)}});const yn=Jt({cast_:function(r,t){const n=Bt(r,"x","cast");if(!Ze(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return Kt.runKernel(Ie,{x:n},{dtype:t})}}),ru=Jt({clone_:function(r){const t={x:Bt(r,"x","clone","string_or_numeric")};return Kt.runKernel(Sd,t)}});function v1(r,t=!1){console.log(r.toString(t))}function b1(r){return new Promise(t=>setTimeout(t)).then(r)}p1(),Qu={buffer:$r,cast:yn,clone:ru,print:v1};class Uh{constructor(t){if(!de().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Uh.URL_SCHEME)&&(t=t.slice(Uh.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=yf(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await b1(()=>o.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const u=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=n,await b1(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Wu(t)}}}}Uh.URL_SCHEME="downloads://";class Rb{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{const i=new FileReader;i.onload=a=>{const o=JSON.parse(a.target.result),u=o.modelTopology;if(null==u)return void n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==o.weightsManifest)return void n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void t({modelTopology:u});const h=ep(o,f=>this.loadWeights(f));t(h)},i.onerror=a=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),i.readAsText(this.jsonFile)})}loadWeights(t){const n=[],i=[];for(const u of t)n.push(...u.weights),i.push(...u.paths);const a=this.checkManifestAndWeightFiles(t),o=i.map(u=>this.loadWeightsFile(u,a[u]));return Promise.all(o).then(u=>[n,tp(u)])}loadWeightsFile(t,n){return new Promise((i,a)=>{const o=new FileReader;o.onload=u=>{i(u.target.result)},o.onerror=u=>a(`Failed to weights data from file of path '${t}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){const n=[],i=this.weightsFiles.map(o=>Af(o.name)),a={};for(const o of t)o.paths.forEach(u=>{const h=Af(u);if(-1!==n.indexOf(h))throw new Error(`Duplicate file basename found in weights manifest: '${h}'`);if(n.push(h),-1===i.indexOf(h))throw new Error(`Weight file with basename '${h}' is not provided.`);a[u]=this.weightsFiles[i.indexOf(h)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}}function bf(r){return new Rb(r)}function l0(r,t,n,i){var o;Z(null!=(o=r)&&Array.isArray(o)&&o.length>0,()=>"promises must be a none empty array"),function(o,u){Z(o>=0&&o<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${o}`),Z(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),Z(u>=o,()=>`startFraction must be no more than endFraction, but got startFraction ${o} and endFraction ${u}`)}(n=n??0,i=i??1);let a=0;return Promise.all(r.map(o=>(o.then(u=>{const h=n+ ++a/r.length*(i-n);return t(h),u}),o)))}async function Jm(r,t){null==t&&(t={});const n=null==t.fetchFunc?de().platform.fetch:t.fetchFunc,i=r.map(o=>n(o,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?await Promise.all(i):await l0(i,t.onProgress,0,.5)).map(o=>o.arrayBuffer());return null==t.onProgress?await Promise.all(a):await l0(a,t.onProgress,.5,1)}async function c0(r,t="",n,i){return Zm(a=>Jm(a,{requestInit:i}))(r,t,n)}function Zm(r){return async(t,n="",i)=>{const a=t.map(()=>!1),o={},u=null!=i?i.map(()=>!1):[],h=[];if(t.forEach((T,R)=>{let L=0;T.weights.forEach(V=>{const H=Zc["quantization"in V?V.quantization.dtype:V.dtype]*Wt(V.shape),nt=()=>{a[R]=!0,null==o[R]&&(o[R]=[]),o[R].push({manifestEntry:V,groupOffset:L,sizeBytes:H})};null!=i?i.forEach((dt,yt)=>{dt===V.name&&(nt(),u[yt]=!0)}):nt(),h.push(V.name),L+=H})}),!u.every(T=>T)){const T=i.filter((R,L)=>!u[L]);throw new Error(`Could not find weights in manifest with names: ${T.join(", ")}. \nManifest JSON has weights with names: ${h.join(", ")}.`)}const f=a.reduce((T,R,L)=>(R&&T.push(L),T),[]),p=[];f.forEach(T=>{t[T].paths.forEach(R=>{const L=n+(n.endsWith("/")?"":"/")+R;p.push(L)})});const m=await r(p),y={};let b=0;return f.forEach(T=>{const R=t[T].paths.length;let L=0;for(let nt=0;nt<R;nt++)L+=m[b+nt].byteLength;const V=new ArrayBuffer(L),j=new Uint8Array(V);let H=0;for(let nt=0;nt<R;nt++){const dt=new Uint8Array(m[b+nt]);j.set(dt,H),H+=dt.byteLength}o[T].forEach(nt=>{const dt=gf(V.slice(nt.groupOffset,nt.groupOffset+nt.sizeBytes),[nt.manifestEntry]);for(const yt in dt)y[yt]=dt[yt]}),b+=R}),y}}as.registerSaveRouter(r=>de().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Uh.URL_SCHEME)?function(t="model"){return new Uh(t)}(r.slice(Uh.URL_SCHEME.length)):null);class xf{constructor(t,n){if(this.DEFAULT_METHOD="POST",null==n&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,null!=n.fetchFunc?(Z("function"==typeof n.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=de().platform.fetch,Z(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&Z(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=n.requestInit&&null!=n.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const i=yf(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);n.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=t.weightData&&n.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:Wu(t),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let u=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?u+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":u+=" Please make sure the server is serving valid JSON for this request.",new Error(u)}if(null==n.modelTopology&&null==n.weightsManifest)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return ep(n,o=>this.loadWeights(o))}async loadWeights(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[i,a]=function(p){const m=p.lastIndexOf("/"),y=p.lastIndexOf("?");return[p.substring(0,m)+"/",y>m?p.substring(y):""]}(n),o=this.weightPathPrefix||i,u=[];for(const p of t)u.push(...p.weights);const h=[],f=[];for(const p of t)for(const m of p.paths)null!=this.weightUrlConverter?f.push(this.weightUrlConverter(m)):h.push(o+m+a);return this.weightUrlConverter&&h.push(...await Promise.all(f)),[u,tp(await Jm(h,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function wf(r){return null!=r.match(xf.URL_SCHEME_REGEX)}xf.URL_SCHEME_REGEX=/^https?:\/\//;const tg=(r,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(r)?r.every(i=>wf(i)):wf(r),n)return iu(r,t)}return null};function iu(r,t){return new xf(r,t)}function su(r,t){return iu(r,t)}as.registerSaveRouter(tg),as.registerLoadRouter(tg);class eg{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class u0{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function x1(r,t,n,i){return 1===arguments.length?null!=r.modelTopology||null!=r.weightSpecs?new eg(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new eg({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new eg({modelTopology:r,weightSpecs:t,weightData:n,trainingConfig:i}))}function ng(r){return new u0(r)}const Or=Jt({matMul_:function(r,t,n=!1,i=!1){let a=Bt(r,"a","matMul"),o=Bt(t,"b","matMul");return[a,o]=Ei(a,o),Kt.runKernel(Gt,{a,b:o},{transposeA:n,transposeB:i})}}),zh=Jt({oneHot_:function(r,t,n=1,i=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:Bt(r,"indices","oneHot","int32")};return Kt.runKernel(oc,a,{depth:t,onValue:n,offValue:i})}}),qr=Jt({transpose_:function(r,t){const n=Bt(r,"x","transpose");return null==t&&(t=n.shape.map((o,u)=>u).reverse()),Z(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(o=>{Z(o>=0&&o<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`)}),n.rank<=1?n.clone():Kt.runKernel(gl,{x:n},{perm:t})}}),Bb=Jt({confusionMatrix_:function(r,t,n){const i=Bt(r,"labels","confusionMatrix"),a=Bt(t,"predictions","confusionMatrix");Z(null==n||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),Z(1===i.rank,()=>`Expected the rank of labels to be 1, but got ${i.rank}`),Z(1===a.rank,()=>`Expected the rank of predictions to be 1, but got ${a.rank}`),Z(i.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${i.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),Z(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const o=zh(yn(i,"int32"),n),u=zh(yn(a,"int32"),n),h=qr(o),f=Or(h,u);return yn(f,"int32")}});function $h(r,t){const n=r.length,i=[];for(let a=0;a<n;a++){const o=n-1-a;(t[t.length-1-a]||1)>1&&1===(r[o]||1)&&i.unshift(o)}return i}function Os(r,t){const n=[];for(let i=0;i<t.length;i++){const a=r[r.length-i-1],o=t.length-i-1;(null==a||1===a&&t[o]>1)&&n.unshift(o)}return n}function Nr(r,t){const n=[],i=Math.max(r.length,t.length);for(let a=0;a<i;a++){let o=r[r.length-a-1];null==o&&(o=1);let u=t[t.length-a-1];if(null==u&&(u=1),1===o)n.unshift(u);else if(1===u)n.unshift(o);else{if(o!==u)throw Error(`Operands could not be broadcast together with shapes ${r} and ${t}.`);n.unshift(o)}}return n}function w1(r,t,n){if(Ht(r),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const i=Tn(r,n);if(3!==i.length&&1!==i.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return gr(r,t,i,n)}let Vh;function E1(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==r)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,i=!1,a=!1,o=!1,u=!1,h=!1;if(r.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)i=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)o=!0;else if(null!=r.getContext)u=!0;else{if(!(typeof ImageBitmap<"u"&&r instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);h=!0}if(a&&a&&r.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(null!=Qd(Gd,Kt.backendName))return Kt.runKernel(Gd,{pixels:r},{numChannels:t});const[f,p]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height];let m,y;if(u)m=r.getContext("2d").getImageData(0,0,f,p).data;else if(i||n)m=r.data;else if(o||a||h){if(null==Vh)if(typeof document>"u"){if(typeof OffscreenCanvas>"u"||typeof OffscreenCanvasRenderingContext2D>"u")throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Vh=new OffscreenCanvas(1,1).getContext("2d")}else Vh=document.createElement("canvas").getContext("2d");Vh.canvas.width=f,Vh.canvas.height=p,Vh.drawImage(r,0,0,f,p),m=Vh.getImageData(0,0,f,p).data}if(4===t)y=new Int32Array(m);else{const b=f*p;y=new Int32Array(b*t);for(let T=0;T<b;T++)for(let R=0;R<t;++R)y[T*t+R]=m[4*T+R]}return w1(y,[p,f,t],"int32")}async function h0(r,t=3){let n=null;if(de().getBool("WRAP_TO_IMAGEBITMAP")&&(i=r,typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")&&!(i instanceof ImageBitmap)&&null!=(a=i)&&0!==a.width&&0!==a.height&&!function(a){return null!=a&&a.data instanceof Uint8Array}(i))){let i;try{i=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch{i=null}n=null!=i&&i.width===r.width&&i.height===r.height?i:r}else n=r;var i,a;return E1(n,t)}async function C1(r,t){let n=Bt(r,"img","toPixels");if(!(r instanceof Zr)){const p=n;n=yn(p,"int32"),p.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[i,a]=n.shape.slice(0,2),o=2===n.rank?1:n.shape[2];if(o>4||2===o)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const u=await n.data(),h="float32"===n.dtype?255:1,f=new Uint8ClampedArray(a*i*4);for(let p=0;p<i*a;++p){const m=[0,0,0,255];for(let b=0;b<o;b++){const T=u[p*o+b];if("float32"===n.dtype){if(T<0||T>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${T}.`)}else if("int32"===n.dtype&&(T<0||T>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${T}.`);1===o?(m[0]=T*h,m[1]=T*h,m[2]=T*h):m[b]=T*h}const y=4*p;f[y+0]=Math.round(m[0]),f[y+1]=Math.round(m[1]),f[y+2]=Math.round(m[2]),f[y+3]=Math.round(m[3])}if(null!=t){t.width=a,t.height=i;const p=t.getContext("2d"),m=new ImageData(f,a,i);p.putImageData(m,0,0)}return n!==r&&n.dispose(),f}const d0=Jt({fromPixels_:E1});function Ef(r,t){const n=r.shape.length,i=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(i<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${i}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[i-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[i-1]} vs. ${n}`);if(0===Wt(r.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);const a=t.shape,o=a[a.length-1];let u=1;for(let y=0;y<a.length-1;++y)u*=a[y];const h=r.shape,f=a.slice();f.pop();let p=1;for(let y=o;y<n;++y)p*=h[y],f.push(h[y]);const m=[...gn(r.shape).map(y=>y/p),1].slice(0,o);return[f,u,p,m]}function rg(r,t,n){const i=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${i}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(o+` update.rank < ${a}. `);if(r.length<i+(n.rank-a))throw new Error(o+` Output shape length < ${i+(n.rank-a)}`);if(n.rank!==a+r.length-i)throw new Error(o+" update.rank != "+(a+r.length-i));for(let u=0;u<a;++u)if(n.shape[u]!==t.shape[u])throw new Error(o+` updates.shape[${u}] (${n.shape[u]}) != indices.shape[${u}] (${t.shape[u]}).`);for(let u=0;u<n.rank-a;++u)if(n.shape[u+a]!==r[u+i])throw new Error(o+` updates.shape[${u+a}] (${n.shape[u+a]}) != shape[${u+a}] (${r[u+a]})`)}function ig(r,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===r.size)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}rg(n,t,r)}function Gh(r,t,n){const i=t.shape.length,a=i>1?t.shape[i-1]:1,o=n.length;let u=1;for(let f=a;f<o;++f)u*=n[f];const h=a<1?1:a;return{sliceRank:a,numUpdates:Wt(t.shape)/h,sliceSize:u,strides:[...gn(n.slice(0,a)),1],outputSize:Wt(n)}}function sg(r,t,n){const i=r.shape.length;Z(i===t.length,()=>`Error in slice${i}D: Length of begin ${t} must match the rank of the array (${i}).`),Z(i===n.length,()=>`Error in slice${i}D: Length of size ${n} must match the rank of the array (${i}).`);for(let a=0;a<i;++a)Z(t[a]+n[a]<=r.shape[a],()=>`Error in slice${i}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${r.shape[a]})`)}function I1(r){const t=[];let n=0;for(;r>0;)1&r&&t.push(n),r/=2,n++;return t}function ag(r,t,n){const i=[];for(let a=0;a<r.length;a++)i[a]=Math.ceil((t[a]-r[a])/n[a]);return i}function p0(r,t,n,i){const a=[...r];for(let o=a.length;o<i.length;o++)a.push(1);for(let o=0;o<n;o++)0===o?a[t]=1:(a.splice(t,0,1),a.pop());return a}function Qh(r,t,n){return n<=r?n:n-(t-1)}function na(r,t){const n=[];for(let i=0;i<r;i++)n.push(t+i);return n}function Aa(r,t,n,i,a,o,u,h,f){const p=r.length;let m=new Array(p),y=new Array(p),b=new Array(p);if(t.length&&n>0){const T=t[0],R=n+1;m=Cf(u,T,R,i,r),y=S1(h,T,R,a,r),b=p0(o,T,R,r)}else for(let T=0;T<p;T++)m[T]=T1(u,i,o,r,T,f),y[T]=_1(h,a,o,r,T,f),b[T]=M1(o,T,f);return{begin:m,end:y,strides:b}}function Cf(r,t,n,i,a){const o=[...a],u=na(n,t);for(let h=0;h<o.length;h++)if(u.indexOf(h)>-1)o[h]=0;else{const f=Qh(t,n,h);let p=i[f];r&1<<f&&(p=0),o[h]=p}return o}function S1(r,t,n,i,a){const o=[...a],u=na(n,t);for(let h=0;h<o.length;h++)if(u.indexOf(h)>-1)o[h]=Number.MAX_SAFE_INTEGER;else{const f=Qh(t,n,h);let p=i[f];r&1<<f&&(p=Number.MAX_SAFE_INTEGER),o[h]=p}for(let h=0;h<o.length;h++)o[h]<0&&(o[h]+=a[h]),o[h]=qs(0,o[h],a[h]);return o}function M1(r,t,n){let i=r[t];return(n&1<<t||null==i)&&(i=1),i}function T1(r,t,n,i,a,o){let u=t[a];(r&1<<a||o&1<<a||null==u)&&(u=(n[a]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const f=i[a];return u<0&&(u+=f),u=qs(0,u,f-1),u}function _1(r,t,n,i,a,o){let u=t[a];const h=n[a]||1;(r&1<<a||o&1<<a||null==u)&&(u=h>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const f=i[a];return u<0&&(u+=f),u=h>0?qs(0,u,f):qs(-1,u,f-1),u}function f0(r,t,n){let i=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){i=a;break}for(let a=i+1;a<n.length;a++)if(t[a]>0||n[a]!==r[a])return!1;return!0}function m0(r,t){let n=r.length>0?r[r.length-1]:1;for(let i=0;i<r.length-1;i++)n+=r[i]*t[i];return n}function og(r,t,n){let i;const a=r.shape.length;let o;return i="number"==typeof t?[t,...new Array(a-1).fill(0)]:t.length<a?t.concat(new Array(a-t.length).fill(0)):t.slice(),i.forEach(u=>{Z(-1!==u,()=>"slice() does not support negative begin indexing.")}),o=null==n?new Array(a).fill(-1):"number"==typeof n?[n,...new Array(a-1).fill(-1)]:n.length<a?n.concat(new Array(a-n.length).fill(-1)):n,o=o.map((u,h)=>u>=0?u:(Z(-1===u,()=>`Negative size values should be exactly -1 but got ${u} for the slice() size at index ${h}.`),r.shape[h]-i[h])),[i,o]}function g0(r,t,n,i,a,o,u,h,f){let p;if(null==i?(p=new Array(t.length),p.fill(1)):p=i,null!=u&&0!=(u&u-1))throw new Error("Multiple ellipses in slice is not allowed.");let m=!1;const y={dims:p.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:p.slice(),beginMask:a,endMask:o,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f};for(let H=0;H<y.dims;H++)m&&1<<H&h&&y.numAddAxisAfterEllipsis++,1<<H&u&&(m=!0);m||(y.ellipsisMask|=1<<y.dims,y.dims++);const b={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(H,nt){nt.beginMask=0,nt.endMask=0,nt.shrinkAxisMask=0;let dt=0;nt.beginValid=null!=H.begin,nt.endValid=null!=H.end,nt.begin=new Array(nt.dims),nt.end=new Array(nt.dims),nt.strides=new Array(nt.dims),nt.finalShapeGatherIndices=[],nt.finalShapeGatherIndicesSparse=[],nt.inputShapeGatherIndicesSparse=new Array(nt.dims);for(let yt=0;yt<H.dims;yt++)if(1<<yt&H.ellipsisMask){const kt=Math.min(nt.dims-(H.dims-yt)+1+H.numAddAxisAfterEllipsis,nt.dims);for(;dt<kt;dt++)nt.begin[dt]=0,nt.end[dt]=0,nt.strides[dt]=1,nt.beginMask|=1<<dt,nt.endMask|=1<<dt,nt.finalShapeGatherIndices.push(dt),nt.finalShapeGatherIndicesSparse.push(-1),nt.inputShapeGatherIndicesSparse[dt]=yt}else if(1<<yt&H.newAxisMask)nt.finalShapeGatherIndices.push(-2),nt.finalShapeGatherIndicesSparse.push(-1);else{if(dt===nt.begin.length)throw Error(`Index out of range using input dim ${dt}; input has only ${nt.dims} dims, ${nt.begin.length}.`);null!=H.begin&&(nt.begin[dt]=H.begin[yt]),null!=H.end&&(nt.end[dt]=H.end[yt]),nt.strides[dt]=H.strides[yt],H.beginMask&1<<yt&&(nt.beginMask|=1<<dt),H.endMask&1<<yt&&(nt.endMask|=1<<dt),H.shrinkAxisMask&1<<yt?(nt.finalShapeGatherIndices.push(-1),nt.finalShapeGatherIndicesSparse.push(-1),nt.shrinkAxisMask|=1<<dt):(nt.finalShapeGatherIndices.push(dt),nt.finalShapeGatherIndicesSparse.push(yt)),nt.inputShapeGatherIndicesSparse[dt]=yt,dt++}}(y,b);let T=!0,R=!0,L=!0;const V=[],j=[];for(let H=0;H<r.length;++H){if(0===b.strides[H])throw Error(`strides[${H}] must be non-zero`);const nt=!!(b.shrinkAxisMask&1<<H),dt=r[H];if(-1===dt){V.push(nt?1:-1);continue}const yt=[b.beginMask&1<<H,b.endMask&1<<H],kt=[b.strides[H]>0?0:-1,b.strides[H]>0?dt:dt-1];if(nt&&b.strides[H]<=0)throw Error("only stride 1 allowed on non-range indexing.");L=L&&1===b.strides[H];const Ot=!!(b.beginMask&1<<H&&b.endMask&1<<H);if(b.beginValid&&b.endValid){if(nt){const Zt=b.begin[H]<0?dt+b.begin[H]:b.begin[H];if(b.begin[H]=Zt,b.end[H]=b.begin[H]+1,Zt<0||Zt>=dt)throw Error(`slice index ${b.begin[H]} of dimension ${H} out of bounds.`)}else b.begin[H]=k1(b.begin[H],0,b.strides[H],dt,yt,kt),b.end[H]=k1(b.end[H],1,b.strides[H],dt,yt,kt);const qt=1===b.strides[H]&&0===b.begin[H]&&b.end[H]===dt;T=T&&qt,R=R&&(0===H&&1===b.strides[H]||qt)}else T=T&&1===b.strides[H]&&Ot,R=R&&(0===H&&1===b.strides[H]||Ot);let Nt,Vt=!1;if(b.beginValid&&b.endValid?(Nt=b.end[H]-b.begin[H],Vt=!0):nt?(Nt=1,Vt=!0):Ot&&dt>=0&&(Nt=b.strides[H]<0?-dt:dt,Vt=!0),Vt){let qt;qt=0===Nt||Nt<0!=b.strides[H]<0?0:Math.trunc(Nt/b.strides[H])+(Nt%b.strides[H]!=0?1:0),V.push(qt)}else V.push(-1)}for(let H=0;H<b.finalShapeGatherIndices.length;++H){const nt=b.finalShapeGatherIndices[H];nt>=0?j.push(V[nt]):-2===nt&&j.push(1)}return{finalShapeSparse:j.filter((H,nt)=>-2!==b.finalShapeGatherIndices[nt]),finalShape:j,isIdentity:T,sliceDim0:R,isSimpleSlice:L,begin:b.begin,end:b.end,strides:b.strides}}function k1(r,t,n,i,a,o){if(a[t])return n>0?o[t]:o[t+1&1];{const u=r<0?i+r:r;return u<o[0]?o[0]:u>o[1]?o[1]:u}}class Hh{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class Zo{constructor(){this.classNameMap={}}static getMap(){return null==Zo.instance&&(Zo.instance=new Zo),Zo.instance}static register(t){Zo.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function on(r){Z(null!=r.className,()=>"Class being registered does not have the static className property defined."),Z("string"==typeof r.className,()=>"className is required to be a string, but got type "+typeof r.className),Z(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Zo.register(r)}const R1=.1;function Nb(r,t,n){return null==n&&(n=A0()),y0(r,t,(i,a)=>v0(i,a,n))}function A0(){return 32===Kt.backend.floatPrecision()?.001:R1}function y0(r,t,n){let i=!0;if((ke(r)||ke(t))&&(i=!1),ke(r)&&ke(t)&&(i=!0),i){const u=r.constructor.name,h=t.constructor.name;if(u!==h)throw new Error(`Arrays are of different type. Actual: ${u}. Expected: ${h}`)}if(Array.isArray(r)&&Array.isArray(t)){const u=Tn(r),h=Tn(t);if(!We(u,h))throw new Error(`Arrays have different shapes. Actual: [${u}]. Expected: [${h}]`)}const a=ke(r)?r:Ae(r),o=ke(t)?t:Ae(t);if(a.length!==o.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${o.length}.\nActual:   ${a}.\nExpected: ${o}.`);for(let u=0;u<o.length;++u){const h=a[u],f=o[u];if(!n(h,f))throw new Error(`Arrays differ: actual[${u}] = ${h}, expected[${u}] = ${f}.\nActual:   ${a}.\nExpected: ${o}.`)}}function Db(r,t){r().then(()=>t.fail(),()=>t())}function Lb(r,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return bn(r)||bn(r[0])||bn(t)||bn(t[0])?y0(r,n,(i,a)=>i==a):y0(r,t,(i,a)=>v0(i,a,0))}function Fb(r,t,n){if(null==n&&(n=A0()),!v0(r,t,n))throw new Error(`Numbers differ: actual === ${r}, expected === ${t}`)}function v0(r,t,n){return!isFinite(r)&&!isFinite(t)||!(isNaN(r)||isNaN(t)||Math.abs(r-t)>n)}function Ob(r,t,n){for(let i=0;i<r.length;i++)if(r[i]<t||r[i]>n)throw new Error(`Value out of range:${r[i]} low: ${t}, high: ${n}`)}function Pb(r,t){const n=new Float32Array(r),i=new Float32Array(t);if(n.length!==i.length)throw new Error(`Expected ArrayBuffer to be of length ${i.length}, but it was ${n.length}`);for(let a=0;a<i.length;a++)if(n[a]!==i[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${i[a]} but got ${n[a]} instead`)}function B1(r){for(let t=0;t<r.length;t++){const n=r[t];Array.isArray(n)?B1(n):r[t]=jl(n)}return r}const N1="3.13.0";function Ub(){de().set("PROD",!0)}function zb(){de().set("DEBUG",!0)}function $b(){de().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function D1(r){de().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Vb(){Kt.disposeVariables()}function au(){return Kt}function lg(){return Kt.memory()}function Gb(r){return Kt.profile(r)}function me(r,t){return Kt.tidy(r,t)}function Dr(r){qo(r).forEach(t=>t.dispose())}function ya(r){return Kt.keep(r)}function Qb(r){return Kt.time(r)}function Hb(r){return Kt.setBackend(r)}function Wb(){return Kt.ready()}function jb(){return Kt.backendName}function qb(r){Kt.removeBackend(r)}function Xb(r){return Kt.findBackend(r)}function b0(r){return Kt.findBackendFactory(r)}function cg(r,t,n=1){return Kt.registerBackend(r,t,n)}function L1(){return Kt.backend}function ug(r,t){de().setPlatform(r,t)}n0=D1;const an=Jt({add_:function(r,t){let n=Bt(r,"a","add"),i=Bt(t,"b","add");return[n,i]=Ei(n,i),Kt.runKernel(Xs,{a:n,b:i})}}),hg=Jt({floorDiv_:function(r,t){let n=Bt(r,"a","floorDiv"),i=Bt(t,"b","floorDiv");return[n,i]=Ei(n,i),Kt.runKernel(Ii,{a:n,b:i})}}),qn=Jt({div_:function(r,t){let n=Bt(r,"a","div"),i=Bt(t,"b","div");return[n,i]=Ei(n,i),"int32"===n.dtype&&"int32"===i.dtype?hg(n,i):Kt.runKernel(Ho,{a:n,b:i},{})}}),ae=Jt({mul_:function(r,t){let n=Bt(r,"a","mul"),i=Bt(t,"b","mul");return[n,i]=Ei(n,i),Kt.runKernel(Lu,{a:n,b:i})}}),Ba=Jt({sqrt_:function(r){const t={x:Bt(r,"x","sqrt","float32")};return Kt.runKernel(Uu,t)}}),Oi=Jt({square_:function(r){const t=Bt(r,"x","square");return Kt.runKernel("Square",{x:t},{})}}),zr=Jt({zerosLike_:function(r){const t={x:Bt(r,"x","zerosLike")};return Kt.runKernel($u,t)}});function F1(r){return Z(jn(r),()=>"The f passed in grad(f) must be a function"),(t,n)=>{const i=Bt(t,"x","tf.grad","string_or_numeric"),a=null!=n?Bt(n,"dy","tf.grad"):null;return Kt.tidy(()=>{const{value:o,grads:u}=Kt.gradients(()=>r(i),[i],a);return null!=a&&_t(o.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),dg(u),u[0]})}}function O1(r){return Z(jn(r),()=>"The f passed in grads(f) must be a function"),(t,n)=>{Z(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const i=mc(t,"args","tf.grads","string_or_numeric"),a=null!=n?Bt(n,"dy","tf.grads"):null;return Kt.tidy(()=>{const{value:o,grads:u}=Kt.gradients(()=>r(...i),i,a);return null!=a&&_t(o.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),dg(u),u})}}function Yb(r){return Z(jn(r),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{Z(t instanceof Zr,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),Z(null==n||n instanceof Zr,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:i,value:a}=Kt.gradients(()=>r(t),[t],n);return dg(i),{grad:i[0],value:a}}}function x0(r){return Z(jn(r),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{Z(Array.isArray(t)&&t.every(a=>a instanceof Zr),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),Z(null==n||n instanceof Zr,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const i=Kt.gradients(()=>r(...t),t,n);return null!=n&&_t(i.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),dg(i.grads),i}}function P1(r,t){Z(jn(r),()=>"The f passed in variableGrads(f) must be a function"),Z(null==t||Array.isArray(t)&&t.every(f=>f instanceof Yd),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const f in Kt.registeredVariables)t.push(Kt.registeredVariables[f])}const i=n?t.filter(f=>!f.trainable):null,a=t.length;Z((t=t.filter(f=>f.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);const{value:o,grads:u}=Kt.gradients(r,t,null,!0);Z(u.some(f=>null!=f),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Z(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const h={};return t.forEach((f,p)=>{null!=u[p]&&(h[f.name]=u[p])}),i?.forEach(f=>h[f.name]=null),{value:o,grads:h}}function gc(r){return Kt.customGrad(r)}function dg(r){if(r.filter(t=>null==t).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function Jn(r,t){if((ke(r)&&"string"!==t||Array.isArray(r))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&ke(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return gr(r,[],[],t)}class ou extends Hh{minimize(t,n=!1,i){const{value:a,grads:o}=this.computeGradients(t,i);if(null!=i){const u=i.map(h=>({name:h.name,tensor:o[h.name]}));this.applyGradients(u)}else this.applyGradients(o);return Dr(o),n?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return P1(t,n)}dispose(){null!=this.iterations_&&Dr(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Jn(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(ou,Symbol.hasInstance,{value:r=>null!=r.minimize&&null!=r.computeGradients&&null!=r.applyGradients});class If extends ou{constructor(t,n,i=null){super(),this.learningRate=t,this.rho=n,this.epsilon=i,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==i&&(this.epsilon=Kt.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,i)=>{const a=Kt.registeredVariables[n];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${n}/accum_grad`,variable:me(()=>zr(a).variable(!1))}),null==this.accumulatedUpdates[i]&&(this.accumulatedUpdates[i]={originalName:`${n}/accum_var`,variable:me(()=>zr(a).variable(!1))});const o=Array.isArray(t)?t[i].tensor:t[n];if(null==o)return;const u=this.accumulatedGrads[i].variable,h=this.accumulatedUpdates[i].variable;me(()=>{const f=an(ae(u,this.rho),ae(Oi(o),1-this.rho)),p=ae(qn(Ba(an(h,this.epsilon)),Ba(an(u,this.epsilon))),o),m=an(ae(h,this.rho),ae(Oi(p),1-this.rho));u.assign(f),h.assign(m);const y=an(ae(p,-this.learningRate),a);a.assign(y)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Dr(this.accumulatedGrads.map(t=>t.variable)),Dr(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){const n=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,n).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),this.accumulatedUpdates=t.slice(n,2*n).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}function op(r,t,n){return Kt.runKernel(Nu,{},{shape:r,value:t,dtype:n})}If.className="Adadelta",on(If);class pg extends ou{constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,i)=>{const a=Kt.registeredVariables[n];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${n}/accumulator`,variable:me(()=>op(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[i].tensor:t[n];if(null==o)return;const u=this.accumulatedGrads[i].variable;me(()=>{const h=an(u,Oi(o));u.assign(h);const f=an(ae(qn(o,Ba(an(h,Kt.backend.epsilon()))),-this.learningRate),a);a.assign(f)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Dr(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}pg.className="Adagrad",on(pg);const lu=Jt({pow_:function(r,t){let n=Bt(r,"base","pow"),i=Bt(t,"exp","pow");return[n,i]=Ei(n,i),Kt.runKernel(lc,{a:n,b:i})}}),zn=Jt({sub_:function(r,t){let n=Bt(r,"a","sub"),i=Bt(t,"b","sub");return[n,i]=Ei(n,i),Kt.runKernel(eo,{a:n,b:i})}});class fg extends ou{constructor(t,n,i,a=null){super(),this.learningRate=t,this.beta1=n,this.beta2=i,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],me(()=>{this.accBeta1=Jn(n).variable(),this.accBeta2=Jn(i).variable()}),null==a&&(this.epsilon=Kt.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);me(()=>{const i=zn(1,this.accBeta1),a=zn(1,this.accBeta2);n.forEach((o,u)=>{const h=Kt.registeredVariables[o];null==this.accumulatedFirstMoment[u]&&(this.accumulatedFirstMoment[u]={originalName:`${o}/m`,variable:me(()=>zr(h).variable(!1))}),null==this.accumulatedSecondMoment[u]&&(this.accumulatedSecondMoment[u]={originalName:`${o}/v`,variable:me(()=>zr(h).variable(!1))});const f=Array.isArray(t)?t[u].tensor:t[o];if(null==f)return;const p=this.accumulatedFirstMoment[u].variable,m=this.accumulatedSecondMoment[u].variable,y=an(ae(p,this.beta1),ae(f,1-this.beta1)),b=an(ae(m,this.beta2),ae(Oi(f),1-this.beta2)),T=qn(y,i),R=qn(b,a);p.assign(y),m.assign(b);const L=an(ae(qn(T,an(Ba(R),this.epsilon)),-this.learningRate),h);h.assign(L)}),this.accBeta1.assign(ae(this.accBeta1,this.beta1)),this.accBeta2.assign(ae(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Dr(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&Dr(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),me(()=>{this.accBeta1.assign(lu(this.beta1,this.iterations_+1)),this.accBeta2.assign(lu(this.beta2,this.iterations_+1))});const n=t.length/2;this.accumulatedFirstMoment=t.slice(0,n).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)})),this.accumulatedSecondMoment=t.slice(n,2*n).map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}fg.className="Adam",on(fg);const Ps=Jt({abs_:function(r){const t=Bt(r,"x","abs");return Kt.runKernel("complex64"===t.dtype?dr:da,{x:t})}}),Ac=Jt({maximum_:function(r,t){let n=Bt(r,"a","maximum"),i=Bt(t,"b","maximum");return[n,i]=Ei(n,i),"bool"===n.dtype&&(n=yn(n,"int32"),i=yn(i,"int32")),Nr(n.shape,i.shape),Kt.runKernel(Ch,{a:n,b:i})}});class Sf extends ou{constructor(t,n,i,a=null,o=0){super(),this.learningRate=t,this.beta1=n,this.beta2=i,this.epsilon=a,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],me(()=>{this.iteration=Jn(0).variable(),this.accBeta1=Jn(n).variable()}),null==a&&(this.epsilon=Kt.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);me(()=>{const i=zn(1,this.accBeta1),a=qn(-this.learningRate,an(ae(this.iteration,this.decay),1));n.forEach((o,u)=>{const h=Kt.registeredVariables[o];null==this.accumulatedFirstMoment[u]&&(this.accumulatedFirstMoment[u]={originalName:`${o}/m`,variable:zr(h).variable(!1)}),null==this.accumulatedWeightedInfNorm[u]&&(this.accumulatedWeightedInfNorm[u]={originalName:`${o}/v`,variable:zr(h).variable(!1)});const f=Array.isArray(t)?t[u].tensor:t[o];if(null==f)return;const p=this.accumulatedFirstMoment[u].variable,m=this.accumulatedWeightedInfNorm[u].variable,y=an(ae(p,this.beta1),ae(f,1-this.beta1)),b=ae(m,this.beta2),T=Ps(f),R=Ac(b,T);p.assign(y),m.assign(R);const L=an(ae(qn(a,i),qn(y,an(R,this.epsilon))),h);h.assign(L)}),this.iteration.assign(an(this.iteration,1)),this.accBeta1.assign(ae(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Dr(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&Dr(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}Sf.className="Adamax",on(Sf);class lp extends ou{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,i)=>{const a=Array.isArray(t)?t[i].tensor:t[n];if(null==a)return;const o=Kt.registeredVariables[n];me(()=>{const u=an(ae(this.c,a),o);o.assign(u)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=ya(Jn(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}lp.className="SGD",on(lp);class mg extends lp{constructor(t,n,i=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=i,this.accumulations=[],this.m=Jn(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,i)=>{const a=Kt.registeredVariables[n];null==this.accumulations[i]&&(this.accumulations[i]={originalName:`${n}/momentum`,variable:me(()=>zr(a).variable(!1))});const o=this.accumulations[i].variable,u=Array.isArray(t)?t[i].tensor:t[n];null!=u&&me(()=>{let h;const f=an(ae(this.m,o),u);h=an(ae(this.c,this.useNesterov?an(u,ae(f,this.m)):f),a),o.assign(f),a.assign(h)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Dr(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}mg.className="Momentum",on(mg);class gg extends ou{constructor(t,n=.9,i=0,a=null,o=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=i,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==a&&(this.epsilon=Kt.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,i)=>{const a=Kt.registeredVariables[n],o=!1;null==this.accumulatedMeanSquares[i]&&(this.accumulatedMeanSquares[i]={originalName:`${n}/rms`,variable:me(()=>zr(a).variable(o))}),null==this.accumulatedMoments[i]&&(this.accumulatedMoments[i]={originalName:`${n}/momentum`,variable:me(()=>zr(a).variable(o))}),null==this.accumulatedMeanGrads[i]&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${n}/mg`,variable:me(()=>zr(a).variable(o))});const u=Array.isArray(t)?t[i].tensor:t[n];if(null==u)return;const h=this.accumulatedMeanSquares[i].variable,f=this.accumulatedMoments[i].variable;me(()=>{const p=an(ae(h,this.decay),ae(Oi(u),1-this.decay));if(this.centered){const m=this.accumulatedMeanGrads[i].variable,y=an(ae(m,this.decay),ae(u,1-this.decay)),b=qn(ae(u,this.learningRate),Ba(zn(p,an(Oi(y),this.epsilon)))),T=an(ae(f,this.momentum),b);h.assign(p),m.assign(y),f.assign(T);const R=zn(a,T);a.assign(R)}else{const m=an(ae(h,this.decay),ae(Oi(u),1-this.decay)),y=an(ae(f,this.momentum),qn(ae(u,this.learningRate),Ba(an(m,this.epsilon))));h.assign(m),f.assign(y);const b=zn(a,y);a.assign(b)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Dr(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Dr(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&Dr(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,i=!1;this.accumulatedMeanSquares=t.slice(0,n).map(a=>({originalName:a.name,variable:a.tensor.variable(i)})),this.accumulatedMoments=t.slice(n,2*n).map(a=>({originalName:a.name,variable:a.tensor.variable(i)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*n,3*n).map(a=>({originalName:a.name,variable:a.tensor.variable(i)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}gg.className="RMSProp",on(gg);class qu{static sgd(t){return new lp(t)}static momentum(t,n,i=!1){return new mg(t,n,i)}static rmsprop(t,n=.9,i=0,a=null,o=!1){return new gg(t,n,i,a,o)}static adam(t=.001,n=.9,i=.999,a=null){return new fg(t,n,i,a)}static adadelta(t=.001,n=.95,i=null){return new If(t,n,i)}static adamax(t=.002,n=.9,i=.999,a=null,o=0){return new Sf(t,n,i,a,o)}static adagrad(t,n=.1){return new pg(t,n)}}const w0=Jt({acos_:function(r){const t={x:Bt(r,"x","acos")};return Kt.runKernel(pa,t)}}),E0=Jt({acosh_:function(r){const t={x:Bt(r,"x","acosh")};return Kt.runKernel(Ss,t)}}),C0=Jt({addN_:function(r){Z(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),Z(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);const t=r.map((a,o)=>Bt(a,`tensors${o}`,"addN")),n=t[0];return t.forEach(a=>{if(a.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(a=>{if(!We(a.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),Kt.runKernel(Ms,t)}}),Ag=Jt({all_:function(r,t=null,n=!1){const i={x:Bt(r,"x","all","bool")};return Kt.runKernel(_a,i,{axis:t,keepDims:n})}}),Wh=Jt({any_:function(r,t=null,n=!1){const i={x:Bt(r,"x","any","bool")};return Kt.runKernel(Pa,i,{axis:t,keepDims:n})}}),cu=Jt({argMax_:function(r,t=0){const n={x:Bt(r,"x","argMax")};return Kt.runKernel(Ys,n,{axis:t})}}),I0=Jt({argMin_:function(r,t=0){const n={x:Bt(r,"x","argMin")};return Kt.runKernel(Ks,n,{axis:t})}}),S0=Jt({asin_:function(r){const t={x:Bt(r,"x","asin")};return Kt.runKernel(Ka,t)}}),M0=Jt({asinh_:function(r){const t={x:Bt(r,"x","asinh")};return Kt.runKernel(oi,t)}}),yg=Jt({atan_:function(r){const t={x:Bt(r,"x","atan")};return Kt.runKernel(Ol,t)}}),tl=Jt({atan2_:function(r,t){let n=Bt(r,"a","atan2"),i=Bt(t,"b","atan2");return[n,i]=Ei(n,i),Kt.runKernel(Li,{a:n,b:i})}}),Mf=Jt({atanh_:function(r){const t={x:Bt(r,"x","atanh")};return Kt.runKernel(Go,t)}});function cp(r,t,n,i,a="NHWC",o){return ra(r,[...t,r[3]],n,o,i,null,null,uu(a))}function el(r,t,n,i,a,o,u="channelsLast"){const[h,f]=vg(t);let p;if("channelsLast"===u)p=[h,f,r[3],r[3]];else{if("channelsFirst"!==u)throw new Error(`Unknown dataFormat ${u}`);p=[h,f,r[1],r[1]]}return ra(r,p,n,i,a,o,!1,u)}function yc(r,t,n,i,a,o,u="NDHWC"){const[h,f,p]=T0(t);let m,y;if("NDHWC"===u)y="channelsLast",m=[h,f,p,r[4],r[4]];else{if("NCDHW"!==u)throw new Error(`Unknown dataFormat ${u}`);y="channelsFirst",m=[h,f,p,r[1],r[1]]}return Xu(r,m,n,i,a,!1,y,o)}function ra(r,t,n,i,a,o,u=!1,h="channelsLast"){let[f,p,m,y]=[-1,-1,-1,-1];if("channelsLast"===h)[f,p,m,y]=r;else{if("channelsFirst"!==h)throw new Error(`Unknown dataFormat ${h}`);[f,y,p,m]=r}const[b,T,,R]=t,[L,V]=vg(n),[j,H]=vg(i),nt=wl(b,j),dt=wl(T,H),{padInfo:yt,outHeight:kt,outWidth:Ot}=function(qt,Zt,te,ue,Ee,De,we,Te,Le){let $e,je,Ne;if("number"==typeof qt){$e={top:qt,bottom:qt,left:qt,right:qt,type:0===qt?"VALID":"NUMBER"};const He=function(Je,dn,mn,Ln,Rn){null==Ln&&(Ln=Tf(Je,dn,mn));const tr=Je[1];return[jh((Je[0]-dn+2*Ln)/mn+1,Rn),jh((tr-dn+2*Ln)/mn+1,Rn)]}([Zt,te],De,ue,qt,Te);je=He[0],Ne=He[1]}else if("same"===qt){je=Math.ceil(Zt/ue),Ne=Math.ceil(te/Ee);const He=Math.max(0,(je-1)*ue+De-Zt),Je=Math.max(0,(Ne-1)*Ee+we-te),dn=Math.floor(He/2),mn=He-dn,Ln=Math.floor(Je/2);$e={top:dn,bottom:mn,left:Ln,right:Je-Ln,type:"SAME"}}else if("valid"===qt)$e={top:0,bottom:0,left:0,right:0,type:"VALID"},je=Math.ceil((Zt-De+1)/ue),Ne=Math.ceil((te-we+1)/Ee);else{if("object"!=typeof qt)throw Error(`Unknown padding parameter: ${qt}`);{const He="channelsLast"===Le?qt[1][0]:qt[2][0],Je="channelsLast"===Le?qt[1][1]:qt[2][1],dn="channelsLast"===Le?qt[2][0]:qt[3][0],mn="channelsLast"===Le?qt[2][1]:qt[3][1];$e={top:He,bottom:Je,left:dn,right:mn,type:0===He&&0===Je&&0===dn&&0===mn?"VALID":"EXPLICIT"},je=jh((Zt-De+He+Je)/ue+1,Te),Ne=jh((te-we+dn+mn)/Ee+1,Te)}}return{padInfo:$e,outHeight:je,outWidth:Ne}}(a,p,m,L,V,nt,dt,o,h),Nt=u?R*y:R;let Vt;return"channelsFirst"===h?Vt=[f,Nt,kt,Ot]:"channelsLast"===h&&(Vt=[f,kt,Ot,Nt]),{batchSize:f,dataFormat:h,inHeight:p,inWidth:m,inChannels:y,outHeight:kt,outWidth:Ot,outChannels:Nt,padInfo:yt,strideHeight:L,strideWidth:V,filterHeight:b,filterWidth:T,effectiveFilterHeight:nt,effectiveFilterWidth:dt,dilationHeight:j,dilationWidth:H,inShape:r,outShape:Vt,filterShape:t}}function Xu(r,t,n,i,a,o=!1,u="channelsLast",h){let[f,p,m,y,b]=[-1,-1,-1,-1,-1];if("channelsLast"===u)[f,p,m,y,b]=r;else{if("channelsFirst"!==u)throw new Error(`Unknown dataFormat ${u}`);[f,b,p,m,y]=r}const[T,R,L,,V]=t,[j,H,nt]=T0(n),[dt,yt,kt]=T0(i),Ot=wl(T,dt),Nt=wl(R,yt),Vt=wl(L,kt),{padInfo:qt,outDepth:Zt,outHeight:te,outWidth:ue}=function(we,Te,Le,$e,je,Ne,He,Je,dn,mn,Ln){let Rn,tr,ur,ir;if("number"==typeof we){Rn={top:we,bottom:we,left:we,right:we,front:we,back:we,type:0===we?"VALID":"NUMBER"};const er=function(Sr,Vr,gi,Cr,Rr,Kr){null==Rr&&(Rr=Tf(Sr,Vr,Cr));const la=Sr[1],ho=Sr[2];return[jh((Sr[0]-Vr+2*Rr)/Cr+1,Kr),jh((la-Vr+2*Rr)/Cr+1,Kr),jh((ho-Vr+2*Rr)/Cr+1,Kr),1]}([Te,Le,$e,1],Je,0,je,we,Ln);tr=er[0],ur=er[1],ir=er[2]}else if("same"===we){tr=Math.ceil(Te/je),ur=Math.ceil(Le/Ne),ir=Math.ceil($e/He);const er=(tr-1)*je+Je-Te,Sr=(ur-1)*Ne+dn-Le,Vr=(ir-1)*He+mn-$e,gi=Math.floor(er/2),Cr=er-gi,Rr=Math.floor(Sr/2),Kr=Sr-Rr,la=Math.floor(Vr/2);Rn={top:Rr,bottom:Kr,left:la,right:Vr-la,front:gi,back:Cr,type:"SAME"}}else{if("valid"!==we)throw Error(`Unknown padding parameter: ${we}`);Rn={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},tr=Math.ceil((Te-Je+1)/je),ur=Math.ceil((Le-dn+1)/Ne),ir=Math.ceil(($e-mn+1)/He)}return{padInfo:Rn,outDepth:tr,outHeight:ur,outWidth:ir}}(a,p,m,y,j,H,nt,Ot,Nt,Vt,h),Ee=o?V*b:V;let De;return"channelsFirst"===u?De=[f,Ee,Zt,te,ue]:"channelsLast"===u&&(De=[f,Zt,te,ue,Ee]),{batchSize:f,dataFormat:u,inDepth:p,inHeight:m,inWidth:y,inChannels:b,outDepth:Zt,outHeight:te,outWidth:ue,outChannels:Ee,padInfo:qt,strideDepth:j,strideHeight:H,strideWidth:nt,filterDepth:T,filterHeight:R,filterWidth:L,effectiveFilterDepth:Ot,effectiveFilterHeight:Nt,effectiveFilterWidth:Vt,dilationDepth:dt,dilationHeight:yt,dilationWidth:kt,inShape:r,outShape:De,filterShape:t}}function Tf(r,t,n,i=1){const a=wl(t,i);return Math.floor((r[0]*(n-1)-n+a)/2)}function vg(r){return"number"==typeof r?[r,r,r]:2===r.length?[r[0],r[1],1]:r}function T0(r){return"number"==typeof r?[r,r,r]:r}function wl(r,t){return t<=1?r:r+(r-1)*(t-1)}function jh(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Yu(r){const[t,n,i]=vg(r);return 1===t&&1===n&&1===i}function Na(r,t){return Yu(r)||Yu(t)}function uu(r){if("NHWC"===r)return"channelsLast";if("NCHW"===r)return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function va(r,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)Z(hn(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${r}: Unknown padding parameter: ${t}`);t.forEach(i=>{i.forEach(a=>{Z(hn(a),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${n} but got pad ${a}.`)})})}}}const le=Jt({reshape_:function(r,t){const n={x:Bt(r,"x","reshape","string_or_numeric")};return Kt.runKernel(Pd,n,{shape:t})}}),up=Jt({avgPool_:function(r,t,n,i,a){const o=Bt(r,"x","avgPool","float32");Z(Na(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let u=o,h=!1;3===o.rank&&(h=!0,u=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(4===u.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${u.rank}.`),va("avgPool",i,a);let m=Kt.runKernel(K,{x:u},{filterSize:t,strides:n,pad:i,dimRoundingMode:a});return m=yn(m,o.dtype),h?le(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),Ku=Jt({avgPool3d_:function(r,t,n,i,a,o="NDHWC"){const u=Bt(r,"x","avgPool3d","float32");let h=u,f=!1;4===u.rank&&(f=!0,h=le(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Z(5===h.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${h.rank}.`),Z("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),va("avgPool3d",i,a);let y=Kt.runKernel(It,{x:h},{filterSize:t,strides:n,pad:i,dimRoundingMode:a,dataFormat:o});return y=yn(y,h.dtype),f?le(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),ti=Jt({concat_:function(r,t=0){Z(r.length>=1,()=>"Pass at least one tensor to concat");const n=mc(r,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===n.length?ru(n[0]):Kt.runKernel(Ar,n,{axis:t})}}),ba=Jt({sigmoid_:function(r){const t={x:Bt(r,"x","sigmoid","float32")};return Kt.runKernel(zd,t)}}),Gr=Jt({slice_:function(r,t,n){const i=Bt(r,"x","slice","string_or_numeric");if(0===i.rank)throw new Error("Slicing scalar is not possible");return Kt.runKernel(cc,{x:i},{begin:t,size:n})}}),El=Jt({tanh_:function(r){const t={x:Bt(r,"x","tanh","float32")};return Kt.runKernel(Vl,t)}}),_f=Jt({basicLSTMCell_:function(r,t,n,i,a,o){const u=Bt(r,"forgetBias","basicLSTMCell"),h=Bt(t,"lstmKernel","basicLSTMCell"),f=Bt(n,"lstmBias","basicLSTMCell"),p=Bt(i,"data","basicLSTMCell"),m=Bt(a,"c","basicLSTMCell"),y=Bt(o,"h","basicLSTMCell"),b=ti([p,y],1),T=Or(b,h),R=an(T,f),V=R.shape[1]/4,j=[R.shape[0],V],H=Gr(R,[0,0],j),nt=Gr(R,[0,V],j),dt=Gr(R,[0,2*V],j),yt=Gr(R,[0,3*V],j),kt=an(ae(ba(H),El(nt)),ae(m,ba(an(u,dt))));return[kt,ae(El(kt),ba(yt))]}}),vc=Jt({batchToSpaceND_:function(r,t,n){const i=Bt(r,"x","batchToSpaceND"),a=t.reduce((h,f)=>h*f);return Z(i.rank>=1+t.length,()=>`input rank is ${i.rank} but should be > than blockShape.length ${t.length}`),Z(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Z(i.shape[0]%a==0,()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`),Kt.runKernel(Xt,{x:i},{blockShape:t,crops:n})}}),Kl=Jt({batchNorm_:function(r,t,n,i,a,o){null==o&&(o=.001);const u=Bt(r,"x","batchNorm"),h=Bt(t,"mean","batchNorm"),f=Bt(n,"variance","batchNorm");let p,m;null!=a&&(p=Bt(a,"scale","batchNorm")),null!=i&&(m=Bt(i,"offset","batchNorm")),Z(h.rank===f.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Z(null==m||h.rank===m.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Z(null==p||h.rank===p.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const y={x:function(R){let L;return L=0===R.rank||1===R.rank?le(R,[1,1,1,R.size]):2===R.rank?le(R,[1,1,R.shape[0],R.shape[1]]):3===R.rank?le(R,[1,R.shape[0],R.shape[1],R.shape[2]]):R,L}(u),scale:p,offset:m,mean:h,variance:f},T=Kt.runKernel(zc,y,{varianceEpsilon:o});return le(T,u.shape)}}),qh=Jt({batchNorm2d_:function(r,t,n,i,a,o){const u=Bt(r,"x","batchNorm"),h=Bt(t,"mean","batchNorm"),f=Bt(n,"variance","batchNorm");let p,m;return null!=a&&(p=Bt(a,"scale","batchNorm")),null!=i&&(m=Bt(i,"offset","batchNorm")),Z(2===u.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${u.rank}.`),Z(2===h.rank||1===h.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${h.rank}.`),Z(2===f.rank||1===f.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${f.rank}.`),null!=p&&Z(2===p.rank||1===p.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${p.rank}.`),null!=m&&Z(2===m.rank||1===m.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${m.rank}.`),Kl(u,h,f,m,p,o)}}),hp=Jt({batchNorm3d_:function(r,t,n,i,a,o){const u=Bt(r,"x","batchNorm"),h=Bt(t,"mean","batchNorm"),f=Bt(n,"variance","batchNorm");let p,m;return null!=a&&(p=Bt(a,"scale","batchNorm")),null!=i&&(m=Bt(i,"offset","batchNorm")),Z(3===u.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${u.rank}.`),Z(3===h.rank||1===h.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${h.rank}.`),Z(3===f.rank||1===f.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${f.rank}.`),null!=p&&Z(3===p.rank||1===p.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${p.rank}.`),null!=m&&Z(3===m.rank||1===m.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${m.rank}.`),Kl(u,h,f,m,p,o)}}),_0=Jt({batchNorm4d_:function(r,t,n,i,a,o){const u=Bt(r,"x","batchNorm"),h=Bt(t,"mean","batchNorm"),f=Bt(n,"variance","batchNorm");let p,m;return null!=a&&(p=Bt(a,"scale","batchNorm")),null!=i&&(m=Bt(i,"offset","batchNorm")),Z(4===u.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${u.rank}.`),Z(4===h.rank||1===h.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${h.rank}.`),Z(4===f.rank||1===f.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${f.rank}.`),null!=p&&Z(4===p.rank||1===p.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${p.rank}.`),null!=m&&Z(4===m.rank||1===m.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${m.rank}.`),Kl(u,h,f,m,p,o)}}),dp=Jt({bincount_:function(r,t,n){const i=Bt(r,"x","bincount"),a=Bt(t,"weights","bincount");return Z("int32"===i.dtype,()=>`Error in bincount: input dtype must be int32, but got ${i.dtype}`),Z(n>=0,()=>`size must be non-negative, but got ${n}.`),Z(a.size===i.size||0===a.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${i.shape}, weights shape: ${a.shape}.`),Kt.runKernel(Me,{x:i,weights:a},{size:n})}}),pp=Jt({broadcastArgs_:function(r,t){const n=Bt(r,"s0","broadcastArgs","int32"),i=Bt(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==i.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${i.rank}`);return Kt.runKernel(un,{s0:n,s1:i})}}),hu=Jt({broadcastTo_:function(r,t){let n=Bt(r,"broadcastTo","x");const i=n.shape;if(t.some(f=>!(f>0)||f%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const f=n.shape.slice();for(;f.length<t.length;)f.unshift(1);n=le(n,f)}const a=n.shape,o=Array.from(t);for(let f=t.length-1;f>=0;f--)if(a[f]===t[f])o[f]=1;else if(1!==n.shape[f])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${t}].`);return 0===o.map((f,p)=>f>1?p:-1).filter(f=>f>=0).length?ru(n):Kt.runKernel(Gl,{x:n},{reps:o})}}),bg=Jt({ceil_:function(r){const t={x:Bt(r,"x","ceil","float32")};return Kt.runKernel(Be,t)}}),Va=Jt({clipByValue_:function(r,t,n){const i=Bt(r,"x","clipByValue");return Z(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),Kt.runKernel(Pn,{x:i},{clipValueMin:t,clipValueMax:n})}}),k0=Jt({concat1d_:function(r){return ti(r,0)}}),R0=Jt({concat2d_:function(r,t){return ti(r,t)}}),kf=Jt({concat3d_:function(r,t){return ti(r,t)}}),Rf=Jt({concat4d_:function(r,t){return ti(r,t)}}),bc=Jt({conv2d_:function(r,t,n,i,a="NHWC",o=[1,1],u){const h=Bt(r,"x","conv2d","float32"),f=Bt(t,"filter","conv2d","float32");let p=h,m=!1;3===h.rank&&(m=!0,p=le(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Z(4===p.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${p.rank}.`),Z(4===f.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${f.rank}.`),va("conv2d",i,u);const y="NHWC"===a?p.shape[3]:p.shape[1];Z(y===f.shape[2],()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${f.shape[2]}.`),Z(Na(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const R=Kt.runKernel(xr,{x:p,filter:f},{strides:n,pad:i,dataFormat:a,dilations:o,dimRoundingMode:u});return m?le(R,[R.shape[1],R.shape[2],R.shape[3]]):R}}),Bf=Jt({conv1d_:function(r,t,n,i,a="NWC",o=1,u){const h=Bt(r,"x","conv1d"),f=Bt(t,"filter","conv1d");let p=h,m=!1;2===h.rank&&(m=!0,p=le(h,[1,h.shape[0],h.shape[1]])),Z(3===p.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${p.rank}.`),Z(3===f.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${f.rank}.`),va("conv1d",i,u),Z(p.shape[2]===f.shape[1],()=>`Error in conv1d: depth of input (${p.shape[2]}) must match input depth for filter ${f.shape[1]}.`),Z(Na(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),Z("NWC"===a,()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);const y=le(f,[1,f.shape[0],f.shape[1],f.shape[2]]),b=le(p,[p.shape[0],1,p.shape[1],p.shape[2]]),T=bc(b,y,[1,n],i,"NHWC",[1,o],u);return le(T,m?[T.shape[2],T.shape[3]]:[T.shape[0],T.shape[2],T.shape[3]])}}),xg=Jt({conv2DBackpropInput_:function(r,t,n,i,a,o="NHWC",u){Z(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let h=r,f=t,p=!1;3===t.rank&&(p=!0,f=le(t,[1,t.shape[0],t.shape[1],t.shape[2]]),h=[1,r[0],r[1],r[2]]),Z(4===h.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${h.length}.`),Z(4===f.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${f.rank}`),Z(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const m="NHWC"===o?h[3]:h[1],y="NHWC"===o?f.shape[3]:f.shape[1];Z(m===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${m}) must match input depth for filter ${n.shape[2]}.`),Z(y===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${y}) must match output depth for filter ${n.shape[3]}.`),va("conv2dDerInput",a,u);const R=Kt.runKernel(Pr,{dy:f,filter:n},{strides:i,pad:a,dataFormat:o,dimRoundingMode:u,inputShape:h});return p?le(R,[R.shape[1],R.shape[2],R.shape[3]]):R}}),Nf=Jt({conv2dTranspose_:function(r,t,n,i,a,o){const u=Bt(r,"x","conv2dTranspose"),h=Bt(t,"filter","conv2dTranspose");return xg(n,u,h,i,a,"NHWC",o)}}),wg=Jt({conv3d_:function(r,t,n,i,a="NDHWC",o=[1,1,1]){const u=Bt(r,"x","conv3d"),h=Bt(t,"filter","conv3d");let f=u,p=!1;4===u.rank&&(p=!0,f=le(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Z(5===f.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${f.rank}.`),Z(5===h.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${h.rank}.`),Z(f.shape[4]===h.shape[3],()=>`Error in conv3d: depth of input (${f.shape[4]}) must match input depth for filter ${h.shape[3]}.`),Z(Na(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Z("NDHWC"===a,()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`);const b=Kt.runKernel(ui,{x:f,filter:h},{strides:n,pad:i,dataFormat:a,dilations:o});return p?le(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}}),U1=Jt({conv3DBackpropInput_:function(r,t,n,i,a){Z(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let o=r,u=t,h=!1;4===t.rank&&(h=!0,u=le(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,r[0],r[1],r[2],r[3]]);const f=o[4],p=u.shape[4];Z(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),Z(5===u.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${u.rank}`),Z(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Z(f===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${f}) must match input depth for filter ${n.shape[3]}.`),Z(p===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[4]}.`);const b=Kt.runKernel(Fi,{dy:u,filter:n},{pad:a,strides:i,inputShape:o});return h?le(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}}),B0=Jt({conv3dTranspose_:function(r,t,n,i,a){const o=Bt(r,"x","conv3dTranspose"),u=Bt(t,"filter","conv3dTranspose");return U1(n,o,u,i,a)}}),Ju=Jt({cos_:function(r){const t={x:Bt(r,"x","cos","float32")};return Kt.runKernel(rs,t)}}),fp=Jt({cosh_:function(r){const t={x:Bt(r,"x","cosh","float32")};return Kt.runKernel(Ts,t)}}),Df=Jt({cumsum_:function(r,t=0,n=!1,i=!1){const a={x:Bt(r,"x","cumsum")};return Kt.runKernel(Js,a,{axis:t,exclusive:n,reverse:i})}}),Eg=Jt({denseBincount_:function(r,t,n,i=!1){const a=Bt(r,"x","denseBincount"),o=Bt(t,"weights","denseBincount");return Z("int32"===a.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),Z(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),Z(n>=0,()=>`size must be non-negative, but got ${n}.`),Z(o.size===a.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${o.shape}.`),Kt.runKernel(ds,{x:a,weights:o},{size:n,binaryOutput:i})}}),Lf=Jt({depthToSpace_:function(r,t,n="NHWC"){const i=Bt(r,"x","depthToSpace","float32"),a="NHWC"===n?i.shape[1]:i.shape[2],o="NHWC"===n?i.shape[2]:i.shape[3],u="NHWC"===n?i.shape[3]:i.shape[1];return Z(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),Z(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${i.shape}`),Z(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t} for depthToSpace with input shape\n        ${i.shape}`),Z(u%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${u} for depthToSpace with input shape ${i.shape}`),Kt.runKernel($i,{x:i},{blockSize:t,dataFormat:n})}}),du=Jt({depthwiseConv2d_:function(r,t,n,i,a="NHWC",o=[1,1],u){const h=Bt(r,"x","depthwiseConv2d","float32"),f=Bt(t,"filter","depthwiseConv2d","float32");let p=h,m=!1;3===h.rank&&(m=!0,p=le(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Z(4===p.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Z(4===f.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),Z(p.shape[3]===f.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),va("depthwiseConv2d",i,u);const T=Kt.runKernel(Zs,{x:p,filter:f},{strides:n,pad:i,dataFormat:a,dilations:o,dimRoundingMode:u});return m?le(T,[T.shape[1],T.shape[2],T.shape[3]]):T}}),pu=Jt({diag_:function(r){const t={x:Bt(r,"x","diag")};return Kt.runKernel(Za,t)}}),Cg=Jt({dilation2d_:function(r,t,n,i,a=[1,1],o="NHWC"){const u=Bt(r,"x","dilation2d"),h=Bt(t,"filter","dilation2d");Z(3===u.rank||4===u.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${u.rank}.`),Z(3===h.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${h.rank}.`),Z("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let f=u,p=!1;3===u.rank&&(f=le(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=!0);const b=Kt.runKernel(Ao,{x:f,filter:h},{strides:n,pad:i,dilations:a});return p?le(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),Bo=Jt({equal_:function(r,t){let n=Bt(r,"a","equal","string_or_numeric"),i=Bt(t,"b","equal","string_or_numeric");return[n,i]=Ei(n,i),Nr(n.shape,i.shape),Kt.runKernel(wi,{a:n,b:i})}}),Us=Jt({where_:function(r,t,n){const i=Bt(t,"a","where"),a=Bt(n,"b","where"),o=Bt(r,"condition","where","bool"),u=Nr(Nr(o.shape,i.shape),a.shape),h={condition:hu(o,u),t:hu(i,u),e:hu(a,u)};return Kt.runKernel(cf,h)}}),Jl=Jt({divNoNan_:function(r,t){let n=Bt(r,"a","div"),i=Bt(t,"b","div");[n,i]=Ei(n,i);const a=qn(n,i),o=zr(a),u=Bo(i,o);return Us(u,o,a)}}),Xh=Jt({dot_:function(r,t){const n=Bt(r,"t1","dot"),i=Bt(t,"t2","dot");Z(!(1!==n.rank&&2!==n.rank||1!==i.rank&&2!==i.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${i.rank}.`);const a=1===n.rank?n.size:n.shape[1],o=1===i.rank?i.size:i.shape[0];if(Z(a===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${o}.`),1===n.rank&&1===i.rank){const u=le(n,[1,-1]),h=le(i,[-1,1]),f=Or(u,h);return le(f,[])}if(1===n.rank&&2===i.rank){const u=le(n,[1,-1]),h=le(i,[i.shape[0],i.shape[1]]),f=Or(u,h);return le(f,[f.size])}if(2===n.rank&&1===i.rank){const u=le(i,[-1,1]),h=Or(n,u);return le(h,[h.size])}{const u=le(i,[i.shape[0],i.shape[1]]);return Or(n,u)}}}),N0=Jt({einsum_:function(r,...t){const n=t.map((a,o)=>Bt(a,`tensors${o}`,"einsum"));return Kt.runKernel(pl,n,{equation:r})}}),fu=Jt({elu_:function(r){const t={x:Bt(r,"x","elu","float32")};return Kt.runKernel(yo,t)}}),Ig=Jt({erf_:function(r){let t=Bt(r,"x","erf");return Z("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=yn(t,"float32")),Kt.runKernel(Wo,{x:t})}}),No=Jt({exp_:function(r){const t={x:Bt(r,"x","exp")};return Kt.runKernel(xh,t)}}),xa=Jt({expandDims_:function(r,t=0){const n=Bt(r,"x","expandDims","string_or_numeric");return Z(t<=n.rank,()=>"Axis must be <= rank of the tensor"),Kt.runKernel(vo,{input:n},{dim:t})}}),Yh=Jt({expm1_:function(r){const t={x:Bt(r,"x","expm1")};return Kt.runKernel(qi,t)}}),xo=Jt({tile_:function(r,t){const n=Bt(r,"x","tile","string_or_numeric");return Z(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),Kt.runKernel(Gl,{x:n},{reps:t})}}),D0=Jt({eye_:function(r,t,n,i="float32"){null==t&&(t=r);const a=$r([r,t],i),o=r<=t?r:t;for(let h=0;h<o;++h)a.set(1,h,h);const u=le(a.toTensor(),[r,t]);if(null==n)return u;if(1===n.length)return xo(xa(u,0),[n[0],1,1]);if(2===n.length)return xo(xa(xa(u,0),0),[n[0],n[1],1,1]);if(3===n.length)return xo(xa(xa(xa(u,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),mp=Jt({floor_:function(r){const t={x:Bt(r,"x","floor","float32")};return Kt.runKernel(ac,t)}}),Kh=Jt({gather_:function(r,t,n=0,i=0){const a={x:Bt(r,"x","gather"),indices:Bt(t,"indices","gather","int32")};return Kt.runKernel($c,a,{axis:n,batchDims:i})}}),ia=Jt({greater_:function(r,t){let n=Bt(r,"a","greater","string_or_numeric"),i=Bt(t,"b","greater","string_or_numeric");return[n,i]=Ei(n,i),Nr(n.shape,i.shape),Kt.runKernel(Ul,{a:n,b:i})}}),wo=Jt({greaterEqual_:function(r,t){let n=Bt(r,"a","greaterEqual","string_or_numeric"),i=Bt(t,"b","greaterEqual","string_or_numeric");return[n,i]=Ei(n,i),Nr(n.shape,i.shape),Kt.runKernel(Id,{a:n,b:i})}}),Ff=Jt({imag_:function(r){const t={input:Bt(r,"input","imag")};return Kt.runKernel(Pm,t)}}),z1=Jt({isFinite_:function(r){const t={x:Bt(r,"x","isFinite")};return Kt.runKernel(Md,t)}}),L0=Jt({isInf_:function(r){const t={x:Bt(r,"x","isInf")};return Kt.runKernel(Td,t)}}),Of=Jt({isNaN_:function(r){const t={x:Bt(r,"x","isNaN")};return Kt.runKernel(_d,t)}}),Zu=Jt({leakyRelu_:function(r,t=.2){const n={x:Bt(r,"x","leakyRelu")};return Kt.runKernel(Kp,n,{alpha:t})}}),xc=Jt({less_:function(r,t){let n=Bt(r,"a","less","string_or_numeric"),i=Bt(t,"b","less","string_or_numeric");return[n,i]=Ei(n,i),Nr(n.shape,i.shape),Kt.runKernel(Jp,{a:n,b:i})}}),Cl=Jt({lessEqual_:function(r,t){let n=Bt(r,"a","lessEqual","string_or_numeric"),i=Bt(t,"b","lessEqual","string_or_numeric");return[n,i]=Ei(n,i),Nr(n.shape,i.shape),Kt.runKernel(Zp,{a:n,b:i})}});function Sg(r,t,n){if(n<=0)throw new Error("The number of values should be positive.");return Kt.runKernel(Um,{},{start:r,stop:t,num:n})}const Da=Jt({localResponseNormalization_:function(r,t=5,n=1,i=1,a=.5){const o=Bt(r,"x","localResponseNormalization");Z(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),Z(hn(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let u=o,h=!1;3===o.rank&&(h=!0,u=le(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const m=Kt.runKernel(Eh,{x:u},{depthRadius:t,bias:n,alpha:i,beta:a});return h?le(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),Ga=Jt({log_:function(r){const t={x:Bt(r,"x","log","float32")};return Kt.runKernel(kd,t)}}),Pf=Jt({log1p_:function(r){const t={x:Bt(r,"x","log1p")};return Kt.runKernel(Rd,t)}}),Ji=Jt({neg_:function(r){const t={x:Bt(r,"x","neg")};return Kt.runKernel(ko,t)}}),ls=Jt({softplus_:function(r){const t={x:Bt(r,"x","softplus")};return Kt.runKernel(fl,t)}}),Uf=Jt({logSigmoid_:function(r){const t=Bt(r,"x","logSigmoid");return gc(n=>({value:Ji(ls(Ji(n))),gradFunc:i=>ae(i,ba(Ji(n)))}))(t)}}),Eo=Jt({max_:function(r,t=null,n=!1){const i={x:Bt(r,"x","max")};return Kt.runKernel(Dd,i,{reductionIndices:t,keepDims:n})}}),Vn=Jt({sum_:function(r,t=null,n=!1){let i=Bt(r,"x","sum");return"bool"===i.dtype&&(i=yn(i,"int32")),Kt.runKernel(uf,{x:i},{axis:t,keepDims:n})}}),th=Jt({logSoftmax_:function(r,t=-1){const n=Bt(r,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return gc((i,a)=>{const o=Eo(i,t,!0),u=zn(i,o),h=zn(yn(u,"float32"),Ga(Vn(No(u),t,!0)));return a([h]),{value:h,gradFunc:(f,p)=>{const[m]=p,y=No(m);return zn(f,ae(Vn(f,t,!0),y))}}})(n)}});function gp(r,t){for(let n=0;n<r.length;++n)if(r[r.length-n-1]!==t-1-n)return!1;return!0}function Mg(r,t,n){const i=r.length+t.length,a=[];let o=0,u=0;for(let h=0;h<i;h++)-1===n.indexOf(h)?a.push(r[o++]):a.push(t[u++]);return a}function sa(r,t){const n=[],i=r.length;for(let a=0;a<i;a++)-1===t.indexOf(a)&&n.push(r[a]);return[n,t.map(a=>r[a])]}function Ni(r,t){return Mg(r,t.map(n=>1),t)}function zs(r,t,n){Z(gp(t,n),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function vs(r,t){if(gp(r,t))return null;const n=[];for(let i=0;i<t;++i)-1===r.indexOf(i)&&n.push(i);return r.forEach(i=>n.push(i)),n}function Jh(r){return r.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function Ai(r,t){const n=[];for(let i=t-r;i<t;++i)n.push(i);return n}const zf=Jt({logSumExp_:function(r,t=null,n=!1){const i=Bt(r,"x","logSumExp"),a=lr(t,i.shape),o=Eo(i,a,!0),u=zn(i,o),h=No(u),f=Vn(h,a),p=Ga(f),m=an(le(o,p.shape),p);if(n){const y=Ni(m.shape,a);return le(m,y)}return m}}),wa=Jt({logicalAnd_:function(r,t){const n=Bt(r,"a","logicalAnd","bool"),i=Bt(t,"b","logicalAnd","bool");return Nr(n.shape,i.shape),Kt.runKernel(wh,{a:n,b:i})}}),Ap=Jt({logicalNot_:function(r){const t={x:Bt(r,"x","logicalNot","bool")};return Kt.runKernel(Bd,t)}}),yp=Jt({logicalOr_:function(r,t){const n=Bt(r,"a","logicalOr","bool"),i=Bt(t,"b","logicalOr","bool");return Nr(n.shape,i.shape),Kt.runKernel(Nd,{a:n,b:i})}}),$f=Jt({logicalXor_:function(r,t){const n=Bt(r,"a","logicalXor","bool"),i=Bt(t,"b","logicalXor","bool");return Nr(n.shape,i.shape),wa(yp(r,t),Ap(wa(r,t)))}}),eh=Jt({maxPool_:function(r,t,n,i,a){const o=Bt(r,"x","maxPool");let u=o,h=!1;3===o.rank&&(h=!0,u=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(4===u.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${u.rank}.`),Z(Na(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),va("maxPool",i,a);const m=Kt.runKernel(Ld,{x:u},{filterSize:t,strides:n,pad:i,dimRoundingMode:a});return h?le(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),nh=Jt({maxPool3d_:function(r,t=[1,1,1],n,i,a,o="NDHWC"){const u=Bt(r,"x","maxPool3d");let h=u,f=!1;4===u.rank&&(f=!0,h=le(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Z(5===h.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${h.rank}.`),Z("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),va("maxPool3d",i,a);const y=Kt.runKernel(ef,{x:h},{filterSize:t,strides:n,pad:i,dimRoundingMode:a,dataFormat:o});return f?le(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),F0=Jt({maxPoolWithArgmax_:function(r,t,n,i,a=!1){const o={x:Bt(r,"x","maxPoolWithArgmax")},h=Kt.runKernel($m,o,{filterSize:t,strides:n,pad:i,includeBatchInIndex:a});return{result:h[0],indexes:h[1]}}}),fs=Jt({mean_:function(r,t=null,n=!1){const i={x:Bt(r,"x","mean")};return Kt.runKernel(nf,i,{axis:t,keepDims:n})}});function $s(r,t="float32"){if("complex64"===t){const i=$s(r,"float32"),a=$s(r,"float32");return ss(i,a)}const n=wn(Wt(r),t);return Kt.makeTensor(n,r,t)}function Ea(r,t="float32"){if("complex64"===t){const i=Ea(r,"float32"),a=$s(r,"float32");return ss(i,a)}const n=rr(Wt(r),t);return Kt.makeTensor(n,r,t)}function $1(r,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===r)return[];let i=Bt(r,"x","meshgrid",r instanceof Zr?r.dtype:"float32");if(void 0===t)return[i];let a=Bt(t,"y","meshgrid",t instanceof Zr?t.dtype:"float32");const o=Wt(i.shape),u=Wt(a.shape);return"xy"===n?(i=le(i,[1,-1]),a=le(a,[-1,1]),[Or(Ea([u,1],i.dtype),i),Or(a,Ea([1,o],a.dtype))]):(i=le(i,[-1,1]),a=le(a,[1,-1]),[Or(i,Ea([1,u],i.dtype)),Or(Ea([o,1],a.dtype),a)])}const vp=Jt({min_:function(r,t=null,n=!1){const i={x:Bt(r,"x","min")};return Kt.runKernel(rf,i,{axis:t,keepDims:n})}}),bp=Jt({minimum_:function(r,t){let n=Bt(r,"a","minimum"),i=Bt(t,"b","minimum");return[n,i]=Ei(n,i),"bool"===n.dtype&&(n=yn(n,"int32"),i=yn(i,"int32")),Nr(n.shape,i.shape),Kt.runKernel(Fd,{a:n,b:i})}}),nl=Jt({mirrorPad_:function(r,t,n){Z("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const i=Bt(r,"x","mirrorPad");if(0===i.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Z(t.length===i.rank,()=>`Padding doesn't match input. Must be ${i.rank}. Got ${t.length}.`);const a="reflect"===n?1:0;for(let h=0;h<i.rank;h++)Z(2===t[h].length,()=>"Invalid number of paddings. Must be length of 2 each."),Z(t[h][0]>=0&&t[h][0]<=i.shape[h]-a&&t[h][1]>=0&&t[h][1]<=i.shape[h]-a,()=>`Padding in dimension ${h} cannot be greater than or equal to ${i.shape[h]-a} or less than 0 for input of shape ${i.shape}`);return Kt.runKernel(sf,{x:i},{paddings:t,mode:n})}}),xp=Jt({mod_:function(r,t){let n=Bt(r,"a","mod"),i=Bt(t,"b","mod");return[n,i]=Ei(n,i),Kt.runKernel(Od,{a:n,b:i})}}),Vf=Jt({moments_:function(r,t=null,n=!1){const i=lr(t,(r=Bt(r,"x","moments")).shape),a=fs(r,i,n);let o=a.shape;n||(o=Ni(a.shape,i));const u=Oi(zn(yn(r,"float32"),le(a,o)));return{mean:a,variance:fs(u,i,n)}}}),O0=Jt({multiRNNCell_:function(r,t,n,i){const a=Bt(t,"data","multiRNNCell"),o=mc(n,"c","multiRNNCell"),u=mc(i,"h","multiRNNCell");let h=a;const f=[];for(let y=0;y<r.length;y++){const b=r[y](h,o[y],u[y]);f.push(b[0]),f.push(b[1]),h=b[1]}const p=[],m=[];for(let y=0;y<f.length;y+=2)p.push(f[y]),m.push(f[y+1]);return[p,m]}}),Gf=Jt({multinomial_:function(r,t,n,i=!1){const a=Bt(r,"logits","multinomial"),o=a.size,u=a.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(u>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${u}`);n=n||Math.random();const h={logits:1===u?le(a,[1,-1]):a},p=Kt.runKernel(Vm,h,{numSamples:t,seed:n,normalized:i});return 1===u?le(p,[p.size]):p}}),mu=Jt({notEqual_:function(r,t){let n=Bt(r,"a","notEqual","string_or_numeric"),i=Bt(t,"b","notEqual","string_or_numeric");return[n,i]=Ei(n,i),Nr(n.shape,i.shape),Kt.runKernel(Vc,{a:n,b:i})}}),so=Jt({onesLike_:function(r){const t={x:Bt(r,"x","onesLike")};return Kt.runKernel(zl,t)}}),P0=Jt({outerProduct_:function(r,t){const n=Bt(r,"v1","outerProduct"),i=Bt(t,"v2","outerProduct");Z(1===n.rank&&1===i.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${i.rank}.`);const a=le(n,[-1,1]),o=le(i,[1,-1]);return Or(a,o)}}),wc=Jt({pad_:function(r,t,n=0){const i=Bt(r,"x","pad");if(0===i.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return Kt.runKernel(Ki,{x:i},{paddings:t,constantValue:n})}}),V1=Jt({pad1d_:function(r,t,n=0){return Z(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),wc(r,[t],n)}}),Qf=Jt({pad2d_:function(r,t,n=0){return Z(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),wc(r,t,n)}}),Hf=Jt({pad3d_:function(r,t,n=0){return Z(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),wc(r,t,n)}}),U0=Jt({pad4d_:function(r,t,n=0){return Z(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),wc(r,t,n)}}),wp=Jt({spaceToBatchND_:function(r,t,n){const i=Bt(r,"x","spaceToBatchND");return Z(i.rank>=1+t.length,()=>`input rank ${i.rank} should be > than [blockShape] ${t.length}`),Z(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Z(i.shape.reduce((u,h,f)=>f>0&&f<=t.length?u&&(h+n[f-1][0]+n[f-1][1])%t[f-1]==0:u,!0),()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),Kt.runKernel(Vi,{x:i},{blockShape:t,paddings:n})}}),Tg=Jt({pool_:function(r,t,n,i,a,o,u){null==a&&(a=[1,1]),null==o&&(o=1),0===i&&(i="valid");const h=Bt(r,"x","maxPool");let f=h,p=!1;3===h.rank&&(p=!0,f=le(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Z(Na(o,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${a}'`);const m=el(f.shape,t,o,a,i),y=[m.dilationHeight,m.dilationWidth];let b;b="same"===i?function(dt,yt){const kt=dt.map((Vt,qt)=>Vt+(Vt-1)*(yt[qt]-1)).map(Vt=>Vt-1),Ot=kt.map(Vt=>Math.floor(Vt/2)),Nt=kt.map((Vt,qt)=>Vt-Ot[qt]);return kt.map((Vt,qt)=>[Ot[qt],Nt[qt]])}([m.filterHeight,m.filterWidth],y):[[0,0],[0,0]];const T=1===y[0]&&1===y[1],[R,L]=function(dt,yt,kt){const Ot=kt.map(te=>te[0]),Nt=kt.map(te=>te[1]),Vt=dt.concat(Ot,Nt),qt=yt.map((te,ue)=>(te-Vt[ue]%te)%te),Zt=Nt.map((te,ue)=>te+qt[ue]);return[yt.map((te,ue)=>[Ot[ue],Zt[ue]]),yt.map((te,ue)=>[0,qt[ue]])]}([m.inHeight,m.inWidth],y,b),V=T?i:"valid",j=T?f:wp(f,y,R),H=("avg"===n?()=>up(j,t,o,V,u):()=>eh(j,t,o,V,u))(),nt=T?H:vc(H,y,L);return p?le(nt,[nt.shape[1],nt.shape[2],nt.shape[3]]):nt}}),Ep=Jt({prelu_:function(r,t){const n={x:Bt(r,"x","prelu"),alpha:Bt(t,"alpha","prelu")};return Kt.runKernel(ma,n)}}),Cp=Jt({prod_:function(r,t=null,n=!1){let i=Bt(r,"x","prod");return"bool"===i.dtype&&(i=yn(i,"int32")),Kt.runKernel(Br,{x:i},{axis:t,keepDims:n})}}),z0=Jt({rand_:function(r,t,n){const i=Wt(r);let a=null;if(null==n||"float32"===n)a=new Float32Array(i);else if("int32"===n)a=new Int32Array(i);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(i)}for(let o=0;o<i;o++)a[o]=t();return Kt.makeTensor(a,r,n)}});var rh=I(6377);class Ip{constructor(t,n,i,a,o){this.mean=t,this.stdDev=n,this.dtype=i,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const u=o||Math.random();this.random=rh.alea(u.toString())}nextValue(){if(!isNaN(this.nextVal)){const a=this.nextVal;return this.nextVal=NaN,a}let t,n,i=!1;for(;!i;){let a,o,u;do{a=2*this.random()-1,o=2*this.random()-1,u=a*a+o*o}while(u>=1||0===u);const h=Math.sqrt(-2*Math.log(u)/u);t=this.mean+this.stdDev*a*h,n=this.mean+this.stdDev*o*h,this.truncated&&!this.isValidTruncated(t)||(i=!0)}return this.truncated&&!this.isValidTruncated(n)||(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class G1{constructor(t,n,i,a){this.alpha=t,this.beta=1/n,this.dtype=i;const o=a||Math.random();this.randu=rh.alea(o.toString()),this.randn=new Ip(0,1,i,!1,this.randu()),this.d=t<1?t+.6666666666666666:t-.3333333333333333,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,n,i,a,o,u;for(;;){do{a=this.randn.nextValue(),u=1+this.c*a}while(u<=0);if(u*=u*u,t=a*a,n=1-.331*t*t,i=.5*t+this.d*(1-u+Math.log(u)),o=this.randu(),o<n||Math.log(o)<i)break}return u*=1/this.beta*this.d,this.alpha<1&&(u*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(u)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class Wf{constructor(t=0,n=1,i,a){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=n-t,this.dtype=i,null==a&&(a=Math.random()),"number"==typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=rh.alea(a)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const jf=Jt({randomGamma_:function(r,t,n=1,i="float32",a){if(null==n&&(n=1),null==i&&(i="float32"),"float32"!==i&&"int32"!==i)throw new Error(`Unsupported data type ${i}`);const o=new G1(t,n,i,a),u=$r(r,i);for(let h=0;h<u.values.length;h++)u.values[h]=o.nextValue();return u.toTensor()}}),qf=Jt({randomNormal_:function(r,t=0,n=1,i,a){if(null!=i&&"bool"===i)throw new Error(`Unsupported data type ${i}`);const o=new Ip(t,n,i,!1,a),u=$r(r,i);for(let h=0;h<u.values.length;h++)u.values[h]=o.nextValue();return u.toTensor()}}),gu=Jt({randomUniform_:function(r,t=0,n=1,i="float32",a){const o=$r(r,i),u=new Wf(t,n,null,a);for(let h=0;h<o.values.length;h++)o.values[h]=u.nextValue();return o.toTensor()}});function Zl(r,t,n=1,i="float32"){if(0===n)throw new Error("Cannot have a step of zero");return Kt.runKernel(Fu,{},{start:r,stop:t,step:n,dtype:i})}const ih=Jt({real_:function(r){const t={input:Bt(r,"input","real")};return Kt.runKernel(Ye,t)}}),Ec=Jt({reciprocal_:function(r){const t={x:Bt(r,"x","reciprocal")};return Kt.runKernel(yr,t)}}),Do=Jt({relu_:function(r){const t={x:Bt(r,"x","relu")};return Kt.runKernel(Ou,t)}}),Zh=Jt({relu6_:function(r){const t={x:Bt(r,"x","relu6")};return Kt.runKernel(Ih,t)}}),Qa=Jt({reverse_:function(r,t){const n={x:Bt(r,"x","reverse")};return Kt.runKernel(Ud,n,{dims:t})}}),$0=Jt({reverse1d_:function(r){const t=Bt(r,"x","reverse");return Z(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Qa(t,0)}}),_g=Jt({reverse2d_:function(r,t){const n=Bt(r,"x","reverse");return Z(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Qa(n,t)}}),Q1=Jt({reverse3d_:function(r,t){const n=Bt(r,"x","reverse");return Z(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Qa(n,t)}}),td=Jt({reverse4d_:function(r,t){const n=Bt(r,"x","reverse");return Z(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Qa(n,t)}}),Xf=Jt({round_:function(r){const t={x:Bt(r,"x","round")};return Kt.runKernel(Sh,t)}}),Cc=Jt({rsqrt_:function(r){const t={x:Bt(r,"x","rsqrt","float32")};return Kt.runKernel(Mh,t)}}),sh=Jt({selu_:function(r){const t={x:Bt(r,"x","selu")};return Kt.runKernel(Jr,t)}}),V0=Jt({separableConv2d_:function(r,t,n,i,a,o=[1,1],u="NHWC"){const h=Bt(r,"x","separableConv2d"),f=Bt(t,"depthwiseFilter","separableConv2d"),p=Bt(n,"pointwiseFilter","separableConv2d");let m=h,y=!1;if(3===h.rank&&(y=!0,m=le(h,[1,h.shape[0],h.shape[1],h.shape[2]])),"NCHW"===u)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Z(4===m.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${m.rank}.`),Z(4===f.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${f.rank}.`),Z(4===p.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${f.rank}.`),Z(1===p.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`),Z(1===p.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`);const b=f.shape[2],T=f.shape[3];Z(p.shape[2]===b*T,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${b*T}, but got ${p.shape[2]}.`);const R=du(m,f,i,a,u,o),L=bc(R,p,1,"valid",u);return y?le(L,[L.shape[1],L.shape[2],L.shape[3]]):L}}),H1=async function(r,t){const n=Bt(r,"x","setdiff1d"),i=Bt(t,"y","setdiff1d");Z(n.dtype===i.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${i.dtype}).`),Z(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),Z(1===i.rank,()=>`y should be 1D tensor, but got y (${i.shape}).`);const a=await n.data(),o=await i.data(),u=new Set(o);let h=0;for(let m=0;m<a.length;m++)u.has(a[m])||h++;const f=new is([h],n.dtype),p=new is([h],"int32");for(let m=0,y=0;m<a.length;m++)u.has(a[m])||(f.values[y]=a[m],p.values[y]=m,y++);return[f.toTensor(),p.toTensor()]},G0=Jt({sign_:function(r){const t={x:Bt(r,"x","sign")};return Kt.runKernel(_h,t)}}),kg=Jt({sin_:function(r){const t={x:Bt(r,"x","sin","float32")};return Kt.runKernel(Pu,t)}}),Rg=Jt({sinh_:function(r){const t={x:Bt(r,"x","sinh")};return Kt.runKernel($l,t)}}),Bg=Jt({slice1d_:function(r,t,n){const i=Bt(r,"x","slice1d");return Z(1===i.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${i.rank} tensor`),Gr(i,[t],[n])}}),Q0=Jt({slice2d_:function(r,t,n){const i=Bt(r,"x","slice2d");return Z(2===i.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${i.rank} tensor`),Gr(i,t,n)}}),Sp=Jt({slice3d_:function(r,t,n){const i=Bt(r,"x","slice3d");return Z(3===i.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${i.rank} tensor`),Gr(i,t,n)}}),Yf=Jt({slice4d_:function(r,t,n){const i=Bt(r,"x","slice4d");return Z(4===i.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${i.rank} tensor`),Gr(i,t,n)}}),Ic=Jt({softmax_:function(r,t=-1){const n=Bt(r,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);return Kt.runKernel($d,{logits:n},{dim:t})}}),Kf=Jt({fft_:function(r){return Z("complex64"===r.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`),Kt.runKernel(ps,{input:r})}}),Hi=Jt({ifft_:function(r){return Z("complex64"===r.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`),Kt.runKernel(Om,{input:r})}}),ed=Jt({irfft_:function(r){const t=r.shape[r.shape.length-1],n=r.size/t;let i;if(t<=2){const a=le(r,[n,t]);i=Hi(a)}else{const a=[n,2*(t-1)],o=le(ih(r),[n,t]),u=le(Ff(r),[n,t]),h=Qa(Gr(o,[0,1],[n,t-2]),1),f=ae(Qa(Gr(u,[0,1],[n,t-2]),1),Jn(-1)),p=ti([o,h],1),m=ti([u,f],1),y=le(ss(p,m),[a[0],a[1]]);i=Hi(y)}if(i=ih(i),3===r.rank&&0!==r.shape[0]){const a=i,o=r.shape[0];i=le(i,[o,i.shape[0]/o,i.shape[1]]),a.dispose()}return i}}),ao=Jt({split_:function(r,t,n=0){const i={x:Bt(r,"x","split")};return Kt.runKernel(li,i,{numOrSizeSplits:t,axis:n})}}),ah=Jt({rfft_:function(r,t){Z("float32"===r.dtype,()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let n=r.shape[r.shape.length-1];const i=r.size/n;let a;if(null!=t&&t<n){const R=r.shape.map(V=>0),L=r.shape.map(V=>V);L[r.shape.length-1]=t,a=Gr(r,R,L),n=t}else if(null!=t&&t>n){const R=r.shape.map(L=>L);R[r.shape.length-1]=t-n,a=ti([r,$s(R)],r.shape.length-1),n=t}else a=r;const o=zr(a),u=le(ss(a,o),[i,n]),h=Kf(u),f=Math.floor(n/2)+1,p=ih(h),m=Ff(h),y=ao(p,[f,n-f],p.shape.length-1),b=ao(m,[f,n-f],m.shape.length-1),T=a.shape.slice();return T[a.shape.length-1]=f,le(ss(y[0],b[0]),T)}}),nd=Jt({squaredDifference_:function(r,t){let n=Bt(r,"a","squaredDifference"),i=Bt(t,"b","squaredDifference");return[n,i]=Ei(n,i),Nr(n.shape,i.shape),Kt.runKernel(_s,{a:n,b:i},{})}}),Lo=Jt({squeeze_:function(r,t){const n=Bt(r,"x","squeeze");return le(n,ki(n.shape,t).newShape)}}),Co=Jt({stack_:function(r,t=0){const n=mc(r,"tensors","stack","string_or_numeric");return Z(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Z(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),Kt.runKernel(Ua,n,{axis:t})}}),rd=Jt({step_:function(r,t=0){const n={x:Bt(r,"x","step")};return Kt.runKernel(Al,n,{alpha:t})}}),id=Jt({stridedSlice_:function(r,t,n,i,a=0,o=0,u=0,h=0,f=0){const p={x:Bt(r,"x","stridedSlice","string_or_numeric")};return Kt.runKernel(Vd,p,{begin:t,end:n,strides:i,beginMask:a,endMask:o,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f})}}),Jf=Jt({tan_:function(r){const t={x:Bt(r,"x","tan","float32")};return Kt.runKernel(Hc,t)}});function Yi(r,t){Ht(r);const n=Tn(r,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return gr(r,null,n,t)}function oh(r,t,n){if(Ht(r),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const i=Tn(r,n);if(2!==i.length&&1!==i.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return gr(r,t,i,n)}function W1(r,t,n){if(Ht(r),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const i=Tn(r,n);if(4!==i.length&&1!==i.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return gr(r,t,i,n)}function Ng(r,t,n){if(Ht(r),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const i=Tn(r,n);if(5!==i.length&&1!==i.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return gr(r,t,i,n)}function Kb(r,t,n){if(Ht(r),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const i=Tn(r,n);if(6!==i.length&&1!==i.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===i.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return gr(r,t=t||i,i,n)}const Mp=Jt({topk_:function(r,t=1,n=!0){const i=Bt(r,"x","topk");if(0===i.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const a=i.shape[i.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);const o={x:i},u={k:t,sorted:n},[h,f]=Kt.runKernel(Wc,o,u);return{values:h,indices:f}}}),lh=Jt({truncatedNormal_:function(r,t=0,n=1,i,a){if(null!=i&&"bool"===i)throw new Error("Unsupported data type $ { dtype }");const o=new Ip(t,n,i,!0,a),u=$r(r,i);for(let h=0;h<u.values.length;h++)u.values[h]=o.nextValue();return u.toTensor()}}),sd=Jt({unique_:function(r,t=0){const n=Bt(r,"x","unique","string_or_numeric");Z(n.rank>0,()=>"The input tensor must be at least 1D");const i={x:n},a={axis:t},[o,u]=Kt.runKernel(uc,i,a);return{values:o,indices:u}}}),Tp=Jt({unsortedSegmentSum_:function(r,t,n){const i=Bt(r,"x","unsortedSegmentSum"),a=Bt(t,"segmentIds","unsortedSegmentSum","int32");return Z(hn(n),()=>"numSegments must be of dtype int"),Kt.runKernel(zu,{x:i,segmentIds:a},{numSegments:n})}}),oo=Jt({unstack_:function(r,t=0){const n=Bt(r,"x","unstack","string_or_numeric");return Z(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),Kt.runKernel(jc,{value:n},{axis:t})}});function Zf(r,t=!0,n,i){return Kt.makeVariable(r,t,n,i)}function ad(r,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const i=$r(r,"int32"),a=$r([n.length,r.length],"int32");for(let o=0;o<n.length;o++){const u=i.indexToLoc(n[o]);a.values.set(u,o*r.length)}return a.toTensor()}const _p=async function(r){const t=Bt(r,"condition","whereAsync","bool"),n=await t.data(),i=ad(t.shape,n);return r!==t&&t.dispose(),i},Dg=async function(r,t,n){const i=Bt(r,"tensor","boolMask"),a=Bt(t,"mask","boolMask","bool"),o=n??0,u=a.rank,h=i.shape;Z(u>0,()=>"mask cannot be scalar"),_t(h.slice(o,o+u),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let f=1;for(let L=o;L<o+u;L++)f*=h[L];const p=h.slice(0,o).concat([f],h.slice(o+u)),m=le(i,p),y=le(a,[-1]),b=await _p(y),T=Lo(b,[1]),R=Kh(m,T,o);return r!==i&&i.dispose(),t!==a&&a.dispose(),T.dispose(),m.dispose(),y.dispose(),b.dispose(),R};function H0(r,t,n=null){if(0===r.rank)return Ps(r);if(1!==r.rank&&null===n)return H0(le(r,[-1]),t,n);if(1===r.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Vn(Ps(r),n);if(t===1/0)return Eo(Ps(r),n);if(t===-1/0)return vp(Ps(r),n);if("euclidean"===t||2===t)return Ba(Vn(lu(Ps(r),Jn(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Eo(Vn(Ps(r),n[0]),n[1]-1);if(t===1/0)return Eo(Vn(Ps(r),n[1]),n[0]);if(t===-1/0)return vp(Vn(Ps(r),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Ba(Vn(Oi(r),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const tm=Jt({norm_:function(r,t="euclidean",n=null,i=!1){const a=H0(r=Bt(r,"x","norm"),t,n);let o=a.shape;if(i){const u=lr(n,r.shape);o=Ni(a.shape,u)}return le(a,o)}}),j1=Jt({movingAverage_:function(r,t,n,i,a=!0){const o=Bt(r,"v","movingAverage"),u=Bt(t,"x","movingAverage"),h=Bt(n,"decay","movingAverage");d1(o,u),Z(We(o.shape,u.shape),()=>"Shape mismatch in v and x");const f=Jn(1),p=zn(f,h);let m=ae(zn(u,o),p);if(a){Z(null!=i,()=>"When using zeroDebias: true, step is required.");const y=Bt(i,"step","movingAverage");m=qn(m,zn(f,lu(h,y)))}return an(o,m)}}),W0=Jt({scatterND_:function(r,t,n){const i=Bt(r,"indices","scatterND","int32"),a=Bt(t,"updates","scatterND");return ig(a,i,n),Kt.runKernel(Th,{indices:i,updates:a},{shape:n})}}),Lg=Jt({sparseToDense_:function(r,t,n,i=0){const a=Bt(r,"sparseIndices","sparseToDense","int32"),o=Bt(t,"sparseValues","sparseToDense"),u=Bt(i,"defaultValue","sparseToDense",o.dtype);return function(p,m,y,b){if("int32"!==p.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${p.dtype}.`);if(p.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${p.shape}.`);const T=p.rank>0?p.shape[0]:1,R=p.rank>1?p.shape[1]:1;if(y.length!==R)throw new Error(`outputShape has incorrect number of elements:, ${y.length}, should be: ${R}.`);if(0!==m.rank&&(1!==m.rank||m.size!==T))throw new Error(`sparseValues has incorrect shape ${m.shape}, should be [] or [${T}]`);if(m.dtype!==b.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,o,n,u),Kt.runKernel(Qm,{sparseIndices:a,sparseValues:o,defaultValue:u},{outputShape:n})}}),kp=Jt({gatherND_:function(r,t){const n=Bt(t,"indices","gatherND","int32"),i={params:Bt(r,"x","gatherND","string_or_numeric"),indices:n};return Kt.runKernel(Fm,i)}}),rl=Jt({dropout_:function(r,t,n,i){const a=Bt(r,"x","dropout");if(Z("float32"===a.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),Z(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return r instanceof Zr?a.clone():a;const o=function(f,p){if(null==p)return f.shape.slice();if(We(f.shape,p))return p;if(f.shape.length===p.length){const m=[];for(let y=0;y<f.shape.length;y++)m.push(null==p[y]&&null!=f.shape[y]?f.shape[y]:p[y]);return m}return p}(a,n),u=1-t,h=qn(mp(an(gu(o,0,1,"float32",i),u)),u);return ae(a,h)}});function em(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function Fg(r,t,n){const i=1-r%2,a=new Float32Array(r);for(let o=0;o<r;++o){const u=2*Math.PI*o/(r+i-1);a[o]=t-n*Math.cos(u)}return Yi(a,"float32")}const q1=async function(r,t,n=1){const i=Bt(r,"predictions","inTopK"),a=Bt(t,"targets","inTopK");Z(i.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${i.rank}`),Z(i.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${i.rank} and targets rank ${a.rank}`),_t(i.shape.slice(0,i.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=i.shape[i.shape.length-1];Z(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const u=await i.data(),h=await a.data(),[f,p]=[u.length/o,o],m=Ut("bool",f);for(let y=0;y<f;y++){const b=y*p,T=u.subarray(b,b+p),R=[];for(let L=0;L<T.length;L++)R.push({value:T[L],index:L});R.sort((L,V)=>V.value-L.value),m[y]=0;for(let L=0;L<n;L++)if(R[L].index===h[y]){m[y]=1;break}}return r!==i&&i.dispose(),t!==a&&a.dispose(),Yo(m,a.shape,"bool")},Og=Jt({conv2DBackpropFilter_:function(r,t,n,i,a,o="NHWC",u){let h=r;3===r.rank&&(h=le(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let f=t;3===f.rank&&(f=le(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Z(4===h.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${h.shape}.`),Z(4===f.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${f.shape}.`),Z(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const p="NHWC"===o?h.shape[3]:h.shape[1],m="NHWC"===o?f.shape[3]:f.shape[1];return Z(p===n[2],()=>`Error in conv2dDerFilter: depth of input ${p}) must match input depth in filter (${n[2]}.`),Z(m===n[3],()=>`Error in conv2dDerFilter: depth of dy (${m}) must match output depth for filter (${n[3]}).`),va("conv2dDerFilter",a,u),Kt.runKernel(_r,{x:h,dy:f},{strides:i,pad:a,dataFormat:o,dimRoundingMode:u,filterShape:n})}});function nm(r,t,n){if(null==n||"linear"===n)return r;if("relu"===n)return ae(r,rd(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function rm(r,t){let n=t;const i=Os(r.shape,t.shape);return i.length>0&&(n=Vn(n,i)),le(n,r.shape)}function Sc(r,t,n,i){if("linear"===t)return r;if("relu"===t)return Do(r);if("elu"===t)return fu(r);if("relu6"===t)return Zh(r);if("prelu"===t)return Ep(r,n);if("leakyrelu"===t)return Zu(r,i);if("sigmoid"===t)return ba(r);throw new Error(`Unknown fused activation ${t}.`)}const im=(r,t)=>!(r>0)||"linear"===t,Pg=Jt({fusedConv2d_:function({x:r,filter:t,strides:n,pad:i,dataFormat:a="NHWC",dilations:o=[1,1],dimRoundingMode:u,bias:h,activation:f="linear",preluActivationWeights:p,leakyreluAlpha:m}){if(!1===im(Kt.state.gradientDepth,f=f||"linear")){let yt=bc(r,t,n,i,a,o,u);return null!=h&&(yt=an(yt,h)),Sc(yt,f,p,m)}const y=Bt(r,"x","conv2d","float32"),b=Bt(t,"filter","conv2d","float32");let T=y,R=!1;3===y.rank&&(R=!0,T=le(y,[1,y.shape[0],y.shape[1],y.shape[2]])),Z(4===T.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${T.rank}.`),Z(4===b.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${b.rank}.`),va("fused conv2d",i,u),Z(T.shape[3]===b.shape[2],()=>`Error in conv2d: depth of input (${T.shape[3]}) must match input depth for filter ${b.shape[2]}.`),Z(Na(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Z("NHWC"===a,()=>`Error in conv2d: got dataFormat of ${a} but only NHWC is currently supported.`);const L=ra(T.shape,b.shape,n,o,i,u);let V,j;null!=h&&(V=Bt(h,"bias","fused conv2d"),[V]=Ei(V,y),Nr(L.outShape,V.shape)),null!=p&&(j=Bt(p,"prelu weights","fused conv2d"));const H=(yt,kt)=>{const[Ot,Nt,Vt,qt]=kt,Zt=nm(yt,Vt,f);Z(Yu(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const te=[xg(Nt.shape,Zt,Ot,n,i),Og(Nt,Zt,Ot.shape,n,i)];if(null!=qt){const ue=rm(qt,Zt);te.push(ue)}return te},nt={x:T,filter:b,bias:V,preluActivationWeights:j},dt={strides:n,pad:i,dataFormat:a,dilations:o,dimRoundingMode:u,activation:f,leakyreluAlpha:m};return null==h?gc((yt,kt,Ot)=>{let Nt=Kt.runKernel(Bh,nt,dt);return Ot([kt,yt,Nt]),R&&(Nt=le(Nt,[Nt.shape[1],Nt.shape[2],Nt.shape[3]])),{value:Nt,gradFunc:H}})(T,b):gc((yt,kt,Ot,Nt)=>{let Vt=Kt.runKernel(Bh,nt,dt);return Nt([kt,yt,Vt,Ot]),R&&(Vt=le(Vt,[Vt.shape[1],Vt.shape[2],Vt.shape[3]])),{value:Vt,gradFunc:H}})(T,b,V)}}),Ug=Jt({depthwiseConv2dNativeBackpropFilter_:function(r,t,n,i,a,o=[1,1],u){let h=r;3===r.rank&&(h=le(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let f=t;return 3===f.rank&&(f=le(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Kt.runKernel(Qo,{x:h,dy:f},{strides:i,pad:a,dimRoundingMode:u,dilations:o,filterShape:n})}}),zg=Jt({depthwiseConv2dNativeBackpropInput_:function(r,t,n,i,a,o=[1,1],u){let h=t,f=!1;3===t.rank&&(f=!0,h=le(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const y=Kt.runKernel(Ja,{dy:h,filter:n},{strides:i,pad:a,dimRoundingMode:u,dilations:o,inputShape:r});return f?le(y,[y.shape[1],y.shape[2],y.shape[3]]):y}}),X1=Jt({fusedDepthwiseConv2d_:function({x:r,filter:t,strides:n,pad:i,dataFormat:a="NHWC",dilations:o=[1,1],dimRoundingMode:u,bias:h,activation:f="linear",preluActivationWeights:p,leakyreluAlpha:m}){if(!1===im(Kt.state.gradientDepth,f)){let yt=du(r,t,n,i,a,o,u);return null!=h&&(yt=an(yt,h)),Sc(yt,f,p,m)}const y=Bt(r,"x","depthwiseConv2d","float32"),b=Bt(t,"filter","depthwiseConv2d","float32");let T=y,R=!1;3===y.rank&&(R=!0,T=le(y,[1,y.shape[0],y.shape[1],y.shape[2]])),Z(4===T.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${T.rank}.`),Z(4===b.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${b.rank}.`),Z(T.shape[3]===b.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${T.shape[3]}) must match the inChannels dimension in filter ${b.shape[2]}.`),null==o&&(o=[1,1]),Z(Na(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),va("fused depthwiseConv2d",i,u);const L=ra(T.shape,b.shape,n,o,i,u,!0);let V,j;null!=h&&(V=Bt(h,"bias","fused conv2d"),[V]=Ei(V,y),Nr(L.outShape,V.shape)),null!=p&&(j=Bt(p,"prelu weights","fused depthwiseConv2d"));const H=(yt,kt)=>{Z(Yu(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[Ot,Nt,Vt,qt]=kt,Zt=nm(yt,Vt,f),te=zg(Nt.shape,Zt,Ot,n,i,o,u),ue=Ug(Nt,Zt,Ot.shape,n,i,o,u);return null!=qt?[te,ue,rm(V,Zt)]:[te,ue]},nt={x:T,filter:b,bias:V,preluActivationWeights:j},dt={strides:n,pad:i,dataFormat:a,dilations:o,dimRoundingMode:u,activation:f,leakyreluAlpha:m};return null==h?gc((yt,kt,Ot)=>{let Nt=Kt.runKernel(Ls,nt,dt);return Ot([kt,yt,Nt]),R&&(Nt=le(Nt,[Nt.shape[1],Nt.shape[2],Nt.shape[3]])),{value:Nt,gradFunc:H}})(T,b):gc((yt,kt,Ot,Nt)=>{let Vt=Kt.runKernel(Ls,nt,dt);return Nt([kt,yt,Vt,Ot]),R&&(Vt=le(Vt,[Vt.shape[1],Vt.shape[2],Vt.shape[3]])),{value:Vt,gradFunc:H}})(T,b,V)}}),Au=Jt({fusedMatMul_:function({a:r,b:t,transposeA:n=!1,transposeB:i=!1,bias:a,activation:o="linear",preluActivationWeights:u,leakyreluAlpha:h}){if(!1===im(Kt.state.gradientDepth,o)){let qt=Or(r,t,n,i);return null!=a&&(qt=an(qt,a)),Sc(qt,o,u,h)}let f=Bt(r,"a","fused matMul"),p=Bt(t,"b","fused matMul");[f,p]=Ei(f,p);const m=n?f.shape[f.rank-2]:f.shape[f.rank-1],y=i?p.shape[p.rank-1]:p.shape[p.rank-2],b=n?f.shape[f.rank-1]:f.shape[f.rank-2],T=i?p.shape[p.rank-2]:p.shape[p.rank-1],R=f.shape.slice(0,-2),L=p.shape.slice(0,-2),V=Wt(R),j=Wt(L);Z(m===y,()=>`Error in fused matMul: inner shapes (${m}) and (${y}) of Tensors with shapes ${f.shape} and ${p.shape} and transposeA=${n} and transposeB=${i} must match.`);const H=Nr(f.shape.slice(0,-2),p.shape.slice(0,-2)).concat([b,T]),nt=le(f,n?[V,m,b]:[V,b,m]),dt=le(p,i?[j,T,y]:[j,y,T]);let yt,kt;null!=a&&(yt=Bt(a,"bias","fused matMul"),[yt]=Ei(yt,f),Nr(H,yt.shape)),null!=u&&(kt=Bt(u,"prelu weights","fused matMul"));const Ot=(qt,Zt)=>{const[te,ue,Ee,De]=Zt,we=nm(le(qt,Ee.shape),Ee,o);let Te,Le;return n||i?!n&&i?(Te=Or(we,ue,!1,!1),Le=Or(we,te,!0,!1)):n&&!i?(Te=Or(ue,we,!1,!0),Le=Or(te,we,!1,!1)):(Te=Or(ue,we,!0,!0),Le=Or(we,te,!0,!0)):(Te=Or(we,ue,!1,!0),Le=Or(te,we,!0,!1)),null!=a?[Te,Le,rm(De,we)]:[Te,Le]},Nt={a:nt,b:dt,bias:yt,preluActivationWeights:kt},Vt={transposeA:n,transposeB:i,activation:o,leakyreluAlpha:h};return null==a?gc((qt,Zt,te)=>{const ue=Kt.runKernel(qc,Nt,Vt);return te([qt,Zt,ue]),{value:le(ue,H),gradFunc:Ot}})(nt,dt):gc((qt,Zt,te,ue)=>{const Ee=Kt.runKernel(qc,Nt,Vt);return ue([qt,Zt,Ee,te]),{value:le(Ee,H),gradFunc:Ot}})(nt,dt,yt)}}),Y1=Jt({hammingWindow_:function(r){return Fg(r,.54,.46)}}),$g=Jt({hannWindow_:function(r){return Fg(r,.5,.5)}}),j0=Jt({frame_:function(r,t,n,i=!1,a=0){let o=0;const u=[];for(;o+t<=r.size;)u.push(Gr(r,o,t)),o+=n;if(i)for(;o<r.size;){const h=o+t-r.size,f=ti([Gr(r,o,t-h),op([h],a)]);u.push(f),o+=n}return 0===u.length?oh([],[0,t]):le(ti(u),[u.length,t])}}),tc=Jt({stft_:function(r,t,n,i,a=$g){null==i&&(i=em(t));const o=j0(r,t,n),u=ae(o,a(t));return ah(u,i)}}),od=Jt({cropAndResize_:function(r,t,n,i,a="bilinear",o=0){const u=Bt(r,"image","cropAndResize"),h=Bt(t,"boxes","cropAndResize","float32"),f=Bt(n,"boxInd","cropAndResize","int32"),p=h.shape[0];return Z(4===u.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${u.rank}.`),Z(2===h.rank&&4===h.shape[1],()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${h.shape}.`),Z(1===f.rank&&f.shape[0]===p,()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${h.shape}.`),Z(2===i.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${i.length}.`),Z(i[0]>=1&&i[1]>=1,()=>`cropSize must be atleast [1,1], but was ${i}`),Z("bilinear"===a||"nearest"===a,()=>`method must be bilinear or nearest, but was ${a}`),Kt.runKernel(hs,{image:u,boxes:h,boxInd:f},{method:a,extrapolationValue:o,cropSize:i})}}),q0=Jt({flipLeftRight_:function(r){const t=Bt(r,"image","flipLeftRight","float32");return Z(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),Kt.runKernel(Uc,{image:t},{})}}),ld=Jt({grayscaleToRGB_:function(r){const t=Bt(r,"image","grayscaleToRGB"),n=t.rank-1,i=t.shape[n];Z(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Z(1===i,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${i}.`);const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,xo(t,a)}}),K1=Jt({rotateWithOffset_:function(r,t,n=0,i=.5){const a=Bt(r,"image","rotateWithOffset","float32");return Z(4===a.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`),Kt.runKernel(Hm,{image:a},{radians:t,fillValue:n,center:i})}});function il(r,t,n,i,a,o){null==i&&(i=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==o&&(o=0);const u=r.shape[0];return n=Math.min(n,u),Z(0<=i&&i<=1,()=>`iouThreshold must be in [0, 1], but was '${i}'`),Z(2===r.rank,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),Z(4===r.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),Z(1===t.rank,()=>"scores must be a 1D tensor"),Z(t.shape[0]===u,()=>`scores has incompatible shape with boxes. Expected ${u}, but was ${t.shape[0]}`),Z(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:i,scoreThreshold:a,softNmsSigma:o}}const cd=Jt({nonMaxSuppression_:function(r,t,n,i=.5,a=Number.NEGATIVE_INFINITY){const o=Bt(r,"boxes","nonMaxSuppression","float32"),u=Bt(t,"scores","nonMaxSuppression","float32"),h=il(o,u,n,i,a),f={maxOutputSize:n=h.maxOutputSize,iouThreshold:i=h.iouThreshold,scoreThreshold:a=h.scoreThreshold};return Kt.runKernel(to,{boxes:o,scores:u},f)}});function ud(r,t,n){const i=function(f,p,m){let y=0,b=f.length,T=0,R=!1;for(;y<b;){T=y+(b-y>>>1);const L=m(p,f[T]);L>0?y=T+1:(b=T,R=!L)}return R?y:-y-1}(r,t,n||Rp);r.splice(i<0?-(i+1):i,0,t)}function Rp(r,t){return r>t?1:r<t?-1:0}function Vg(r,t,n,i,a){return sm(r,t,n,i,a,0)}function Il(r,t,n,i,a,o){return sm(r,t,n,i,a,0,!1,o,!0)}function Bp(r,t,n,i,a,o){return sm(r,t,n,i,a,o,!0)}function sm(r,t,n,i,a,o,u=!1,h=!1,f=!1){const p=[];for(let V=0;V<t.length;V++)t[V]>a&&p.push({score:t[V],boxIndex:V,suppressBeginIndex:0});p.sort(J1);const m=o>0?-.5/o:0,y=[],b=[];for(;y.length<n&&p.length>0;){const V=p.pop(),{score:j,boxIndex:H,suppressBeginIndex:nt}=V;if(j<a)break;let dt=!1;for(let yt=y.length-1;yt>=nt;--yt){const kt=Ca(r,H,y[yt]);if(kt>=i){dt=!0;break}if(V.score=V.score*yu(i,m,kt),V.score<=a)break}V.suppressBeginIndex=y.length,dt||(V.score===j?(y.push(H),b.push(V.score)):V.score>a&&ud(p,V,J1))}const T=y.length,R=n-T;h&&R>0&&(y.push(...new Array(R).fill(0)),b.push(...new Array(R).fill(0)));const L={selectedIndices:y};return u&&(L.selectedScores=b),f&&(L.validOutputs=T),L}function Ca(r,t,n){const i=r.subarray(4*t,4*t+4),a=r.subarray(4*n,4*n+4),o=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),f=Math.max(i[1],i[3]),p=Math.min(a[0],a[2]),m=Math.min(a[1],a[3]),y=Math.max(a[0],a[2]),b=Math.max(a[1],a[3]),T=(h-o)*(f-u),R=(y-p)*(b-m);if(T<=0||R<=0)return 0;const L=Math.max(o,p),V=Math.max(u,m),j=Math.min(h,y),H=Math.min(f,b),nt=Math.max(j-L,0)*Math.max(H-V,0);return nt/(T+R-nt)}function yu(r,t,n){const i=Math.exp(t*n*n);return n<=r?i:0}function J1(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}const La=Jt({nonMaxSuppressionWithScore_:function(r,t,n,i=.5,a=Number.NEGATIVE_INFINITY,o=0){const u=Bt(r,"boxes","nonMaxSuppression"),h=Bt(t,"scores","nonMaxSuppression"),f=il(u,h,n,i,a,o),m={maxOutputSize:n=f.maxOutputSize,iouThreshold:i=f.iouThreshold,scoreThreshold:a=f.scoreThreshold,softNmsSigma:o=f.softNmsSigma},y=Kt.runKernel(af,{boxes:u,scores:h},m);return{selectedIndices:y[0],selectedScores:y[1]}}}),Jb=Jt({nonMaxSuppressionPadded_:function(r,t,n,i=.5,a=Number.NEGATIVE_INFINITY,o=!1){const u=Bt(r,"boxes","nonMaxSuppression"),h=Bt(t,"scores","nonMaxSuppression"),f=il(u,h,n,i,a,null),y=Kt.runKernel(fa,{boxes:u,scores:h},{maxOutputSize:f.maxOutputSize,iouThreshold:f.iouThreshold,scoreThreshold:f.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:y[0],validOutputs:y[1]}}}),Z1=Jt({resizeBilinear_:function(r,t,n=!1,i=!1){const a=Bt(r,"images","resizeBilinear");Z(3===a.rank||4===a.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),Z(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Z(!1===i||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=a,u=!1;3===a.rank&&(u=!0,o=le(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,p=Kt.runKernel(Qc,{images:o},{alignCorners:n,halfPixelCenters:i,size:t});return u?le(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Np=Jt({resizeNearestNeighbor_:function(r,t,n=!1,i=!1){const a=Bt(r,"images","resizeNearestNeighbor");Z(3===a.rank||4===a.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),Z(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Z("float32"===a.dtype||"int32"===a.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Z(!1===i||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=a,u=!1;3===a.rank&&(u=!0,o=le(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,p=Kt.runKernel(of,{images:o},{alignCorners:n,halfPixelCenters:i,size:t});return u?le(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Zb=Jt({threshold_:function(r,t="binary",n=!1,i=.5){const a=Bt(r,"image","threshold"),o=a.shape[0]*a.shape[1];let u,h,f,p,m=ae(Yi([i]),255);if(Z(3===a.rank,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),Z(3===a.shape[2]||1===a.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),Z("int32"===a.dtype||"float32"===a.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),Z("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===a.shape[2]){[u,h,f]=ao(a,[1,1,1],-1);const b=ae(u,.2989),T=ae(h,.587),R=ae(f,.114);p=an(an(b,T),R)}else p=r;"otsu"===t&&(m=function(b,T){let R,L,V,j,H,nt,dt=Yi([-1]),yt=Yi([0]),kt=Yi([0]);for(let Ot=0;Ot<b.size-1;Ot++){R=Gr(b,0,Ot+1),L=Gr(b,Ot+1),H=qn(Vn(R),T),nt=qn(Vn(L),T);const Nt=Vn(ae(R,Zl(0,R.size)));V=qn(Nt,Vn(R));const Vt=op(L.shape,R.size),qt=an(Zl(0,L.size),Vt),Zt=ae(L,qt);j=qn(Vn(Zt),Vn(L));const te=zn(V,j),ue=zn(V,j),Ee=ae(H,nt);kt=ae(ae(Ee,te),ue);const De=ia(kt,yt);yt=Us(De,kt,yt),dt=Us(De,Yi([Ot]),dt)}return dt}(dp(yn(Xf(p),"int32"),Yo([]),256),o));const y=n?Cl(p,m):ia(p,m);return yn(ae(y,255),"int32")}}),tx=Jt({transform_:function(r,t,n="nearest",i="constant",a=0,o){const u=Bt(r,"image","transform","float32"),h=Bt(t,"transforms","transform","float32");return Z(4===u.rank,()=>`Error in transform: image must be rank 4,but got rank ${u.rank}.`),Z(2===h.rank&&(h.shape[0]===u.shape[0]||1===h.shape[0])&&8===h.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Z(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),Kt.runKernel(Ql,{image:u,transforms:h},{interpolation:n,fillMode:i,fillValue:a,outputShape:o})}}),X0=Jt({bandPart_:function(r,t,n){Z(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Z(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const i=Bt(r,"a","bandPart");Z(i.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${i.rank}.`);const a=i.shape,[o,u]=i.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(n<=u))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${u}).`);t<0&&(t=o),n<0&&(n=u);const h=le(Zl(0,o,1,"int32"),[-1,1]),f=Zl(0,u,1,"int32"),p=zn(h,f),m=wa(Cl(p,Jn(+t,"int32")),wo(p,Jn(-n,"int32"))),y=$s([o,u],i.dtype);return le(Co(oo(le(i,[-1,o,u])).map(b=>Us(m,b,y))),a)}}),ch=Jt({gramSchmidt_:function(r){let t;if(Array.isArray(r)){t=!1,Z(null!=r&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const a=r[0].shape[0];for(let o=1;o<r.length;++o)Z(r[o].shape[0]===a,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[o].shape[0]} vs. ${a})`)}else t=!0,r=ao(r,r.shape[0],0).map(a=>Lo(a,[0]));Z(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);const n=[],i=r;for(let a=0;a<r.length;++a)n.push(Kt.tidy(()=>{let o=i[a];if(a>0)for(let u=0;u<a;++u){const h=ae(Vn(ae(n[u],o)),n[u]);o=zn(o,h)}return qn(o,tm(o,"euclidean"))}));return t?Co(n,0):n}});function Y0(r,t=!1){return Kt.tidy(()=>{Z(2===r.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);const n=r.shape[0],i=r.shape[1];let a=D0(n),o=ru(r);const u=oh([[1]],[1,1]);let h=ru(u);const f=n>=i?i:n;for(let p=0;p<f;++p){const m=o,y=h,b=a;[h,o,a]=Kt.tidy(()=>{const T=Gr(o,[p,p],[n-p,1]),R=tm(T),L=Gr(o,[p,p],[1,1]),V=Us(ia(L,0),oh([[-1]]),oh([[1]])),j=zn(L,ae(V,R)),H=qn(T,j);h=1===H.shape[0]?ru(u):ti([u,Gr(H,[1,0],[H.shape[0]-1,H.shape[1]])],0);const nt=Ji(qn(Or(V,j),R)),dt=Gr(o,[p,0],[n-p,i]),yt=ae(nt,h),kt=qr(h);if(0===p)o=zn(dt,Or(yt,Or(kt,dt)));else{const Vt=zn(dt,Or(yt,Or(kt,dt)));o=ti([Gr(o,[0,0],[p,i]),Vt],0)}const Ot=qr(yt),Nt=Gr(a,[0,p],[n,a.shape[1]-p]);if(0===p)a=zn(Nt,Or(Or(Nt,h),Ot));else{const Vt=zn(Nt,Or(Or(Nt,h),Ot));a=ti([Gr(a,[0,0],[n,p]),Vt],1)}return[h,o,a]}),Dr([m,y,b])}return!t&&n>i&&(a=Gr(a,[0,0],[n,i]),o=Gr(o,[0,0],[i,i])),[a,o]})}const K0=Jt({qr_:function(r,t=!1){if(Z(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),2===r.rank)return Y0(r,t);{const n=r.shape.slice(0,r.shape.length-2).reduce((u,h)=>u*h),i=oo(le(r,[n,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),a=[],o=[];return i.forEach(u=>{const[h,f]=Y0(u,t);a.push(h),o.push(f)}),[le(Co(a,0),r.shape),le(Co(o,0),r.shape)]}}});var Ha;!function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Ha||(Ha={}));const Mc=Jt({computeWeightedLoss_:function(r,t,n=Ha.SUM_BY_NONZERO_WEIGHTS){const i=Bt(r,"losses","computeWeightedLoss");let a=null;null!=t&&(a=Bt(t,"weights","computeWeightedLoss"));const o=null==a?i:ae(i,a);if(n===Ha.NONE)return o;if(n===Ha.SUM)return Vn(o);if(n===Ha.MEAN){if(null==a)return fs(o);{const u=i.size/a.size,h=qn(Vn(o),Vn(a));return u>1?qn(h,Jn(u)):h}}if(n===Ha.SUM_BY_NONZERO_WEIGHTS){if(null==a)return qn(Vn(o),Jn(i.size));{const u=ae(a,Ea(i.shape)),h=yn(Vn(mu(u,Jn(0))),"float32");return qn(Vn(o),h)}}throw Error(`Unknown reduction: ${n}`)}}),J0=Jt({absoluteDifference_:function(r,t,n,i=Ha.SUM_BY_NONZERO_WEIGHTS){const a=Bt(r,"labels","absoluteDifference"),o=Bt(t,"predictions","absoluteDifference");let u=null;null!=n&&(u=Bt(n,"weights","absoluteDifference")),_t(a.shape,o.shape,"Error in absoluteDifference: ");const h=Ps(zn(a,o));return Mc(h,u,i)}}),ex=Jt({cosineDistance_:function(r,t,n,i,a=Ha.SUM_BY_NONZERO_WEIGHTS){const o=Bt(r,"labels","cosineDistance"),u=Bt(t,"predictions","cosineDistance");let h=null;null!=i&&(h=Bt(i,"weights","cosineDistance")),_t(o.shape,u.shape,"Error in cosineDistance: ");const f=Jn(1),p=zn(f,Vn(ae(o,u),n,!0));return Mc(p,h,a)}}),Z0=Jt({hingeLoss_:function(r,t,n,i=Ha.SUM_BY_NONZERO_WEIGHTS){let a=Bt(r,"labels","hingeLoss");const o=Bt(t,"predictions","hingeLoss");let u=null;null!=n&&(u=Bt(n,"weights","hingeLoss")),_t(a.shape,o.shape,"Error in hingeLoss: ");const h=Jn(1);a=zn(ae(Jn(2),a),h);const f=Do(zn(h,ae(a,o)));return Mc(f,u,i)}}),tv=Jt({huberLoss_:function(r,t,n,i=1,a=Ha.SUM_BY_NONZERO_WEIGHTS){const o=Bt(r,"labels","huberLoss"),u=Bt(t,"predictions","huberLoss");let h=null;null!=n&&(h=Bt(n,"weights","huberLoss")),_t(o.shape,u.shape,"Error in huberLoss: ");const f=Jn(i),p=Ps(zn(u,o)),m=bp(p,f),y=zn(p,m),b=an(ae(Jn(.5),Oi(m)),ae(f,y));return Mc(b,h,a)}}),am=Jt({logLoss_:function(r,t,n,i=1e-7,a=Ha.SUM_BY_NONZERO_WEIGHTS){const o=Bt(r,"labels","logLoss"),u=Bt(t,"predictions","logLoss");let h=null;null!=n&&(h=Bt(n,"weights","logLoss")),_t(o.shape,u.shape,"Error in logLoss: ");const f=Jn(1),p=Jn(i),m=Ji(ae(o,Ga(an(u,p)))),y=ae(zn(f,o),Ga(an(zn(f,u),p))),b=zn(m,y);return Mc(b,h,a)}}),ty=Jt({meanSquaredError_:function(r,t,n,i=Ha.SUM_BY_NONZERO_WEIGHTS){const a=Bt(r,"labels","meanSquaredError"),o=Bt(t,"predictions","meanSquaredError");let u=null;null!=n&&(u=Bt(n,"weights","meanSquaredError")),_t(a.shape,o.shape,"Error in meanSquaredError: ");const h=nd(a,o);return Mc(h,u,i)}}),nx=Jt({sigmoidCrossEntropy_:function(r,t,n,i=0,a=Ha.SUM_BY_NONZERO_WEIGHTS){let o=Bt(r,"multiClassLabels","sigmoidCrossEntropy");const u=Bt(t,"logits","sigmoidCrossEntropy");let h=null;if(null!=n&&(h=Bt(n,"weights","sigmoidCrossEntropy")),_t(o.shape,u.shape,"Error in sigmoidCrossEntropy: "),i>0){const p=Jn(i),m=Jn(1),y=Jn(.5);o=an(ae(o,zn(m,p)),ae(y,p))}const f=function(p,m){const y=Bt(p,"labels","sigmoidCrossEntropyWithLogits"),b=Bt(m,"logits","sigmoidCrossEntropyWithLogits");_t(y.shape,b.shape,"Error in sigmoidCrossEntropyWithLogits: ");const T=Do(b),R=ae(b,y),L=Pf(No(Ji(Ps(b))));return an(zn(T,R),L)}(o,u);return Mc(f,h,a)}}),ey=Jt({softmaxCrossEntropy_:function(r,t,n,i=0,a=Ha.SUM_BY_NONZERO_WEIGHTS){let o=Bt(r,"onehotLabels","softmaxCrossEntropy");const u=Bt(t,"logits","softmaxCrossEntropy");let h=null;if(null!=n&&(h=Bt(n,"weights","softmaxCrossEntropy")),_t(o.shape,u.shape,"Error in softmaxCrossEntropy: "),i>0){const p=Jn(i),m=Jn(1),y=Jn(o.shape[1]);o=an(ae(o,zn(m,p)),qn(p,y))}const f=function(p,m,y=-1){if(-1===y&&(y=m.rank-1),y!==m.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${m.rank} and dim was ${y}`);return gc((b,T,R)=>{const L=zf(T,[y],!0),V=zn(yn(T,"float32"),L);R([b,V]);const j=Ji(ae(V,b));return{value:Vn(j,[y]),gradFunc:(H,nt)=>{const[dt,yt]=nt,kt=Ni(H.shape,[y]);return[ae(le(H,kt),zn(yn(dt,"float32"),No(yt))),ae(le(H,kt),zn(No(yt),yn(dt,"float32")))]}}})(p,m)}(o,u);return Mc(f,h,a)}}),rx=Jt({sparseFillEmptyRows_:function(r,t,n,i){const a=Bt(r,"indices","sparseFillEmptyRows","int32"),o=Bt(t,"values","sparseFillEmptyRows"),u=Bt(n,"denseShape","sparseFillEmptyRows","int32"),h=Bt(i,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==u.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${u.shape}`);if(0!==h.rank)throw new Error(`Default value should be a scalar but received shape ${h.shape}`);const p=Kt.runKernel(bo,{indices:a,values:o,denseShape:u,defaultValue:h});return{outputIndices:p[0],outputValues:p[1],emptyRowIndicator:p[2],reverseIndexMap:p[3]}}}),ny=Jt({sparseReshape_:function(r,t,n){const i=Bt(r,"inputIndices","sparseReshape","int32"),a=Bt(t,"inputShape","sparseReshape","int32"),o=Bt(n,"newShape","sparseReshape","int32");if(2!==i.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${i.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const h=Kt.runKernel(kh,{inputIndices:i,inputShape:a,newShape:o});return{outputIndices:h[0],outputShape:h[1]}}}),ev=Jt({sparseSegmentMean_:function(r,t,n){const i=Bt(r,"data","sparseSegmentMean"),a=Bt(t,"indices","sparseSegmentMean","int32"),o=Bt(n,"segmentIds","sparseSegmentMean","int32");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);return Kt.runKernel(Gm,{data:i,indices:a,segmentIds:o})}}),nv=Jt({sparseSegmentSum_:function(r,t,n){const i=Bt(r,"data","sparseSegmentSum"),a=Bt(t,"indices","sparseSegmentSum","int32"),o=Bt(n,"segmentIds","sparseSegmentSum","int32");if(i.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);return Kt.runKernel(Rh,{data:i,indices:a,segmentIds:o})}}),Dp=Jt({stringNGrams_:function(r,t,n,i,a,o,u,h){const f=Bt(r,"data","stringNGrams","string");if("string"!==f.dtype)throw new Error("Data must be of datatype string");if(1!==f.shape.length)throw new Error(`Data must be a vector, saw: ${f.shape}`);const p=Bt(t,"dataSplits","stringNGrams");if("int32"!==p.dtype)throw new Error("Data splits must be of datatype int32");const b=Kt.runKernel(hf,{data:f,dataSplits:p},{separator:n,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:h});return{nGrams:b[0],nGramsSplits:b[1]}}}),Gg=Jt({stringSplit_:function(r,t,n=!0){const i=Bt(r,"input","stringSplit","string"),a=Bt(t,"delimiter","stringSplit","string");if(1!==i.rank)throw new Error(`Input should be Tensor1D but received shape ${i.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const h=Kt.runKernel(ta,{input:i,delimiter:a},{skipEmpty:n});return{indices:h[0],values:h[1],shape:h[2]}}}),Qg=Jt({stringToHashBucketFast_:function(r,t){const n=Bt(r,"input","stringToHashBucketFast","string"),i={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return Kt.runKernel(ml,{input:n},i)}}),vu={fft:Kf,ifft:Hi,rfft:ah,irfft:ed},rv={hammingWindow:Y1,hannWindow:$g,frame:j0,stft:tc},sl={flipLeftRight:q0,grayscaleToRGB:ld,resizeNearestNeighbor:Np,resizeBilinear:Z1,rotateWithOffset:K1,cropAndResize:od,nonMaxSuppression:cd,nonMaxSuppressionAsync:async function(r,t,n,i=.5,a=Number.NEGATIVE_INFINITY){const o=Bt(r,"boxes","nonMaxSuppressionAsync"),u=Bt(t,"scores","nonMaxSuppressionAsync"),h=il(o,u,n,i,a);n=h.maxOutputSize,i=h.iouThreshold,a=h.scoreThreshold;const f=await Promise.all([o.data(),u.data()]),p=f[0],m=f[1],{selectedIndices:y}=Vg(p,m,n,i,a);return o!==r&&o.dispose(),u!==t&&u.dispose(),Yi(y,"int32")},nonMaxSuppressionWithScore:La,nonMaxSuppressionWithScoreAsync:async function(r,t,n,i=.5,a=Number.NEGATIVE_INFINITY,o=0){const u=Bt(r,"boxes","nonMaxSuppressionAsync"),h=Bt(t,"scores","nonMaxSuppressionAsync"),f=il(u,h,n,i,a,o);n=f.maxOutputSize,i=f.iouThreshold,a=f.scoreThreshold,o=f.softNmsSigma;const p=await Promise.all([u.data(),h.data()]),m=p[0],y=p[1],{selectedIndices:b,selectedScores:T}=Bp(m,y,n,i,a,o);return u!==r&&u.dispose(),h!==t&&h.dispose(),{selectedIndices:Yi(b,"int32"),selectedScores:Yi(T)}},nonMaxSuppressionPadded:Jb,nonMaxSuppressionPaddedAsync:async function(r,t,n,i=.5,a=Number.NEGATIVE_INFINITY,o=!1){const u=Bt(r,"boxes","nonMaxSuppressionAsync"),h=Bt(t,"scores","nonMaxSuppressionAsync"),f=il(u,h,n,i,a,null),p=f.maxOutputSize,m=f.iouThreshold,y=f.scoreThreshold,[b,T]=await Promise.all([u.data(),h.data()]),{selectedIndices:R,validOutputs:L}=Il(b,T,p,m,y,o);return u!==r&&u.dispose(),h!==t&&h.dispose(),{selectedIndices:Yi(R,"int32"),validOutputs:Jn(L,"int32")}},threshold:Zb,transform:tx},iv={bandPart:X0,gramSchmidt:ch,qr:K0},ix={absoluteDifference:J0,computeWeightedLoss:Mc,cosineDistance:ex,hingeLoss:Z0,huberLoss:tv,logLoss:am,meanSquaredError:ty,sigmoidCrossEntropy:nx,softmaxCrossEntropy:ey},Lp={sparseFillEmptyRows:rx,sparseReshape:ny,sparseSegmentMean:ev,sparseSegmentSum:nv},om={stringNGrams:Dp,stringSplit:Gg,stringToHashBucketFast:Qg},uh={sgd:qu.sgd,momentum:qu.momentum,adadelta:qu.adadelta,adagrad:qu.adagrad,rmsprop:qu.rmsprop,adamax:qu.adamax,adam:qu.adam},Hg=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:r=>r();function Wg(){return new Promise(r=>Hg(()=>r()))}function ry(r,t){const n=r[0].length;r.forEach((a,o)=>{Z(a.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),Z(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const i=r[0];r.forEach((a,o)=>{for(let u=0;u<n;u++)Z(u===t||a[u]===i[u],()=>`Error in concat${n}D: Shape of tensors[${o}] (${a}) does not match the shape of the rest (${i}) along the non-concatenated axis ${o}.`)})}function ec(r,t){const n=r[0].slice();for(let i=1;i<r.length;i++)n[t]+=r[i][t];return n}const jg=30;function Tc(r){return r<=jg?r:Kn(r,Math.floor(Math.sqrt(r)))}function iy(r,t,n){return[n*("number"==typeof r?r:r[0]),t*("number"==typeof r?r:r[1])]}function Fp(r,t,n,i=!0){let a=[];if(i)a=a.concat(t.slice(0)),a.push(r[0]/n),a=a.concat(r.slice(1));else{a=a.concat(r[0]);const o=t.length;for(let u=0;u<o;++u)a=a.concat([r[u+1]/t[u],t[u]]);a=a.concat(r.slice(o+1))}return a}function Op(r,t,n=!0){const i=[];if(n){i.push(t);for(let a=t+1;a<r;++a)a<=2*t?(i.push(a),i.push(a-(t+1))):i.push(a)}else{const a=[],o=[];for(let u=1;u<r;++u)u>=2*t+1||u%2==1?o.push(u):a.push(u);i.push(...a),i.push(0),i.push(...o)}return i}function nc(r,t,n,i=!0){const a=[];a.push(i?r[0]/n:r[0]*n);for(let o=1;o<r.length;++o)a.push(o<=t.length?i?t[o-1]*r[o]:r[o]/t[o-1]:r[o]);return a}function qg(r,t){const n=[0];for(let i=0;i<t;++i)n.push(r[i][0]);return n}function sy(r,t,n){const i=r.slice(0,1);for(let a=0;a<n;++a)i.push(r[a+1]-t[a][0]-t[a][1]);return i}const _c=1.7580993408473768,Xg=1.0507009873554805,Yg=.3275911,bu=.254829592,Kg=-.284496736,ay=1.421413741,xu=-1.453152027,oy=1.061405429;function wu(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);const n=new Float32Array(2*r.length);for(let i=0;i<n.length;i+=2)n[i]=r[i/2],n[i+1]=t[i/2];return n}function ly(r){const t=new Float32Array(r.length/2),n=new Float32Array(r.length/2);for(let i=0;i<r.length;i+=2)t[i/2]=r[i],n[i/2]=r[i+1];return{real:t,imag:n}}function Jg(r){const t=Math.ceil(r.length/4),n=new Float32Array(t),i=new Float32Array(t);for(let a=0;a<r.length;a+=4)n[Math.floor(a/4)]=r[a],i[Math.floor(a/4)]=r[a+1];return{real:n,imag:i}}function sv(r){const t=Math.floor(r.length/4),n=new Float32Array(t),i=new Float32Array(t);for(let a=2;a<r.length;a+=4)n[Math.floor(a/4)]=r[a],i[Math.floor(a/4)]=r[a+1];return{real:n,imag:i}}function lm(r,t){return{real:r[2*t],imag:r[2*t+1]}}function av(r,t,n,i){r[2*i]=t,r[2*i+1]=n}function ov(r,t){const n=new Float32Array(r/2),i=new Float32Array(r/2);for(let a=0;a<Math.ceil(r/2);a++){const o=(t?2:-2)*Math.PI*(a/r);n[a]=Math.cos(o),i[a]=Math.sin(o)}return{real:n,imag:i}}function lv(r,t,n){const i=(n?2:-2)*Math.PI*(r/t);return{real:Math.cos(i),imag:Math.sin(i)}}const pi=/->/g;function cy(r,t){const n=((r=r.replace(/\s/g,"")).length-r.replace(pi,"").length)/2;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[i,a]=r.split("->");Z(-1===i.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const o=i.split(","),u=o.length;if(t!==u)throw new Error(`Expected ${u} input tensors, received ${t}`);if(u>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const h=[];for(let y=0;y<a.length;++y){const b=a[y];if(!o.some(T=>-1!==T.indexOf(b)))throw new Error(`Output subscripts contain the label ${b} not present in the input subscripts.`);-1===h.indexOf(b)&&h.push(b)}for(let y=0;y<i.length;++y){const b=i[y];-1===h.indexOf(b)&&","!==b&&h.push(b)}const f=new Array(o.length);for(let y=0;y<u;++y){if(new Set(o[y].split("")).size!==o[y].length)throw new Error(`Found duplicate axes in input component ${o[y]}. Support for duplicate axes in input is not implemented yet.`);f[y]=[];for(let b=0;b<o[y].length;++b)f[y].push(h.indexOf(o[y][b]))}const p=h.length,m=[];for(let y=a.length;y<p;++y)m.push(y);return{allDims:h,summedDims:m,idDims:f}}function Zg(r,t){let n=new Array(r);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;const i=[];for(let a=0;a<r;++a)-1===n[a]&&i.push(a);return n=n.filter(a=>-1!==a),{permutationIndices:n,expandDims:i}}function uy(r,t,n){const i=new Array(r);for(let a=0;a<n.length;++a){const o=n[a].shape;for(let u=0;u<t[a].length;++u)void 0===i[t[a][u]]?i[t[a][u]]=o[u]:Z(i[t[a][u]]===o[u],()=>`Expected dimension ${i[t[a][u]]} at axis ${u} of input shaped ${JSON.stringify(o)}, but got dimension ${o[u]}`)}}function hy(r,t){const n=r,i=[];let a=0;0===r.length&&n.push(-1),a=r.length+1;for(let u=0;u<a;++u)i.push([]);const o=[];for(let u=0;u<n.length;++u){const h=sx(t,n[u]);for(const f of h)-1===o.indexOf(f)&&(i[u].push(f),o.push(f))}return{path:n,steps:i}}function cm(r){return r.every((t,n)=>t===n)}function sx(r,t){const n=[];for(let i=0;i<r.length;++i)0!==r[i].length&&-1===r[i].indexOf(t)&&-1!==t||n.push(i);return n}function dy(r,t,n=0){let i=[];if("number"==typeof t)Z(r.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),i=new Array(t).fill(r.shape[n]/t);else{Z(t.reduce((o,u)=>(-1===u&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(-1!==a){const o=t.reduce((u,h)=>h>0?u+h:u);t[a]=r.shape[n]-o}Z(r.shape[n]===t.reduce((o,u)=>o+u),()=>"The sum of sizes must match the size of the axis dimension."),i=t}return i}function cv(r){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${r}`}function uv(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function py(r,t,n){return`indices(${r}, 0) is invalid: ${t} >= ${n}`}function hv(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function fy(r,t){return`size ${r} must be non-negative, not ${t}`}function my(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function dv(r,t){return`Input to reshape is a SparseTensor with ${Wt(r)}\n  dense values, but the requested shape requires a multiple of ${Wt(t)}. inputShape=${r} outputShape= ${t}`}function pv(r,t){return`Input to reshape is a tensor with ${Wt(r)} dense values, but the requested shape has ${Wt(t)}. inputShape=${r} outputShape=${t}`}function fv(){return"segment ids must be >= 0"}function ax(){return"segment ids are not increasing"}function gy(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function um(r,t,n){return`Bad: indices[${r}] == ${t} out of range [0, ${n})`}function mv(r,t){let n,i=!1;for(r<=jg?(n=r,i=!0):n=Kn(r,Math.floor(Math.sqrt(r)));!i;)n>t||n===r?i=!0:n=Kn(r,n+1);return n}function Ay(r,t,n){const i=[],a=r.length;for(let o=0;o<a;o++)i.push(o!==t?r[o]:n);return i}function yy(r,t,n,i){const a=t.shape.length,o=r.shape.length;if(0!==i&&(i<-a||i>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${i}`);if(i<0&&(i+=a),i>o)throw new Error(`batchDims (${i}) must be less than rank(x) (\n    ${o}).`);if(n<i)throw new Error(`batchDims (${i}) must be less than or equal to axis (${n}).`);for(let y=0;y<i;++y)if(r.shape[y]!==t.shape[y])throw new Error(`x.shape[${y}]: ${r.shape[y]} should be equal to indices.shape[${y}]: ${t.shape[y]}.`);const u=r.shape[n],h=[];let f=1,p=1,m=1;for(let y=0;y<i;++y)h.push(r.shape[y]),f*=r.shape[y];for(let y=i;y<n;y++)h.push(r.shape[y]),p*=r.shape[y];for(let y=i;y<a;y++)h.push(t.shape[y]);for(let y=n+1;y<o;y++)h.push(r.shape[y]),m*=r.shape[y];return{batchSize:f,sliceSize:m,outerSize:p,dimSize:u,outputShape:h}}function Fo(r){try{return r.map(t=>Dh(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function hm(r){return r.map(t=>jl(t))}const tA={kernelName:da,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(r,rd(yn(n,"float32"),-1))}}},ox={kernelName:pa,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>{const i=Oi(yn(n,"float32")),a=Ba(zn(Jn(1),i));return Ji(qn(r,a))}}}},gv={kernelName:Ss,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>{const i=Ba(zn(Oi(yn(n,"float32")),1));return qn(r,i)}}}},lx={kernelName:Xs,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t,a=Nr(n.shape,i.shape);return{a:()=>{let o=r;const u=Os(n.shape,a);return u.length>0&&(o=Vn(o,u)),le(o,n.shape)},b:()=>{let o=r;const u=Os(i.shape,a);return u.length>0&&(o=Vn(o,u)),le(o,i.shape)}}}},cx={kernelName:Ms,saveAllInputs:!0,gradFunc:(r,t)=>{const n={};return t.forEach((i,a)=>{n[a]=()=>r.clone()}),n}},Av={kernelName:Ys,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>zr(n)}}},yv={kernelName:Ks,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>zr(n)}}},ux={kernelName:Ka,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>qn(r,Ba(zn(Jn(1),Oi(yn(n,"float32")))))}}},hx={kernelName:oi,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>{const i=Ba(an(Jn(1),Oi(yn(n,"float32"))));return qn(r,i)}}}},dx={kernelName:Li,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t,a=Nr(n.shape,i.shape);return{a:()=>{const o=an(Oi(n),Oi(i));let u=ae(r,qn(i,o));const h=Os(n.shape,a);return h.length>0&&(u=Vn(u,h)),le(u,n.shape)},b:()=>{const o=an(Oi(n),Oi(i));let u=Ji(ae(r,qn(n,o)));const h=Os(i.shape,a);return h.length>0&&(u=Vn(u,h)),le(u,i.shape)}}}},vv={kernelName:Ol,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>qn(r,an(Oi(yn(n,"float32")),1))}}},eA={kernelName:Go,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>qn(r,zn(Jn(1),Oi(yn(n,"float32"))))}}},bv=Jt({avgPool3dGrad_:function(r,t,n,i,a,o){const u=Bt(r,"dy","avgPool3dGrad"),h=Bt(t,"input","avgPool3dGrad");let f=u,p=h,m=!1;4===h.rank&&(m=!0,f=le(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),p=le(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),Z(5===f.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${f.rank}.`),Z(5===p.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),va("avgPool3dGrad",a,o);const T=Kt.runKernel(Mt,{dy:f,input:p},{filterSize:n,strides:i,pad:a,dimRoundingMode:o});return m?le(T,[T.shape[1],T.shape[2],T.shape[3],T.shape[4]]):T}}),px={kernelName:It,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:h}=n;return{x:()=>bv(r,i,a,o,u,h)}}},nA=Jt({avgPoolGrad_:function(r,t,n,i,a){const o=Bt(r,"dy","avgPoolGrad"),u=Bt(t,"input","avgPoolGrad");Z(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`);let h=u,f=o,p=!1;3===u.rank&&(p=!0,h=le(u,[1,u.shape[0],u.shape[1],u.shape[2]]),f=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Z(4===f.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${f.rank}.`),Z(4===h.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${h.rank}.`);const b=Kt.runKernel(mt,{dy:f,input:h},{filterSize:n,strides:i,pad:a});return p?le(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),Rs={kernelName:K,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,{filterSize:a,strides:o,pad:u}=n;return{x:()=>nA(r,i,a,o,u)}}},fx={kernelName:Gt,inputsToSave:["a","b"],gradFunc:(r,t,n)=>{const[i,a]=t,{transposeA:o,transposeB:u}=n;return o||u?!o&&u?{a:()=>Or(r,a,!1,!1),b:()=>Or(r,i,!0,!1)}:o&&!u?{a:()=>Or(a,r,!1,!0),b:()=>Or(i,r,!1,!1)}:{a:()=>Or(a,r,!0,!0),b:()=>Or(r,i,!0,!0)}:{a:()=>Or(r,a,!1,!0),b:()=>Or(i,r,!0,!1)}}},Vs={kernelName:Xt,gradFunc:(r,t,n)=>{const{blockShape:i,crops:a}=n;return{x:()=>wp(r,i,a)}}},rA={kernelName:sn,gradFunc:(r,t,n)=>{const a=n.inputShape,o=n.shape,u=Array.from(o);for(let f=a.length-1;f>=0;f--)if(a[f]===o[f])u[f]=1;else if(1!==a[f])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${o}].`);const h=[];for(let f=0;f<u.length;f++)u[f]>1&&h.push(f);return{x:()=>Vn(r,h,!0)}}},mx={kernelName:Ie,gradFunc:r=>({x:()=>r.clone()})},gx={kernelName:Be,gradFunc:r=>({x:()=>zr(r)})},Ax={kernelName:Pn,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,{clipValueMin:a,clipValueMax:o}=n;return{x:()=>Us(wa(wo(i,a),Cl(i,o)),r,zr(r))}}},xv={kernelName:dr,inputsToSave:["x"],gradFunc:tA.gradFunc},iA={kernelName:Ar,saveAllInputs:!0,gradFunc:(r,t,n)=>{const i=t.map(h=>h.shape),{axis:a}=n,o=lr(a,t[0].shape)[0],u=i.map(h=>h[o]);return ao(r,u,o).map(h=>()=>h)}},vy={kernelName:xr,inputsToSave:["x","filter"],gradFunc:(r,t,n)=>{const[i,a]=t,{dilations:o,strides:u,pad:h,dataFormat:f}=n;return Z(Yu(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>xg(i.shape,r,a,u,h,f),filter:()=>Og(i,r,a.shape,u,h,f)}}},yx={kernelName:Pr,inputsToSave:["dy","filter"],gradFunc:(r,t,n)=>{const[i,a]=t,{strides:o,pad:u,dataFormat:h,dimRoundingMode:f}=n;return{dy:()=>bc(r,a,o,u,h,1,f),filter:()=>Og(r,i,a.shape,o,u,h,f)}}},vx=Jt({conv3DBackpropFilter_:function(r,t,n,i,a){let o=r;4===r.rank&&(o=le(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let u=t;return 4===u.rank&&(u=le(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Z(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),Z(5===u.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${u.shape}.`),Z(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Z(o.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${n[3]}.`),Z(u.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${u.shape[4]}) must match output depth for filter (${n[4]}).`),Kt.runKernel(us,{x:o,dy:u},{strides:i,pad:a,filterShape:n})}}),bx={kernelName:ui,inputsToSave:["x","filter"],gradFunc:(r,t,n)=>{const{dilations:i,strides:a,pad:o}=n;Z(Yu(i),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const[u,h]=t;return{x:()=>U1(u.shape,r,h,a,o),filter:()=>vx(u,r,h.shape,a,o)}}},xx={kernelName:rs,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(Ji(kg(yn(n,"float32"))),r)}}},by={kernelName:Ts,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(Rg(yn(n,"float32")),r)}}},wx={kernelName:Js,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,{axis:a,exclusive:o,reverse:u}=n;return{x:()=>{const h=vs([a],i.rank);let f=Df(r,a,o,!u);return null!=h&&(f=qr(f,h)),f}}}},Ex={kernelName:Zs,inputsToSave:["x","filter"],gradFunc:(r,t,n)=>{const{dilations:i,strides:a,pad:o,dimRoundingMode:u}=n,h=i??[1,1];Z(Yu(h),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${h}'`);const[f,p]=t;return Z(4===f.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${f.rank}.`),Z(4===p.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${p.rank}.`),Z(f.shape[3]===p.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),Z(Na(a,h),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${h}'.`),va("depthwiseConv2d",o,u),{x:()=>zg(f.shape,r,p,a,o,h,u),filter:()=>Ug(f,r,p.shape,a,o,h,u)}}},Cx={kernelName:Ao,inputsToSave:["x","filter"],gradFunc:(r,t,n)=>{const[i,a]=t,o={x:i,filter:a,dy:r},u={x:i,filter:a,dy:r};return{x:()=>Kt.runKernel(hl,o,n),filter:()=>Kt.runKernel(dl,u,n)}}},xy={kernelName:yo,outputsToSave:[!0],gradFunc:(r,t)=>{const[n]=t,i={dy:r,y:n};return{x:()=>Kt.runKernel(Pl,i)}}},Ix={kernelName:Wo,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t,i=ae(No(Ji(Oi(n))),2/Math.sqrt(Math.PI));return{x:()=>ae(r,i)}}},Sx={kernelName:xh,outputsToSave:[!0],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(r,n)}}},sA={kernelName:vo,inputsToSave:["input"],gradFunc:(r,t)=>{const[n]=t;return{input:()=>le(r,n.shape)}}},Mx={kernelName:qi,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(r,No(n))}}},Tx={kernelName:ac,gradFunc:r=>({x:()=>zr(r)})},_x={kernelName:Ii,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t,a=Nr(n.shape,i.shape);return{a:()=>{const o=qn(r,yn(i,"float32")),u=Os(n.shape,a);return u.length>0?le(Vn(o,u),n.shape):o},b:()=>{let o=ae(r,yn(n,"float32"));const u=Os(i.shape,a);u.length>0&&(o=le(Vn(o,u),i.shape));const h=Oi(i);return Ji(qn(o,yn(h,"float32")))}}}},wy={kernelName:zc,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,n)=>{const{varianceEpsilon:i}=n,[a,o,u,h]=t,f=h??Jn(1),p=Os(o.shape,a.shape),m=[];if(1===o.rank){for(let L=0;L<a.shape.length-1;++L)m.push(a.shape[L]);m.push(1)}const y=zn(a,o),b=ae(r,f),T=Cc(an(u,Jn(i))),R=ae(ae(ae(T,T),T),Jn(-.5));return{x:()=>le(ae(ae(r,1===o.rank?xo(le(T,[1,1,1,o.shape[0]]),m):T),f),a.shape),mean:()=>{let L=ae(ae(T,Jn(-1)),b);return 1===o.rank&&(L=Vn(L,p)),le(L,o.shape)},variance:()=>{let L=ae(ae(R,y),b);return 1===o.rank&&(L=Vn(L,p)),le(L,o.shape)},scale:()=>{const L=ae(y,T);let V=ae(r,L);return 1===o.rank&&(V=Vn(V,p)),le(V,o.shape)},offset:()=>{let L=r;return 1===o.rank&&(L=Vn(L,p)),le(L,o.shape)}}}},kx={kernelName:$c,inputsToSave:["x","indices"],gradFunc:(r,t,n)=>{const[i,a]=t,{axis:o}=n,u=lr(o,i.shape)[0];return{x:()=>{const h=i.shape,f=a.size,p=h.slice(0,u),m=p.length,y=h.slice(o,h.length).slice(1),b=y.length,T=wv(0,m),R=wv(m+1,m+1+b),L=Ev([p,[f],y]),V=le(r,L),j=le(a,[f]),H=Ev([[m],T,R]),nt=qr(V,H);let dt=Tp(nt,j,i.shape[u]);const yt=Jh(H);return dt=qr(dt,yt),dt},indices:()=>a}}};function wv(r,t){const n=[];for(let i=r;i<t;++i)n.push(i);return n}function Ev(r){const t=[];for(let n=0;n<r.length;++n)for(let i=0;i<r[n].length;++i)t.push(r[n][i]);return t}const Rx={kernelName:Id,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t;return{a:()=>zr(n),b:()=>zr(i)}}},aA={kernelName:Sd,gradFunc:r=>({x:()=>yn(r,"float32")})},dm={kernelName:Md,gradFunc:r=>({x:()=>zr(r)})},Bx={kernelName:Td,gradFunc:r=>({x:()=>zr(r)})},Nx={kernelName:_d,gradFunc:r=>({x:()=>zr(r)})},Dx={kernelName:Kp,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,{alpha:a}=n,o=ia(i,0);return{x:()=>Us(o,r,ae(r,a))}}},Lx={kernelName:Rd,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>qn(r,an(n,1))}}},Fx={kernelName:kd,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>qn(r,yn(n,"float32"))}}},Ox={kernelName:XA,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,n)=>{const[i]=t,{axis:a}=n;return{logits:()=>{const o=No(i);return zn(r,ae(Vn(r,a,!0),o))}}}},Px=Jt({localResponseNormalizationBackprop_:function(r,t,n,i=5,a=1,o=1,u=.5){return Kt.runKernel(tf,{x:r,y:t,dy:n},{depthRadius:i,bias:a,alpha:o,beta:u})}}),Ux={kernelName:Eh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{const[i,a]=t,{depthRadius:o,bias:u,alpha:h,beta:f}=n;return{x:()=>Px(i,a,r,o,u,h,f)}}};function Cv(r,t,n,i){return t.rank<n.rank&&(t=le(t,Ni(t.shape,i))),r.rank<n.rank&&(r=le(r,Ni(r.shape,i))),{x:()=>ae(r,yn(Bo(n,t),r.dtype))}}const pm={kernelName:Dd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{const i=n,{reductionIndices:a}=i,o=t[0],u=Cv(r,t[1],o,lr(a,o.shape));return{x:()=>u.x()}}},zx={kernelName:Ch,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t;return{a:()=>ae(r,yn(wo(n,i),"float32")),b:()=>ae(r,yn(xc(n,i),"float32"))}}},$x=Jt({maxPool3dGrad_:function(r,t,n,i,a,o,u){const h=Bt(r,"dy","maxPool3dGrad"),f=Bt(t,"input","maxPool3dGrad"),p=Bt(n,"output","maxPool3dGrad");let m=h,y=f,b=p,T=!1;4===f.rank&&(T=!0,m=le(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]]),y=le(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]]),b=le(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),Z(5===m.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${m.rank}.`),Z(5===y.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${y.rank}.`),Z(5===b.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${b.rank}.`),va("maxPool3dGrad",o,u);const V=Kt.runKernel(zm,{dy:m,input:y,output:b},{filterSize:i,strides:a,pad:o,dimRoundingMode:u});return T?le(V,[V.shape[1],V.shape[2],V.shape[3],V.shape[4]]):V}}),fm={kernelName:ef,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{const[i,a]=t,{filterSize:o,strides:u,pad:h,dimRoundingMode:f}=n;return{x:()=>$x(r,i,a,o,u,h,f)}}},Iv=Jt({maxPoolGrad_:function(r,t,n,i,a,o,u){const h=Bt(r,"dy","maxPoolGrad"),f=Bt(t,"input","maxPoolGrad"),p=Bt(n,"output","maxPoolGrad");return Z(f.rank===h.rank,()=>`Rank of input (${f.rank}) does not match rank of dy (${h.rank})`),Z(4===h.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${h.rank}.`),Z(4===f.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${f.rank}.`),va("maxPoolGrad",o,u),Kt.runKernel(Du,{dy:h,input:f,output:p},{filterSize:i,strides:a,pad:o,dimRoundingMode:u})}}),Sv={kernelName:Ki,inputsToSave:["x"],gradFunc:(r,t,n)=>{const i=t[0],{paddings:a}=n,o=a.map(u=>u[0]);return{x:()=>Gr(r,o,i.shape)}}},Mv={kernelName:Vi,gradFunc:(r,t,n)=>{const{blockShape:i,paddings:a}=n;return{x:()=>vc(r,i,a)}}},Tv={kernelName:li,gradFunc:(r,t,n)=>{const{axis:i}=n;return{x:()=>ti(r,i)}}},Vx=[tA,ox,gv,lx,cx,Av,yv,ux,hx,dx,vv,eA,px,Rs,fx,Vs,rA,mx,gx,Ax,xv,iA,yx,vy,bx,xx,by,wx,Ex,Cx,{kernelName:Ho,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t,a=Nr(n.shape,i.shape);return{a:()=>{const o=qn(r,yn(i,"float32")),u=Os(n.shape,a);return u.length>0?le(Vn(o,u),n.shape):o},b:()=>{let o=ae(r,yn(n,"float32"));const u=Os(i.shape,a);u.length>0&&(o=le(Vn(o,u),i.shape));const h=Oi(i);return Ji(qn(o,yn(h,"float32")))}}}},xy,Ix,Sx,sA,Mx,_x,Tx,wy,kx,Rx,aA,dm,Bx,Nx,Dx,Lx,Fx,Ox,Ux,pm,pm,zx,fm,{kernelName:Ld,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{const[i,a]=t,{filterSize:o,strides:u,pad:h}=n;return{x:()=>Iv(r,i,a,o,u,h)}}},{kernelName:nf,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,{axis:a}=n,o=lr(a,i.shape),u=Wt(sa(i.shape,o)[1]);return{x:()=>{const h=i.shape.slice();o.forEach(p=>{h[p]=1});const f=le(r,h);return qn(ae(f,Ea(i.shape,"float32")),u)}}}},{kernelName:rf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,n)=>{const i=n,{axis:a}=i,[o,u]=t,h=Cv(r,u,o,lr(a,o.shape));return{x:()=>h.x()}}},{kernelName:Fd,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t;return{a:()=>ae(r,yn(Cl(n,i),"float32")),b:()=>ae(r,yn(ia(n,i),"float32"))}}},{kernelName:sf,inputsToSave:["x"],gradFunc:(r,t,n)=>{const i=t[0],{paddings:a}=n,o=a.map(u=>u[0]);return{x:()=>Gr(r,o,i.shape)}}},{kernelName:Od,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t,a=Nr(n.shape,i.shape);return{a:()=>{const o=Os(n.shape,a);return o.length>0?le(Vn(r,o),n.shape):r},b:()=>{const o=ae(r,Ji(mp(qn(n,i)))),u=Os(i.shape,a);return u.length>0?le(Vn(o,u),i.shape):o}}}},{kernelName:Lu,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t,a=Nr(n.shape,i.shape);return{a:()=>{const o=ae(r,yn(i,"float32")),u=Os(n.shape,a);return u.length>0?le(Vn(o,u),n.shape):o},b:()=>{const o=ae(r,yn(n,"float32")),u=Os(i.shape,a);return u.length>0?le(Vn(o,u),i.shape):o}}}},{kernelName:ko,gradFunc:r=>({x:()=>Ji(r)})},{kernelName:oc,inputsToSave:["indices"],gradFunc:(r,t)=>{const n=t[0];return{indices:()=>$s(n.shape,"float32")}}},{kernelName:zl,gradFunc:r=>({x:()=>zr(r)})},{kernelName:Ua,saveAllInputs:!0,gradFunc:(r,t,n)=>{const{axis:i}=n;return oo(r,i).map(a=>()=>a)}},Sv,Sv,{kernelName:lc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{const[n,i,a]=t,o=n,u=i,h=Nr(o.shape,u.shape);return{a:()=>{const f=yn(u,"float32");let p=ae(r,ae(f,lu(o,zn(f,Jn(1)))));const m=Os(o.shape,h);return m.length>0&&(p=Vn(p,m)),le(p,o.shape)},b:()=>{const f=ia(o,0),p=Us(f,Ga(o),zr(o));let m=ae(r,ae(a,p));const y=Os(u.shape,h);return y.length>0&&(m=Vn(m,y)),le(m,u.shape)}}}},{kernelName:ma,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{const[n,i]=t,a=ia(n,0);return{x:()=>Us(a,r,ae(r,i)),alpha:()=>{let o=Us(a,zr(r),ae(r,n));const u=Os(i.shape,r.shape);return u.length>0&&(o=Vn(o,u)),le(o,i.shape)}}}},{kernelName:yr,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>qn(r,Ji(Oi(n)))}}},{kernelName:Ih,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t,i=ae(Cl(n,6),rd(n));return{x:()=>ae(r,yn(i,"float32"))}}},{kernelName:Ou,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(r,yn(rd(n),"float32"))}}},{kernelName:Pd,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>le(r,n.shape)}}},{kernelName:Qc,inputsToSave:["images"],gradFunc:(r,t,n)=>{const[i]=t,a={dy:r,images:i};return{images:()=>Kt.runKernel(lf,a,n)}}},{kernelName:of,inputsToSave:["images"],gradFunc:(r,t,n)=>{const[i]=t,a={dy:r,images:i};return{images:()=>Kt.runKernel(Gc,a,n)}}},{kernelName:Ud,gradFunc:(r,t,n)=>{const{dims:i}=n,a=lr(i,r.shape);return{x:()=>Qa(r,a)}}},{kernelName:Sh,gradFunc:r=>({x:()=>zr(r)})},{kernelName:Mh,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>Ji(qn(r,ae(lu(n,1.5),2)))}}},{kernelName:cf,inputsToSave:["condition"],gradFunc:(r,t)=>{const[n]=t;return{condition:()=>yn(zr(n),"float32"),t:()=>ae(r,yn(n,r.dtype)),e:()=>ae(r,yn(Ap(n),r.dtype))}}},{kernelName:Jr,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>{const i=ia(n,Jn(0)),a=Jn(_c),o=Jn(Xg),u=ae(r,o),h=ae(ae(r,a),No(yn(n,"float32")));return Us(i,u,h)}}}},{kernelName:zd,outputsToSave:[!0],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(r,ae(n,zn(Jn(1),n)))}}},{kernelName:_h,gradFunc:r=>({x:()=>zr(r)})},{kernelName:Pu,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(Ju(yn(n,"float32")),r)}}},{kernelName:$l,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(fp(yn(n,"float32")),r)}}},{kernelName:cc,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,{begin:a,size:o}=n,u=i.shape,[h,f]=og(i,a,o),p=[];for(let m=0;m<r.rank;m++)p.push([h[m],u[m]-h[m]-f[m]]);return{x:()=>wc(r,p)}}},{kernelName:$d,outputsToSave:[!0],gradFunc:(r,t,n)=>{const[i]=t,{dim:a}=n,o=ae(r,i);return{logits:()=>zn(o,ae(Vn(o,[a],!0),i))}}},{kernelName:fl,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(r,ba(n))}}},Mv,Mv,Tv,Tv,{kernelName:Uu,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>qn(r,ae(Ba(yn(n,"float32")),2))}}},{kernelName:_s,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t,a=Jn(2);return{a:()=>ae(r,ae(a,zn(n,i))),b:()=>ae(r,ae(a,zn(i,n)))}}},{kernelName:Dt,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(r,ae(yn(n,"float32"),2))}}},{kernelName:Al,gradFunc:r=>({x:()=>zr(r)})},{kernelName:eo,inputsToSave:["a","b"],gradFunc:(r,t)=>{const[n,i]=t,a=Nr(n.shape,i.shape);return{a:()=>{let o=r;const u=Os(n.shape,a);return u.length>0&&(o=Vn(o,u)),le(o,n.shape)},b:()=>{let o=r;const u=Os(i.shape,a);return u.length>0&&(o=Vn(o,u)),le(Ji(o),i.shape)}}}},{kernelName:uf,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,a=i.shape.slice(),{axis:o}=n;lr(o,i.shape).forEach(f=>{a[f]=1});const u=le(r,a),h=ae(u,Ea(i.shape,"float32"));return{x:()=>h}}},{kernelName:Hc,inputsToSave:["x"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>qn(r,Oi(Ju(n)))}}},{kernelName:Vl,outputsToSave:[!0],gradFunc:(r,t)=>{const[n]=t;return{x:()=>ae(zn(Jn(1),Oi(n)),r)}}},{kernelName:Gl,inputsToSave:["x"],gradFunc:(r,t,n)=>{const[i]=t,{reps:a}=n;return{x:()=>{let o=zr(i);if(1===i.rank)for(let u=0;u<a[0];++u)o=an(o,Gr(r,[u*i.shape[0]],[i.shape[0]]));else if(2===i.rank)for(let u=0;u<a[0];++u)for(let h=0;h<a[1];++h)o=an(o,Gr(r,[u*i.shape[0],h*i.shape[1]],[i.shape[0],i.shape[1]]));else if(3===i.rank)for(let u=0;u<a[0];++u)for(let h=0;h<a[1];++h)for(let f=0;f<a[2];++f)o=an(o,Gr(r,[u*i.shape[0],h*i.shape[1],f*i.shape[2]],[i.shape[0],i.shape[1],i.shape[2]]));else{if(4!==i.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${i.rank} tensors yet.`);for(let u=0;u<a[0];++u)for(let h=0;h<a[1];++h)for(let f=0;f<a[2];++f)for(let p=0;p<a[3];++p)o=an(o,Gr(r,[u*i.shape[0],h*i.shape[1],f*i.shape[2],p*i.shape[3]],[i.shape[0],i.shape[1],i.shape[2],i.shape[3]]))}return o}}}},{kernelName:gl,gradFunc:(r,t,n)=>{const i=n,{perm:a}=i,o=Jh(a);return{x:()=>qr(r,o)}}},{kernelName:jc,gradFunc:(r,t,n)=>{const i=n,{axis:a}=i;return{value:()=>Co(r,a)}}},{kernelName:zu,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{const[n]=t;return{x:()=>function(i,a){const o=Ac(a,zr(a)),u=Kh(i,o);let h=wo(a,Jn(0,"int32"));const f=u.rank-h.rank;for(let m=0;m<f;++m)h=xa(h,m+1);h=wa(h,Ea(u.shape,"bool"));const p=zr(u);return Us(h,u,p)}(r,n)}}},{kernelName:$u,gradFunc:r=>({x:()=>zr(r)})}];for(const r of Vx)Yn(r);let Ey;function aa(){return null==Ey&&(Ey=L1().epsilon()),Ey}Re().prototype.abs=function(){return this.throwIfDisposed(),Ps(this)},Re().prototype.acos=function(){return this.throwIfDisposed(),w0(this)},Re().prototype.acosh=function(){return this.throwIfDisposed(),E0(this)},Re().prototype.add=function(r){return this.throwIfDisposed(),an(this,r)},Re().prototype.all=function(r,t){return this.throwIfDisposed(),Ag(this,r,t)},Re().prototype.any=function(r,t){return this.throwIfDisposed(),Wh(this,r,t)},Re().prototype.argMax=function(r){return this.throwIfDisposed(),cu(this,r)},Re().prototype.argMin=function(r){return this.throwIfDisposed(),I0(this,r)},Re().prototype.asScalar=function(){return this.throwIfDisposed(),Z(1===this.size,()=>"The array must have only 1 element."),le(this,[])},Re().prototype.asType=function(r){return this.throwIfDisposed(),yn(this,r)},Re().prototype.as1D=function(){return this.throwIfDisposed(),le(this,[this.size])},Re().prototype.as2D=function(r,t){return this.throwIfDisposed(),le(this,[r,t])},Re().prototype.as3D=function(r,t,n){return this.throwIfDisposed(),le(this,[r,t,n])},Re().prototype.as4D=function(r,t,n,i){return this.throwIfDisposed(),le(this,[r,t,n,i])},Re().prototype.as5D=function(r,t,n,i,a){return this.throwIfDisposed(),le(this,[r,t,n,i,a])},Re().prototype.asin=function(){return this.throwIfDisposed(),S0(this)},Re().prototype.asinh=function(){return this.throwIfDisposed(),M0(this)},Re().prototype.atan=function(){return this.throwIfDisposed(),yg(this)},Re().prototype.atan2=function(r){return this.throwIfDisposed(),tl(this,r)},Re().prototype.atanh=function(){return this.throwIfDisposed(),Mf(this)},Re().prototype.avgPool=function(r,t,n,i){return this.throwIfDisposed(),up(this,r,t,n,i)},Re().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),vc(this,r,t)},Re().prototype.batchNorm=function(r,t,n,i,a){return this.throwIfDisposed(),Kl(this,r,t,n,i,a)},Re().prototype.broadcastTo=function(r){return this.throwIfDisposed(),hu(this,r)},Re().prototype.cast=function(r){return this.throwIfDisposed(),yn(this,r)},Re().prototype.ceil=function(){return this.throwIfDisposed(),bg(this)},Re().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),Va(this,r,t)},Re().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof Zr&&(r=[r]),ti([this,...r],t)},Re().prototype.conv1d=function(r,t,n,i,a,o){return this.throwIfDisposed(),Bf(this,r,t,n,i,a,o)},Re().prototype.conv2dTranspose=function(r,t,n,i,a){return this.throwIfDisposed(),Nf(this,r,t,n,i,a)},Re().prototype.conv2d=function(r,t,n,i,a,o){return this.throwIfDisposed(),bc(this,r,t,n,i,a,o)},Re().prototype.cos=function(){return this.throwIfDisposed(),Ju(this)},Re().prototype.cosh=function(){return this.throwIfDisposed(),fp(this)},Re().prototype.cumsum=function(r,t,n){return this.throwIfDisposed(),Df(this,r,t,n)},Re().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),Lf(this,r,t)},Re().prototype.depthwiseConv2d=function(r,t,n,i,a,o){return this.throwIfDisposed(),du(this,r,t,n,i,a,o)},Re().prototype.dilation2d=function(r,t,n,i,a){return this.throwIfDisposed(),Cg(this,r,t,n,i,a)},Re().prototype.divNoNan=function(r){return this.throwIfDisposed(),Jl(this,r)},Re().prototype.div=function(r){return this.throwIfDisposed(),qn(this,r)},Re().prototype.dot=function(r){return this.throwIfDisposed(),Xh(this,r)},Re().prototype.elu=function(){return this.throwIfDisposed(),fu(this)},Re().prototype.equal=function(r){return this.throwIfDisposed(),Bo(this,r)},Re().prototype.erf=function(){return this.throwIfDisposed(),Ig(this)},Re().prototype.exp=function(){return this.throwIfDisposed(),No(this)},Re().prototype.expandDims=function(r){return this.throwIfDisposed(),xa(this,r)},Re().prototype.expm1=function(){return this.throwIfDisposed(),Yh(this)},Re().prototype.fft=function(){return this.throwIfDisposed(),Kf(this)},Re().prototype.flatten=function(){return this.throwIfDisposed(),le(this,[this.size])},Re().prototype.floor=function(){return this.throwIfDisposed(),mp(this)},Re().prototype.floorDiv=function(r){return this.throwIfDisposed(),hg(this,r)},Re().prototype.gather=function(r,t){return this.throwIfDisposed(),Kh(this,r,t)},Re().prototype.greaterEqual=function(r){return this.throwIfDisposed(),wo(this,r)},Re().prototype.greater=function(r){return this.throwIfDisposed(),ia(this,r)},Re().prototype.ifft=function(){return this.throwIfDisposed(),Hi(this)},Re().prototype.irfft=function(){return this.throwIfDisposed(),ed(this)},Re().prototype.isFinite=function(){return this.throwIfDisposed(),z1(this)},Re().prototype.isInf=function(){return this.throwIfDisposed(),L0(this)},Re().prototype.isNaN=function(){return this.throwIfDisposed(),Of(this)},Re().prototype.leakyRelu=function(r){return this.throwIfDisposed(),Zu(this,r)},Re().prototype.lessEqual=function(r){return this.throwIfDisposed(),Cl(this,r)},Re().prototype.less=function(r){return this.throwIfDisposed(),xc(this,r)},Re().prototype.localResponseNormalization=function(r,t,n,i){return this.throwIfDisposed(),Da(this,r,t,n,i)},Re().prototype.logSigmoid=function(){return this.throwIfDisposed(),Uf(this)},Re().prototype.logSoftmax=function(r){return this.throwIfDisposed(),th(this,r)},Re().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),zf(this,r,t)},Re().prototype.log=function(){return this.throwIfDisposed(),Ga(this)},Re().prototype.log1p=function(){return this.throwIfDisposed(),Pf(this)},Re().prototype.logicalAnd=function(r){return this.throwIfDisposed(),wa(this,r)},Re().prototype.logicalNot=function(){return this.throwIfDisposed(),Ap(this)},Re().prototype.logicalOr=function(r){return this.throwIfDisposed(),yp(this,r)},Re().prototype.logicalXor=function(r){return this.throwIfDisposed(),$f(this,r)},Re().prototype.matMul=function(r,t,n){return this.throwIfDisposed(),Or(this,r,t,n)},Re().prototype.maxPool=function(r,t,n,i){return this.throwIfDisposed(),eh(this,r,t,n,i)},Re().prototype.max=function(r,t){return this.throwIfDisposed(),Eo(this,r,t)},Re().prototype.maximum=function(r){return this.throwIfDisposed(),Ac(this,r)},Re().prototype.mean=function(r,t){return this.throwIfDisposed(),fs(this,r,t)},Re().prototype.min=function(r,t){return this.throwIfDisposed(),vp(this,r,t)},Re().prototype.minimum=function(r){return this.throwIfDisposed(),bp(this,r)},Re().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),nl(this,r,t)},Re().prototype.mod=function(r){return this.throwIfDisposed(),xp(this,r)},Re().prototype.mul=function(r){return this.throwIfDisposed(),ae(this,r)},Re().prototype.neg=function(){return this.throwIfDisposed(),Ji(this)},Re().prototype.norm=function(r,t,n){return this.throwIfDisposed(),tm(this,r,t,n)},Re().prototype.notEqual=function(r){return this.throwIfDisposed(),mu(this,r)},Re().prototype.oneHot=function(r,t=1,n=0){return this.throwIfDisposed(),zh(this,r,t,n)},Re().prototype.onesLike=function(){return this.throwIfDisposed(),so(this)},Re().prototype.pad=function(r,t){return this.throwIfDisposed(),wc(this,r,t)},Re().prototype.pool=function(r,t,n,i,a,o){return this.throwIfDisposed(),Tg(this,r,t,n,i,a,o)},Re().prototype.pow=function(r){return this.throwIfDisposed(),lu(this,r)},Re().prototype.prelu=function(r){return this.throwIfDisposed(),Ep(this,r)},Re().prototype.prod=function(r,t){return this.throwIfDisposed(),Cp(this,r,t)},Re().prototype.reciprocal=function(){return this.throwIfDisposed(),Ec(this)},Re().prototype.relu=function(){return this.throwIfDisposed(),Do(this)},Re().prototype.relu6=function(){return this.throwIfDisposed(),Zh(this)},Re().prototype.reshapeAs=function(r){return this.throwIfDisposed(),le(this,r.shape)},Re().prototype.reshape=function(r){return this.throwIfDisposed(),le(this,r)},Re().prototype.resizeBilinear=function(r,t,n){return this.throwIfDisposed(),Z1(this,r,t,n)},Re().prototype.resizeNearestNeighbor=function(r,t,n){return this.throwIfDisposed(),Np(this,r,t,n)},Re().prototype.reverse=function(r){return this.throwIfDisposed(),Qa(this,r)},Re().prototype.rfft=function(){return this.throwIfDisposed(),ah(this)},Re().prototype.round=function(){return this.throwIfDisposed(),Xf(this)},Re().prototype.rsqrt=function(){return this.throwIfDisposed(),Cc(this)},Re().prototype.selu=function(){return this.throwIfDisposed(),sh(this)},Re().prototype.separableConv2d=function(r,t,n,i,a,o){return this.throwIfDisposed(),V0(this,r,t,n,i,a,o)},Re().prototype.sigmoid=function(){return this.throwIfDisposed(),ba(this)},Re().prototype.sign=function(){return this.throwIfDisposed(),G0(this)},Re().prototype.sin=function(){return this.throwIfDisposed(),kg(this)},Re().prototype.sinh=function(){return this.throwIfDisposed(),Rg(this)},Re().prototype.slice=function(r,t){return this.throwIfDisposed(),Gr(this,r,t)},Re().prototype.softmax=function(r){return this.throwIfDisposed(),Ic(this,r)},Re().prototype.softplus=function(){return this.throwIfDisposed(),ls(this)},Re().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),wp(this,r,t)},Re().prototype.split=function(r,t){return this.throwIfDisposed(),ao(this,r,t)},Re().prototype.sqrt=function(){return this.throwIfDisposed(),Ba(this)},Re().prototype.square=function(){return this.throwIfDisposed(),Oi(this)},Re().prototype.squaredDifference=function(r){return this.throwIfDisposed(),nd(this,r)},Re().prototype.squeeze=function(r){return this.throwIfDisposed(),Lo(this,r)},Re().prototype.stack=function(r,t){this.throwIfDisposed();const n=r instanceof Zr?[this,r]:[this,...r];return Co(n,t)},Re().prototype.step=function(r){return this.throwIfDisposed(),rd(this,r)},Re().prototype.stridedSlice=function(r,t,n,i,a,o,u,h){return this.throwIfDisposed(),id(this,r,t,n,i,a,o,u,h)},Re().prototype.sub=function(r){return this.throwIfDisposed(),zn(this,r)},Re().prototype.sum=function(r,t){return this.throwIfDisposed(),Vn(this,r,t)},Re().prototype.tan=function(){return this.throwIfDisposed(),Jf(this)},Re().prototype.tanh=function(){return this.throwIfDisposed(),El(this)},Re().prototype.tile=function(r){return this.throwIfDisposed(),xo(this,r)},Re().prototype.toBool=function(){return this.throwIfDisposed(),yn(this,"bool")},Re().prototype.toFloat=function(){return this.throwIfDisposed(),yn(this,"float32")},Re().prototype.toInt=function(){return this.throwIfDisposed(),yn(this,"int32")},Re().prototype.topk=function(r,t){return this.throwIfDisposed(),Mp(this,r,t)},Re().prototype.transpose=function(r){return this.throwIfDisposed(),qr(this,r)},Re().prototype.unique=function(r){return this.throwIfDisposed(),sd(this,r)},Re().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),Tp(this,r,t)},Re().prototype.unstack=function(r){return this.throwIfDisposed(),oo(this,r)},Re().prototype.where=function(r,t){return this.throwIfDisposed(),Us(r,this,t)},Re().prototype.zerosLike=function(){return this.throwIfDisposed(),zr(this)};class kc extends Error{constructor(t){super(t),Object.setPrototypeOf(this,kc.prototype)}}class Sl extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Sl.prototype)}}class he extends Error{constructor(t){super(t),Object.setPrototypeOf(this,he.prototype)}}class Lr extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Lr.prototype)}}class Cy extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Cy.prototype)}}function hd(r,t){if(Array.isArray(r)){let n=[];for(let i=0;i<t;i++)n=n.concat(r);return n}{const n=new Array(t);return n.fill(r),n}}function Rc(r,t){if(!r)throw new Cy(t)}function _v(r,t){let n=0;for(const i of r)i===t&&n++;return n}function Io(r){return 1===r.length?r[0]:r}function Zi(r){return Array.isArray(r)?r:[r]}function Eu(r){const t=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function dd(r){return r.length<=1||-1===r.indexOf("_")?r:r.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}let Ml={};function Iy(r){if(null==r)return null;const t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function Sy(r){if(null!=r&&"object"==typeof r)if(Array.isArray(r))r.forEach(t=>Sy(t));else{const t=Object.keys(r);for(const n of t){const i=r[n];null!=i&&"object"==typeof i&&(Array.isArray(i)||"ndarray"!==i.type||"number"!=typeof i.value?Sy(i):r[n]=i.value)}}}function mm(r,t={},n={},i="object",a=!1){if("string"==typeof r){let u;if(r in n)u=n[r];else if(r in Ml)u=Ml[r];else if(u=t[r],null==u)throw new he(`Unknown ${i}: ${r}. This may be due to one of the following reasons:\n1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return u}{const o=r;if(null==o.className||null==o.config)throw new he(`${i}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const u=o.className;let h,f;if(u in n?[h,f]=n[u]:u in Ml?[h,f]=Ml.className:u in t&&([h,f]=t[u]),null==h)throw new he(`Unknown ${i}: ${u}. This may be due to one of the following reasons:\n1. The ${i} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${i} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=f){const p={};for(const b of Object.keys(Ml))p[b]=Ml[b];for(const b of Object.keys(n))p[b]=n[b];o.config.customObjects=p;const m=Object.assign({},Ml);for(const b of Object.keys(n))Ml[b]=n[b];Sy(o.config);const y=f(h,o.config,n,a);return Ml=Object.assign({},m),y}{const p=Object.assign({},Ml);for(const y of Object.keys(n))Ml[y]=n[y];const m=new h(o.config);return Ml=Object.assign({},p),m}}}function oA(r,t){return-1*((n=r)<(i=t)?-1:n>i?1:0);var n,i}function hh(r){if(null==r)return r;const t=[];for(const n of r)-1===t.indexOf(n)&&t.push(n);return t}function kv(r){if(null==r)throw new he(`Invalid value in obj: ${JSON.stringify(r)}`);for(const t in r)if(r.hasOwnProperty(t))return!1;return!0}function pd(r,t,n){if(null!=n&&r.indexOf(n)<0)throw new he(`${n} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function My(r,t,n=0,i=1/0){return Rc(n>=0),Rc(i>=n),Array.isArray(r)&&r.length>=n&&r.length<=i&&r.every(a=>typeof a===t)}function Ia(r,t){Array.isArray(r)?(Z(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((n,i)=>Ia(n,`element ${i+1} of ${t}`))):Z(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${Rv(r)}.`)}function Rv(r){return null===r?"null":Array.isArray(r)?"["+r.map(t=>Rv(t)).join(",")+"]":"string"==typeof r?`"${r}"`:`${r}`}function Ty(r){return"relu"===r?"relu":"linear"===r?"linear":"elu"===r?"elu":null}function _y(r,t){return me(()=>Ba(Vn(ae(r,r),t,!0)))}class gm extends Hh{getConfig(){return{}}}class Oo extends gm{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return me(()=>{const n=_y(t,this.axis),i=Va(n,0,this.maxValue);return ae(t,qn(i,an(aa(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Oo.className="MaxNorm",on(Oo);class dh extends gm{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return me(()=>qn(t,an(aa(),_y(t,this.axis))))}getConfig(){return{axis:this.axis}}}dh.className="UnitNorm",on(dh);class lA extends gm{apply(t){return Do(t)}}lA.className="NonNeg",on(lA);class cA extends gm{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return me(()=>{const n=_y(t,this.axis),i=an(ae(this.rate,Va(n,this.minValue,this.maxValue)),ae(1-this.rate,n));return ae(t,qn(i,an(aa(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}cA.className="MinMaxNorm",on(cA);const uA={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Bs(r){return Iy(r)}function Cu(r,t={}){return mm(r,Zo.getMap().classNameMap,t,"constraint")}function oa(r){return null==r?null:"string"==typeof r?Cu({className:r in uA?uA[r]:r,config:{}}):r instanceof gm?r:Cu(r)}function fd(r){return new Oo(r)}function ph(r){return new dh(r)}function Gx(){return new lA}function Qx(r){return new cA(r)}const ky=["channelsFirst","channelsLast"],Ry=["nearest","bilinear"],Hx=["valid","same","causal"],Wx=["max","avg"],Bv=["sum","mul","concat","ave"],Pp=new Map;function Ns(r){pd(ky,"DataFormat",r)}function al(r){pd(Hx,"PaddingMode",r)}function Up(r){pd(Wx,"PoolMode",r)}const Sa=[];function fh(r,t){Sa.push(r);try{const n=t();return Sa.pop(),n}catch(n){throw Sa.pop(),n}}function Nv(r){if(!dA(r))throw new Error("Not a valid tensor name: '"+r+"'");return(0===Sa.length?"":Sa.join("/")+"/")+r}function hA(r){if(!dA(r))throw new Error("Not a valid tensor name: '"+r+"'");Pp.has(r)||Pp.set(r,0);const t=Pp.get(r);if(Pp.set(r,Pp.get(r)+1),t>0){const n=`${r}_${t}`;return Pp.set(n,1),n}return r}const Iu=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function dA(r){return!!r.match(Iu)}function Bc(r,t,n){null==t&&(t=0),null==n&&(n=r.length);let i=1;for(let a=t;a<n;++a)i*=r[a];return i}function zp(r){if(0===r.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<r.length;n++){const i=r[n];i<t&&(t=i)}return t}function Su(r){if(0===r.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<r.length;n++){const i=r[n];i>t&&(t=i)}return t}function ol(r,t){if(t<r)throw new he(`end (${t}) < begin (${r}) is forbidden.`);const n=[];for(let i=r;i<t;++i)n.push(i);return n}function $p(r,t){return yn(r,t)}function md(r,t=-1){const n=r.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),le(r,n)}function lo(r,t,n){return me(()=>{switch(r.rank){case 1:return Bg(r,t,n);case 2:return Q0(r,[t,0],[n,r.shape[1]]);case 3:return Sp(r,[t,0,0],[n,r.shape[1],r.shape[2]]);case 4:return Yf(r,[t,0,0,0],[n,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Gr(r,[t,0,0,0,0],[n,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Gr(r,[t,0,0,0,0,0],[n,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new he(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function By(r,t,n){return me(()=>{switch(r.rank){case 1:return Bg(r,t,n);case 2:return Q0(r,[0,t],[r.shape[0],n]);case 3:return Sp(r,[0,0,t],[r.shape[0],r.shape[1],n]);case 4:return Yf(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],n]);default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Vp(r,t,n,i){return me(()=>{switch(r.rank){case 1:return Bg(r,t,n);case 2:switch(i){case 1:return lo(r,t,n);case 2:return By(r,t,n);default:throw new he(`The axis is not within the rank of the tensor ${i}`)}case 3:switch(i){case 1:return lo(r,t,n);case 2:return Sp(r,[0,t,0],[r.shape[0],n,r.shape[2]]);case 3:return By(r,t,n);default:throw new he(`The axis is not within the rank of the tensor ${i}`)}case 4:switch(i){case 1:return lo(r,t,n);case 2:return Yf(r,[0,t,0,0],[r.shape[0],n,r.shape[2],r.shape[3]]);case 3:return Yf(r,[0,0,t,0],[r.shape[0],r.shape[1],n,r.shape[3]]);case 4:return By(r,t,n);default:throw new he(`The axis is not within the rank of the tensor ${i}`)}default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Am(r,t=-1){let n;return t<0&&(n=r[0].rank,t=0!==n?n:0),t===r[0].rank&&(t=-1),ti(r,t)}function Ny(r,t){switch(r.rank){case 1:return k0([r,t]);case 2:return R0([r,t],0);case 3:return kf([r,t],0);case 4:return Rf([r,t],0);default:throw new he(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function ei(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new he(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return xo(r,t)}function fi(r,t=0,n=1,i,a){return qf(r,t,n,i,a)}function Si(r,t,n,i){if(r.rank<2||t.rank<2)throw new Lr(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3&&r.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Lr(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`);if(2===r.rank&&2===t.rank)return Au({a:r,b:t,transposeA:!1,transposeB:!1,bias:i?Mu(r.rank,i,"channelsLast"):null,activation:n});{const a=r.shape.slice(),o=a.pop();r=le(r,[-1,o]);const u=t.shape.slice(),h=u.pop(),f=u.pop(),p=[...u,h],m=Array.from({length:t.rank},(b,T)=>0===T?t.rank-2:T<=t.rank-2?T-1:T);t=le(qr(t,m),[f,-1]);const y=[...a,...p];return le(Au({a:r,b:t,transposeA:!1,transposeB:!1,bias:i?Mu(r.rank,i,"channelsLast"):null,activation:n}),y)}}function Fr(r,t,n){return me(()=>(t=Array.isArray(t)?Yi(t,"int32"):yn(t,"int32"),Kh(r,t,n)))}function Pi(r){return ae(r,r)}function Mu(r,t,n){const i=t.shape;if(1!==t.rank&&t.rank!==r)throw new he(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(5===r){if("channelsFirst"===n)return le(t,1===i.length?[1,i[0],1,1,1]:[1,i[3],i[0],i[1],i[2]]);if("channelsLast"===n)return le(t,1===i.length?[1,1,1,1,i[0]]:[1].concat(i))}else if(4===r){if("channelsFirst"===n)return le(t,1===i.length?[1,i[0],1,1]:[1,i[2],i[0],i[1]]);if("channelsLast"===n)return le(t,1===i.length?[1,1,1,i[0]]:[1].concat(i))}else if(3===r){if("channelsFirst"===n)return le(t,1===i.length?[1,i[0],1]:[1,i[1],i[0]]);if("channelsLast"===n)return le(t,1===i.length?[1,1,i[0]]:[1].concat(i))}else if(r<3)return t;throw new he(`Unsupported input rank by biasAdd: ${t.rank}`)}function Wa(r,t,n){return me(()=>(null==n&&(n="channelsLast"),Ns(n),an(r,Mu(r.rank,t,n))))}function mh(r,t,n,i){return me(()=>rl(r,t,n,i))}function bs(r,t,n=!1){return n?r():t()}const Dv=["fanIn","fanOut","fanAvg"],Lv=["normal","uniform","truncatedNormal"];class Ds extends Hh{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class pA extends Ds{apply(t,n){return $s(t,n)}}pA.className="Zeros",on(pA);class gd extends Ds{apply(t,n){return Ea(t,n)}}gd.className="Ones",on(gd);class fA extends Ds{constructor(t){if(super(),"object"!=typeof t)throw new he(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new he(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return me(()=>ae(Jn(this.value),Ea(t,n)))}getConfig(){return{value:this.value}}}fA.className="Constant",on(fA);class mA extends Ds{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return gu(t,this.minval,this.maxval,n)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}mA.className="RandomUniform",on(mA);class gA extends Ds{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if("float32"!==(n=n||"float32")&&"int32"!==n)throw new Lr(`randomNormal does not support dType ${n}.`);return fi(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}gA.className="RandomNormal",on(gA);class Dy extends Ds{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if("float32"!==(n=n||"float32")&&"int32"!==n)throw new Lr(`truncatedNormal does not support dType ${n}.`);return lh(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Dy.className="TruncatedNormal",on(Dy);class Ly extends Ds{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,n){return me(()=>{if(2!==t.length||t[0]!==t[1])throw new he("Identity matrix initializer can only be used for 2D square matrices.");return ae(this.gain,D0(t[0]))})}getConfig(){return{gain:this.gain}}}Ly.className="Identity",on(Ly);class So extends Ds{constructor(t){if(super(),t.scale<0)throw new he(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,pd(Dv,"FanMode",this.mode),this.distribution=null==t.distribution?"normal":t.distribution,pd(Lv,"Distribution",this.distribution),this.seed=t.seed}apply(t,n){const i=function(h,f="channelsLast"){let p,m;if(Ns(f),2===h.length)p=h[0],m=h[1];else if(-1!==[3,4,5].indexOf(h.length)){if("channelsFirst"===f){const y=Bc(h,2);p=h[1]*y,m=h[0]*y}else if("channelsLast"===f){const y=Bc(h,0,h.length-2);p=h[h.length-2]*y,m=h[h.length-1]*y}}else{const y=Bc(h);p=Math.sqrt(y),m=Math.sqrt(y)}return[p,m]}(t),a=i[0],o=i[1];let u=this.scale;if(u/="fanIn"===this.mode?Math.max(1,a):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(a+o)/2),"normal"===this.distribution){const h=Math.sqrt(u);if("float32"!==(n=n||"float32")&&"int32"!==n)throw new Lr(`${this.getClassName()} does not support dType ${n}.`);return lh(t,0,h,n,this.seed)}{const h=Math.sqrt(3*u);return gu(t,-h,h,n)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}So.className="VarianceScaling",on(So);class AA extends So{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return So.className}}AA.className="GlorotUniform",on(AA);class yA extends So{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return So.className}}yA.className="GlorotNormal",on(yA);class ym extends So{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return So.className}}ym.className="HeNormal",on(ym);class vm extends So{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return So.className}}vm.className="HeUniform",on(vm);class Gp extends So{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return So.className}}Gp.className="LeCunNormal",on(Gp);class bm extends So{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return So.className}}bm.className="LeCunNormal",on(bm);class vA extends Ds{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new Lr("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,n){return me(()=>{if(t.length<2)throw new Lr("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const i=fi(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let a=iv.gramSchmidt(i);return t[0]>t[1]&&(a=qr(a)),ae(this.gain,a)})}getConfig(){return{gain:this.gain,seed:this.seed}}}vA.className="Orthogonal",on(vA);const ll={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function xm(r,t={}){return mm(r,Zo.getMap().classNameMap,t,"initializer")}function ms(r){return Iy(r)}function cs(r){if("string"==typeof r){const t=r in ll?ll[r]:r;if("GlorotNormal"===t)return new yA;if("GlorotUniform"===t)return new AA;if("HeNormal"===t)return new ym;if("HeUniform"===t)return new vm;if("LeCunNormal"===t)return new Gp;if("LeCunUniform"===t)return new bm;{const n={};return n.className=t,n.config={},xm(n)}}return r instanceof Ds?r:xm(r)}function Fv(){return new pA}function Tu(){return new gd}function jx(r){return new fA(r)}function A(r){return new mA(r)}function e(r){return new gA(r)}function s(r){return new Dy(r)}function l(r){return new Ly(r)}function c(r){return new So(r)}function d(r){return new AA(r)}function g(r){return new yA(r)}function v(r){return new ym(r)}function x(r){return new vm(r)}function w(r){return new Gp(r)}function S(r){return new bm(r)}function P(r){return new vA(r)}let z=0;function W(){return z++}const Y={};function tt(r=""){return r in Y||(Y[r]=0),Y[r]+=1,r+Y[r].toString()}function J(r){return Array.isArray(r)&&Array.isArray(r[0])}function at(r){return 0===r.length?[]:Array.isArray(r[0])?r:[r]}function it(r){let t;if(Array.isArray(r)){if(1!==r.length)throw new he(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function ct(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(1===r.length)return r[0];throw new he(`Expected exactly 1 Shape; got ${r.length}`)}return r}function At(r){let t=0;for(const n of r)t+=0===n.shape.length?1:n.shape.reduce((i,a)=>i*a);return t}class Ft{constructor(t,n="float32",i="Variable",a=!0,o=null){this.dtype=n??"float32",this.shape=t.shape,this.id=W(),this.originalName=Nv(i=i??"Variable"),this.name=hA(this.originalName),this.trainable_=a,this.constraint=o,this.val=Zf(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(n,i){if(n.shape.toString()!==i.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(i.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Tt(r){return r.map(t=>t.read())}function Pt(r){r.forEach(t=>{t[0].write(t[1])})}class zt{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class ee{constructor(t,n,i,a,o,u,h){this.dtype=t,this.shape=n,this.sourceLayer=i,this.inputs=a,this.callArgs=o,this.outputTensorIndex=h,this.id=W(),null!=u&&(this.originalName=Nv(u),this.name=hA(this.originalName)),this.rank=n.length}}let ce=0;class ne{constructor(t,n){this.callArgs=n,this.id=ce++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const i of t.inboundLayers)i?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers)t.push(null!=n?n.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ge=0;class ie extends Hh{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ge++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){const i=this.getClassName();n=Eu(i)+"_"+tt(i)}if(this.name=n,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let i;if(null!=t.batchInputShape)i=t.batchInputShape;else if(null!=t.inputShape){let o=null;null!=t.batchSize&&(o=t.batchSize),i=[o].concat(t.inputShape)}this.batchInputShape=i;let a=t.dtype;null==a&&(a=t.inputDType),null==a&&(a="float32"),this.dtype=a}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(0===this.inboundNodes.length)throw new Sl(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=t)throw new he(`Asked to get ${n} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Io(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Io(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new kc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new kc(`Layer ${this.name} is not connected, no input to return.`);return Io(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new kc(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new kc(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Io(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(n=>n.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Zi(t),null==this.inputSpec||0===this.inputSpec.length)return;const n=Zi(this.inputSpec);if(t.length!==n.length)throw new he(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let i=0;i<t.length;i++){const a=t[i],o=n[i];if(null==o)continue;const u=a.rank;if(null!=o.ndim&&u!==o.ndim)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${u}`);if(null!=o.maxNDim&&u>o.maxNDim)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${u}`);if(null!=o.minNDim&&u<o.minNDim)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${u}.`);if(null!=o.dtype&&a.dtype!==o.dtype)throw new he(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${a.dtype}.`);if(o.axes){const h=a.shape;for(const f in o.axes){const p=Number(f),m=o.axes[f];if(null!=m&&-1===[m,null].indexOf(p>=0?h[p]:h[h.length+p]))throw new he(`Input ${i} is incompatible with layer ${this.name}: expected axis ${p} of input shape to have value ${m} but got shape ${h}.`)}}if(null!=o.shape)for(let h=0;h<o.shape.length;++h){const f=o.shape[h],p=a.shape[h];if(null!=f&&null!=p&&f!==p)throw new he(`Input ${i} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${a.shape}.`)}}}call(t,n){return t}invokeCallHook(t,n){null!=this._callHook&&this._callHook(t,n)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{},this.assertNotDisposed();const i=Zi(t);let a=!0;for(const u of i)if(!(u instanceof ee)){a=!1;break}let o=!0;for(const u of i)if(u instanceof ee){o=!1;break}if(a===o)throw new he("Arguments to apply() must be all SymbolicTensors or all Tensors");return fh(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const u=[];for(const h of Zi(t))u.push(h.shape);this.build(Io(u)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let u=this.call(t,n);const h=Zi(u),f=[];for(let p of h)-1!==i.indexOf(p)&&(p=p.clone()),f.push(p);if(u=Io(f),null!=this.activityRegularizer)throw new Lr("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}{const u=function(m){m=Zi(m);const y=[];for(const b of m)y.push(b.shape);return Io(y)}(t),h=this.computeOutputShape(u);let f;const p="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?u[0]:u),f=null!=h&&h.length>0&&Array.isArray(h[0])?h.map((m,y)=>new ee(p,m,this,Zi(t),n,this.name,y)):new ee(p,h,this,Zi(t),n,this.name),this.addInboundNode(t,f,null,null,u,h,n),this._refCount++,null!=this.activityRegularizer)throw new Lr("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return f}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((i,a)=>{null!=i&&null!=t[a]&&t[a]!==i&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new kc(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const n of this.inboundNodes){const i=JSON.stringify(n.outputShapes);-1===t.indexOf(i)&&t.push(i)}if(1===t.length){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&1===n.length?n[0]:n}throw new kc(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Sl(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return At(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Tt(t?this.trainableWeights:this.weights)}setWeights(t){me(()=>{const n=this.weights;if(n.length!==t.length)throw new he(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${n.length} weights. Provided weights: ${t}...`);if(0===n.length)return;const i=[],a=Tt(n);for(let o=0;o<a.length;++o){const u=a[o],h=n[o],f=t[o];if(!We(u.shape,f.shape))throw new he(`Layer weight shape ${u.shape} not compatible with provided weight shape ${f.shape}`);i.push([h,f])}Pt(i)})}addWeight(t,n,i,a,o,u,h,f){if(-1!==this._addedWeightNames.indexOf(t))throw new he(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==i&&(i="float32"),this.fastWeightInitDuringBuild&&(a=null!=f?f():cs("zeros"));const p=a.apply(n,i),m=new Ft(p,i,t,u,h);return p.dispose(),null!=o&&this.addLoss(()=>o.apply(m.read())),null==u&&(u=!0),u?this._trainableWeights.push(m):this._nonTrainableWeights.push(m),m}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=Zi(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(null!=n){if(!Array.isArray(n))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);n.forEach(i=>{if(null!=i)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return n}addInboundNode(t,n,i,a,o,u,h=null){const f=Zi(t);n=Zi(n),i=Zi(i),a=Zi(a),o=at(o),u=at(u);const p=[],m=[],y=[];for(const b of f)p.push(b.sourceLayer),m.push(b.nodeIndex),y.push(b.tensorIndex);new ne({outboundLayer:this,inboundLayers:p,nodeIndices:m,tensorIndices:y,inputTensors:f,outputTensors:n,inputMasks:i,outputMasks:a,inputShapes:o,outputShapes:u},h);for(let b=0;b<n.length;b++)n[b].sourceLayer=this,n[b].nodeIndex=this.inboundNodes.length-1,n[b].tensorIndex=b}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function pe(r,t,n){if((null==t||null!=n&&n>0)&&(t=r.sourceLayer,n=r.nodeIndex),0===t.inboundNodes.length)return[r];{const i=t.inboundNodes[n];if(0===i.inboundLayers.length)return i.inputTensors;{const a=[];for(let o=0;o<i.inboundLayers.length;o++){const u=pe(i.inputTensors[o],i.inboundLayers[o],i.nodeIndices[o]);for(const h of u)-1===a.indexOf(h)&&a.push(h)}return a}}}class Oe extends ie{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:tt("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new he("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(null==n){if(null==t.inputShape)throw new he("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new he("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const i=t.dtype||"float32";this.batchInputShape=n,this.dtype=i,this.inputSpec=[{shape:n}];const a=new ee(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new ne({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new he(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function Pe(r){if(null==r.batchShape&&null==r.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=r.batchShape&&null!=r.shape)throw new he("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;null!=r.shape&&null==t&&(t=[null].concat(r.shape));let n=r.dtype;return null==n&&(n="float32"),new Oe({batchInputShape:t,name:r.name,dtype:n,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}async function ze(r){if(null==r)return;const t=[],n=[],i=[];for(const a in r){const o=r[a];if("number"!=typeof o){const u=o;t.push(u.data()),n.push(a),i.push(u)}}if(t.length>0){const a=await Promise.all(t);for(let o=0;o<a.length;++o)r[n[o]]=a[o][0];Dr(i)}}function Fe(r){if(null!=r)for(const t in r){const n=r[t];"number"!=typeof n&&n.dispose()}}var Dn;Oe.className="InputLayer",on(Oe),function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"}(Dn||(Dn={}));class Nn{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class fn{constructor(t,n=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){null==n&&(n={});for(const i of this.callbacks)await i.onEpochBegin(t,n)}async onEpochEnd(t,n){null==n&&(n={});for(const i of this.callbacks)await i.onEpochEnd(t,n)}async onBatchBegin(t,n){null==n&&(n={});for(const i of this.callbacks)await i.onBatchBegin(t,n)}async onBatchEnd(t,n){null==n&&(n={});for(const i of this.callbacks)await i.onBatchEnd(t,n)}async onTrainBegin(t){null==t&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class xn extends Nn{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){null==n&&(n={});const i=null==n.size?0:n.size;this.seen+=i;for(const a in n){const o=n[a];if("number"==typeof o)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+o*i;else{let u;a in this.totals?u=this.totals[a]:this.totals[a]=0;const h=me(()=>an(this.totals[a],ae(o,i)));this.totals[a]=h,u?.dispose()}}}async onEpochEnd(t,n){if(null!=n)for(const i of this.params.metrics)null!=this.totals[i]&&("number"==typeof this.totals[i]?n[i]=this.totals[i]/this.seen:me(()=>{const a=ae(qn(1,this.seen),this.totals[i]);n[i]=a,this.totals[i].dispose(),ya(n[i])}))}}class In extends Nn{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){null==n&&(n={}),this.epoch.push(t);for(const i in n)null==this.history[i]&&(this.history[i]=[]),this.history[i].push(n[i])}async syncData(){const t=[],n=[],i=[];for(const o in this.history){const u=this.history[o];for(let h=0;h<u.length;++h)"number"!=typeof u[h]&&(t.push(u[h].data()),n.push(o),i.push(h))}const a=await Promise.all(t);for(let o=0;o<a.length;++o)this.history[n[o]][i[o]].dispose(),this.history[n[o]][i[o]]=a[o][0]}}class Mn extends Nn{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Wg,this.yieldEvery=n||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Sn(this.yieldEvery)&&(this.maybeWait=function(i,a,o){let u,h=null!=o?o():ga();return(...f)=>{const p=null!=o?o():ga();return p-h<a||(h=p,u=i(...f)),u}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,i){const a=[];null!=this.yield&&(await ze(i),a.push(this.yield(t,n,i))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(t,n){this.currentEpoch=t,null!=this.epochBegin&&(await ze(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const i=[];null!=this.epochEnd&&(await ze(n),i.push(this.epochEnd(t,n))),"epoch"===this.yieldEvery&&i.push(this.nextFrameFunc()),await Promise.all(i)}async onBatchBegin(t,n){null!=this.batchBegin&&(await ze(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const i=[];null!=this.batchEnd&&(await ze(n),i.push(this.batchEnd(t,n))),"batch"===this.yieldEvery?i.push(this.nextFrameFunc()):Sn(this.yieldEvery)&&i.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(i)}async onTrainBegin(t){null!=this.trainBegin&&(await ze(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await ze(t),await this.trainEnd(t))}}function Ce(r,t){return null==r&&(r={}),r instanceof Nn?[r]:Array.isArray(r)&&r[0]instanceof Nn?r:Zi(r).map(n=>new Mn(n,t))}class rn{constructor(){}static registerCallbackConstructor(t,n){Z(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),rn.checkForDuplicate(n),null==rn.constructors[t]&&(rn.constructors[t]=[]),rn.constructors[t].push(n)}static checkForDuplicate(t){for(const n in rn.constructors)rn.constructors[+n].forEach(i=>{if(i===t)throw new he("Duplicate callback constructor.")})}static clear(){rn.constructors={}}static createCallbacks(t){const n=[];for(const i in rn.constructors){const a=+i;t>=a&&n.push(...rn.constructors[a])}return n.map(i=>new i)}}function On(r,t,n,i,a,o,u,h,f){const p=new In,m=[new xn,...rn.createCallbacks(t)];null!=r&&m.push(...r),m.push(p);const y=new fn(m);return y.setParams({epochs:n,initialEpoch:i,samples:a,steps:o,batchSize:u,verbose:t,doValidation:h,metrics:f}),{callbackList:y,history:p}}function ln(r,t={},n=!1){return mm(r,Zo.getMap().classNameMap,t,"layer",n)}function Lt(r,t){return me(()=>{"float32"!==r.dtype&&(r=yn(r,"float32"));const n=Vn(Pi(r),t,!0),i=op(n.shape,aa()),a=Ba(Ac(n,i));return qn(r,a)})}function St(r,t){return me(()=>fs(Pi(zn(t,r)),-1))}function Et(r,t){return me(()=>fs(Ps(zn(t,r)),-1))}function re(r,t){return me(()=>{const n=zn(r,t),i=Va(Ps(r),aa(),Number.MAX_VALUE),a=Ps(qn(n,i));return ae(100,fs(a,-1))})}function $t(r,t,n=!1){return me(()=>{if(n)t=Ic(t);else{const i=Vn(t,t.shape.length-1,!0);t=qn(t,i)}return t=Va(t,aa(),1-aa()),Ji(Vn(ae(yn(r,"float32"),Ga(t)),t.shape.length-1))})}function oe(r,t,n=!1){return me(()=>{const i=yn(mp(function(o){const u=[Bc(o.shape)];return le(o,u)}(r)),"int32"),a=(t=Va(t,aa(),1-aa())).shape;return $t(le(zh(i,a[a.length-1]),a),t,n)})}function fe(r,t){return me(()=>{let n;return n=Va(t,aa(),1-aa()),n=Ga(qn(n,zn(1,n))),fs(function(i,a){if(!We(i.shape,a.shape))throw new he(`logits and labels must have the same shape, but got shapes ${JSON.stringify(i.shape)} and ${JSON.stringify(a.shape)}`);return me(()=>{const o=Do(a),u=Ji(Ps(a));return an(zn(o,ae(a,i)),Pf(No(u)))})}(r,n),-1)})}function ye(r,t){return me(()=>{const n=Lt(r,-1),i=Lt(t,-1),a=ae(n,i);return Ji(Vn(a,-1))})}rn.constructors={};const Xe={meanSquaredError:St,meanAbsoluteError:Et,meanAbsolutePercentageError:re,meanSquaredLogarithmicError:function(r,t){return me(()=>{const n=Va(t,aa(),Number.MAX_VALUE),i=Ga(an(1,n)),a=Va(r,aa(),Number.MAX_VALUE),o=Ga(an(1,a));return fs(Pi(zn(i,o)),-1)})},squaredHinge:function(r,t){return me(()=>{const n=Ac(0,zn(1,ae(r,t)));return fs(Pi(n),-1)})},hinge:function(r,t){return me(()=>{const n=Ac(0,zn(1,ae(r,t)));return fs(n,-1)})},categoricalHinge:function(r,t){return me(()=>{const n=Vn(ae(r,t),-1),i=Eo(ae(zn(1,r),t),-1);return Ac(0,an(1,zn(i,n)))})},logcosh:function(r,t){return me(()=>{const n=Math.log(2),i=zn(t,r),a=zn(an(i,ls(ae(-2,i))),n);return fs(a,-1)})},categoricalCrossentropy:$t,sparseCategoricalCrossentropy:oe,binaryCrossentropy:fe,kullbackLeiblerDivergence:function(r,t){return me(()=>{const n=Va(r,aa(),1),i=Va(t,aa(),1);return Vn(ae(r,Ga(qn(n,i))),-1)})},poisson:function(r,t){return me(()=>{const n=Ga(an(aa(),t));return fs(zn(t,ae(r,n)),-1)})},cosineProximity:ye};function Fn(r){if("string"==typeof r){if(r in Xe)return Xe[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new he(t)}return r}function An(r,t){return me(()=>{const n=ae(.5,so(t)),i=$p(ia(t,n),r.dtype);return fs(Bo(r,i),-1)})}function Un(r,t){return me(()=>$p(Bo(cu(r,-1),cu(t,-1)),"float32"))}function ar(r,t){return me(()=>yn(Vn(wa(Bo(r,1),Bo(t,1))),"float32"))}function $n(r,t){return me(()=>{const n=ar(r,t),i=(o=r,u=t,me(()=>yn(Vn(wa(Bo(o,0),Bo(u,1))),"float32"))),a=an(n,i);var o,u;return yn(Us(ia(a,0),qn(n,a),0),"float32")})}function sr(r,t){return fe(r,t)}function Xr(r,t){return r.rank===t.rank&&(r=Lo(r,[r.rank-1])),(t=cu(t,-1)).dtype!==r.dtype&&(t=yn(t,r.dtype)),yn(Bo(r,t),"float32")}const Ir=$t,kr=oe,Qr={binaryAccuracy:An,categoricalAccuracy:Un,precision:$n,categoricalCrossentropy:Ir,sparseCategoricalCrossentropy:kr,mse:St,MSE:St,mae:Et,MAE:Et,mape:re,MAPE:re,cosine:ye};function Ui(r){if("string"==typeof r&&r in Qr)return Qr[r];if("string"!=typeof r&&null!=r)return r;throw new he(`Unknown metric ${r}`)}function Zn(r){if(Rc(null!==r,`Unknown LossOrMetricFn ${r}`),"string"==typeof r)return r;{let t;for(const n of Object.keys(Xe))if(Xe[n]===r){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(Qr))if(Qr[n]===r){t=n;break}return void 0!==t?t:r.name}}function ts(r,t,n=!1){if(null==r||"object"!=typeof r||Object.getPrototypeOf(r)!==Object.prototype||!Gs(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const i=JSON.stringify(r);i.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${i.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Gs(r){if(null===r)return!0;if("object"==typeof r){if(Object.getPrototypeOf(r)===Object.prototype){const t=Object.keys(r);for(const n of t)if("string"!=typeof n||!Gs(r[n]))return!1;return!0}if(Array.isArray(r)){for(const t of r)if(!Gs(t))return!1;return!0}return!1}{const t=typeof r;return"string"===t||"number"===t||"boolean"===t}}function rc(r,t,n=console.log){let i="";for(let a=0;a<r.length;++a)a>0&&(i=i.slice(0,i.length-1)+" "),i+=r[a],i=i.slice(0,t[a]),i+=" ".repeat(t[a]-i.length);n(i)}function or(r,t,n){let i;try{i=JSON.stringify(r.outputShape)}catch{i="multiple"}rc([`${r.name} (${r.getClassName()})`,i,r.countParams().toString()],t,n)}function zi(r,t,n,i){let a;try{a=JSON.stringify(r.outputShape)}catch{a="multiple"}const o=[];for(const p of r.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(p)))for(let m=0;m<p.inboundLayers.length;++m)o.push(`${p.inboundLayers[m].name}[${p.nodeIndices[m]}][${p.tensorIndices[m]}]`);const u=r.name,h=r.getClassName(),f=0===o.length?"":o[0];rc([`${u} (${h})`,a,r.countParams().toString(),f],t,i);for(let p=1;p<o.length;++p)rc(["","","",o[p]],t,i)}function Di(r,t,n){return("inboundNodes"===r||"outputLayers"===r||"inputLayers"===r)&&0===t&&"string"==typeof n}function Ue(r,t){if(null===r)return null;if("string"==typeof r)return dd(r);if("number"==typeof r||"boolean"==typeof r)return r;if(r instanceof Array){const n=[],i=r.length;for(let a=0;a<i;++a){const o=r[a];Di(t,a,o)?n.push(o):n.push(Ue(o,t))}return n}{const n={};for(const i of Object.keys(r)){const a=r[i];if("name"===i&&"string"==typeof a)n[i]=a;else{const o=dd(i);n[o]=Ue(a,o)}}return n}}function Ad(r,t){if(null==r)return null;if("string"==typeof r)return Eu(r);if("number"==typeof r||"boolean"==typeof r)return r;if(r instanceof Array){const n=[],i=r.length;for(let a=0;a<i;++a){const o=r[a];Di(t,a,o)?n.push(o):n.push(Ad(o,t))}return n}{const n={};for(const i of Object.keys(r)){const a=r[i];n[Eu(i)]="name"!==i&&"className"!==i||"string"!=typeof a?Ad(a,i):a}return n}}const Nc="3.13.0";class Mi{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Mi)for(const n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(null==t)return;for(const n of t)this.add(n.key,n.value)}}add(t,n,i){if(null!=this.id2Value[t.id])throw new he(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(a,o){if(null==a.dtype||a.dtype===o.dtype)return o;try{return yn(o,a.dtype)}catch{throw new he(`The dtype of the feed (${o.dtype}) can not be cast to the dtype of the key '${a.name}' (${a.dtype}).`)}}(t,n),this.name2Id[t.name]=t.id,null!=i&&(this.id2Mask[t.id]=i),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ee){if(null==this.id2Value[t.id])throw new he(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const n=this.name2Id[t];if(null==n)throw new he(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof ee){if(null==this.id2Value[t.id])throw new he(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const n=this.name2Id[t];if(null==n)throw new he(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){null!=this.id2Mask&&Dr(this.id2Mask)}}const bA={},Fy={};function Qp(r,t,n,i){const a=null!=n&&n.training,o=Array.isArray(r),u=o?r:[r],h=u.map(R=>R.name),f=[],p=t.names();for(const R of h)-1!==p.indexOf(R)?f.push(t.getValue(R)):f.push(null);null!=i&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);const m=h.join(",")+"|"+t.names().join(",");let y,b;if(null==bA[m]){const R=function(L,V){Z(null!=L&&L.length>0,()=>"Expected at least one fetch, got none");let j=[],H={};if(1===L.length){const nt=Oy(L[0],V);j=nt.sorted,H=nt.recipientMap}else{const nt=new Set;for(const dt of L){const{sorted:yt,recipientMap:kt}=Oy(dt,V);for(const Ot of yt)nt.has(Ot.name)||(j.push(Ot),nt.add(Ot.name));for(const Ot in kt)null==H[Ot]&&(H[Ot]=new Set),kt[Ot].forEach(Nt=>H[Ot].add(Nt))}}return{sorted:j,recipientCounts:Ov(H)}}(u,t);y=R.sorted,b=R.recipientCounts,bA[m]=y,Fy[m]=b}y=bA[m],b={},a||Object.assign(b,Fy[m]);const T=new Mi(t);for(let R=0;R<y.length;++R){if(null!=i){const Vt=lg().numTensors;Vt>i.maxNumTensors&&(i.maxNumTensors=Vt),Vt<i.minNumTensors&&(i.minNumTensors=Vt)}const L=y[R],V=L.sourceLayer;if(V instanceof Oe)continue;const j=[],H=[],nt=[];let dt=!1;for(const Vt of L.inputs){const qt=T.getValue(Vt),Zt=T.getMask(Vt);j.push(qt),H.push(Zt),null!=Zt&&(dt=!0),a||(b[Vt.name]--,0!==b[Vt.name]||t.hasKey(Vt)||-1!==h.indexOf(Vt.name)||qt.isDisposed||!0===Vt.sourceLayer.stateful||nt.push(qt))}dt&&((n=n||{}).mask=H[0]);const yt=Zi(V.apply(j,n));let kt=null;V.supportsMasking&&(kt=V.computeMask(j,H));const Ot=Py(L),Nt=Array.isArray(Ot)?Ot:[Ot];for(let Vt=0;Vt<Nt.length;++Vt){T.hasKey(Nt[Vt])||T.add(Nt[Vt],yt[Vt],Array.isArray(kt)?kt[0]:kt);const qt=h.indexOf(Nt[Vt].name);-1!==qt&&(f[qt]=yt[Vt])}a||Dr(nt)}return T.disposeMasks(),o?f:f[0]}function Ov(r){const t={};for(const n in r)t[n]=r[n].size;return t}function Oy(r,t){const n=new Set,i=[],a={};for(const h of t.names())n.add(h);const o=[],u=[];for(o.push(r);o.length>0;){const h=o[o.length-1];if(n.has(h.name)){o.pop();continue}const f=u[u.length-1]===o.length-1;if(0===h.inputs.length||f)o.pop(),i.push(h),n.add(h.name),f&&u.pop();else{u.push(o.length-1);for(const p of h.inputs)null==a[p.name]&&(a[p.name]=new Set),a[p.name].add(h.name),n.has(p.name)||o.push(p)}}return{sorted:i,recipientMap:a}}function Py(r){let t;if(1===r.sourceLayer.inboundNodes.length)t=r.sourceLayer.output;else{let n=null;for(let i=0;i<r.sourceLayer.inboundNodes.length;++i)for(const a of r.sourceLayer.inboundNodes[i].outputTensors)if(a.id===r.id){n=i;break}t=r.sourceLayer.getOutputAt(n)}return t}class Tl extends ie{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const H=this.getClassName().toLowerCase();this.name=tt(H)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],hh(this.inputs).length!==this.inputs.length)throw new he(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(H=>H.name)}`);hh(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(H=>H.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const H of this.outputs){const dt=H.nodeIndex,yt=H.tensorIndex;this.outputLayers.push(H.sourceLayer),this.outputLayersNodeIndices.push(dt),this.outputLayersTensorIndices.push(yt)}for(const H of this.inputs){const nt=H.sourceLayer,dt=H.nodeIndex,yt=H.tensorIndex;Rc(0===dt,"input layer has >1 nodes"),Rc(0===yt,"input layer has >1 tensors"),this.inputLayers.push(nt),this.inputLayersNodeIndices.push(dt),this.inputLayersTensorIndices.push(yt)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let H=0;H<this.inputLayers.length;H++){const nt=this.inputLayers[H];if(!(nt instanceof Oe))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${H} (0-based) originates from layer type ${nt.getClassName()}.`);this.inputNames.push(nt.name),this.feedInputShapes.push(nt.batchInputShape),this.feedInputNames.push(nt.name)}for(const H of this.outputLayers)this.outputNames.push(H.name);this.internalInputShapes=this.inputs.map(H=>H.shape),this.internalOutputShapes=this.outputs.map(H=>H.shape);const n={},i={},a={},o={},u={},h=[],f=(H,nt,dt,yt,kt,Ot)=>{null!=yt&&null!=kt&&null!=Ot||(yt=H.sourceLayer,kt=H.nodeIndex,Ot=H.tensorIndex);const Nt=yt.inboundNodes[kt];if(-1!==dt.indexOf(Nt))throw new Sl(`The tensor ${H.name} at layer "${yt.name}" is part of a cycle.`);if(-1!==nt.indexOf(Nt))return;this.containerNodes.add(Tl.nodeKey(yt,kt)),yt.id in u||(u[yt.id]=Object.keys(u).length),-1===dt.indexOf(Nt)&&dt.push(Nt);const Vt=Nt.inboundLayers.length;for(let qt=0;qt<Vt;qt++)f(Nt.inputTensors[qt],nt,dt,Nt.inboundLayers[qt],Nt.nodeIndices[qt],Nt.tensorIndices[qt]);for(nt.push(Nt);dt.indexOf(Nt)>=0;)dt.splice(dt.indexOf(Nt),1);h.push(Nt)},p=[],m=[];for(const H of this.outputs)f(H,p,m);const y=h.slice().reverse();for(const H of y){i[H.id]=H,H.id in n||(n[H.id]=0);let nt=n[H.id];nt=Math.max(nt,null==a[H.outboundLayer.id]?0:a[H.outboundLayer.id]),a[H.outboundLayer.id]=nt,o[H.outboundLayer.id]=H.outboundLayer,n[H.id]=nt;for(let yt=0;yt<H.inboundLayers.length;yt++){const Nt=H.inboundLayers[yt].inboundNodes[H.nodeIndices[yt]];n[Nt.id]=Math.max(nt+1,null==n[Nt.id]?0:n[Nt.id]),i[Nt.id]=Nt}}const b={};for(const H in n){const nt=n[H];nt in b||(b[nt]=[]),b[nt].push(i[H])}const T={};for(const H in a){const nt=a[H];nt in T||(T[nt]=[]),T[nt].push(o[H])}let R=Object.keys(T).map(H=>parseInt(H,10)).sort(oA);this.layers=[];for(const H of R){const nt=T[H];nt.sort((dt,yt)=>{const kt=u[dt.id],Ot=u[yt.id];return kt<Ot?-1:kt>Ot?1:0});for(const dt of nt)dt instanceof Tl&&this.internalContainerRefs.push(dt),this.layers.push(dt)}this.layersByDepth=T,R=Object.keys(b).map(H=>parseInt(H,10)).sort(oA);const L=this.inputs.slice(),V=[];for(const H of R)for(const nt of b[H]){const dt=nt.outboundLayer;if(null!=dt){for(const yt of nt.inputTensors)if(-1===L.indexOf(yt))throw new Sl(`Graph disconnected: cannot obtain value for tensor ${yt} at layer "${dt.name}". The following previous layers were accessed without issue: ${V}`);for(const yt of nt.outputTensors)L.push(yt);V.push(dt.name)}}this.nodesByDepth=b;const j=this.layers.map(H=>H.name);for(const H of j){const nt=j.filter(dt=>dt===H).length;if(1!==nt)throw new Sl(`The name "${H}" is used ${nt} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(j))}this.outboundNodes=[],this.inboundNodes=[],new ne({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(H=>null),outputMasks:this.outputs.map(H=>null),inputShapes:this.inputs.map(H=>H.shape),outputShapes:this.outputs.map(H=>H.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(i=>i.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new he("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const i of this.layers)n.push(...i.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){const i={};let a=0;for(const u of this.layers)for(const h of u.weights){if(null!=i[h.originalName])throw new he(`Duplicate weight name: ${h.originalName}`);i[h.originalName]=h,a++}const o=[];for(const u in t){let h=u;if(null==i[u]){const f=u.split("/");h=f.slice(0,-2).concat([f[f.length-1]]).join("/")}if(null!=i[h])o.push([i[h],t[u]]);else if(n)throw new he(`Provided weight data has no target variable: ${u}`);delete i[h]}if(n){const u=[];for(const h in i)u.push(h);if(u.length>0)throw new he(`${u.length} of ${a} weights are not set: ${u}`)}Pt(o)}updatedConfig(){const t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${Nc}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){const i=Ad(this.updatedConfig());return n?JSON.stringify(i):i}call(t,n){return me(()=>{t=Zi(t);const i=new Mi;for(let a=0;a<this.inputs.length;++a)i.add(this.inputs[a],t[a]);return Qp(this.outputs,i,n)})}computeMask(t,n){return me(()=>{let i;return t=Zi(t),i=null==n?hd(null,t.length):Zi(n),this.runInternalGraph(t,i)[1]})}computeOutputShape(t){const n=at(t);if(n.length!==this.inputLayers.length)throw new he(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const i={};for(let h=0;h<n.length;h++)i[this.inputLayers[h].name+"_0_0"]=n[h];const a=Object.keys(this.nodesByDepth).map(h=>parseInt(h,10)).sort(oA);if(a.length>1)for(const h of a){const f=this.nodesByDepth[h];for(const p of f){const m=p.outboundLayer;if(-1!==this.inputLayers.map(R=>R.id).indexOf(m.id))continue;const y=[];for(let R=0;R<p.inboundLayers.length;R++)y.push(i[`${p.inboundLayers[R].name}_${p.nodeIndices[R]}_${p.tensorIndices[R]}`]);const b=at(m.computeOutputShape(Io(y))),T=m.inboundNodes.indexOf(p);for(let R=0;R<b.length;R++)i[`${m.name}_${T}_${R}`]=b[R]}}const o=[],u=[];for(let h=0;h<this.outputLayers.length;h++)u.push(`${this.outputLayers[h].name}_${this.outputLayersNodeIndices[h]}_${this.outputLayersTensorIndices[h]}`);for(let h=0;h<u.length;h++){const f=u[h];Rc(f in i),o.push(i[f])}return Io(o)}runInternalGraph(t,n){null==n&&(n=hd(null,t.length));const i={};for(let f=0;f<this.inputs.length;++f)i[this.inputs[f].id]=[t[f],n[f]];const a=Object.keys(this.nodesByDepth).map(f=>parseInt(f,10)).sort(oA);for(const f of a){const p=this.nodesByDepth[f];for(const m of p){const y=m.outboundLayer,b=m.inputTensors,T=m.outputTensors,R=new Array;for(const L of b)L.id in i&&R.push(i[L.id]);if(R.length===b.length){let L,V,j,H,nt={};if(null!=m.callArgs&&(nt=m.callArgs),1===R.length){const[dt,yt]=R[0];null==nt.mask&&(nt.mask=yt),j=Zi(y.call(dt,nt)),H=Zi(y.computeMask(dt,yt)),L=[dt],V=[yt]}else L=R.map(dt=>dt[0]),V=R.map(dt=>dt[1]),null==nt.mask&&(nt.mask=V),j=Zi(y.call(L,nt)),H=Zi(y.computeMask(L,V));if(y.activityRegularizer)throw new Lr("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let dt=0;dt<T.length;++dt)i[T[dt].id]=[j[dt],H[dt]]}}}const o=[],u=[],h=[];for(const f of this.outputs){Rc(f.id in i,`Could not compute output ${f.name} : ${f.id}`);const[p,m]=i[f.id];h.push(p.shape),o.push(p),u.push(m)}return[o,u,h]}buildNodeConversionMap(t){const n={};let i;for(const a of this.layers){i=a instanceof Tl?1:0;for(let o=0;o<a.inboundNodes.length;o++){const u=Tl.nodeKey(a,o);this.containerNodes.has(u)&&(n[u]=i,i+=1)}}return n}getLayer(t,n){if(null!=n){if(this.layers.length<=n)throw new he(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}if(null==t)throw new he("Provide either a layer name or layer index");for(const i of this.layers)if(i.name===t)return i;throw new he(`No such layer: ${t}`)}calculateLosses(){return me(()=>{const t=[];for(const n of this.layers)for(let i=0;i<n.inboundNodes.length;++i){const a=Tl.nodeKey(n,i);this.containerNodes.has(a)&&t.push(...n.calculateLosses())}return t})}getConfig(){const t={name:this.name},n=this.buildNodeConversionMap(this.layers),i=[];for(const u of this.layers){const h=u.getClassName(),f=u.getConfig(),p=[];for(let y=0;y<u.inboundNodes.length;y++){const b=u.inboundNodes[y],T=Tl.nodeKey(u,y);let R={};if(this.containerNodes.has(T)){if(b.callArgs)try{JSON.stringify(b.callArgs),R=b.callArgs}catch{console.warn(`Layer ${u.name} was passed non-serializable keyword arguments: ${b.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),R={}}if(b.inboundLayers.length>0){const L=[];for(let V=0;V<b.inboundLayers.length;V++){const j=b.inboundLayers[V],nt=b.tensorIndices[V];let dt=n[Tl.nodeKey(j,b.nodeIndices[V])];null==dt&&(dt=0),L.push([j.name,dt,nt,R])}p.push(L)}}}const m={};m.name=u.name,m.className=h,m.config=f,m.inboundNodes=p,i.push(m)}t.layers=i;const a=[];for(let u=0;u<this.inputLayers.length;u++){const h=this.inputLayers[u],p=Tl.nodeKey(h,this.inputLayersNodeIndices[u]);if(!this.containerNodes.has(p))continue;let m=n[p];null==m&&(m=0),a.push([h.name,m,this.inputLayersTensorIndices[u]])}t.inputLayers=a;const o=[];for(let u=0;u<this.outputLayers.length;u++){const h=this.outputLayers[u],p=Tl.nodeKey(h,this.outputLayersNodeIndices[u]);if(!this.containerNodes.has(p))continue;let m=n[p];null==m&&(m=0),o.push([h.name,m,this.outputLayersTensorIndices[u]])}return t.outputLayers=o,t}static fromConfig(t,n,i={},a=!1){const o={},u={};function h(V,j){V.name in u?u[V.name].push(j):u[V.name]=[j]}function f(V,j){const H=[];let nt;for(const dt of j){const yt=dt[0],kt=dt[1],Ot=dt[2];if(nt=null==dt[3]?{}:dt[3],!(yt in o))return void h(V,j);const Nt=o[yt];if(Nt.inboundNodes.length<=kt)return void h(V,j);H.push(Nt.inboundNodes[kt].outputTensors[Ot])}H.length>0&&V.apply(Io(H),nt)}function p(V){const j=V.name,H=ln(V,null!=n.customObjects?n.customObjects:{});H.setFastWeightInitDuringBuild(a),o[j]=H,V.inboundNodes.forEach(nt=>{if(!(nt instanceof Array))throw new he(`Corrupted configuration, expected array for nodeData: ${nt}`);h(H,nt)})}const m=n.name,y=n.layers;for(const V of y)p(V);for(;!kv(u);)for(const V of y){const j=o[V.name];if(j.name in u){const H=u[j.name];delete u[j.name];for(const nt of H)f(j,nt)}}const b=[],T=[],R=n.inputLayers;for(const V of R){const j=V[0],H=V[1],nt=V[2];Rc(j in o),b.push(o[j].inboundNodes[H].outputTensors[nt])}const L=n.outputLayers;for(const V of L){const j=V[0],H=V[1],nt=V[2];Rc(j in o),T.push(o[j].inboundNodes[H].outputTensors[nt])}return new t({inputs:b,outputs:T,name:m})}get stateful(){if(this._stateful)throw new he("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){me(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Uy(r,t){return function(n,i,a){const o=i.length;if(null==n||Array.isArray(n)&&0===n.length)return i.map(u=>null);if(1===o)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&i[0]in n?[n[i[0]]]:[n];if(Array.isArray(n)){if(n.length!==o)throw new Error(`Provided ${a} is an array of ${n.length} element(s), but the model has ${o} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const u=[];return i.forEach(h=>{u.push(h in n?n[h]:null)}),u}throw new Error(`The model has multiple (${o}) outputs, so ${a} must be either an array with ${o} elements or an object with ${i} keys. Provided ${a} not understood: ${JSON.stringify(n)}`)}(r,t,"classWeight")}async function gh(r,t,n,i){if(null!=t||null!=i)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const a=me(()=>{if(1===r.shape.length)return ru(r);if(2===r.shape.length){if(r.shape[1]>1)return cu(r,1);if(1===r.shape[1])return le(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await a.data());Dr(a);const u=[];return o.forEach(h=>{if(null==n[h])throw new Error(`classWeight must contain all classes in the training data. The class ${h} exists in the data but not in classWeight`);u.push(n[h])}),Yi(u,"float32")}return null}function Pv(r,t){return ae(r,t)}function xA(r,t){let n,i;n=t.xs,i=t.ys,Z(null!=n&&null!=i,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const o=zy("input",r.inputNames,n),u=zy("output",r.outputNames,i),h=o[0].shape[0];Z(o.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),Z(u.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${u.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let f=0;f<o.length;f++)Z(o[f].shape[0]===h,()=>`Batch size mismatch: input ${r.inputNames[f]} has ${o[f].shape[0]}; expected  ${h} based on input ${r.inputNames[0]}.`);for(let f=0;f<u.length;f++)Z(u[f].shape[0]===h,()=>`Batch size mismatch: output ${r.outputNames[f]} has ${u[f].shape[0]}; expected  ${h} based on input ${r.inputNames[0]}.`);return{xs:o,ys:u}}function zy(r,t,n){if(n instanceof Zr)return[n];if(Array.isArray(n))return Z(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),n;{const i=[];for(const a of t){if(null==n[a])throw new he(`The feature data generated by the dataset lacks the required ${r} key '${a}'.`);i.push(n[a])}return i}}function wm(r){return"function"==typeof r.iterator}function wA(r){Z(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function Ah(r,t,n){return null==r?[null]:Array.isArray(r)?r.map(i=>lo(i,t,n-t)):lo(r,t,n-t)}function EA(r,t){return me(()=>null==r?null:Array.isArray(r)?r.map(n=>EA(n,t)):Fr(r,"int32"===t.dtype?t:yn(t,"int32")))}function CA(r,t){const n=[];let i=0,a=null;for(;i<r;)a=i+t,a>=r&&(a=r),n.push([i,a]),i=a;return n}function IA(r){const t=[];r instanceof Zr&&(r=[r]);for(let n=0;n<r.length;++n){const i=r[n];if(1===i.rank)t.push(md(i,1));else{if(0===i.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(i)}}return t}function Qt(r,t){if(null==r)return;const n=[];if(t instanceof Zr)n.push(t.id);else if(Array.isArray(t))t.forEach(a=>n.push(a.id));else if(null!=t)for(const a in t)n.push(t[a].id);const i=[];if(r instanceof Zr)-1===n.indexOf(r.id)&&i.push(r);else if(Array.isArray(r))r.forEach(a=>{-1===n.indexOf(a.id)&&i.push(a)});else if(null!=r)for(const a in r){const o=r[a];-1===n.indexOf(o.id)&&i.push(o)}i.forEach(a=>{a.isDisposed||a.dispose()})}function Se(r){return Array.isArray(r)}function Ve(r){return!(r instanceof Zr||Se(r))}function Ke(r,t,n,i=!0,a=""){if(null==t||0===t.length){if(null!=r){let u=!1;if(Se(r)&&r.length>0)u=!0;else if(Ve(r)){for(const h in r)if(r.hasOwnProperty(h)){u=!0;break}}else u=!0;if(u)throw new he(`Error when checking model ${a} expected no data, but got ${r}`)}return[]}if(null==r)return t.map(u=>null);let o;if(Ve(r)){o=[];for(const u of t){if(null==r[u])throw new he(`No data provided for "${u}". Need data for each key in: ${t}`);o.push(r[u])}}else if(Se(r)){if(r.length!==t.length)throw new he(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);o=r}else{if(t.length>1)throw new he(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);o=[r]}if(o=IA(o),null!=n)for(let u=0;u<t.length;++u){if(null==n[u])continue;const h=o[u];if(h.shape.length!==n[u].length)throw new he(`Error when checking ${a}: expected ${t[u]} to have ${n[u].length} dimension(s). but got array with shape ${h.shape}`);for(let f=0;f<n[u].length;++f){if(0===f&&!i)continue;const m=n[u][f];if(null!=m&&m>=0&&h.shape[f]!==m)throw new he(`${a} expected a batch of elements where each example has shape [${n[u].slice(1,n[u].length)}] (i.e.,tensor shape [*,${n[u].slice(1,n[u].length)}]) but the ${a} received an input with ${h.shape[0]} examples, each with shape [${h.shape.slice(1,h.shape.length)}] (tensor shape [${h.shape}])`)}}return o}function Qe(r,t,n,i=!0,a=""){let o;if(Array.isArray(r)){if(r.length!==t.length)throw new he(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);o=r}else{if(t.length>1)throw new he(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);o=[r]}if(null!=n)for(let u=0;u<t.length;++u){if(null==n[u])continue;const h=o[u];if(h.shape.length!==n[u].length)throw new he(`Error when checking ${a}: expected ${t[u]} to have ${n[u].length} dimension(s), but got array with shape ${JSON.stringify(h.shape)}`);for(let f=0;f<n[u].length;++f){if(0===f&&!i)continue;const m=n[u][f];if(null!=m&&m!==h.shape[f])throw new he(`Error when checking ${a}: expected ${t[u]} to have shape ${JSON.stringify(n[u])} but got array with shape ${JSON.stringify(h.shape)}.`)}}}class Cn extends Tl{constructor(t){super(t),this.isTraining=!1}summary(t,n,i=console.log){if(!this.built)throw new he("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(a,o,u,h=console.log){const f=function(R){let L=!0;const V=[],j=[];for(const H in R.nodesByDepth)V.push(R.nodesByDepth[H]);for(const H of V){if(H.length>1||1===H.length&&H[0].inboundLayers.length>1){L=!1;break}j.push(...H)}if(L)for(const H of R.layers){let nt=!1;for(const dt of H.inboundNodes)if(-1!==j.indexOf(dt)){if(nt){L=!1;break}nt=!0}if(!L)break}return L}(a),p=["Layer (type)","Output shape","Param #"];let m;if(f?(o=o||65,u=u||[.45,.85,1]):(o=o||98,u=u||[.33,.55,.67,1]),u[u.length-1]<=1&&(u=u.map(R=>Math.floor(o*R))),!f){p.push("Receives inputs"),m=[];for(const R in a.nodesByDepth)m.push(...a.nodesByDepth[R])}h("_".repeat(o)),rc(p,u,h),h("=".repeat(o));const y=a.layers;for(let R=0;R<y.length;++R)f?or(y[R],u,h):zi(y[R],u,m,h),h((R===y.length-1?"=":"_").repeat(o));a.checkTrainableWeightsConsistency();const b=function(R){let L;return L=At(null!=R.collectedTrainableWeights?R.collectedTrainableWeights:R.trainableWeights),L}(a),T=At(a.nonTrainableWeights);h(`Total params: ${b+T}`),h(`Trainable params: ${b}`),h(`Non-trainable params: ${T}`),h("_".repeat(o))}(this,t,n,i)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(u){const h={Adagrad:()=>uh.adagrad(.01),Adadelta:()=>uh.adadelta(1,.95,aa()),Adam:()=>uh.adam(.001,.9,.999,aa()),Adamax:()=>uh.adamax(.002,.9,.999,aa(),0),RMSProp:()=>uh.rmsprop(.001,.9,0,aa()),SGD:()=>uh.sgd(.01)};if(h.adagrad=h.Adagrad,h.adadelta=h.Adadelta,h.adam=h.Adam,h.adamax=h.Adamax,h.rmsprop=h.RMSProp,h.sgd=h.SGD,u in h)return h[u]();throw new he(`Unknown Optimizer ${u}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof ou))throw new he("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let n=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new he(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);n=t.loss.map(h=>Fn(h))}else{const u=Fn(t.loss);this.outputs.forEach(h=>{n.push(u)})}else{t.loss=t.loss;for(const u in t.loss)if(-1===this.outputNames.indexOf(u))throw new he(`Unknown entry in loss dictionary: "${u}". Only expected the following keys: ${this.outputNames}`);for(const u of this.outputNames)null==t.loss[u]&&console.warn(`Output "${u}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${u} during training`),n.push(Fn(t.loss[u]))}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let u=0;u<this.outputs.length;++u){const h=this.internalOutputShapes[u];this.feedOutputNames.push(this.outputNames[u]),this.feedOutputShapes.push(h),this.feedLossFns.push(this.lossFunctions[u])}const i=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],fh("loss",()=>{for(let u=0;u<this.outputs.length;++u)-1===i.indexOf(u)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[u],u]),this.metricsNames.push(this.outputNames[u]+"_loss"))});const a=function(u,h){if(null==u||Array.isArray(u)&&0===u.length)return h.map(p=>[]);let f;if("string"==typeof u||"function"==typeof u)f=[u];else{if(!Array.isArray(u)&&"object"!=typeof u)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${u}`);f=u}if(Array.isArray(f))return h.map(p=>f);{const p=[];for(const m of h){let y=f.hasOwnProperty(m)?f[m]:[];Array.isArray(y)||(y=[y]),p.push(y)}return p}}(t.metrics,this.outputNames),o=(u,h,f)=>{this.outputNames.length>1&&(h=this.outputNames[u]+"_"+h),this.metricsNames.push(h),this.metricsTensors.push([f,u])};fh("metric",()=>{for(let u=0;u<this.outputs.length;++u)-1===i.indexOf(u)&&(h=>{let f,p,m;for(const y of h){if("string"==typeof y&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(y)){const T=this.internalOutputShapes[u];let R;1===T[T.length-1]||this.lossFunctions[u]===fe?-1!==["accuracy","acc"].indexOf(y)?p=An:-1!==["crossentropy","ce"].indexOf(y)&&(p=sr):this.lossFunctions[u]===oe?-1!==["accuracy","acc"].indexOf(y)?p=Xr:-1!==["crossentropy","ce"].indexOf(y)&&(p=kr):-1!==["accuracy","acc"].indexOf(y)?p=Un:-1!==["crossentropy","ce"].indexOf(y)&&(p=Ir),-1!==["accuracy","acc"].indexOf(y)?R="acc":-1!==["crossentropy","ce"].indexOf(y)&&(R="ce"),m=p,f=""+R}else m=Ui(y),f=""+Zn(y);let b;fh(f,()=>{b=m}),o(u,f,b)}})(a[u])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,n,i={}){const a=null==i.batchSize?32:i.batchSize;wA(a);const o=this.standardizeUserDataXY(t,n,!0,a);try{const u=o[0].concat(o[1]);return this.makeTestFunction(),Io(this.testLoop(this.testFunction,u,a,i.verbose,i.steps))}finally{Qt(o[0],t),Qt(o[1],n)}}async evaluateDataset(t,n){return this.makeTestFunction(),async function(i,a,o){const u=null!=(o=o||{}).batches,h=i.testFunction;let f=[];if(o.verbose>0)throw new Lr("Verbose mode is not implemented yet.");Z(!u||o.batches>0&&Number.isInteger(o.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(o.batches)}`);const p="function"==typeof a.next?a:await a.iterator();let m=0,y=0;for(;!u||y<o.batches;){const b=await p.next();if(f=me(()=>{if(b.value){const{xs:T,ys:R}=xA(i,b.value),L=T.concat(R),V=me(()=>h(L));if(Dr(L),0===y)for(let H=0;H<V.length;++H)f.push(Jn(0));const j=L[0].shape[0];for(let H=0;H<V.length;++H){const nt=V[H],dt=f[H];f[H]=me(()=>an(f[H],ae(j,nt))),y>0&&Dr(dt)}Dr(V),m+=j,++y}return f}),b.done){u&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${o.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let b=0;b<f.length;++b){const T=f[b];f[b]=qn(f[b],m),Dr(T)}return Io(f)}(this,t,n)}checkNumSamples(t,n,i,a="steps"){let o;if(null!=i){if(o=null,null!=n)throw new he(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else{if(null==t)throw new he(`Either the input data should have a defined shape, or ${a} shoud be specified.`);o=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return o}execute(t,n){if(Array.isArray(n)&&0===n.length)throw new he("`outputs` is an empty Array, which is not allowed.");const i=Array.isArray(n),o=this.retrieveSymbolicTensors(i?n:[n]),u=new Mi;if(t instanceof Zr&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new he(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let f=0;f<this.inputs.length;++f)u.add(this.inputs[f],t[f])}else for(const f of this.inputs){const p=t[f.name];if(null==p)throw new he(`No value is provided for the model's input ${f.name}`);u.add(f,p)}const h=Qp(o,u);return i?h:h[0]}retrieveSymbolicTensors(t){const n=hd(null,t.length);let i=t.length;for(const a of this.layers){const o=Array.isArray(a.output)?a.output:[a.output],u=o.map(h=>h.name);for(let h=0;h<t.length;++h){const f=u.indexOf(t[h]);if(-1!==f&&(n[h]=o[f],i--),0===i)break}if(0===i)break}if(i>0){const a=[];throw n.forEach((o,u)=>{null==o&&a.push(t[u])}),new he(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return n}predictLoop(t,n=32,i=!1){return me(()=>{const a=this.checkNumSamples(t);if(i)throw new Lr("Verbose predictLoop() is not implemented yet.");const o=CA(a,n),u=this.outputs.map(h=>[]);for(let h=0;h<o.length;++h)me(()=>{const m=Ah(t,o[h][0],o[h][1]),y=[];if(Array.isArray(m))for(let T=0;T<m.length;++T)y.push({key:this.inputs[T],value:m[T]});else y.push({key:this.inputs[0],value:m});const b=new Mi(y);return Qp(this.outputs,b)}).forEach((f,p)=>u[p].push(f));return Io(u.map(h=>ti(h,0)))})}predict(t,n={}){const i=IA(t);Qe(i,this.inputNames,this.feedInputShapes,!1);try{const a=null==n.batchSize?32:n.batchSize;return wA(a),this.predictLoop(i,a)}finally{Qt(i,t)}}predictOnBatch(t){Qe(t,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,i=!0,a){if(null==this.optimizer_)throw new Sl("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let u=0;u<this.feedOutputShapes.length;++u){const h=this.feedOutputShapes[u];o.push(this.feedLossFns[u]===oe?h.slice(0,h.length-1).concat([1]):h)}if(function(u,h,f){const p=hh(u.map(y=>y.shape[0]));p.sort();const m=hh(h.map(y=>y.shape[0]));if(m.sort(),p.length>1)throw new he(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(u.map(y=>y.shape))}`);if(m.length>1)throw new he(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(h.map(y=>y.shape))}`);if(p.length>0&&m.length>0&&!We(p,m))throw new he(`Input Tensors should have the same number of samples as target Tensors. Found ${p[0]} input sample(s) and ${m[0]} target sample(s).`)}(t=Ke(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=Ke(n,this.feedOutputNames,o,!1,"target")),function(u,h,f){const p=[St,fe,$t];for(let m=0;m<u.length;++m){const y=u[m],b=h[m],T=f[m];if(null!=b){if(b===$t&&1===y.shape[y.shape.length-1])throw new he(`You are passing a target array of shape ${y.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==p.indexOf(b)){const R=y.shape.slice(1),L=T.slice(1);for(let V=0;V<R.length;++V){const H=L[V];if(null!=H&&R[V]!==H)throw new he(`A target Tensor with shape ${y.shape} was passed for an output of shape ${T}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=a&&a>0&&t[0].shape[0]%a!=0)throw new he(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${t[0].shape[0]} sample(s).`);return[t,n]}async standardizeUserData(t,n,i,a,o=!0,u){const[h,f]=this.standardizeUserDataXY(t,n,o,u);if(null!=i)throw new Error("sample weight is not supported yet.");let p=null;if(null!=a){const m=Uy(a,this.outputNames);p=[];for(let y=0;y<m.length;++y)p.push(await gh(f[y],null,m[y]))}return[h,f,p]}testLoop(t,n,i,a=0,o){return me(()=>{const u=this.checkNumSamples(n,i,o,"steps"),h=[];if(a>0)throw new Lr("Verbose mode is not implemented yet.");if(null!=o)throw new Lr("steps mode in testLoop() is not implemented yet");{const f=CA(u,i),p=Yi(ol(0,u));for(let m=0;m<f.length;++m){const y=f[m][0],b=f[m][1],T=lo(p,y,b-y),R=EA(n,T),L=t(R);if(0===m)for(let V=0;V<L.length;++V)h.push(Jn(0));for(let V=0;V<L.length;++V)h[V]=an(h[V],ae(b-y,L[V]))}for(let m=0;m<h.length;++m)h[m]=qn(h[m],u)}return h})}getDedupedMetricsNames(){const t=this.metricsNames,n=[];for(let i=0;i<t.length;++i){const a=t[i];let o=a;_v(t,a)>1&&(o+=`_${_v(t.slice(0,i),a)}`),n.push(o)}return n}makeTrainFunction(){return t=>{const n=[],i=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),u=[],h=this.collectedTrainableWeights.map(f=>f.read());return[this.optimizer_.minimize(()=>{const f=[];for(let b=0;b<this.inputs.length;++b)f.push({key:this.inputs[b],value:i[b]});const p=new Mi(f),m=Qp(this.outputs,p,{training:!0});let y;for(let b=0;b<this.lossFunctions.length;++b){let T=(0,this.lossFunctions[b])(a[b],m[b]);null!=o[b]&&(T=Pv(T,o[b]));const R=fs(T);n.push(R),y=0===b?T:an(y,T)}for(let b=0;b<this.metricsTensors.length;++b){let T;if(this.outputs.length>1&&b<this.outputs.length)T=n[b];else{const L=this.metricsTensors[b][1];T=fs((0,this.metricsTensors[b][0])(a[L],m[L]))}ya(T),u.push(T)}return y=fs(y),this.calculateLosses().forEach(b=>{y=an(y,b)}),y},!0,h)].concat(u)}}makeTestFunction(){this.testFunction=t=>me(()=>{const n=[];let i;const a=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),u=[];for(let p=0;p<this.inputs.length;++p)u.push({key:this.inputs[p],value:a[p]});const h=new Mi(u),f=Qp(this.outputs,h);for(let p=0;p<this.lossFunctions.length;++p){const y=fs((0,this.lossFunctions[p])(o[p],f[p]));i=0===p?y:an(i,y),n.push(i)}for(let p=0;p<this.metricsTensors.length;++p){const y=this.metricsTensors[p][1],b=fs((0,this.metricsTensors[p][0])(o[y],f[y]));n.push(b)}return n})}async fit(t,n,i={}){return async function(a,o,u,h={}){if(a.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let f,p,m,y,b,T,R,L,V;a.isTraining=!0;try{const j=null==h.batchSize?32:h.batchSize;wA(j);const H=!1,nt=await a.standardizeUserData(o,u,h.sampleWeight,h.classWeight,H,j);f=nt[0],p=nt[1],V=nt[2];let dt,yt=!1;if(null!=h.validationData&&h.validationData.length>0){if(yt=!0,2!==h.validationData.length)throw 3===h.validationData.length?new Lr("validationData including sample weights is not supported yet."):new he(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${h.validationData} is invalid.`);b=h.validationData[0],T=h.validationData[1];const te=!0,ue=await a.standardizeUserData(b,T,null,null,te,j);R=ue[0],L=ue[1],dt=R.concat(L)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){yt=!0;const te=Math.floor(f[0].shape[0]*(1-h.validationSplit)),ue=f[0].shape[0];R=Ah(f,te,ue),m=f,f=Ah(f,0,te),L=Ah(p,te,ue),y=p,p=Ah(p,0,te),dt=R.concat(L)}else null!=h.validationSteps&&(yt=!0);const kt=f.concat(p).concat(V);a.checkTrainableWeightsConsistency();const Ot=a.makeTrainFunction(),Nt=a.getDedupedMetricsNames();let Vt,qt;yt?(a.makeTestFunction(),Vt=a.testFunction,qt=Nt.slice().concat(Nt.map(te=>"val_"+te))):(Vt=null,dt=[],qt=Nt.slice());const Zt=Ce(h.callbacks,h.yieldEvery);return await async function(te,ue,Ee,De,we,Te,Le,$e,je,Ne,He,Je,dn,mn,Ln){null==we&&(we=32),null==Te&&(Te=1),null==He&&(He=!0),null==dn&&(dn=0);let Rn=!1;null!=je&&null!=Ne&&(Rn=!0);const tr=te.checkNumSamples(Ee,we,null,"steps_per_epoch");let ur;null!=tr&&(ur=ol(0,tr)),null==Le&&(Le=1);const{callbackList:ir,history:er}=On($e,Le,Te,dn,tr,null,we,Rn,Je);ir.setModel(te),te.history=er,await ir.onTrainBegin(),te.stopTraining_=!1;for(let Sr=dn;Sr<Te;++Sr){await ir.onEpochBegin(Sr);const Vr={};{if("batch"===He)throw new Lr("batch shuffling is not implemneted yet");He&&ys(ur);const gi=Yi(ur),Cr=CA(tr,we);for(let Rr=0;Rr<Cr.length;++Rr){const Kr={};if(await ir.onBatchBegin(Rr,Kr),me(()=>{const la=Cr[Rr][0],ho=Cr[Rr][1],po=lo(gi,la,ho-la);Kr.batch=Rr,Kr.size=ho-la;const ca=EA(Ee,po),wd=ue(ca);for(let Fa=0;Fa<De.length;++Fa){const Vo=wd[Fa];Kr[De[Fa]]=Vo,ya(Vo)}if(Rr===Cr.length-1&&Rn){const Fa=te.testLoop(je,Ne,we);for(let fo=0;fo<De.length;++fo){const Vo=De[fo],Bu=Fa[fo];ya(Bu),Vr["val_"+Vo]=Bu}}}),await ir.onBatchEnd(Rr,Kr),Fe(Kr),te.stopTraining_)break}gi.dispose()}if(await ir.onEpochEnd(Sr,Vr),te.stopTraining_)break}return await ir.onTrainEnd(),await te.history.syncData(),te.history}(a,Ot,kt,Nt,j,h.epochs,h.verbose,Zt,Vt,dt,h.shuffle,qt,h.initialEpoch)}finally{a.isTraining=!1,Qt(f,o),Qt(p,u),Qt(m,o),Qt(y,u),Qt(R,b),Qt(L,T),null!=V&&Dr(V)}}(this,t,n,i)}async fitDataset(t,n){return async function(i,a,o){const u=null!=o.batchesPerEpoch;if(Z(null!=i.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Z(null!=o,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Z(null!=o.epochs&&o.epochs>0&&Number.isInteger(o.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${o.epochs}`),Z(!u||o.batchesPerEpoch>0&&Number.isInteger(o.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${o.batchesPerEpoch}`),Z(null==o.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),i.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");i.isTraining=!0;try{const h=null!=o.validationData;let f,p;if(h)if(wm(o.validationData))Z(null==o.validationBatches||o.validationBatches>0&&Number.isInteger(o.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${o.validationBatches}`);else{const nt=function(dt){if(3===dt.length)throw new Lr("Validation with sample weights is not implemented yet.");return{xs:dt[0],ys:dt[1]}}(o.validationData);f=nt.xs,p=nt.ys}const m=i.makeTrainFunction(),y=i.getDedupedMetricsNames();let b;b=h?y.slice().concat(y.map(nt=>"val_"+nt)):y.slice();const T=Ce(o.callbacks,o.yieldEvery),R=null==o.verbose?1:o.verbose,{callbackList:L,history:V}=On(T,R,o.epochs,null,null,function(nt,dt){let yt=null;return null!=dt.batchesPerEpoch?yt=dt.batchesPerEpoch:Number.isFinite(nt.size)&&(yt=nt.size),yt}(a,o),null,h,b);L.setModel(i),i.history=V,await L.onTrainBegin(),i.stopTraining_=!1;let j=null==o.initialEpoch?0:o.initialEpoch,H=await a.iterator();for(;j<o.epochs;){const nt={};await L.onEpochBegin(j);let dt=0,yt=0;for(u||(H=await a.iterator());!u||dt<o.batchesPerEpoch;){const kt=await H.next();if(u&&kt.done){console.warn(`You provided \`batchesPerEpoch\` as ${o.batchesPerEpoch}, but your dataset iterator ran out of data after ${dt} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+o.batchesPerEpoch*o.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=kt.value){const{xs:Ot,ys:Nt}=xA(i,kt.value),Vt={};Vt.batch=yt,Vt.size=Ot[0].shape[0],await L.onBatchBegin(yt,Vt);const qt=[];if(null!=o.classWeight){const ue=Uy(o.classWeight,i.outputNames);for(let Ee=0;Ee<ue.length;++Ee)qt.push(await gh(Nt[Ee],null,ue[Ee]))}const Zt=Ot.concat(Nt).concat(qt),te=m(Zt);Dr(Zt);for(let ue=0;ue<y.length;++ue){const De=te[ue];Vt[y[ue]]=De,ya(De)}await L.onBatchEnd(yt,Vt),Fe(Vt),yt++,dt++}if(u?dt>=o.batchesPerEpoch:kt.done){if(h){let Ot;Ot=wm(o.validationData)?Zi(await i.evaluateDataset(o.validationData,{batches:o.validationBatches})):Zi(i.evaluate(f,p,{batchSize:null==o.validationBatchSize?32:o.validationBatchSize,verbose:0}));for(let Nt=0;Nt<i.metricsNames.length;++Nt)nt[`val_${i.metricsNames[Nt]}`]=Ot[Nt]}break}if(i.stopTraining_)break}if(await L.onEpochEnd(j,nt),j++,i.stopTraining_)break}return await L.onTrainEnd(),await i.history.syncData(),i.history}finally{i.isTraining=!1}}(this,t,n)}async trainOnBatch(t,n){const i=await this.standardizeUserData(t,n),a=i[0],o=i[1],u=this.makeTrainFunction()(a.concat(o)),h=[];for(const f of u){const p=await f.data();h.push(p[0])}return Dr(u),Qt(i[0],t),Qt(i[1],n),Io(h)}getNamedWeights(t){const n=[],i=null!=t&&t.trainableOnly,a=i?this.trainableWeights:this.weights,o=this.getWeights(i);for(let u=0;u<a.length;++u)i&&!a[u].trainable||n.push({name:a[u].originalName,tensor:o[u]});return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const n=lg().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-lg().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=Eu(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if("string"!=typeof n)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(n=>Eu(n))}else{const n=Object.keys(this.loss);t={};const i=this.loss;for(const a of n){if("string"!=typeof i[a])throw new Error("Serialization of non-string loss is not supported.");t[a]=Eu(i[a])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Eu(Zn(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Eu(Zn(t)));{const t={};for(const n in this.metrics)t[n]=Eu(Zn(this.metrics[n]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const n=ln(Ue(t.optimizer_config));let i,a;if("string"==typeof t.loss)i=dd(t.loss);else if(Array.isArray(t.loss))i=t.loss.map(o=>dd(o));else if(null!=t.loss){i={};for(const o in t.loss)i[o]=dd(t.loss[o])}if(Array.isArray(t.metrics))a=t.metrics.map(o=>dd(o));else if(null!=t.metrics){a={};for(const o in t.metrics)a[o]=dd(t.metrics[o])}this.compile({loss:i,metrics:a,optimizer:n})}async save(t,n){if("string"==typeof t){const o=np(t);if(0===o.length)throw new he(`Cannot find any save handlers for URL '${t}'`);if(o.length>1)throw new he(`Found more than one (${o.length}) save handlers for URL '${t}'`);t=o[0]}if(null==t.save)throw new he("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=await Jd(this.getNamedWeights(n)),a={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${Nc}`,convertedBy:null};if(null!=n&&n.includeOptimizer&&null!=this.optimizer){a.trainingConfig=this.getTrainingConfig();const o="optimizer",{data:u,specs:h}=await Jd(await this.optimizer.getWeights(),o);i.specs.push(...h),i.data=tp([i.data,u])}return null!=this.userDefinedMetadata&&(ts(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=i.data,a.weightSpecs=i.specs,t.save(a)}setUserDefinedMetadata(t){ts(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Cn.className="Model",on(Cn);class pr extends Cn{}async function fr(r,t){"modelTopology"in r||(r={modelTopology:r});let n=r.modelTopology;null!=n.model_config&&(n=n.model_config);const i=ln(Ue(n),t);if(null!=r.weightsManifest){const a=await c0(r.weightsManifest,r.pathPrefix,i.weights.map(u=>u.originalName)),o={};for(const u of i.weights)o[u.originalName]=a[u.originalName];i.loadWeights(o),Dr(a)}return i}pr.className="Functional",on(pr);class Er extends Cn{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:tt("sequential_"),null!=t.layers)for(const n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new he(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const n=t instanceof Er||t instanceof Cn;let i;if(n){if(i=t,1!==i.outputs.length)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==i.inputs.length)throw new he("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new he("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const a=Pe({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(a)}if(n)this.outputs=i.outputs,this.inputs=i.inputs;else{if(1!==t.inboundNodes.length)throw new he(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=pe(this.outputs[0])}this.inboundNodes=[],new ne({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:hd(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{const a=t.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return null==this.model&&this.build(),this.model.call(t,n)}build(t){if(ct(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Cn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,i=console.log){this.built||this.build(),super.summary(t,n,i)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,n,i={}){if(!this.built)throw new Sl("The model needs to be compiled before being used.");return this.model.evaluate(t,n,i)}async evaluateDataset(t,n){if(!this.built)throw new Sl("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return null==this.model&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,i={}){if(!this.built)throw new Sl("The model needs to be compiled before being used.");return this.model.fit(t,n,i)}async fitDataset(t,n){if(!this.built)throw new Sl("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,i={},a=!1){let o,u={};if(n instanceof Array){if(null==n[0].className||"Merge"===n[0].className)throw new he("Legacy serialization format not supported yet.");o=n}else Z(null!=n.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=n.layers,delete n.layers,u=n;const h=new t(u);if(!(h instanceof Er))throw new Lr(`Sequential.fromConfig called on non-Sequential input: ${h}`);for(const f of o){const p=ln(f,void 0,a);a&&p.setFastWeightInitDuringBuild(!0),h.add(p)}return h}set stopTraining(t){if(null==this.model)throw new he("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new he("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const i={};i.className=n.getClassName(),i.config=n.getConfig(),t.push(i)}return{name:this.name,layers:t}}}function Yr(r){return new Cn(r)}function yi(r){return new Er(r)}function mi(r,t){return null==t&&(t={}),async function(n,i){if(null==i&&(i={}),"string"==typeof n){const a=os(n,i);if(0===a.length)a.push(su(n,i));else if(a.length>1)throw new he(`Found more than one (${a.length}) load handlers for URL '${n}'`);n=a[0]}return async function(a,o,u){if(null==u&&(u={}),null==a.load)throw new he("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const h=await a.load();let f=h.modelTopology;null!=f.model_config&&(f=f.model_config);const p=null==u.strict||u.strict,m=null!=h.weightData&&null!=h.weightSpecs&&p,y=ln(Ue(f),void 0,m),b=h.trainingConfig;if(null!=b&&y.loadTrainingConfig(b),null!=h.userDefinedMetadata&&y.setUserDefinedMetadata(h.userDefinedMetadata),null!=h.weightData){if(null==h.weightSpecs)throw new he("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:T,optimizerWeights:R}=function(L,V){const j=gf(L,V),H={},nt=[];return V.forEach(dt=>{"optimizer"===dt.group?nt.push({name:dt.name,tensor:j[dt.name]}):H[dt.name]=j[dt.name]}),{modelWeights:H,optimizerWeights:nt}}(h.weightData,h.weightSpecs);y.loadWeights(T,p),null!=y.optimizer&&R.length>0&&await y.optimizer.setWeights(R),Dr(T),Dr(R.map(L=>L.tensor))}return y}(n,0,i)}(r,t)}function es(r){return Pe(r)}function _l(r,t){rn.registerCallbackConstructor(r,t)}Er.className="Sequential",on(Er);class xs extends Hh{getConfig(){return{}}}class cl extends xs{apply(t,n=1){return function(i,a=1){if(1!==a)throw new Lr(`Support for alpha values other than 1 (${a}) is not implemented yet.`);return fu(i)}(t,n)}}cl.className="elu",on(cl);class ws extends xs{apply(t){return sh(t)}}ws.className="selu",on(ws);class gs extends xs{apply(t){return Do(t)}}gs.className="relu",on(gs);class Dc extends xs{apply(t){return me(()=>bp(6,Do(t)))}}Dc.className="relu6",on(Dc);class kl extends xs{apply(t){return t}}kl.className="linear",on(kl);class ni extends xs{apply(t){return ba(t)}}ni.className="sigmoid",on(ni);class Ci extends xs{apply(t){return n=t,me(()=>{const i=an(.5,ae(.2,n));return Va(i,0,1)});var n}}Ci.className="hardSigmoid",on(Ci);class SA extends xs{apply(t){return ls(t)}}SA.className="softplus",on(SA);class Uv extends xs{apply(t){return n=t,me(()=>qn(n,an(Ps(n),1)));var n}}Uv.className="softsign",on(Uv);class zv extends xs{apply(t){return El(t)}}zv.className="tanh",on(zv);class Hp extends xs{apply(t,n=-1){return Ic(t,n)}}Hp.className="softmax",on(Hp);class $v extends xs{apply(t,n=-1){return th(t,n)}}$v.className="logSoftmax",on($v);class Vv extends xs{apply(t,n=1){return me(()=>ae(ba(ae(t,n)),t))}}Vv.className="swish",on(Vv);class Gv extends xs{apply(t){return me(()=>ae(t,El(ls(t))))}}function yh(r){return r.getClassName()}function $y(r,t={}){return mm(r,Zo.getMap().classNameMap,t,"activation")}function _u(r){if(null==r)return $y({className:"linear",config:{}});if("string"==typeof r){const t={};return t.className=r,t.config={},$y(t)}return r instanceof xs?r:$y(r)}function Vy(r){if(null!=r&&"object"!=typeof r)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}Gv.className="mish",on(Gv);class Gy extends Hh{}class Em extends Gy{constructor(t){super(),Vy(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return me(()=>{let n=$s([1]);return this.hasL1&&(n=an(n,Vn(ae(this.l1,Ps(t))))),this.hasL2&&(n=an(n,Vn(ae(this.l2,Pi(t))))),le(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n.l1,l2:n.l2})}}Em.className="L1L2",on(Em);const ri={l1l2:"L1L2"};function Wi(r){return Iy(r)}function Rl(r,t={}){return mm(r,Zo.getMap().classNameMap,t,"regularizer")}function vi(r){return null==r?null:"string"==typeof r?Rl({className:r in ri?ri[r]:r,config:{}}):r instanceof Gy?r:Rl(r)}class MA extends ie{constructor(t){super(t??{}),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,n){t=it(t);let i=Do(t);return null!=this.maxValue&&(i=Va(i,0,this.maxValue)),i}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}}MA.className="ReLU",on(MA);class yd extends ie{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,n){const i=it(t);return Zu(i,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}yd.className="LeakyReLU",on(yd);class Cm extends ie{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=cs(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vi(t.alphaRegularizer),this.alphaConstraint=oa(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new he(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const n=(t=ct(t)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)n[a-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const i={};if(null!=this.sharedAxes)for(let a=1;a<t.length;++a)i[a]=t[a];this.inputSpec=[new zt({ndim:t.length,axes:i})],this.built=!0}call(t,n){return t=it(t),Ep(t,this.alpha.read())}getConfig(){const t={alphaInitializer:ms(this.alphaInitializer),alphaRegularizer:Wi(this.alphaRegularizer),alphaConstraint:Bs(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}}Cm.className="PReLU",on(Cm);class Qs extends ie{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new Lr(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,n){const i=it(t);return fu(i)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}Qs.className="ELU",on(Qs);class Lc extends ie{constructor(t){super(t??{}),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,n){const i=it(t);return ae(i,yn(ia(i,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}}Lc.className="ThresholdedReLU",on(Lc);class Im extends ie{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new Hp).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,n){const i=it(t);return this.softmax(i,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}function Mo(r,t,n){if("number"==typeof r)return hd(r,t);if(r.length!==t)throw new he(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let a=0;a<t;++a){const o=r[a];if((i=o)!==parseInt(i.toString(),10))throw new he(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r;var i}function Hs(r,t,n,i,a=1){if(null==r)return r;let o;return o="same"===n?r:r-(t+(t-1)*(a-1))+1,Math.floor((o+i-1)/i)}function Ws(r,t,n,i){if(null==r)return null;if("valid"===i)r=r*t+Su([n-t,0]);else{if("same"!==i)throw new he(`Unsupport padding mode: ${i}.`);r*=t}return r}function Sm(r,t){return me(()=>(Ns(t),"channelsFirst"===t?qr(r,[0,2,3,1]):r))}function Qv(r,t){return me(()=>(Ns(t),"channelsFirst"===t?qr(r,[0,2,3,4,1]):r))}function Qy(r,t,n,i=[1,1],a="valid",o,u,h=null){return me(()=>{if(null==o&&(o="channelsLast"),Ns(o),3!==r.rank&&4!==r.rank)throw new he(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(3!==t.rank&&4!==t.rank)throw new he(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let f=Sm(r,o);if("causal"===a)throw new Lr("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return f=Pg({x:f,filter:t,strides:i,pad:"same"===a?"same":"valid",dilations:u,dataFormat:"NHWC",bias:n,activation:h}),"channelsFirst"===o&&(f=qr(f,[0,3,1,2])),f})}Im.className="Softmax",on(Im);class Hv extends ie{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Hv.verifyArgs(n),this.rank=t,Ia(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Lr(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Mo(n.kernelSize,t,"kernelSize"),this.strides=Mo(null==n.strides?1:n.strides,t,"strides"),this.padding=null==n.padding?"valid":n.padding,al(this.padding),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Ns(this.dataFormat),this.activation=_u(n.activation),this.useBias=null==n.useBias||n.useBias,this.biasInitializer=cs(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=oa(n.biasConstraint),this.biasRegularizer=vi(n.biasRegularizer),this.activityRegularizer=vi(n.activityRegularizer),this.dilationRate=Mo(null==n.dilationRate?1:n.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new he(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new he(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new he(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(Rc("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!My(t.kernelSize,"number",1,3))throw new he(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:yh(this.activation),useBias:this.useBias,biasInitializer:ms(this.biasInitializer),biasRegularizer:Wi(this.biasRegularizer),activityRegularizer:Wi(this.activityRegularizer),biasConstraint:Bs(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}class TA extends Hv{constructor(t,n){super(t,n),this.kernel=null,TA.verifyArgs(n),this.filters=n.filters,Ia(this.filters,"filters"),this.kernelInitializer=cs(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=oa(n.kernelConstraint),this.kernelRegularizer=vi(n.kernelRegularizer)}build(t){t=ct(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new he(`The channel dimension of the input should be defined. Found ${t[n]}`);const i=t[n],a=this.kernelSize.concat([i,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:i}}],this.built=!0}call(t,n){return me(()=>{let i;t=it(t);const a=null==this.bias?null:this.bias.read(),o=Ty(this.activation.getClassName());if(null!=o&&2===this.rank)i=Qy(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)i=function(u,h,f,p=1,m="valid",y,b=1){return me(()=>{if(null==y&&(y="channelsLast"),Ns(y),3!==u.shape.length)throw new he(`The input of a conv1dWithBias operation should be 3, but is ${u.shape.length} instead.`);if(3!==h.shape.length)throw new he(`The kernel for a conv1dWithBias operation should be 3, but is ${h.shape.length} instead`);if(null!=f&&1!==f.shape.length)throw new he(`The bias for a conv1dWithBias operation should be 1, but is ${h.shape.length} instead`);if("channelsFirst"===y&&(u=qr(u,[0,2,1])),"causal"===m)throw new Lr("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let T=Bf(u,h,p,"same"===m?"same":"valid","NWC",b);return null!=f&&(T=Wa(T,f)),T})}(t,this.kernel.read(),a,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)i=Qy(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Lr("convolutions greater than 3D are not implemented yet.");i=function(u,h,f,p=[1,1,1],m="valid",y,b){return me(()=>{if(null==y&&(y="channelsLast"),Ns(y),4!==u.rank&&5!==u.rank)throw new he(`conv3dWithBias expects input to be of rank 4 or 5, but received ${u.rank}.`);if(4!==h.rank&&5!==h.rank)throw new he(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${u.rank}.`);let T=Qv(u,y);if("causal"===m)throw new Lr("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return T=wg(T,h,p,"same"===m?"same":"valid","NDHWC",b),null!=f&&(T=Wa(T,f)),"channelsFirst"===y&&(T=qr(T,[0,4,1,2,3])),T})}(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(i=this.activation.apply(i))}return i})}computeOutputShape(t){t=ct(t);const n=[],i="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<i.length;++o){const u=Hs(i[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);n.push(u)}let a=[t[0]];return"channelsLast"===this.dataFormat?(a=a.concat(n),a.push(this.filters)):(a.push(this.filters),a=a.concat(n)),a}getConfig(){const t={filters:this.filters,kernelInitializer:ms(this.kernelInitializer),kernelRegularizer:Wi(this.kernelRegularizer),kernelConstraint:Bs(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new he(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class _A extends TA{constructor(t){super(2,t),_A.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!My(t.kernelSize,"number",1,2))throw new he(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}_A.className="Conv2D",on(_A);class kA extends TA{constructor(t){super(3,t),kA.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new he(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}kA.className="Conv3D",on(kA);class qx extends _A{constructor(t){if(super(t),this.inputSpec=[new zt({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new he(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=ct(t)).length)throw new he("Input should have rank 4; Received input shape: "+JSON.stringify(t));const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new he("The channel dimension of the inputs should be defined. Found `None`.");const i=t[n],a=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zt({ndim:4,axes:{[n]:i}})],this.built=!0}call(t,n){return me(()=>{let i=it(t);if(4!==i.shape.length)throw new he(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const a=i.shape;let u,h;"channelsFirst"===this.dataFormat?(u=2,h=3):(u=1,h=2);const p=a[h],y=this.kernelSize[1],T=this.strides[1],R=[a[0],Ws(a[u],this.strides[0],this.kernelSize[0],this.padding),Ws(p,T,y,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=qr(i,[0,2,3,1]));let L=Nf(i,this.kernel.read(),R,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(L=qr(L,[0,3,1,2])),null!=this.bias&&(L=Wa(L,this.bias.read(),this.dataFormat)),null!=this.activation&&(L=this.activation.apply(L)),L})}computeOutputShape(t){const n=(t=ct(t)).slice();let i,a,o;"channelsFirst"===this.dataFormat?(i=1,a=2,o=3):(i=3,a=1,o=2);const u=this.kernelSize[0],h=this.kernelSize[1],f=this.strides[0],p=this.strides[1];return n[i]=this.filters,n[a]=Ws(n[a],f,u,this.padding),n[o]=Ws(n[o],p,h,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}qx.className="Conv2DTranspose",on(qx);class Xx extends kA{constructor(t){if(super(t),this.inputSpec=[new zt({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new he(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=ct(t)).length)throw new he("Input should have rank 5; Received input shape: "+JSON.stringify(t));const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new he("The channel dimension of the inputs should be defined. Found `None`.");const i=t[n],a=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new zt({ndim:5,axes:{[n]:i}})],this.built=!0}call(t,n){return me(()=>{let i=it(t);if(5!==i.shape.length)throw new he(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${i.shape.length}`);const a=i.shape;let u,h,f;"channelsFirst"===this.dataFormat?(f=2,u=3,h=4):(f=1,u=2,h=3);const m=a[u],y=a[h],T=this.kernelSize[1],R=this.kernelSize[2],V=this.strides[1],j=this.strides[2],H=[a[0],Ws(a[f],this.strides[0],this.kernelSize[0],this.padding),Ws(m,V,T,this.padding),Ws(y,j,R,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=qr(i,[0,2,3,4,1]));let nt=B0(i,this.kernel.read(),H,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(nt=qr(nt,[0,4,1,2,3])),null!==this.bias&&(nt=Wa(nt,this.bias.read(),this.dataFormat)),null!==this.activation&&(nt=this.activation.apply(nt)),nt})}computeOutputShape(t){const n=(t=ct(t)).slice();let i,a,o,u;"channelsFirst"===this.dataFormat?(i=1,a=2,o=3,u=4):(i=4,a=1,o=2,u=3);const h=this.kernelSize[0],f=this.kernelSize[1],p=this.kernelSize[2],m=this.strides[0],y=this.strides[1],b=this.strides[2];return n[i]=this.filters,n[a]=Ws(n[a],m,h,this.padding),n[o]=Ws(n[o],y,f,this.padding),n[u]=Ws(n[u],b,p,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}Xx.className="Conv3DTranspose",on(Xx);class LE extends TA{constructor(t,n){if(super(t,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==n.filters)throw new he("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=n.kernelInitializer||null!=n.kernelRegularizer||null!=n.kernelConstraint)throw new he("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=n.padding&&"same"!==n.padding&&"valid"!==n.padding)throw new he(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=null==n.depthMultiplier?1:n.depthMultiplier,this.depthwiseInitializer=cs(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vi(n.depthwiseRegularizer),this.depthwiseConstraint=oa(n.depthwiseConstraint),this.pointwiseInitializer=cs(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vi(n.pointwiseRegularizer),this.pointwiseConstraint=oa(n.pointwiseConstraint)}build(t){if((t=ct(t)).length<this.rank+2)throw new he(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n]||t[n]<0)throw new he(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);const i=t[n],a=this.kernelSize.concat([i,this.depthMultiplier]),o=[];for(let h=0;h<this.rank;++h)o.push(1);o.push(i*this.depthMultiplier,this.filters);const u=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,u,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,u,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,u,this.biasConstraint):null,this.inputSpec=[new zt({ndim:this.rank+2,axes:{[n]:i}})],this.built=!0}call(t,n){return me(()=>{let i;if(t=it(t),1===this.rank)throw new Lr("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=qr(t,[0,2,3,1])),i=V0(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(i=Wa(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),"channelsFirst"===this.dataFormat&&(i=qr(i,[0,3,1,2])),i})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=ms(this.depthwiseInitializer),t.pointwiseInitializer=ms(this.pointwiseInitializer),t.depthwiseRegularizer=Wi(this.depthwiseRegularizer),t.pointwiseRegularizer=Wi(this.pointwiseRegularizer),t.depthwiseConstraint=Bs(this.depthwiseConstraint),t.pointwiseConstraint=Bs(this.pointwiseConstraint),t}}LE.className="SeparableConv";class Yx extends LE{constructor(t){super(2,t)}}Yx.className="SeparableConv2D",on(Yx);class Hy extends TA{constructor(t){super(1,t),Hy.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!My(t.kernelSize,"number",1,1))throw new he(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}Hy.className="Conv1D",on(Hy);class Kx extends ie{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return me(()=>{if(t=it(t),"channelsLast"===this.dataFormat){const i=Vp(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Vp(i,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const i=Vp(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Vp(i,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}Kx.className="Cropping2D",on(Kx);class Jx extends ie{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Ns(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,pd(Ry,"InterpolationFormat",this.interpolation)}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,n){return me(()=>{let i=it(t);const a=i.shape;if("channelsFirst"===this.dataFormat){i=qr(i,[0,2,3,1]);const o=this.size[0]*a[2],u=this.size[1]*a[3],h="nearest"===this.interpolation?sl.resizeNearestNeighbor(i,[o,u]):sl.resizeBilinear(i,[o,u]);return qr(h,[0,3,1,2])}{const o=this.size[0]*a[1],u=this.size[1]*a[2];return"nearest"===this.interpolation?sl.resizeNearestNeighbor(i,[o,u]):sl.resizeBilinear(i,[o,u])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}Jx.className="UpSampling2D",on(Jx);class Zx extends Hv{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=cs(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=oa(t.depthwiseConstraint),this.depthwiseRegularizer=vi(t.depthwiseRegularizer)}build(t){if((t=ct(t)).length<4)throw new he(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const n="channelsFirst"===this.dataFormat?1:3;if(null==t[n]||t[n]<0)throw new he(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);const i=t[n];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,n){return me(()=>{let i=function(a,o,u=[1,1],h="valid",f,p){return me(()=>{null==f&&(f="channelsLast"),Ns(f);let m=Sm(a,f);if(4!==a.rank)throw new he(`Input for depthwiseConv2d is required to be 4-D, but is instead ${a.rank}-D`);if(4!==o.rank)throw new he(`depthwiseKernel is required to be 4-D, but is instead ${o.rank}-D`);return m=du(m,o,u,"same"===h?"same":"valid","NHWC",p),"channelsFirst"===f&&(m=qr(m,[0,3,1,2])),m})}(t=it(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(i=Wa(i,this.bias.read(),this.dataFormat)),null!=this.activation&&(i=this.activation.apply(i)),i})}computeOutputShape(t){t=ct(t);const i="channelsFirst"===this.dataFormat?t[3]:t[2],a="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,o=Hs("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),u=Hs(i,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],a,o,u]:[t[0],o,u,a]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=ms(this.depthwiseInitializer),t.depthwiseRegularizer=Wi(this.depthwiseRegularizer),t.depthwiseConstraint=Bs(this.depthwiseRegularizer),t}}function FE(r,t,n,i){if(Array.isArray(r)){if(null!=t||null!=n)throw new he("When inputs is an array, neither initialState or constants should be provided");null!=i&&(n=r.slice(r.length-i,r.length),r=r.slice(0,r.length-i)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function a(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:r,initialState:t=a(t),constants:n=a(n)}}function OE(r,t,n,i=!1,a,o,u=!1,h=!1){return me(()=>{const f=t.shape.length;if(f<3)throw new he(`Input should be at least 3D, but is ${f}D.`);const p=[1,0].concat(ol(2,f));if(t=qr(t,p),null!=o)throw new Lr("The rnn() functoin of the deeplearn.js backend does not support constants yet.");u&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=yn(yn(a,"bool"),"float32")).rank===f-1&&(a=xa(a,-1)),a=qr(a,p)),i&&(t=Qa(t,0),null!=a&&(a=Qa(a,0)));const m=[];let y,b=n;const T=t.shape[0],R=oo(t);let L,V;null!=a&&(L=oo(a));for(let j=0;j<T;++j){const H=R[j],nt=me(()=>r(H,b));if(null==a)y=nt[0],b=nt[1];else{const dt=me(()=>{const yt=L[j],kt=zn(so(yt),yt);return{output:an(ae(nt[0],yt),ae(b[0],kt)),newStates:b.map((Ot,Nt)=>an(ae(nt[1][Nt],yt),ae(Ot,kt)))}});y=dt.output,b=dt.newStates}h&&m.push(y)}return h&&(V=Co(m,1)),[y,V,b]})}Zx.className="DepthwiseConv2D",on(Zx);class ku extends ie{constructor(t){let n;if(super(t),null==t.cell)throw new he("cell property is missing for the constructor of RNN.");if(n=Array.isArray(t.cell)?new qv({cells:t.cell}):t.cell,null==n.stateSize)throw new he("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new zt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?ol(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(t=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){J(t)&&(t=t[0]);let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const i=n[0];let a;if(a=this.returnSequences?[t[0],t[1],i]:[t[0],i],this.returnState){const o=[];for(const u of n)o.push([t[0],u]);return[a].concat(o)}return a}computeMask(t,n){return me(()=>{Array.isArray(n)&&(n=n[0]);const i=this.returnSequences?n:null;if(this.returnState){const a=this.states.map(o=>null);return[i].concat(a)}return i})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let i=0;i<t;++i)n.push(null);return n}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new Lr("Constants support is not implemented in RNN yet.");J(t)&&(t=t[0]);const n=this.stateful?t[0]:null,i=t.slice(2);this.inputSpec[0]=new zt({shape:[n,null,...i]});const a=[t[0]].concat(t.slice(2));let o;if(this.cell.build(a),o=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!We(this.stateSpec.map(u=>u.shape[u.shape.length-1]),o))throw new he(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(u=>new zt({shape:[null,u]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){me(()=>{if(!this.stateful)throw new kc("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape[0];if(null==i)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>$s([i,a])):[$s([i,this.cell.stateSize])];else if(null==t)Dr(this.states_),null!=this.keptStates&&(Dr(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>$s([i,a])):this.states_[0]=$s([i,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===n?this.keptStates.push(this.states_.slice()):Dr(this.states_);for(let a=0;a<this.states_.length;++a){const o=t[a],u=Array.isArray(this.cell.stateSize)?this.cell.stateSize[a]:this.cell.stateSize,h=[i,u];if(!We(o.shape,h))throw new he(`State ${a} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${o.shape}`);this.states_[a]=o}}this.states_=this.states_.map(a=>ya(a.clone()))})}apply(t,n){let i=null==n?null:n.initialState,a=null==n?null:n.constants;null==n&&(n={});const o=FE(t,i,a,this.numConstants);t=o.inputs,i=o.initialState,a=o.constants;let u=[],h=[];if(null!=i){n.initialState=i,u=u.concat(i),this.stateSpec=[];for(const f of i)this.stateSpec.push(new zt({shape:f.shape}));h=h.concat(this.stateSpec)}if(null!=a&&(n.constants=a,u=u.concat(a),this.numConstants=a.length),u[0]instanceof ee){const f=[t].concat(u),p=this.inputSpec.concat(h),m=this.inputSpec;this.inputSpec=p;const y=super.apply(f,n);return this.inputSpec=m,y}return super.apply(t,n)}call(t,n){return me(()=>{const i=null==n?null:n.mask,a=null==n?null:n.training;let o=null==n?null:n.initialState;t=it(t),null==o&&(o=this.stateful?this.states_:this.getInitialState(t));const u=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==u)throw new he(`RNN Layer has ${u} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const h={training:a},f=OE((T,R)=>{const L=this.cell.call([T].concat(R),h);return[L[0],L.slice(1)]},t,o,this.goBackwards,i,null,this.unroll,this.returnSequences),p=f[0],m=f[1],y=f[2];this.stateful&&this.resetStates(y,a);const b=this.returnSequences?m:p;return this.returnState?[b].concat(y):b})}getInitialState(t){return me(()=>{let n=$s(t.shape);return n=Vn(n,[1,2]),n=md(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>i>1?ei(n,[1,i]):n):this.cell.stateSize>1?[ei(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(n.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===ku.className&&(n.cell={className:this.cell.getClassName(),config:i}),Object.assign({},i,t,n)}static fromConfig(t,n,i={}){const a=ln(n.cell,i);return new t(Object.assign(n,{cell:a}))}}ku.className="RNN",on(ku);class Wy extends ie{}class Wv extends Wy{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Ia(this.units,"units"),this.activation=_u(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=cs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=cs(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=cs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vi(t.kernelRegularizer),this.recurrentRegularizer=vi(t.recurrentRegularizer),this.biasRegularizer=vi(t.biasRegularizer),this.kernelConstraint=oa(t.kernelConstraint),this.recurrentConstraint=oa(t.recurrentConstraint),this.biasConstraint=oa(t.biasConstraint),this.dropout=zp([1,Su([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=zp([1,Su([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=ct(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,n){return me(()=>{if(2!==t.length)throw new he(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let i=t[1];t=t[0];const a=null!=n.training&&n.training;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Wp({ones:()=>so(t),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Wp({ones:()=>so(i),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,h=this.recurrentDropoutMask;o=Si(null!=u?ae(t,u):t,this.kernel.read()),null!=this.bias&&(o=Wa(o,this.bias.read())),null!=h&&(i=ae(i,h));let f=an(o,Si(i,this.recurrentKernel.read()));return null!=this.activation&&(f=this.activation.apply(f)),[f,f]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:yh(this.activation),useBias:this.useBias,kernelInitializer:ms(this.kernelInitializer),recurrentInitializer:ms(this.recurrentInitializer),biasInitializer:ms(this.biasInitializer),kernelRegularizer:Wi(this.kernelRegularizer),recurrentRegularizer:Wi(this.recurrentRegularizer),biasRegularizer:Wi(this.biasRegularizer),activityRegularizer:Wi(this.activityRegularizer),kernelConstraint:Bs(this.kernelConstraint),recurrentConstraint:Bs(this.recurrentConstraint),biasConstraint:Bs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,n)}}Wv.className="SimpleRNNCell",on(Wv);class tw extends ku{constructor(t){t.cell=new Wv(t),super(t)}call(t,n){return me(()=>(null!=this.cell.dropoutMask&&(Dr(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Dr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==n?null:n.mask,training:null==n?null:n.training,initialState:null==n?null:n.initialState})))}static fromConfig(t,n){return new t(n)}}tw.className="SimpleRNN",on(tw);class jv extends Wy{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new he("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Ia(this.units,"units"),this.activation=_u(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=_u(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=cs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=cs(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=cs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vi(t.kernelRegularizer),this.recurrentRegularizer=vi(t.recurrentRegularizer),this.biasRegularizer=vi(t.biasRegularizer),this.kernelConstraint=oa(t.kernelConstraint),this.recurrentConstraint=oa(t.recurrentConstraint),this.biasConstraint=oa(t.biasConstraint),this.dropout=zp([1,Su([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=zp([1,Su([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const n=(t=ct(t))[t.length-1];this.kernel=this.addWeight("kernel",[n,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,n){return me(()=>{if(2!==t.length)throw new he(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const i=null!=n.training&&n.training;let a=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Wp({ones:()=>so(t),rate:this.dropout,training:i,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Wp({ones:()=>so(a),rate:this.recurrentDropout,training:i,count:3,dropoutFunc:this.dropoutFunc}));const u=this.recurrentDropoutMask;let h,f,p;0<this.dropout&&this.dropout<1&&(t=ae(t,this.dropoutMask[0]));let m=Si(t,this.kernel.read());this.useBias&&(m=Wa(m,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=ae(a,u[0]));const y=this.recurrentKernel.read(),[b,T]=ao(y,[2*this.units,this.units],y.rank-1),R=Si(a,b),[L,V,j]=ao(m,3,m.rank-1),[H,nt]=ao(R,2,R.rank-1);h=this.recurrentActivation.apply(an(L,H)),f=this.recurrentActivation.apply(an(V,nt));const dt=Si(ae(f,a),T);p=this.activation.apply(an(j,dt));const yt=an(ae(h,a),ae(an(1,Ji(h)),p));return[yt,yt]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:yh(this.activation),recurrentActivation:yh(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ms(this.kernelInitializer),recurrentInitializer:ms(this.recurrentInitializer),biasInitializer:ms(this.biasInitializer),kernelRegularizer:Wi(this.kernelRegularizer),recurrentRegularizer:Wi(this.recurrentRegularizer),biasRegularizer:Wi(this.biasRegularizer),activityRegularizer:Wi(this.activityRegularizer),kernelConstraint:Bs(this.kernelConstraint),recurrentConstraint:Bs(this.recurrentConstraint),biasConstraint:Bs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,n)}}jv.className="GRUCell",on(jv);class ew extends ku{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new jv(t),super(t)}call(t,n){return me(()=>(null!=this.cell.dropoutMask&&(Dr(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Dr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==n?null:n.mask,training:null==n?null:n.training,initialState:null==n?null:n.initialState})))}static fromConfig(t,n){return 0===n.implmentation&&(n.implementation=1),new t(n)}}ew.className="GRU",on(ew);class jy extends Wy{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Ia(this.units,"units"),this.activation=_u(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=_u(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=cs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=cs(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=cs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=vi(t.kernelRegularizer),this.recurrentRegularizer=vi(t.recurrentRegularizer),this.biasRegularizer=vi(t.biasRegularizer),this.kernelConstraint=oa(t.kernelConstraint),this.recurrentConstraint=oa(t.recurrentConstraint),this.biasConstraint=oa(t.biasConstraint),this.dropout=zp([1,Su([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=zp([1,Su([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;const i=(t=ct(t))[t.length-1];let a;if(this.kernel=this.addWeight("kernel",[i,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,u=this.units;a=new((n=class extends Ds{apply(h,f){const p=o.apply([u]),m=(new gd).apply([u]),y=o.apply([2*u]);return Ny(Ny(p,m),y)}}).className="CustomInit",n)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return me(()=>{const i=null!=n.training&&n.training;if(3!==t.length)throw new he(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let a=t[1];const o=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Wp({ones:()=>so(t),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Wp({ones:()=>so(a),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let f,p,m,y;0<this.dropout&&this.dropout<1&&(t=ae(t,this.dropoutMask[0]));let b=Si(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=ae(a,h[0])),b=an(b,Si(a,this.recurrentKernel.read())),this.useBias&&(b=Wa(b,this.bias.read()));const[T,R,L,V]=ao(b,4,b.rank-1);f=this.recurrentActivation.apply(T),p=this.recurrentActivation.apply(R),m=an(ae(p,o),ae(f,this.activation.apply(L))),y=this.recurrentActivation.apply(V);const j=ae(y,this.activation.apply(m));return[j,j,m]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:yh(this.activation),recurrentActivation:yh(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ms(this.kernelInitializer),recurrentInitializer:ms(this.recurrentInitializer),biasInitializer:ms(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Wi(this.kernelRegularizer),recurrentRegularizer:Wi(this.recurrentRegularizer),biasRegularizer:Wi(this.biasRegularizer),activityRegularizer:Wi(this.activityRegularizer),kernelConstraint:Bs(this.kernelConstraint),recurrentConstraint:Bs(this.recurrentConstraint),biasConstraint:Bs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,n)}}jy.className="LSTMCell",on(jy);class nw extends ku{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new jy(t),super(t)}call(t,n){return me(()=>(null!=this.cell.dropoutMask&&(Dr(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Dr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==n?null:n.mask,training:null==n?null:n.training,initialState:null==n?null:n.initialState})))}static fromConfig(t,n){return 0===n.implmentation&&(n.implementation=1),new t(n)}}nw.className="LSTM",on(nw);class qv extends Wy{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return me(()=>{let i=t.slice(1);const a=[];for(const h of this.cells.slice().reverse())Array.isArray(h.stateSize)?a.push(i.splice(0,h.stateSize.length)):a.push(i.splice(0,1));a.reverse();const o=[];let u;for(let h=0;h<this.cells.length;++h){const f=this.cells[h];i=a[h],u=0===h?[t[0]].concat(i):[u[0]].concat(i),u=f.call(u,n),o.push(u.slice(1))}i=[];for(const h of o.slice().reverse())i.push(...h);return[u[0]].concat(i)})}build(t){let n;J(t)&&(t=t[0]),this.cells.forEach((i,a)=>{fh(`RNNCell_${a}`,()=>{i.build(t),n=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){const t=super.getConfig(),n={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign({},t,n)}static fromConfig(t,n,i={}){const a=[];for(const o of n.cells)a.push(ln(o,i));return new t({cells:a})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const i of this.cells)n.push(...i.trainableWeights);return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells)t.push(...n.weights);return Tt(t)}setWeights(t){const n=[];for(const i of this.cells){const o=t.splice(i.weights.length);for(let u=0;u<i.weights.length;++u)n.push([i.weights[u],o[u]])}Pt(n)}}function Wp(r){const{ones:t,rate:n,training:i=!1,count:a=1,dropoutFunc:o}=r,u=()=>null!=o?o(t(),n):mh(t(),n),h=()=>bs(u,t,i);return!a||a<=1?ya(h().clone()):Array(a).fill(void 0).map(h).map(f=>ya(f.clone()))}qv.className="StackedRNNCells",on(qv);class PE extends ku{constructor(t){if(t.unroll)throw new Lr("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Lr("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new zt({ndim:5})]}call(t,n){return me(()=>{if(null!=this.cell.dropoutMask&&(Dr(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Dr(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new he("ConvRNN2D cell does not support constants");return super.call(t,{mask:null==n?null:n.mask,training:null==n?null:n.training,initialState:null==n?null:n.initialState})})}computeOutputShape(t){let n=this.computeSingleOutputShape(t);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([t[0],...n.slice(-3)])]),n}getInitialState(t){return me(()=>{const{stateSize:n}=this.cell,a=this.computeSingleOutputShape(t.shape),o=$s([a[0],...a.slice(2)]);return Array.isArray(n)?Array(n.length).fill(o):[o]})}resetStates(t,n=!1){me(()=>{if(!this.stateful)throw new kc("Cannot call resetStates() on an RNN Layer that is not stateful.");const i=this.inputSpec[0].shape,a=this.computeSingleOutputShape(i),o=[a[0],...a.slice(2)];if(null==i[0])throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>$s(o)):[$s(o)];else if(null==t)Dr(this.states_),null!=this.keptStates&&(Dr(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>$s(o)):this.states_[0]=$s(o);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n?this.keptStates.push(this.states_.slice()):Dr(this.states_);for(let u=0;u<this.states_.length;++u){const h=t[u],f=o;if(!We(h.shape,f))throw new he(`State ${u} is incompatible with layer ${this.name}: expected shape=${f}, received shape=${h.shape}`);this.states_[u]=h}}this.states_=this.states_.map(u=>ya(u.clone()))})}computeSingleOutputShape(t){const{dataFormat:n,filters:i,kernelSize:a,padding:o,strides:u,dilationRate:h}=this.cell,f="channelsFirst"===n,m=t[f?4:3],y=Hs(t[f?3:2],a[0],o,u[0],h[0]),b=Hs(m,a[1],o,u[1],h[1]);return[...t.slice(0,2),...f?[i,y,b]:[y,b,i]]}}PE.className="ConvRNN2D";class Xv extends jy{constructor(t){const{filters:n,kernelSize:i,strides:a,padding:o,dataFormat:u,dilationRate:h}=t;super(Object.assign({},t,{units:n})),this.filters=n,Ia(this.filters,"filters"),this.kernelSize=Mo(i,2,"kernelSize"),this.kernelSize.forEach(f=>Ia(f,"kernelSize")),this.strides=Mo(a||1,2,"strides"),this.strides.forEach(f=>Ia(f,"strides")),this.padding=o||"valid",al(this.padding),this.dataFormat=u||"channelsLast",Ns(this.dataFormat),this.dilationRate=Mo(h||1,2,"dilationRate"),this.dilationRate.forEach(f=>Ia(f,"dilationRate"))}build(t){var n;t=ct(t);const i="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[i])throw new he(`The channel dimension of the input should be defined. Found ${t[i]}`);const o=this.kernelSize.concat([t[i],4*this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const u=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",u,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let h;if(this.unitForgetBias){const f=this.biasInitializer,p=this.filters;h=new((n=class extends Ds{apply(m,y){return Am([f.apply([p]),Ea([p]),f.apply([2*p])])}}).className="CustomInit",n)}else h=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,h,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return me(()=>{if(3!==t.length)throw new he(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const i=n.training||!1,a=t[0],o=t[1],u=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Wp({ones:()=>so(a),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const h=this.dropoutMask,f=(Le,$e,je)=>$e&&$e[je]?ae($e[je],Le):Le;let p=f(a,h,0),m=f(a,h,1),y=f(a,h,2),b=f(a,h,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Wp({ones:()=>so(o),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const T=this.recurrentDropoutMask;let R=f(o,T,0),L=f(o,T,1),V=f(o,T,2),j=f(o,T,3);const[H,nt,dt,yt]=ao(this.kernel.read(),4,3),[kt,Ot,Nt,Vt]=this.useBias?ao(this.bias.read(),4):[null,null,null,null];p=this.inputConv(p,H,kt,this.padding),m=this.inputConv(m,nt,Ot,this.padding),y=this.inputConv(y,dt,Nt,this.padding),b=this.inputConv(b,yt,Vt,this.padding);const[qt,Zt,te,ue]=ao(this.recurrentKernel.read(),4,3);R=this.recurrentConv(R,qt),L=this.recurrentConv(L,Zt),V=this.recurrentConv(V,te),j=this.recurrentConv(j,ue);const Ee=this.recurrentActivation.apply(an(p,R)),De=this.recurrentActivation.apply(an(m,L)),we=an(ae(De,u),ae(Ee,this.activation.apply(an(y,V)))),Te=ae(this.recurrentActivation.apply(an(b,j)),this.activation.apply(we));return[Te,Te,we]})}getConfig(){const i=function(o,u){var h={};for(var f in o)Object.prototype.hasOwnProperty.call(o,f)&&u.indexOf(f)<0&&(h[f]=o[f]);if(null!=o&&"function"==typeof Object.getOwnPropertySymbols){var p=0;for(f=Object.getOwnPropertySymbols(o);p<f.length;p++)u.indexOf(f[p])<0&&Object.prototype.propertyIsEnumerable.call(o,f[p])&&(h[f[p]]=o[f[p]])}return h}(super.getConfig(),["units"]);return Object.assign({},i,{filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides})}inputConv(t,n,i,a){const o=bc(t,n,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return i?Wa(o,i,this.dataFormat):o}recurrentConv(t,n){return bc(t,n,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}Xv.className="ConvLSTM2DCell",on(Xv);class rw extends PE{constructor(t){const n=new Xv(t);super(Object.assign({},t,{cell:n}))}static fromConfig(t,n){return new t(n)}}rw.className="ConvLSTM2D",on(rw);class Yv extends ie{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const n=t.shape,i=[];for(let a=0;a<this.noiseShape.length;++a)i.push(null==this.noiseShape[a]?n[a]:this.noiseShape[a]);return i}call(t,n){return me(()=>{this.invokeCallHook(t,n);const i=it(t);if(0<this.rate&&this.rate<1){const a=null!=n.training&&n.training,o=this.getNoiseShape(i);return bs(()=>mh(i,this.rate,o,this.seed),()=>i,a)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}}Yv.className="Dropout",on(Yv);class iw extends Yv{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}iw.className="SpatialDropout1D",on(iw);class sw extends ie{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let n=null;null!=t.batchSize&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,Ia(this.units,"units"),this.activation=_u(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=cs(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=cs(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=oa(t.kernelConstraint),this.biasConstraint=oa(t.biasConstraint),this.kernelRegularizer=vi(t.kernelRegularizer),this.biasRegularizer=vi(t.biasRegularizer),this.activityRegularizer=vi(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const n=(t=ct(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){const n=(t=ct(t)).slice();return n[n.length-1]=this.units,n}call(t,n){return me(()=>{this.invokeCallHook(t,n);const i=it(t),a=Ty(this.activation.getClassName());let o;return null!=a?o=Si(i,this.kernel.read(),a,this.bias?this.bias.read():null):(o=Si(i,this.kernel.read()),null!=this.bias&&(o=Wa(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const t={units:this.units,activation:yh(this.activation),useBias:this.useBias,kernelInitializer:ms(this.kernelInitializer),biasInitializer:ms(this.biasInitializer),kernelRegularizer:Wi(this.kernelRegularizer),biasRegularizer:Wi(this.biasRegularizer),activityRegularizer:Wi(this.activityRegularizer),kernelConstraint:Bs(this.kernelConstraint),biasConstraint:Bs(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}sw.className="Dense",on(sw);class aw extends ie{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=ct(t);for(const n of t.slice(1))if(null==n)throw new he(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Bc(t,1)]}call(t,n){return me(()=>{this.invokeCallHook(t,n);let i=it(t);if("channelsFirst"===this.dataFormat&&i.rank>1){const a=[0];for(let o=2;o<i.rank;++o)a.push(o);a.push(1),i=qr(i,a)}return function(a){if(a.rank<=1)throw new he(`batchFlatten requires a minimum rank of 2. Got rank: ${a.rank}.`);const o=[a.shape[0],Bc(a.shape,1)];return le(a,o)}(i)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(t,n),t}}aw.className="Flatten",on(aw);class ow extends ie{constructor(t){super(t),this.supportsMasking=!0,this.activation=_u(t.activation)}call(t,n){return me(()=>{this.invokeCallHook(t,n);const i=it(t);return this.activation.apply(i)})}getConfig(){const t={activation:yh(this.activation)},n=super.getConfig();return Object.assign(t,n),t}}ow.className="Activation",on(ow);class lw extends ie{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return me(()=>{return t=it(t),i=t,a=this.n,me(()=>{if(2!==i.shape.length)throw new he(`repeat() expects a rank-2 tensor, but received a rank-${i.shape.length} tensor.`);return ei(md(i,1),[1,a,1])});var i,a})}getConfig(){const t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}}lw.className="RepeatVector",on(lw);class cw extends ie{constructor(t){super(t),this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,n){const i="Total size of new array must be unchanged.",a=n.slice();let o=1,u=null;for(let f=0;f<a.length;++f){const p=a[f];if(this.isUnknown(p)){if(null!==u)throw new he("Can only specifiy one unknown dimension.");u=f}else o*=p}const h=Bc(t);if(null!==u){if(0===o||h%o!=0)throw new he(i);a[u]=h/o}else if(h!==o)throw new he(i);return a}computeOutputShape(t){let n=!1;for(let i=0;i<t.length;++i)if(this.isUnknown(t[i])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return me(()=>{this.invokeCallHook(t,n);const i=it(t),a=i.shape,o=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return le(i,o)})}getConfig(){const t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}}cw.className="Reshape",on(cw);class uw extends ie{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const n=ol(1,t.dims.length+1);if(!We(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new zt({ndim:this.dims.length+1})]}computeOutputShape(t){const n=(t=ct(t)).slice();return this.dims.forEach((i,a)=>{n[a+1]=t[i]}),n}call(t,n){return qr(it(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}}uw.className="Permute",on(uw);class hw extends ie{constructor(t){super(t??{}),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){const i=it(t);return Wh(mu(i,this.maskValue),-1)}call(t,n){return me(()=>{this.invokeCallHook(t,n);const i=it(t),a=Wh(mu(i,this.maskValue),-1,!0);return ae(i,yn(a,i.dtype))})}}hw.className="Masking",on(hw);class dw extends ie{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),this.batchInputShape=null==t.inputLength?[n,null]:[n].concat(Zi(t.inputLength))}this.inputDim=t.inputDim,Ia(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Ia(this.outputDim,"outputDim"),this.embeddingsInitializer=cs(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vi(t.embeddingsRegularizer),this.activityRegularizer=vi(t.activityRegularizer),this.embeddingsConstraint=oa(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return me(()=>this.maskZero?(t=it(t),mu(t,zr(t))):null)}computeOutputShape(t){if(t=ct(t),null==this.inputLength)return[...t,this.outputDim];const n=Zi(this.inputLength);if(n.length!==t.length-1)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let i=0;for(let a=0;a<n.length;++a){const o=n[a],u=t[a+1];if(null!=o&&null!=u&&o!==u)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==o&&(n[i]=u),i++}}return[t[0],...n,this.outputDim]}call(t,n){return me(()=>{this.invokeCallHook(t,n);let i=it(t);"int32"!==i.dtype&&(i=$p(i,"int32"));const a=Fr(this.embeddings.read(),le(i,[i.size]));return le(a,ct(this.computeOutputShape(i.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ms(this.embeddingsInitializer),embeddingsRegularizer:Wi(this.embeddingsRegularizer),activityRegularizer:Wi(this.activityRegularizer),embeddingsConstraint:Bs(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}}dw.className="Embedding",on(dw);class Mm extends ie{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Lr}computeElementwiseOpOutputShape(t,n){if(null==t||null==n)return null;if(t.length<n.length)return this.computeElementwiseOpOutputShape(n,t);if(0===n.length)return t;const i=t.slice(0,t.length-n.length);for(let a=0;a<n.length;++a){const o=t[t.length-n.length+a],u=n[a];if(null==o||null==u||o<0||u<0)i.push(null);else if(1===o)i.push(u);else if(1===u)i.push(o);else{if(o!==u)throw new he("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n));i.push(o)}}return i}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[ct(t)]),t.length<2)throw new he(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let n=[];for(const o of t)null!=o&&null!==o[0]&&n.push(o[0]);if(n=hh(n),n.length>1)throw new he(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let i=null==t[0]?null:t[0].slice(1);for(let o=1;o<t.length;++o){const u=null==t[o]?null:t[o].slice(1);i=this.computeElementwiseOpOutputShape(i,u)}const a=t.map(o=>o.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==hh(a).length}call(t,n){return me(()=>{if(this.reshapeRequired){const i=[],a=t.map(o=>o.rank);if(-1===a.indexOf(null)){const o=Su(a);for(let u of t){const h=u.rank;for(let f=0;f<o-h;++f)u=md(u,1);i.push(u)}return this.mergeFunction(i)}{let o=!1;for(const f of t){const p=f.rank;if(null==p){const m=f.shape,y=m[0],b=m.slice(1).concat([y]);let T=le(f,[y].concat(Bc(m.slice(1))));T=qr(T,[1,0]),T=le(T,b),i.push(T),o=!0}else if(p>1){const m=ol(1,p).concat([0]);i.push(qr(f,m)),o=!0}else i.push(f)}let u=this.mergeFunction(i);const h=u.rank;if(o)if(null==h){const f=u.shape,p=f[f.length-1],m=[p].concat(f.slice(0,f.length-1));u=le(qr(le(u,[-1,p]),[1,0]),m)}else if(h>1){const f=[h-1].concat(ol(0,h-1));u=qr(u,f)}return u}}return this.mergeFunction(t)})}computeOutputShape(t){let n;n=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const o=null==t[a]?null:t[a].slice(1);n=this.computeElementwiseOpOutputShape(n,o)}let i=[];for(const a of t)null!=a&&null!==a[0]&&i.push(a[0]);return i=hh(i),n=1===i.length?i.concat(n):[null].concat(n),n}computeMask(t,n){return me(()=>{if(null==n)return null;if(!Array.isArray(n))throw new he("`mask` should be an Array");if(!Array.isArray(t))throw new he("`inputs` should be an Array");if(n.length!==t.length)throw new he(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${n.length})`);if(n.every(a=>null==a))return null;let i=(n=n.map(a=>null==a?a:xa(a,0)))[0];for(let a=1;a<n.length-1;++a)i=wa(i,n[a]);return i})}}class pw extends Mm{constructor(t){super(t)}mergeFunction(t){return me(()=>{let n=t[0].clone();for(let i=1;i<t.length;++i)n=an(n,t[i]);return n})}}pw.className="Add",on(pw);class fw extends Mm{constructor(t){super(t)}mergeFunction(t){return me(()=>{let n=t[0].clone();for(let i=1;i<t.length;++i)n=ae(n,t[i]);return n})}}fw.className="Multiply",on(fw);class mw extends Mm{constructor(t){super(t)}mergeFunction(t){return me(()=>{let n=t[0].clone();for(let i=1;i<t.length;++i)n=an(n,t[i]);return ae(1/t.length,n)})}}mw.className="Average",on(mw);class gw extends Mm{constructor(t){super(t)}mergeFunction(t){return me(()=>{let n=t[0];for(let i=1;i<t.length;++i)n=Ac(n,t[i]);return n})}}gw.className="Maximum",on(gw);class Aw extends Mm{constructor(t){super(t)}mergeFunction(t){return me(()=>{let n=t[0];for(let i=1;i<t.length;++i)n=bp(n,t[i]);return n})}}Aw.className="Minimum",on(Aw);class yw extends Mm{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new he("A `Concatenate` layer should be called on a list of at least 2 inputs");let n=!0;for(const a of t)if(null!=a){n=!1;break}if(n)return;const i=[];for(let a=0;a<t.length;++a){const o=t[a].slice();o.splice(this.axis,1);let u=!1;for(const h of i)if(We(h,o)){u=!0;break}u||i.push(o)}if(i.length>1)throw new he("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return me(()=>Am(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new he("A `Concatenate` layer should be called on a list of inputs.");const n=t,i=n[0].slice(),a=this.axis<0?i.length+this.axis:this.axis;for(const o of n.slice(1)){if(null==i[a]||null==o[a]){i[a]=null;break}i[a]+=o[a]}return i}computeMask(t,n){if(null==n)return null;if(!Array.isArray(n))throw new he("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new he("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new he(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return me(()=>{let i=!0;if(n.forEach(u=>{null==u||(i=!1)}),i)return null;const a=[];for(let u=0;u<t.length;++u)a.push(null==n[u]?yn(so(t[u]),"bool"):n[u].rank<t[u].rank?xa(n[u],-1):n[u]);const o=ti(a,this.axis);return Ag(o,-1,!1)})}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}function qy(r,t){for(;r<0;)r+=t;return r}yw.className="Concatenate",on(yw);class vw extends Mm{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){Z(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0],i=t[1];if(n.length>3||i.length>3)throw new Lr("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(n,i);if(n[a[0]]!==i[a[1]])throw new he(`Dimension incompatibility: ${n[a[0]]} !== ${i[a[1]]}`)}mergeFunction(t){if(2!==t.length)throw new he(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let n,i=t[0],a=t[1];return n=Array.isArray(this.axes)?this.axes.map((o,u)=>qy(o,t[u].shape.length)):[qy(this.axes,i.shape.length),qy(this.axes,a.shape.length)],this.normalize&&(i=Lt(i,n[0]),a=Lt(a,n[1])),function(o,u,h){if(o.shape.length>3||u.shape.length>3)throw new Lr("batchDot is not implemented for tensors of 4D or higher rank yet");if(Z(o.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${o.shape.length}`),Z(o.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${u.shape.length}`),"number"==typeof h&&(h=[h,h]),"complex64"===o.dtype||"complex64"===u.dtype)throw new Lr("batchDot is not implemented for complex64-type Tensors yet.");const f=o.shape.length,p=u.shape.length;null==h&&(h=[f-1,p-2]);const m=h;return me(()=>{let y,b;if(f>p){y=f-p;const T=[];for(let R=0;R<y;++R)T.push(1);u=le(u,u.shape.concat(T))}else if(p>f){y=p-f;const T=[];for(let R=0;R<y;++R)T.push(1);o=le(o,o.shape.concat(T))}else y=0;if(b=2===o.shape.length&&2===u.shape.length?m[0]===m[1]?Vn(ae(o,u),m[0]):Vn(ae(qr(o,[1,0]),u),m[1]):Or(o,u,m[0]!==o.shape.length-1,m[1]===u.shape.length-1),y>0){let T;T=f>p?f+p-3:f-1;const R=[];for(let L=T;L<T+y;++L)R.push(L);b=Lo(b,R)}return 1===b.shape.length&&(b=xa(b,1)),b})}(i,a,n)}interpretAxes(t,n){let i;return i=Array.isArray(this.axes)?this.axes:[qy(this.axes,t.length),qy(this.axes,n.length)],i}computeOutputShape(t){Z(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0].slice(),i=t[1].slice();if(n.length>3||i.length>3)throw new Lr("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(n,i);n.splice(a[0],1),i.splice(a[1],1),i.splice(0,1);const o=n.concat(i);return 1===o.length&&o.push(1),o}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}}vw.className="Dot",on(vw);class bw extends ie{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return me(()=>{this.invokeCallHook(t,n);const i=it(t);return bs(()=>an(fi(i.shape,0,this.stddev),i),()=>i,n.training||!1)})}}bw.className="GaussianNoise",on(bw);class xw extends ie{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return me(()=>{this.invokeCallHook(t,n);const i=it(t);return this.rate>0&&this.rate<1?bs(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return ae(i,fi(i.shape,1,a))},()=>i,n.training||!1):i})}}xw.className="GaussianDropout",on(xw);class ww extends ie{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||it(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return me(()=>{if(this.rate<1&&this.rate>0){const i=this._getNoiseShape(t);return bs(()=>{const a=it(t),o=-1.7580993408473766;let u=wo(gu(i),this.rate);u=$p(u,"float32");const h=((1-this.rate)*(1+this.rate*o**2))**-.5,f=-h*o*this.rate,p=an(ae(a,u),ae(an(u,-1),o));return an(ae(p,h),f)},()=>it(t),n.training||!1)}return t})}}function Xy(r,t,n,i,a,o=.001){let u;if(2===r.rank)u=qh(r,t,n,i,a,o);else if(3===r.rank)u=hp(r,t,n,i,a,o);else{if(4!==r.rank)throw new Lr(`batchNormalization is not implemented for array of rank ${r.rank} yet`);u=_0(r,t,n,i,a,o)}return u}ww.className="AlphaDropout",on(ww);class Ew extends ie{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=cs(t.betaInitializer||"zeros"),this.gammaInitializer=cs(t.gammaInitializer||"ones"),this.movingMeanInitializer=cs(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=cs(t.movingVarianceInitializer||"ones"),this.betaConstraint=oa(t.betaConstraint),this.gammaConstraint=oa(t.gammaConstraint),this.betaRegularizer=vi(t.betaRegularizer),this.gammaRegularizer=vi(t.gammaRegularizer)}build(t){t=ct(t);const n=this.axis>=0?this.axis:this.axis+t.length,i=t[n];if(null==i)throw new he(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new zt({ndim:t.length,axes:{[n]:i}})];const a=[i];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return me(()=>{const i=null!=n.training&&n.training,a=it(t),o=a.shape,u=o.length,h=ol(0,u),f=this.axis>=0?this.axis:this.axis+u;h.splice(f,1);const p=hd(1,u);p[f]=o[f];const m=h.slice();m.sort();const y=!We(m,ol(0,u).slice(0,u-1));if(!i)return(()=>{if(y){const V=le(this.movingMean.read(),p),j=le(this.movingVariance.read(),p),H=this.center?le(this.beta.read(),p):null,nt=this.scale?le(this.gamma.read(),p):null;return Xy(a,V,j,H,nt,this.epsilon)}return Xy(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[b,T,R]=function(V,j,H,nt,dt=.001){return We(nt.slice().sort(),ol(0,V.rank-1))?function(yt,kt,Ot,Nt,Vt=.001){return me(()=>{const qt=Vf(yt,Nt),Zt=qt.mean,te=qt.variance;return[Xy(yt,Zt,te,Ot,kt,Vt),Zt,te]})}(V,j,H,nt,dt):function(yt,kt,Ot,Nt,Vt=.001){return me(()=>{const qt=Vf(yt,Nt),Zt=qt.mean,te=qt.variance,ue=[];for(const Le of ol(0,yt.rank))-1!==Nt.indexOf(Le)?ue.push(1):ue.push(yt.shape[Le]);const Ee=le(Zt,ue),De=le(te,ue),we=null==kt?null:le(kt,ue),Te=null==Ot?null:le(Ot,ue);return[Xy(yt,Ee,De,Te,we,Vt),Zt,te]})}(V,j,H,nt,dt)}(a,this.gamma.read(),this.beta.read(),h,this.epsilon),L=(V,j,H)=>{me(()=>{const nt=1-H,dt=V.read(),yt=ae(zn(dt,j),nt);V.write(zn(dt,yt))})};return L(this.movingMean,T,this.momentum),L(this.movingVariance,R,this.momentum),b})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ms(this.betaInitializer),gammaInitializer:ms(this.gammaInitializer),movingMeanInitializer:ms(this.movingMeanInitializer),movingVarianceInitializer:ms(this.movingVarianceInitializer),betaRegularizer:Wi(this.betaRegularizer),gammaRegularizer:Wi(this.gammaRegularizer),betaConstraint:Bs(this.betaConstraint),gammaConstraint:Bs(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}}Ew.className="BatchNormalization",on(Ew);class Cw extends ie{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=cs(t.betaInitializer||"zeros"),this.gammaInitializer=cs(t.gammaInitializer||"ones"),this.betaRegularizer=vi(t.betaRegularizer),this.gammaRegularizer=vi(t.gammaRegularizer),this.supportsMasking=!0}build(t){const n=(t=ct(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(const a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==hh(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const i=this.axis.map(a=>t[a]);this.gamma=this.scale?this.addWeight("gamma",i,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",i,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(t,n){const i=it(t),a=i.shape,o=a.length;return me(()=>{let{mean:u,variance:h}=Vf(i,this.axis,!0);const f=hd(1,o);for(const R of this.axis)f[R]=a[R];const p=R=>null!=R&&R.shape.length!==o?le(R,f):R;let m=p(this.gamma.read()),y=p(this.beta.read());const b=[],T=[];for(let R=0;R<o;++R)-1!==this.axis.indexOf(R)?(b.push(a[R]),T.push(1)):(b.push(1),T.push(a[R]));return u=xo(u,b),h=xo(h,b),m=xo(m,T),y=xo(y,T),Xy(i,u,h,y,m,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ms(this.betaInitializer),gammaInitializer:ms(this.gammaInitializer),betaRegularizer:Wi(this.betaRegularizer),gammaRegularizer:Wi(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}}Cw.className="LayerNormalization",on(Cw);class Iw extends ie{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new he(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,i;if("number"==typeof t.padding[0])n=[t.padding[0],t.padding[0]],i=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new he(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],2!==t.padding[1].length)throw new he(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);i=t.padding[1]}this.padding=[n,i]}this.inputSpec=[new zt({ndim:4})]}computeOutputShape(t){let n,i;return t=ct(t),"channelsFirst"===this.dataFormat?(n=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,i=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],n,i]):(n=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,i=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],n,i,t[3]])}call(t,n){return me(()=>{return i=it(t),a=this.padding,o=this.dataFormat,me(()=>{if(4!==i.rank)throw new he(`temporalPadding expects input tensor to be 4-D, but received a ${i.rank}-D tensor.`);if(null==a&&(a=[[1,1],[1,1]]),2!==a.length||2!==a[0].length||2!==a[1].length)throw new he("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==o&&(o="channelsLast"),"channelsLast"!==o&&"channelsFirst"!==o)throw new he(`Unknown data format: ${o}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let u;return u="channelsFirst"===o?[[0,0],[0,0],a[0],a[1]]:[[0,0],a[0],a[1],[0,0]],wc(i,u)});var i,a,o})}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}function Kv(r,t,n,i,a,o){return me(()=>{let u;Ns(a),Up(o),al(i),null==n&&(n=[1,1]),null==i&&(i="valid"),null==a&&(a="channelsLast"),null==o&&(o="max"),r=Sm(r,a);const h="same"===i?"same":"valid";return u="max"===o?eh(r,t,n,h):up(r,t,n,h),"channelsFirst"===a&&(u=qr(u,[0,3,1,2])),u})}function UE(r,t,n,i,a,o){return me(()=>{let u;Ns(a),Up(o),al(i),null==n&&(n=[1,1,1]),null==i&&(i="valid"),null==a&&(a="channelsLast"),null==o&&(o="max"),r=Qv(r,a);const h="same"===i?"same":"valid";return u="max"===o?nh(r,t,n,h):Ku(r,t,n,h),"channelsFirst"===a&&(u=qr(u,[0,4,1,2,3])),u})}Iw.className="ZeroPadding2D",on(Iw);class zE extends ie{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new he(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Ia(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new he(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Ia(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,al(this.padding),this.inputSpec=[new zt({ndim:3})]}computeOutputShape(t){const n=Hs((t=ct(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return me(()=>{this.invokeCallHook(t,n),t=md(it(t),2);const i=this.poolingFunction(it(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Lo(i,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(t,n),t}}class Sw extends zE{constructor(t){super(t)}poolingFunction(t,n,i,a,o){return Ns(o),al(a),Kv(t,n,i,a,o,"max")}}Sw.className="MaxPooling1D",on(Sw);class Mw extends zE{constructor(t){super(t)}poolingFunction(t,n,i,a,o){return Ns(o),al(a),Kv(t,n,i,a,o,"avg")}}Mw.className="AveragePooling1D",on(Mw);class $E extends ie{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new he(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Ia(this.poolSize,"poolSize"),Ia(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Ns(this.dataFormat),al(this.padding),this.inputSpec=[new zt({ndim:4})]}computeOutputShape(t){t=ct(t);let n="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2];return n=Hs(n,this.poolSize[0],this.padding,this.strides[0]),i=Hs(i,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],n,i]:[t[0],n,i,t[3]]}call(t,n){return me(()=>(this.invokeCallHook(t,n),this.poolingFunction(it(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class Tw extends $E{constructor(t){super(t)}poolingFunction(t,n,i,a,o){return Ns(o),al(a),Kv(t,n,i,a,o,"max")}}Tw.className="MaxPooling2D",on(Tw);class _w extends $E{constructor(t){super(t)}poolingFunction(t,n,i,a,o){return Ns(o),al(a),Kv(t,n,i,a,o,"avg")}}_w.className="AveragePooling2D",on(_w);class VE extends ie{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new he(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Ia(this.poolSize,"poolSize"),Ia(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Ns(this.dataFormat),al(this.padding),this.inputSpec=[new zt({ndim:5})]}computeOutputShape(t){t=ct(t);let n="channelsFirst"===this.dataFormat?t[2]:t[1],i="channelsFirst"===this.dataFormat?t[3]:t[2],a="channelsFirst"===this.dataFormat?t[4]:t[3];return n=Hs(n,this.poolSize[0],this.padding,this.strides[0]),i=Hs(i,this.poolSize[1],this.padding,this.strides[1]),a=Hs(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],n,i,a]:[t[0],n,i,a,t[4]]}call(t,n){return me(()=>(this.invokeCallHook(t,n),this.poolingFunction(it(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class kw extends VE{constructor(t){super(t)}poolingFunction(t,n,i,a,o){return Ns(o),al(a),UE(t,n,i,a,o,"max")}}kw.className="MaxPooling3D",on(kw);class Rw extends VE{constructor(t){super(t)}poolingFunction(t,n,i,a,o){return Ns(o),al(a),UE(t,n,i,a,o,"avg")}}Rw.className="AveragePooling3D",on(Rw);class GE extends ie{constructor(t){super(t),this.inputSpec=[new zt({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new Lr}}class Bw extends GE{constructor(t){super(t||{})}call(t,n){return me(()=>{const i=it(t);return fs(i,1)})}}Bw.className="GlobalAveragePooling1D",on(Bw);class Nw extends GE{constructor(t){super(t||{})}call(t,n){return me(()=>{const i=it(t);return Eo(i,1)})}}Nw.className="GlobalMaxPooling1D",on(Nw);class QE extends ie{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Ns(this.dataFormat),this.inputSpec=[new zt({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,n){throw new Lr}getConfig(){const t={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class Dw extends QE{call(t,n){return me(()=>{const i=it(t);return fs(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}Dw.className="GlobalAveragePooling2D",on(Dw);class Lw extends QE{call(t,n){return me(()=>{const i=it(t);return Eo(i,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}Lw.className="GlobalMaxPooling2D",on(Lw);class HE extends ie{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(t,n),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,n,i={}){const a=ln(n.layer,i);delete n.layer;const o={layer:a};return Object.assign(o,n),new t(o)}}class Fw extends HE{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=ct(t)).length<3)throw new he(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){const n=[(t=ct(t))[0]].concat(t.slice(2)),i=this.layer.computeOutputShape(n);return[i[0],t[1]].concat(i.slice(1))}call(t,n){return me(()=>OE((i,a)=>[it(this.layer.call(i,n)),[]],t=it(t),[],!1,null,null,!1,!0)[1])}}Fw.className="TimeDistributed",on(Fw);class Ow extends HE{constructor(t){super(t);const n=t.layer.getConfig(),i={};i.className=t.layer.getClassName(),i.config=n,this.forwardLayer=ln(i),n.goBackwards=!0!==n.goBackwards;const a={};if(a.className=t.layer.getClassName(),a.config=n,this.backwardLayer=ln(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,pd(Bv,"BidirectionalMergeMode",this.mergeMode),t.weights)throw new Lr("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const i=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,i)),this.backwardLayer.setWeights(t.slice(i))}computeOutputShape(t){let n,i,a,o=this.forwardLayer.computeOutputShape(t);return Array.isArray(o)&&Array.isArray(o[0])||(o=[o]),this.returnState&&(a=o.slice(1)),n=o[0],"concat"===this.mergeMode?(n[n.length-1]*=2,i=[n]):i=null==this.mergeMode?[n,n.slice()]:[n],this.returnState?null==this.mergeMode?i.concat(a).concat(a.slice()):[n].concat(a).concat(a.slice()):Io(i)}apply(t,n){let i=null==n?null:n.initialState,a=null==n?null:n.constants;null==n&&(n={});const o=FE(t,i,a,this.numConstants);if(t=o.inputs,i=o.initialState,a=o.constants,Array.isArray(t)&&(i=t.slice(1),t=t[0]),(null==i||0===i.length)&&null==a)return super.apply(t,n);const u=[],h=[];if(null!=i){const p=i.length;if(p%2>0)throw new he("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=i,u.push(...i);const m=i.map(y=>new zt({shape:y.shape}));this.forwardLayer.stateSpec=m.slice(0,p/2),this.backwardLayer.stateSpec=m.slice(p/2),h.push(...m)}if(null!=a)throw new Lr("Support for constants in Bidirectional layers is not implemented yet.");const f=u[0]instanceof ee;for(const p of u)if(p instanceof ee!==f)throw new he("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(f){const p=[t].concat(u),m=this.inputSpec.concat(h),y=this.inputSpec;this.inputSpec=m;const b=super.apply(p,n);return this.inputSpec=y,b}return super.apply(t,n)}call(t,n){return me(()=>{const i=n.initialState;let a,o,u,h;if(null==i)a=this.forwardLayer.call(t,n),o=this.backwardLayer.call(t,n);else{const f=i.slice(0,i.length/2),p=i.slice(i.length/2);a=this.forwardLayer.call(t,Object.assign(n,{initialState:f})),o=this.backwardLayer.call(t,Object.assign(n,{initialState:p}))}return this.returnState&&(Array.isArray(a)&&(u=a.slice(1).concat(o.slice(1))),a=a[0],o=o[0]),this.returnSequences&&(o=Qa(o,1)),"concat"===this.mergeMode?h=Am([a,o]):"sum"===this.mergeMode?h=an(a,o):"ave"===this.mergeMode?h=ae(.5,an(a,o)):"mul"===this.mergeMode?h=ae(a,o):null==this.mergeMode&&(h=[a,o]),this.returnState?null==this.mergeMode?h.concat(u):[h].concat(u):h})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){fh(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),fh(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,n){let i;if(Array.isArray(n)&&(n=n[0]),i=this.returnSequences?null==this.mergeMode?[n,n]:n:null==this.mergeMode?[null,null]:null,this.returnState){const a=this.forwardLayer.states.map(o=>null);return Array.isArray(i)?i.concat(a).concat(a):[i].concat(a).concat(a)}return i}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,n){const i=ln(n.layer);if(delete n.layer,null!=n.numConstants)throw new Lr("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=n;return a.layer=i,new t(a)}}function WI(r){return new Oe(r)}function jI(r){return new Qs(r)}function qI(r){return new MA(r)}function XI(r){return new yd(r)}function YI(r){return new Cm(r)}function KI(r){return new Im(r)}function JI(r){return new Lc(r)}function ZI(r){return new Hy(r)}function tS(r){return new _A(r)}function eS(r){return new qx(r)}function nS(r){return new kA(r)}function rS(r){return new Xx(r)}function iS(r){return new Yx(r)}function sS(r){return new Kx(r)}function aS(r){return new Jx(r)}function oS(r){return new Zx(r)}function lS(r){return new ow(r)}function cS(r){return new sw(r)}function uS(r){return new Yv(r)}function hS(r){return new iw(r)}function dS(r){return new aw(r)}function pS(r){return new lw(r)}function fS(r){return new cw(r)}function mS(r){return new uw(r)}function gS(r){return new dw(r)}function AS(r){return new pw(r)}function yS(r){return new mw(r)}function vS(r){return new yw(r)}function bS(r){return new gw(r)}function xS(r){return new Aw(r)}function wS(r){return new fw(r)}function ES(r){return new vw(r)}function CS(r){return new Ew(r)}function IS(r){return new Cw(r)}function SS(r){return new Iw(r)}function Pw(r){return new Mw(r)}function MS(r){return Pw(r)}function TS(r){return Pw(r)}function Uw(r){return new _w(r)}function _S(r){return Uw(r)}function kS(r){return Uw(r)}function zw(r){return new Rw(r)}function RS(r){return zw(r)}function BS(r){return zw(r)}function NS(r){return new Bw(r)}function DS(r){return new Dw(r)}function WE(r){return new Nw(r)}function jE(r){return new Lw(r)}function qE(r){return new Sw(r)}function XE(r){return new Tw(r)}function LS(r){return new kw(r)}function FS(r){return new ew(r)}function OS(r){return new jv(r)}function PS(r){return new nw(r)}function US(r){return new jy(r)}function zS(r){return new tw(r)}function $S(r){return new Wv(r)}function VS(r){return new rw(r)}function GS(r){return new Xv(r)}function QS(r){return new ku(r)}function HS(r){return new qv(r)}function WS(r){return new Ow(r)}function jS(r){return new Fw(r)}Ow.className="Bidirectional",on(Ow);const qS=WE,XS=jE,YS=qE,KS=XE;function JS(r){return new bw(r)}function ZS(r){return new xw(r)}function tM(r){return new ww(r)}function eM(r){return new hw(r)}function nM(r,t){return An(r,t)}function rM(r,t){return sr(r,t)}function iM(r,t){return Xr(r,t)}function sM(r,t){return Un(r,t)}function aM(r,t){return Ir(r,t)}function oM(r,t){return $n(r,t)}function lM(r,t){return n=r,i=t,me(()=>{const a=ar(n,i),o=(h=n,f=i,me(()=>yn(Vn(wa(Bo(h,1),Bo(f,0))),"float32"))),u=an(a,o);var h,f;return yn(Us(ia(u,0),qn(a,u),0),"float32")});var n,i}function cM(r,t){return ye(r,t)}function uM(r,t){return Et(r,t)}function hM(r,t){return re(r,t)}function dM(r,t){return re(r,t)}function pM(r,t){return re(r,t)}function fM(r,t){return St(r,t)}function mM(r,t){return St(r,t)}function gM(r,t){return St(r,t)}function AM(r){return new Em(r)}function yM(r){return Vy(t=r),new Em({l1:null!=t?t.l1:null,l2:0});var t}function vM(r){return Vy(t=r),new Em({l2:null!=t?t.l2:null,l1:0});var t}class YE extends Nn{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof Cn))throw new Error("model must be a LayersModel, not some other Container");this.model=t}}function Jv(r,t){return r<t}function bM(r,t){return r>t}class KE extends YE{constructor(t){if(super(),null==t&&(t={}),t.restoreBestWeights)throw new Lr("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.monitorFunc="min"===this.mode?Jv:"max"===this.mode||-1!==this.monitor.indexOf("acc")?bM:Jv,this.monitorFunc===Jv&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,this.best=null!=this.baseline?this.baseline:this.monitorFunc===Jv?1/0:-1/0}async onEpochEnd(t,n){await ze(n);const i=this.getMonitorValue(n);null!=i&&(this.monitorFunc(i-this.minDelta,this.best)?(this.best=i,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){null==t&&(t={});const n=t[this.monitor];return null==n&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),n}}const xM={earlyStopping:function(r){return new KE(r)}};var Fc,JE;de().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"}(Fc||(Fc={})),function(r){let t;var n;(n=t=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))[n.LEGACY=0]="LEGACY",n[n.V1=1]="V1",n[n.V2=2]="V2"}(JE||(JE={}));const $w={};function wM(r,t){$w[r]={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:t}}function ZE(r){return $w[r]}function EM(r){delete $w[r]}function gt(r,t,n,i,a){const o=t.inputParams[r];if(o&&void 0!==o.inputIndexStart){const h=o.inputIndexStart,f=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?h+1:o.inputIndexEnd;if("tensor"===o.type)return Po(t.inputNames[o.inputIndexStart],n,i,a);if("tensors"===o.type)return t.inputNames.slice(h,f).map(y=>Po(y,n,i,a));const p=Po(t.inputNames.slice(h)[0],n,i,a),m=p.dataSync();return"number"===o.type?m[0]:Tr(p.shape,m)}const u=t.attrParams[r];return u&&u.value}function Po(r,t,n,i){const[a,o]=Bl(r);if(null!=i){const h=i.getHashTableHandleByName(a);if(null!=h)return h}const u=n.currentContextIds.find(h=>!!t[Zv(a,h)]);return void 0!==u?t[Zv(a,u)][o]:void 0}function vh(r,t){const[n,i,a]=Bl(r);return[Zv(n,t&&t.currentContextId),i,a]}function Zv(r,t){return t?`${r}-${t}`:r}function Bl(r){const t=r.split(":");if(1===t.length)return[r,0,void 0];const i=3===t.length?t[1]:void 0;return[t[0],Number(t[t.length-1]),i]}function tb(r,t,n){let i=gt("pad",r,t,n);if("explicit"===i){i=gt("explicitPaddings",r,t,n);const a=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)a[o][0]=i[2*o],a[o][1]=i[2*o+1];return a}return i}function vd(r){return r.kept?r:ru(r)}const CM=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],IM=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],SM=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],MM=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],TM=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],_M=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],kM=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],RM=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],BM=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],NM=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],DM=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LM=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],FM=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],OM=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],PM=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],UM=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],zM=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],$M=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],VM=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class t2{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[et,xt,Rt,Yt,ve,xe,Ge,en,nn,vn,_n,nr,hr,Cs,Ti,Is,As,ua,Oa].map(n=>n.json));this.opMappers=t.reduce((n,i)=>(n[i.tfOpName]=i,n),{})}transformGraph(t,n={}){const a=[],o=[],u=[],h=t.node.reduce((L,V)=>(L[V.name]=this.mapNode(V),V.op.startsWith("Placeholder")?a.push(L[V.name]):"Const"===V.op?o.push(L[V.name]):null!=V.input&&0!==V.input.length||u.push(L[V.name]),L),{});let f=[];const p=[];let m={},y={};null!=n&&(m=this.mapSignatureEntries(n.inputs),y=this.mapSignatureEntries(n.outputs));const b=Object.keys(h);b.forEach(L=>{const V=h[L];V.inputNames.forEach((j,H)=>{const[nt,,dt]=vh(j),yt=h[nt];if(null!=yt.outputs){const kt=yt.outputs.indexOf(dt);-1!==kt&&(V.inputNames[H]=`${nt}:${kt}`)}V.inputs.push(yt),yt.children.push(V)})}),0===Object.keys(y).length?b.forEach(L=>{const V=h[L];0===V.children.length&&p.push(V)}):Object.keys(y).forEach(L=>{const[V]=vh(L),j=h[V];null!=j&&(j.signatureKey=y[L],p.push(j))}),Object.keys(m).length>0?Object.keys(m).forEach(L=>{const[V]=vh(L),j=h[V];j&&(j.signatureKey=m[L],f.push(j))}):f=a;let T={};null!=t.library&&null!=t.library.function&&(T=t.library.function.reduce((L,V)=>(L[V.signature.name]=this.mapFunction(V),L),{}));const R={nodes:h,inputs:f,outputs:p,weights:o,placeholders:a,signature:n,functions:T};return u.length>0&&(R.initNodes=u),R}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,i)=>(n[t[i].name]=i,n),{})}mapNode(t){const n=ZE(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const i={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(a=>a.startsWith("^")?a.substr(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};return null!=n.inputs&&(i.inputParams=n.inputs.reduce((a,o)=>(a[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},a),{})),null!=n.attrs&&(i.attrParams=n.attrs.reduce((a,o)=>{const u=o.type;let h;switch(o.type){case"string":h=Vw(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=Vw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":h=Yw(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=Yw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":h=Qw(t.attr,o.tfName,o.defaultValue||0),void 0===h&&o.tfDeprecatedName&&(h=Qw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":h=Xw(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=Xw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":h=Gw(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=Gw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":h=Jw(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=Jw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":h=qw(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=qw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":h=Kw(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=Kw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":h=Ww(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=Ww(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":h=jw(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=jw(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":h=n2(t.attr,o.tfName,o.defaultValue),void 0===h&&o.tfDeprecatedName&&(h=n2(t.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}return a[o.name]={value:h,type:u},a},{})),i}mapFunction(t){const n=t.nodeDef,i=[];let a={};null!=n&&(a=n.reduce((p,m)=>(p[m.name]=this.mapNode(m),"Const"===m.op&&i.push(p[m.name]),p),{}));const o=[],u=[];t.signature.inputArg.forEach(p=>{const[m]=vh(p.name),y={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Hw(p.type),type:"dtype"}},children:[]};y.signatureKey=p.name,o.push(y),a[m]=y}),Object.keys(a).forEach(p=>{const m=a[p];m.inputNames.forEach((y,b)=>{const[T,,R]=vh(y),L=a[T];if(null!=L.outputs){const V=L.outputs.indexOf(R);-1!==V&&(m.inputNames[b]=`${T}:${V}`)}m.inputs.push(L),L.children.push(m)})});const h=t.ret;t.signature.outputArg.forEach(p=>{const[m,y]=vh(h[p.name]),b=a[m];null!=b&&(b.defaultOutput=y,u.push(b))});const f=this.mapArgsToSignature(t);return{nodes:a,inputs:o,outputs:u,weights:i,placeholders:[],signature:f}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,i)=>(n[i.name]=this.mapArgToTensorInfo(i),n),{}),outputs:t.signature.outputArg.reduce((n,i)=>(n[i.name]=this.mapArgToTensorInfo(i,t.ret),n),{})}}mapArgToTensorInfo(t,n){let i=t.name;return null!=n&&(i=n[i]),{name:i,dtype:t.type}}}function e2(r,t){const n=Array.isArray(r)?String.fromCharCode.apply(null,r):function(i){const a=de().global;if(void 0!==a.atob)return a.atob(i);if(typeof Buffer<"u")return new Buffer(i,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(r);return t?n:n.toLowerCase()}function Vw(r,t,n,i=!1){const a=r[t];return null!=a?e2(a.s,i):n}function Gw(r,t,n){const i=r[t];return i?i.b:n}function Qw(r,t,n){const i=r[t]||{},a=null!=i.i?i.i:null!=i.f?i.f:n;return"number"==typeof a?a:parseInt(a,10)}function Hw(r){switch("string"==typeof r&&(r=Fc[r]),r){case Fc.DT_FLOAT:case Fc.DT_HALF:return"float32";case Fc.DT_INT32:case Fc.DT_INT64:case Fc.DT_INT8:case Fc.DT_UINT8:return"int32";case Fc.DT_BOOL:return"bool";case Fc.DT_DOUBLE:return"float32";case Fc.DT_STRING:return"string";default:return null}}function n2(r,t,n){const i=r[t];return i&&i.func?i.func.name:n}function Ww(r,t,n){const i=r[t];return i&&i.type?Hw(i.type):n}function jw(r,t,n){const i=r[t];return i&&i.list&&i.list.type?i.list.type.map(a=>Hw(a)):n}function r2(r){if(!r.unknownRank)return null!=r.dim?r.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function qw(r,t,n){const i=r[t];return i&&i.shape?r2(i.shape):n}function Xw(r,t,n){const i=r[t];return i?((i.list.f&&i.list.f.length?i.list.f:i.list.i)||[]).map(a=>"number"==typeof a?a:parseInt(a,10)):n}function Yw(r,t,n,i=!1){const a=r[t];return a&&a.list&&a.list.s?a.list.s.map(o=>e2(o,i)):n}function Kw(r,t,n){const i=r[t];return i&&i.list&&i.list.shape?i.list.shape.map(a=>r2(a)):n}function Jw(r,t,n){const i=r[t];return i&&i.list&&i.list.b?i.list.b:n}class GM{constructor(t,n,i){this.node=t,this.tensorMap=n,this.context=i,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(a=>this.getInput(a)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((a,o)=>(a[o]=this.getAttr(o),a),{}))}getInput(t){return Po(t,this.tensorMap,this.context)}getAttr(t,n){const i=this.node.rawAttrs[t];if(null!=i.tensor)return Po(t,this.tensorMap,this.context);if(null!=i.i||null!=i.f)return Qw(this.node.rawAttrs,t,n);if(null!=i.s)return Vw(this.node.rawAttrs,t,n);if(null!=i.b)return Gw(this.node.rawAttrs,t,n);if(null!=i.shape)return qw(this.node.rawAttrs,t,n);if(null!=i.type)return Ww(this.node.rawAttrs,t,n);if(null!=i.list){if(null!=i.list.i||null!=i.list.f)return Xw(this.node.rawAttrs,t,n);if(null!=i.list.s)return Yw(this.node.rawAttrs,t,n);if(null!=i.list.shape)return Kw(this.node.rawAttrs,t,n);if(null!=i.list.b)return Jw(this.node.rawAttrs,t,n);if(null!=i.list.type)return jw(this.node.rawAttrs,t,n)}return n}}function Oc(r,t,n=""){if("number"!=typeof r&&"number"!=typeof t){Z(r.length===t.length,()=>n+` Shapes ${r} and ${t} must match`);for(let i=0;i<r.length;i++){const a=r[i],o=t[i];Z(a<0||o<0||a===o,()=>n+` Shapes ${r} and ${t} must match`)}}}function i2(r){return"number"!=typeof r&&!r.some(t=>t<0)}function Yy(r,t,n){let i=Zw(r,n);const a=!i2(i);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${i}`);if(a&&t.forEach(o=>{i=Zw(o.shape,i)}),!i2(i))throw new Error(`Non-fully-defined elementShape: ${i}`);return i}function Zw(r,t){if("number"==typeof r)return t;if("number"==typeof t)return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);const n=[];for(let i=0;i<r.length;++i){const a=r[i],o=t[i];if(a>=0&&o>=0&&a!==o)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);n[i]=a>=0?a:o}return n}class QM{constructor(t,n,i,a,o,u,h){this.name=t,this.dtype=n,this.maxSize=i,this.elementShape=a,this.identicalElementShapes=o,this.dynamicSize=u,this.clearAfterRead=h,this.tensors=[],this.closed_=!1,this.idTensor=Jn(0),ya(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{null!=t&&t.has(n.tensor.id)||n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const n=this.tensors[t];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const i=this.tensors[t]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=n.shape),Oc(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),i.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(i.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);i.tensor=n,ya(n),i.written=!0,this.tensors[t]=i}writeMany(t,n){if(t.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`);t.forEach((i,a)=>this.write(i,n[a]))}gather(t,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(t)t=t.slice(0,this.size());else{t=[];for(let a=0;a<this.size();a++)t.push(a)}if(0===t.length)return Yo([],[0].concat(this.elementShape));const i=this.readMany(t);return Oc(this.elementShape,i[0].shape,"TensorArray shape mismatch: "),Co(i,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return Yo([],[0].concat(this.elementShape));const n=[];for(let a=0;a<this.size();a++)n.push(a);const i=this.readMany(n);return Oc(this.elementShape,i[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${i[0].shape})`),ti(i,0)}scatter(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const i=Math.max(...t);if(!this.dynamicSize&&i>=this.maxSize)throw new Error(`Max index must be < array size (${i}  vs. ${this.maxSize})`);this.writeMany(t,oo(n,0))}split(t,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let i=0;const a=t.map(f=>(i+=f,i));if(i!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${i}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===i?0:n.size/i,u=[];me(()=>{n=le(n,[1,i,o]);for(let f=0;f<t.length;++f)u[f]=le(Gr(n,[0,0===f?0:a[f-1],0],[1,t[f],o]),this.elementShape);return u});const h=[];for(let f=0;f<t.length;f++)h[f]=f;this.writeMany(h,u)}}class RA{constructor(t,n,i,a=-1){this.tensors=t,this.elementShape=n,this.elementDtype=i,t?.forEach(o=>{if(i!==o.dtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${o.dtype}`);Oc(n,o.shape,"TensorList shape mismatch: "),ya(o)}),this.idTensor=Jn(0),this.maxNumElements=a,ya(this.idTensor)}get id(){return this.idTensor.id}copy(){return new RA([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{null!=t&&t.has(n.id)||n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,i=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(-1!==i&&this.tensors.length!==i)throw new Error(`Operation expected a list with ${i} elements but got a list with ${this.tensors.length} elements.`);Oc(t,this.elementShape,"TensorList shape mismatch: ");const a=Yy(this.elementShape,this.tensors,t);return me(()=>{const o=this.tensors.map(u=>le(u,a));return Co(o,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const i=Yy(this.elementShape,this.tensors,t),a=this.tensors.pop();return Oc(a.shape,t,"TensorList shape mismatch: "),le(a,i)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Oc(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ya(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,n,i){if(i!==this.elementDtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);Oc(this.tensors[t].shape,n,"TensorList shape mismatch: ");const a=Yy(this.elementShape,this.tensors,n);return le(this.tensors[t],a)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Oc(this.elementShape,n.shape,"TensorList shape mismatch: "),ya(n),this.tensors[t]=n}gather(t,n,i){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Oc(this.elementShape,i,"TensorList shape mismatch: "),t=t.slice(0,this.size());const a=Yy(this.elementShape,this.tensors,i);return 0===t.length?Yo([],[0].concat(a)):me(()=>{const o=t.map(u=>le(this.tensors[u],a));return Co(o,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Oc(this.elementShape,n,"TensorList shape mismatch: ");const i=Yy(this.elementShape,this.tensors,n);return 0===this.size()?Yo([],[0].concat(i)):me(()=>{const a=this.tensors.map(o=>le(o,i));return ti(a,0)})}}function s2(r,t,n){const[i,a]=gt("fusedOps",r,t,n),o="biasadd"===i,u=!o,h="prelu"===a,f="fusedbatchnorm"===i,p=gt("numArgs",r,t,n);if(o){if(h&&2!==p)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!h&&o&&1!==p)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(f)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const m=gt("strides",r,t,n),y=tb(r,t,n),b=gt("dataFormat",r,t,n).toUpperCase(),T=gt("dilations",r,t,n);let[R,L]=gt("args",r,t,n);return u&&(L=R,R=void 0),{stride:m,pad:y,dataFormat:b,dilations:T,biasArg:R,preluArg:L,activationFunc:a,leakyreluAlpha:gt("leakyreluAlpha",r,t,n)}}function tE(r,t,n){return{boxes:gt("boxes",r,t,n),scores:gt("scores",r,t,n),maxOutputSize:gt("maxOutputSize",r,t,n),iouThreshold:gt("iouThreshold",r,t,n),scoreThreshold:gt("scoreThreshold",r,t,n),softNmsSigma:gt("softNmsSigma",r,t,n)}}class HM{constructor(t,n){this.keyDType=t,this.valueDType=n,this.handle=Jn(0),this.tensorMap=new Map,ya(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Jn(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);const i=await t.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),me(()=>{const a=oo(n),o=i.length,u=a.length;Z(o===u,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${u} elements.`);for(let h=0;h<o;h++){const f=i[h],p=a[h];ya(p),this.tensorMap.set(f,p)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);const i=await t.data();return me(()=>{const a=[];for(let o=0;o<i.length;o++){const h=this.findWithDefault(i[o],n);a.push(h)}return Co(a)})}findWithDefault(t,n){return this.tensorMap.get(t)??n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}function a2(r,t,n,i){const a=((o,u,h)=>{switch(o.category){case"arithmetic":return me(()=>((p,m,y)=>{switch(p.op){case"BiasAdd":case"AddV2":case"Add":return[an(gt("a",p,m,y),gt("b",p,m,y))];case"AddN":return[C0(gt("tensors",p,m,y))];case"FloorMod":case"Mod":return[xp(gt("a",p,m,y),gt("b",p,m,y))];case"Mul":return[ae(gt("a",p,m,y),gt("b",p,m,y))];case"RealDiv":case"Div":return[qn(gt("a",p,m,y),gt("b",p,m,y))];case"DivNoNan":return[Jl(gt("a",p,m,y),gt("b",p,m,y))];case"FloorDiv":return[hg(gt("a",p,m,y),gt("b",p,m,y))];case"Sub":return[zn(gt("a",p,m,y),gt("b",p,m,y))];case"Minimum":return[bp(gt("a",p,m,y),gt("b",p,m,y))];case"Maximum":return[Ac(gt("a",p,m,y),gt("b",p,m,y))];case"Pow":return[lu(gt("a",p,m,y),gt("b",p,m,y))];case"SquaredDifference":return[nd(gt("a",p,m,y),gt("b",p,m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"basic_math":return me(()=>((p,m,y)=>{switch(p.op){case"Abs":case"ComplexAbs":return[Ps(gt("x",p,m,y))];case"Acos":return[w0(gt("x",p,m,y))];case"Acosh":return[E0(gt("x",p,m,y))];case"Asin":return[S0(gt("x",p,m,y))];case"Asinh":return[M0(gt("x",p,m,y))];case"Atan":return[yg(gt("x",p,m,y))];case"Atan2":return[tl(gt("x",p,m,y),gt("y",p,m,y))];case"Atanh":return[Mf(gt("x",p,m,y))];case"Ceil":return[bg(gt("x",p,m,y))];case"Complex":return[ss(gt("real",p,m,y),gt("imag",p,m,y))];case"Cos":return[Ju(gt("x",p,m,y))];case"Cosh":return[fp(gt("x",p,m,y))];case"Elu":return[fu(gt("x",p,m,y))];case"Erf":return[Ig(gt("x",p,m,y))];case"Exp":return[No(gt("x",p,m,y))];case"Expm1":return[Yh(gt("x",p,m,y))];case"Floor":return[mp(gt("x",p,m,y))];case"Log":return[Ga(gt("x",p,m,y))];case"Log1p":return[Pf(gt("x",p,m,y))];case"Imag":return[Ff(gt("x",p,m,y))];case"Neg":return[Ji(gt("x",p,m,y))];case"Reciprocal":return[Ec(gt("x",p,m,y))];case"Real":return[ih(gt("x",p,m,y))];case"Relu":return[Do(gt("x",p,m,y))];case"Round":return[Xf(gt("x",p,m,y))];case"Selu":return[sh(gt("x",p,m,y))];case"Sigmoid":return[ba(gt("x",p,m,y))];case"Sin":return[kg(gt("x",p,m,y))];case"Sign":return[G0(gt("x",p,m,y))];case"Sinh":return[Rg(gt("x",p,m,y))];case"Softplus":return[ls(gt("x",p,m,y))];case"Sqrt":return[Ba(gt("x",p,m,y))];case"Square":return[Oi(gt("x",p,m,y))];case"Tanh":return[El(gt("x",p,m,y))];case"Tan":return[Jf(gt("x",p,m,y))];case"ClipByValue":return[Va(gt("x",p,m,y),gt("clipValueMin",p,m,y),gt("clipValueMax",p,m,y))];case"Relu6":return[Zh(gt("x",p,m,y))];case"Rsqrt":return[Cc(Po(p.inputNames[0],m,y))];case"Prod":return[Cp(gt("x",p,m,y),gt("axes",p,m,y))];case"LeakyRelu":return[Zu(gt("x",p,m,y),gt("alpha",p,m,y))];case"Prelu":return[Ep(gt("x",p,m,y),gt("alpha",p,m,y))];case"IsNan":return[Of(Po(p.inputNames[0],m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"control":return(async(p,m,y)=>{switch(p.op){case"If":case"StatelessIf":{const b=gt("thenBranch",p,m,y),T=gt("elseBranch",p,m,y),R=gt("cond",p,m,y),L=gt("args",p,m,y);return(await R.data())[0]?y.functionMap[b].executeFunctionAsync(L,y.tensorArrayMap,y.tensorListMap):y.functionMap[T].executeFunctionAsync(L,y.tensorArrayMap,y.tensorListMap)}case"While":case"StatelessWhile":{const b=gt("body",p,m,y),T=gt("cond",p,m,y),R=gt("args",p,m,y),L=await y.functionMap[T].executeFunctionAsync(R,y.tensorArrayMap,y.tensorListMap),V=R.map(nt=>nt.id);let j=await L[0].data();L.forEach(nt=>{nt.kept||-1!==V.indexOf(nt.id)||nt.dispose()});let H=R;for(;j[0];){const nt=H;H=await y.functionMap[b].executeFunctionAsync(H,y.tensorArrayMap,y.tensorListMap);const dt=H.map(kt=>kt.id);nt.forEach(kt=>{kt.kept||-1!==V.indexOf(kt.id)||-1!==dt.indexOf(kt.id)||kt.dispose()});const yt=await y.functionMap[T].executeFunctionAsync(H,y.tensorArrayMap,y.tensorListMap);j=await yt[0].data(),yt.forEach(kt=>{kt.kept||-1!==V.indexOf(kt.id)||-1!==dt.indexOf(kt.id)||kt.dispose()})}return H}case"LoopCond":return[vd(gt("pred",p,m,y))];case"Switch":{const b=gt("pred",p,m,y);let T=gt("data",p,m,y);return T.kept||(T=vd(T)),(await b.data())[0]?[void 0,T]:[T,void 0]}case"Merge":{const b=p.inputNames.find(T=>void 0!==Po(T,m,y));return b?[vd(Po(b,m,y))]:void 0}case"Enter":{const b=gt("frameName",p,m,y),T=gt("tensor",p,m,y);return y.enterFrame(b),[vd(T)]}case"Exit":{const b=gt("tensor",p,m,y);return y.exitFrame(),[vd(b)]}case"NextIteration":{const b=gt("tensor",p,m,y);return y.nextIteration(),[vd(b)]}case"TensorArrayV3":{const b=gt("size",p,m,y),T=gt("dtype",p,m,y),R=gt("elementShape",p,m,y),L=gt("dynamicSize",p,m,y),V=gt("clearAfterRead",p,m,y),j=gt("identicalElementShapes",p,m,y),H=gt("name",p,m,y),nt=new QM(H,T,b,R,j,L,V);return y.addTensorArray(nt),[nt.idTensor,Jn(1)]}case"TensorArrayWriteV3":{const b=gt("tensorArrayId",p,m,y),T=gt("index",p,m,y),R=gt("tensor",p,m,y),L=y.getTensorArray(b.id);return L.write(T,R),[L.idTensor]}case"TensorArrayReadV3":{const b=gt("tensorArrayId",p,m,y),T=gt("index",p,m,y);return[y.getTensorArray(b.id).read(T)]}case"TensorArrayGatherV3":{const b=gt("tensorArrayId",p,m,y),T=gt("indices",p,m,y),R=gt("dtype",p,m,y);return[y.getTensorArray(b.id).gather(T,R)]}case"TensorArrayScatterV3":{const b=gt("tensorArrayId",p,m,y),T=gt("indices",p,m,y),R=gt("tensor",p,m,y),L=y.getTensorArray(b.id);return L.scatter(T,R),[L.idTensor]}case"TensorArrayConcatV3":{const b=gt("tensorArrayId",p,m,y),T=y.getTensorArray(b.id),R=gt("dtype",p,m,y);return[T.concat(R)]}case"TensorArraySplitV3":{const b=gt("tensorArrayId",p,m,y),T=gt("tensor",p,m,y),R=gt("lengths",p,m,y),L=y.getTensorArray(b.id);return L.split(R,T),[L.idTensor]}case"TensorArraySizeV3":{const b=gt("tensorArrayId",p,m,y);return[Jn(y.getTensorArray(b.id).size(),"int32")]}case"TensorArrayCloseV3":{const b=gt("tensorArrayId",p,m,y),T=y.getTensorArray(b.id);return T.clearAndClose(),[T.idTensor]}case"TensorListSetItem":{const b=gt("tensorListId",p,m,y),T=gt("index",p,m,y),R=gt("tensor",p,m,y),L=y.getTensorList(b.id);return L.setItem(T,R),[L.idTensor]}case"TensorListGetItem":{const b=gt("tensorListId",p,m,y),T=gt("index",p,m,y),R=gt("elementShape",p,m,y),L=gt("elementDType",p,m,y);return[y.getTensorList(b.id).getItem(T,R,L)]}case"TensorListScatterV2":case"TensorListScatter":{const b=gt("indices",p,m,y),T=function(R,L,V,j){if(L.length!==R.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${L.length} vs. ${R.shape[0]}`);const H=Math.max(...L);if(null!=j&&-1!==j&&H>=j)throw new Error(`Max index must be < array size (${H}  vs. ${j})`);const nt=new RA([],V,R.dtype,j),dt=oo(R,0);return L.forEach((yt,kt)=>{nt.setItem(yt,dt[kt])}),nt}(gt("tensor",p,m,y),b,gt("elementShape",p,m,y),gt("numElements",p,m,y));return y.addTensorList(T),[T.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const b=gt("elementShape",p,m,y),T=gt("elementDType",p,m,y);let R;R="TensorListReserve"===p.op?"numElements":"maxNumElements";const L=(V=b,j=T,H=gt(R,p,m,y),new RA([],V,j,H));return y.addTensorList(L),[L.idTensor]}case"TensorListGather":{const b=gt("tensorListId",p,m,y),T=gt("indices",p,m,y),R=gt("elementShape",p,m,y),L=gt("elementDType",p,m,y);return[y.getTensorList(b.id).gather(T,L,R)]}case"TensorListStack":{const b=gt("tensorListId",p,m,y),T=gt("elementShape",p,m,y),R=gt("elementDType",p,m,y),L=gt("numElements",p,m,y);return[y.getTensorList(b.id).stack(T,R,L)]}case"TensorListFromTensor":{const b=function(T,R,L){const V=T.dtype;if(T.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${T.shape}`);if(T.dtype!==L)throw new Error(`Invalid data types; op elements ${T.dtype}, but list elements ${L}`);Oc(T.shape.slice(1),R,"TensorList shape mismatch: ");const j=oo(T);return new RA(j,R,V)}(gt("tensor",p,m,y),gt("elementShape",p,m,y),gt("elementDType",p,m,y));return y.addTensorList(b),[b.idTensor]}case"TensorListConcat":{const b=gt("tensorListId",p,m,y),T=y.getTensorList(b.id),R=gt("dtype",p,m,y),L=gt("elementShape",p,m,y);return[T.concat(R,L)]}case"TensorListPushBack":{const b=gt("tensorListId",p,m,y),T=gt("tensor",p,m,y),R=y.getTensorList(b.id);return R.pushBack(T),[R.idTensor]}case"TensorListPopBack":{const b=gt("tensorListId",p,m,y),T=gt("elementShape",p,m,y),R=gt("elementDType",p,m,y);return[y.getTensorList(b.id).popBack(T,R)]}case"TensorListSplit":{const b=gt("tensor",p,m,y),T=gt("elementShape",p,m,y),R=function(L,V,j){let H=0;const nt=V.map(Nt=>(H+=Nt,H));if(H!==L.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${H}, and tensor's shape is: ${L.shape}`);const dt=Zw(L.shape.slice(1),j),yt=0===H?0:L.size/H,kt=me(()=>{const Nt=[];L=le(L,[1,H,yt]);for(let Vt=0;Vt<V.length;++Vt)Nt[Vt]=le(Gr(L,[0,0===Vt?0:nt[Vt-1],0],[1,V[Vt],yt]),dt);return L.dispose(),Nt}),Ot=new RA([],j,L.dtype,V.length);for(let Nt=0;Nt<kt.length;Nt++)Ot.setItem(Nt,kt[Nt]);return Ot}(b,gt("lengths",p,m,y),T);return y.addTensorList(R),[R.idTensor]}default:throw TypeError(`Node type ${p.op} is not implemented`)}var V,j,H})(o,u,h);case"convolution":return me(()=>((p,m,y)=>{switch(p.op){case"Conv1D":{const b=gt("stride",p,m,y),T=gt("pad",p,m,y),R=gt("dataFormat",p,m,y).toUpperCase(),L=gt("dilation",p,m,y);return[Bf(gt("x",p,m,y),gt("filter",p,m,y),b,T,R,L)]}case"Conv2D":{const b=gt("strides",p,m,y),T=tb(p,m,y),R=gt("dataFormat",p,m,y).toUpperCase(),L=gt("dilations",p,m,y);return[bc(gt("x",p,m,y),gt("filter",p,m,y),[b[1],b[2]],T,R,[L[1],L[2]])]}case"_FusedConv2D":{const{stride:b,pad:T,dataFormat:R,dilations:L,biasArg:V,preluArg:j,activationFunc:H,leakyreluAlpha:nt}=s2(p,m,y);return[Pg({x:gt("x",p,m,y),filter:gt("filter",p,m,y),strides:[b[1],b[2]],pad:T,dataFormat:R,dilations:[L[1],L[2]],bias:V,activation:H,preluActivationWeights:j,leakyreluAlpha:nt})]}case"FusedDepthwiseConv2dNative":{const{stride:b,pad:T,dataFormat:R,dilations:L,biasArg:V,preluArg:j,activationFunc:H,leakyreluAlpha:nt}=s2(p,m,y);return[X1({x:gt("x",p,m,y),filter:gt("filter",p,m,y),strides:[b[1],b[2]],pad:T,dataFormat:R,dilations:[L[1],L[2]],bias:V,activation:H,preluActivationWeights:j,leakyreluAlpha:nt})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const b=gt("outputShape",p,m,y),T=gt("strides",p,m,y),R=tb(p,m,y);return[Nf(gt("x",p,m,y),gt("filter",p,m,y),b,[T[1],T[2]],R)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const b=gt("strides",p,m,y),T=tb(p,m,y),R=gt("dilations",p,m,y),L=gt("dataFormat",p,m,y).toUpperCase();return[du(gt("input",p,m,y),gt("filter",p,m,y),[b[1],b[2]],T,L,[R[1],R[2]])]}case"Conv3D":{const b=gt("strides",p,m,y),T=gt("pad",p,m,y),R=gt("dataFormat",p,m,y).toUpperCase(),L=gt("dilations",p,m,y);return[wg(gt("x",p,m,y),gt("filter",p,m,y),[b[1],b[2],b[3]],T,R,[L[1],L[2],L[3]])]}case"AvgPool":{const b=gt("strides",p,m,y),T=gt("pad",p,m,y),R=gt("kernelSize",p,m,y);return[up(gt("x",p,m,y),[R[1],R[2]],[b[1],b[2]],T)]}case"MaxPool":{const b=gt("strides",p,m,y),T=gt("pad",p,m,y),R=gt("kernelSize",p,m,y);return[eh(gt("x",p,m,y),[R[1],R[2]],[b[1],b[2]],T)]}case"MaxPoolWithArgmax":{const b=gt("strides",p,m,y),T=gt("pad",p,m,y),R=gt("kernelSize",p,m,y),L=gt("includeBatchInIndex",p,m,y),{result:V,indexes:j}=F0(gt("x",p,m,y),[R[1],R[2]],[b[1],b[2]],T,L);return[V,j]}case"AvgPool3D":{const b=gt("strides",p,m,y),T=gt("pad",p,m,y),R=gt("kernelSize",p,m,y);return[Ku(gt("x",p,m,y),[R[1],R[2],R[3]],[b[1],b[2],b[3]],T)]}case"MaxPool3D":{const b=gt("strides",p,m,y),T=gt("pad",p,m,y),R=gt("kernelSize",p,m,y);return[nh(gt("x",p,m,y),[R[1],R[2],R[3]],[b[1],b[2],b[3]],T)]}case"Dilation2D":{const b=gt("strides",p,m,y),T=gt("pad",p,m,y),R=gt("dilations",p,m,y),L=b[1],V=b[2],j=R[1],H=R[2];return[Cg(gt("x",p,m,y),gt("filter",p,m,y),[L,V],T,[j,H],"NHWC")]}default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"creation":return me(()=>((p,m,y)=>{switch(p.op){case"Fill":{const b=gt("shape",p,m,y),T=gt("dtype",p,m,y);return[op(b,gt("value",p,m,y),T)]}case"LinSpace":return[Sg(gt("start",p,m,y),gt("stop",p,m,y),gt("num",p,m,y))];case"Multinomial":{const b=gt("logits",p,m,y),T=gt("numSamples",p,m,y),R=gt("seed",p,m,y);return[Gf(b,T,R)]}case"OneHot":{const b=gt("indices",p,m,y),T=gt("depth",p,m,y),R=gt("onValue",p,m,y),L=gt("offValue",p,m,y);return[zh(b,T,R,L)]}case"Ones":return[Ea(gt("shape",p,m,y),gt("dtype",p,m,y))];case"OnesLike":return[so(gt("x",p,m,y))];case"RandomUniform":return[gu(gt("shape",p,m,y),gt("minval",p,m,y),gt("maxval",p,m,y),gt("dtype",p,m,y))];case"Range":return[Zl(gt("start",p,m,y),gt("stop",p,m,y),gt("step",p,m,y),gt("dtype",p,m,y))];case"TruncatedNormal":{const b=gt("shape",p,m,y),T=gt("mean",p,m,y),R=gt("stdDev",p,m,y),L=gt("seed",p,m,y);return[lh(b,T,R,gt("dtype",p,m,y),L)]}case"Zeros":return[$s(gt("shape",p,m,y),gt("dtype",p,m,y))];case"ZerosLike":return[zr(gt("x",p,m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"dynamic":return(async(p,m,y)=>{switch(p.op){case"NonMaxSuppressionV5":{const{boxes:b,scores:T,maxOutputSize:R,iouThreshold:L,scoreThreshold:V,softNmsSigma:j}=tE(p,m,y),H=await sl.nonMaxSuppressionWithScoreAsync(b,T,R,L,V,j);return[H.selectedIndices,H.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:b,scores:T,maxOutputSize:R,iouThreshold:L,scoreThreshold:V}=tE(p,m,y),j=gt("padToMaxOutputSize",p,m,y),H=await sl.nonMaxSuppressionPaddedAsync(b,T,R,L,V,j);return[H.selectedIndices,H.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:b,scores:T,maxOutputSize:R,iouThreshold:L,scoreThreshold:V}=tE(p,m,y);return[await sl.nonMaxSuppressionAsync(b,T,R,L,V)]}case"Where":{const b=yn(gt("condition",p,m,y),"bool"),T=[await _p(b)];return b.dispose(),T}case"ListDiff":return H1(gt("x",p,m,y),gt("y",p,m,y));default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h);case"evaluation":return me(()=>((p,m,y)=>{switch(p.op){case"TopKV2":{const b=gt("x",p,m,y),T=gt("k",p,m,y),R=gt("sorted",p,m,y),L=Mp(b,T,R);return[L.values,L.indices]}case"Unique":{const b=gt("x",p,m,y),T=sd(b);return[T.values,T.indices]}case"UniqueV2":{const b=gt("x",p,m,y),T=gt("axis",p,m,y),R=sd(b,T);return[R.values,R.indices]}default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"image":return me(()=>((p,m,y)=>{switch(p.op){case"ResizeBilinear":{const b=gt("images",p,m,y),T=gt("size",p,m,y),R=gt("alignCorners",p,m,y),L=gt("halfPixelCenters",p,m,y);return[sl.resizeBilinear(b,[T[0],T[1]],R,L)]}case"ResizeNearestNeighbor":{const b=gt("images",p,m,y),T=gt("size",p,m,y),R=gt("alignCorners",p,m,y),L=gt("halfPixelCenters",p,m,y);return[sl.resizeNearestNeighbor(b,[T[0],T[1]],R,L)]}case"CropAndResize":{const b=gt("image",p,m,y),T=gt("boxes",p,m,y),R=gt("boxInd",p,m,y),L=gt("cropSize",p,m,y),V=gt("method",p,m,y),j=gt("extrapolationValue",p,m,y);return[sl.cropAndResize(b,T,R,L,V,j)]}default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"graph":return me(()=>((p,m,y)=>{switch(p.op){case"Const":return m[p.name];case"PlaceholderWithDefault":const b=gt("default",p,m,y);return[Po(p.name,m,y)||b];case"Placeholder":return[Po(p.name,m,y)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[vd(gt("x",p,m,y))];case"IdentityN":return gt("x",p,m,y).map(j=>vd(j));case"Shape":return[Yi(gt("x",p,m,y).shape,"int32")];case"ShapeN":return gt("x",p,m,y).map(j=>Yi(j.shape));case"Size":return[Jn(gt("x",p,m,y).size,"int32")];case"Rank":return[Jn(gt("x",p,m,y).rank,"int32")];case"NoOp":return[Jn(1)];case"Print":const T=gt("x",p,m,y),R=gt("data",p,m,y),L=gt("message",p,m,y),V=gt("summarize",p,m,y);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(L);for(let j=0;j<R.length;j++)console.log(Array.prototype.slice.call(R[j].dataSync()).slice(0,V));return[T];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"logical":return me(()=>((p,m,y)=>{switch(p.op){case"Equal":return[Bo(gt("a",p,m,y),gt("b",p,m,y))];case"NotEqual":return[mu(gt("a",p,m,y),gt("b",p,m,y))];case"Greater":return[ia(gt("a",p,m,y),gt("b",p,m,y))];case"GreaterEqual":return[wo(gt("a",p,m,y),gt("b",p,m,y))];case"Less":return[xc(gt("a",p,m,y),gt("b",p,m,y))];case"LessEqual":return[Cl(gt("a",p,m,y),gt("b",p,m,y))];case"LogicalAnd":return[wa(gt("a",p,m,y),gt("b",p,m,y))];case"LogicalNot":return[Ap(gt("a",p,m,y))];case"LogicalOr":return[yp(gt("a",p,m,y),gt("b",p,m,y))];case"Select":case"SelectV2":return[Us(gt("condition",p,m,y),gt("a",p,m,y),gt("b",p,m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"matrices":return me(()=>((p,m,y)=>{switch(p.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Or(gt("a",p,m,y),gt("b",p,m,y),gt("transposeA",p,m,y),gt("transposeB",p,m,y))];case"Einsum":return[N0(gt("equation",p,m,y),...gt("tensors",p,m,y))];case"Transpose":return[qr(gt("x",p,m,y),gt("perm",p,m,y))];case"_FusedMatMul":const[b,T]=gt("fusedOps",p,m,y),R="biasadd"===b,L="prelu"===T,V=gt("numArgs",p,m,y),j=gt("leakyreluAlpha",p,m,y);if(R){if(L&&2!==V)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!L&&1!==V)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[H,nt]=gt("args",p,m,y);return[Au({a:gt("a",p,m,y),b:gt("b",p,m,y),transposeA:gt("transposeA",p,m,y),transposeB:gt("transposeB",p,m,y),bias:H,activation:T,preluActivationWeights:nt,leakyreluAlpha:j})];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"normalization":return me(()=>((p,m,y)=>{switch(p.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Kl(gt("x",p,m,y),gt("mean",p,m,y),gt("variance",p,m,y),gt("offset",p,m,y),gt("scale",p,m,y),gt("epsilon",p,m,y))];case"LRN":return[Da(gt("x",p,m,y),gt("radius",p,m,y),gt("bias",p,m,y),gt("alpha",p,m,y),gt("beta",p,m,y))];case"Softmax":return[Ic(gt("x",p,m,y))];case"LogSoftmax":return[th(gt("x",p,m,y))];case"SparseToDense":return[Lg(gt("sparseIndices",p,m,y),gt("outputShape",p,m,y),gt("sparseValues",p,m,y),gt("defaultValue",p,m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"reduction":return me(()=>((p,m,y)=>{switch(p.op){case"Max":{const L=gt("axis",p,m,y),V=gt("keepDims",p,m,y);return[Eo(gt("x",p,m,y),L,V)]}case"Mean":{const L=gt("axis",p,m,y),V=gt("keepDims",p,m,y);return[fs(gt("x",p,m,y),L,V)]}case"Min":{const L=gt("axis",p,m,y),V=gt("keepDims",p,m,y);return[vp(gt("x",p,m,y),L,V)]}case"Sum":{const L=gt("axis",p,m,y),V=gt("keepDims",p,m,y);return[Vn(gt("x",p,m,y),L,V)]}case"All":{const L=gt("axis",p,m,y),V=gt("keepDims",p,m,y);return[Ag(gt("x",p,m,y),L,V)]}case"Any":{const L=gt("axis",p,m,y),V=gt("keepDims",p,m,y);return[Wh(gt("x",p,m,y),L,V)]}case"ArgMax":{const L=gt("axis",p,m,y);return[cu(gt("x",p,m,y),L)]}case"ArgMin":{const L=gt("axis",p,m,y);return[I0(gt("x",p,m,y),L)]}case"Prod":{const L=gt("axis",p,m,y),V=gt("keepDims",p,m,y);return[Cp(gt("x",p,m,y),L,V)]}case"Cumsum":{const L=gt("axis",p,m,y),V=gt("exclusive",p,m,y),j=gt("reverse",p,m,y);return[Df(gt("x",p,m,y),L,V,j)]}case"Bincount":const b=gt("x",p,m,y),T=gt("weights",p,m,y),R=gt("size",p,m,y);return[dp(b,T,R)];case"DenseBincount":{const L=gt("x",p,m,y),V=gt("weights",p,m,y),j=gt("size",p,m,y),H=gt("binaryOutput",p,m,y);return[Eg(L,V,j,H)]}default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"slice_join":return me(()=>((p,m,y)=>{switch(p.op){case"ConcatV2":case"Concat":{const b=gt("n",p,m,y),T=gt("axis",p,m,y);let R=gt("tensors",p,m,y);return R=R.slice(0,b),[ti(R,T)]}case"Gather":{const b=gt("x",p,m,y),T=gt("indices",p,m,y);return[Kh(b,yn(T,"int32"),0)]}case"GatherV2":{const b=gt("axis",p,m,y),T=gt("batchDims",p,m,y),R=gt("x",p,m,y),L=gt("indices",p,m,y);return[Kh(R,yn(L,"int32"),b,T)]}case"Reverse":{const b=gt("dims",p,m,y),T=[];for(let L=0;L<b.length;L++)b[L]&&T.push(L);const R=gt("x",p,m,y);return[Qa(R,T)]}case"ReverseV2":{const b=gt("axis",p,m,y),T=gt("x",p,m,y);return[Qa(T,b)]}case"Slice":{const b=gt("begin",p,m,y),T=gt("size",p,m,y);return[Gr(gt("x",p,m,y),b,T)]}case"StridedSlice":{const b=gt("begin",p,m,y),T=gt("end",p,m,y),R=gt("strides",p,m,y),L=gt("beginMask",p,m,y),V=gt("endMask",p,m,y),j=gt("ellipsisMask",p,m,y),H=gt("newAxisMask",p,m,y),nt=gt("shrinkAxisMask",p,m,y),dt=gt("x",p,m,y);return[id(dt,b,T,R,L,V,j,H,nt)]}case"Pack":return me(()=>{const b=gt("axis",p,m,y),T=gt("tensors",p,m,y),R=T[0].shape,L=Lo(T[0]).shape,V=T.map(j=>{const H=We(j.shape,R);if(!H&&!We(Lo(j).shape,L))throw new Error("the input tensors shape does not match");return H?j:le(j,R)});return[Co(V,b)]});case"Unpack":{const b=gt("axis",p,m,y),T=gt("tensor",p,m,y);return oo(T,b)}case"Tile":{const b=gt("reps",p,m,y);return[xo(gt("x",p,m,y),b)]}case"Split":case"SplitV":{const b=gt("axis",p,m,y),T=gt("numOrSizeSplits",p,m,y),R=gt("x",p,m,y);return ao(R,T,b)}case"ScatterNd":{const b=gt("indices",p,m,y),T=gt("values",p,m,y),R=gt("shape",p,m,y);return[W0(b,T,R)]}case"GatherNd":{const b=gt("x",p,m,y),T=gt("indices",p,m,y);return[kp(b,T)]}case"SparseToDense":{const b=gt("sparseIndices",p,m,y),T=gt("outputShape",p,m,y),R=gt("sparseValues",p,m,y),L=gt("defaultValue",p,m,y);return[Lg(b,R,T,R.dtype===L.dtype?L:yn(L,R.dtype))]}default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"sparse":return me(()=>((p,m,y)=>{switch(p.op){case"SparseFillEmptyRows":{const{outputIndices:b,outputValues:T,emptyRowIndicator:R,reverseIndexMap:L}=Lp.sparseFillEmptyRows(gt("indices",p,m,y),gt("values",p,m,y),gt("denseShape",p,m,y),gt("defaultValue",p,m,y));return[b,T,R,L]}case"SparseReshape":{const{outputIndices:b,outputShape:T}=Lp.sparseReshape(gt("inputIndices",p,m,y),gt("inputShape",p,m,y),gt("newShape",p,m,y));return[b,T]}case"SparseSegmentMean":return[Lp.sparseSegmentMean(gt("data",p,m,y),gt("indices",p,m,y),gt("segmentIds",p,m,y))];case"SparseSegmentSum":return[Lp.sparseSegmentSum(gt("data",p,m,y),gt("indices",p,m,y),gt("segmentIds",p,m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"spectral":return me(()=>((p,m,y)=>{switch(p.op){case"FFT":return[Kf(gt("x",p,m,y))];case"IFFT":return[Hi(gt("x",p,m,y))];case"RFFT":return[ah(gt("x",p,m,y))];case"IRFFT":return[ed(gt("x",p,m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"string":return me(()=>((p,m,y)=>{switch(p.op){case"StringNGrams":{const{nGrams:b,nGramsSplits:T}=om.stringNGrams(gt("data",p,m,y),gt("dataSplits",p,m,y),gt("separator",p,m,y),gt("nGramWidths",p,m,y),gt("leftPad",p,m,y),gt("rightPad",p,m,y),gt("padWidth",p,m,y),gt("preserveShortSequences",p,m,y));return[b,T]}case"StringSplit":{const{indices:b,values:T,shape:R}=om.stringSplit(gt("input",p,m,y),gt("delimiter",p,m,y),gt("skipEmpty",p,m,y));return[b,T,R]}case"StringToHashBucketFast":return[om.stringToHashBucketFast(gt("input",p,m,y),gt("numBuckets",p,m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"transformation":return me(()=>((p,m,y)=>{switch(p.op){case"Cast":return[yn(gt("x",p,m,y),gt("dtype",p,m,y))];case"ExpandDims":{const b=gt("axis",p,m,y);return[xa(gt("x",p,m,y),b)]}case"Squeeze":{const b=gt("axis",p,m,y);return[Lo(gt("x",p,m,y),b)]}case"Reshape":return[le(gt("x",p,m,y),gt("shape",p,m,y))];case"MirrorPad":return[nl(gt("x",p,m,y),gt("padding",p,m,y),gt("mode",p,m,y))];case"PadV2":case"Pad":return[wc(gt("x",p,m,y),gt("padding",p,m,y),gt("constantValue",p,m,y))];case"SpaceToBatchND":{const b=gt("blockShape",p,m,y),T=gt("paddings",p,m,y);return[wp(gt("x",p,m,y),b,T)]}case"BatchToSpaceND":{const b=gt("blockShape",p,m,y),T=gt("crops",p,m,y);return[vc(gt("x",p,m,y),b,T)]}case"DepthToSpace":{const b=gt("blockSize",p,m,y),T=gt("dataFormat",p,m,y).toUpperCase();return[Lf(gt("x",p,m,y),b,T)]}case"BroadcastTo":return[hu(gt("x",p,m,y),gt("shape",p,m,y))];case"BroadcastArgs":return[pp(gt("s0",p,m,y),gt("s1",p,m,y))];default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h));case"hash_table":return(async(p,m,y,b)=>{switch(p.op){case"HashTable":case"HashTableV2":{const T=gt("keyDType",p,m,y),R=gt("valueDType",p,m,y),L=new HM(T,R);return b.addHashTable(p.name,L),[L.handle]}case"LookupTableImport":case"LookupTableImportV2":{const T=gt("tableHandle",p,m,y,b),R=gt("keys",p,m,y),L=gt("values",p,m,y);return[await b.getHashTableById(T.id).import(R,L)]}case"LookupTableFind":case"LookupTableFindV2":{const T=gt("tableHandle",p,m,y,b),R=gt("keys",p,m,y),L=gt("defaultValue",p,m,y);return[await b.getHashTableById(T.id).find(R,L)]}case"LookupTableSize":case"LookupTableSizeV2":{const T=gt("tableHandle",p,m,y,b);return[b.getHashTableById(T.id).tensorSize()]}default:throw TypeError(`Node type ${p.op} is not implemented`)}})(o,u,h,i);case"custom":const f=ZE(o.op);if(f&&f.customExecutor)return f.customExecutor(new GM(o,u,h));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,n);return ci(a)?a.then(o=>[].concat(o)):[].concat(a)}class o2{constructor(t={},n={},i={},a={}){this.weightMap=t,this.tensorArrayMap=n,this.tensorListMap=i,this.functionMap=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let n=0;n<this.contexts.length-1;n++){const i=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(i))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>0===n.id&&0===n.iterationId?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(t);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(t)}}function l2(r,t,n,i){const a=new Set,o=[];let u=null,h=null;const f=new Set,p=Object.keys(r).map(b=>Bl(b)[0]);let m=[];null!=i&&(m=i.map(b=>Bl(b.name)[0]));const y=[...t];for(;y.length>0;){const b=y.pop();(c2(b)||XM(b)||YM(b))&&null==u&&(u=b,h=u.children.map(T=>T.name).filter(T=>a.has(T))),a.add(b.name),null==n[b.name]&&-1===p.indexOf(b.name)&&-1===m.indexOf(b.name)&&(0!==b.inputs.length?b.inputs.forEach(T=>{f.has(T.name)||(f.add(T.name),y.push(T))}):o.push(b.name))}return{inputs:r,outputs:t,usedNodes:a,missingInputs:o,dynamicNode:u,syncInputs:h}}const WM=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],jM=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],qM=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function c2(r){return WM.indexOf(r.op)>=0}function XM(r){return jM.indexOf(r.op)>=0}function YM(r){return qM.indexOf(r.op)>=0}class eb{constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(i=>{this._functionExecutorMap[i]=new eb(t.functions[i],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const n=Object.keys(t).map(i=>t[i].map(a=>a.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}getCompilationKey(t,n){const i=t.map(o=>o.name).sort(),a=n.map(o=>o.name).sort();return i.join(this.SEPERATOR)+"--"+a.join(this.SEPERATOR)}compile(t,n){const i=l2(t,n,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:o,syncInputs:u}=i;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${u}]`);if(a.length>0){const h=n.map(p=>p.name),f=Object.keys(t);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${f}]. Missing the following inputs: [${a}]`)}return function(h,f,p){const{usedNodes:m,inputs:y}=p,b=[],T=Object.keys(y).map(j=>Bl(j)[0]).map(j=>h.nodes[j]),R=h.initNodes;T.forEach(j=>{m.has(j.name)&&b.push(j)}),h.weights.forEach(j=>{m.has(j.name)&&b.push(j)}),R?.forEach(j=>{m.has(j.name)&&b.push(j)});const L=new Set,V=[];for(;b.length>0;){const j=b.pop();L.add(j.name),f[j.name]||V.push(j),j.children.forEach(H=>{!L.has(H.name)&&m.has(H.name)&&H.inputs.every(nt=>L.has(nt.name))&&b.push(H)})}return V}(this.graph,this.weightMap,i)}execute(t,n){t=this.mapInputs(t);const i=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);const a=i.map(y=>this.graph.nodes[Bl(y)[0]]),o=n.map(y=>Bl(y)[0]);let u=o.map(y=>this.graph.nodes[y]);this.resetIntermediateTensors(),0===u.length&&(u=this._outputs);const h=this.getCompilationKey(a,u);let f=this.compiledMap.get(h);null==f&&(f=this.compile(t,u),this.compiledMap.set(h,f));const p={},m={};return me(()=>{const y=new o2(this.weightMap,p,m,this.functionExecutorMap),b=Object.assign({},this.weightMap);Object.keys(t).forEach(L=>{const[V,j]=Bl(L),H=[];H[j]=t[L],b[V]=H});const T=this.getFrozenTensorIds(b),R={};for(let L=0;L<f.length;L++){const V=f[L];if(!b[V.name]){const j=a2(V,b,y,this._resourceManager);if(ci(j))throw new Error(`The execution of the op '${V.op}' returned a promise. Please use model.executeAsync() instead.`);b[V.name]=j,this.checkTensorForDisposal(V.name,V,b,y,T,o,R)}}return null==this.parent&&y.dispose(T),n.map(L=>Po(L,b,y))})}getFrozenTensorIds(t){const n=[].concat.apply([],Object.keys(t).map(i=>t[i]).map(i=>i.map(a=>a.id)));return new Set(n)}checkTensorForDisposal(t,n,i,a,o,u,h){"control"!==n.category&&-1===u.indexOf(t)&&(i[t].forEach(f=>{null!=f&&(h[f.id]=(h[f.id]||0)+n.children.length)}),n.inputs.forEach(f=>{if("control"!==f.category){const p=i[Zv(f.name,a.currentContextId)];p?.forEach(m=>{if(m&&!m.kept&&!o.has(m.id)){const y=h[m.id];if(1===y){if(this.keepTensorForDebug){const[b,T]=vh(n.name,a);this.intermediateTensors[b]||(this.intermediateTensors[b]=[]),this.intermediateTensors[b][T]=m}else m.dispose();delete h[m.id]}else null!=y&&h[m.id]--}})}}))}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(n=>n.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach(t=>{this.tensorsMap[t].forEach(n=>{!n||n.kept||n.isDisposed||this.keepIds.has(n.id)||n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const t in this.intermediateTensors)this.intermediateTensors[t].forEach(n=>n.dispose()),delete this.intermediateTensors[t]}async _executeAsync(t,n,i=!1,a={},o={}){i||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepTensorForDebug=de().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){console.warn(m.message)}this.resetIntermediateTensors();const u=new o2(this.weightMap,a,o,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(t,u,n,i);const h=n.map(m=>Po(m,this.tensorsMap,u)),f=h.map(m=>m.id),p=Object.keys(t).map(m=>t[m].id);return this.keepIds=new Set([...f,...p,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&u.dispose(this.keepIds),h}async executeFunctionAsync(t,n,i){const a=t.reduce((o,u,h)=>(o[this.inputs[h].name]=u,o),{});return this._executeAsync(a,this.outputNodes,!0,n,i)}async executeWithControlFlow(t,n,i,a){const o=Object.keys(t),u=o.map(nt=>this.graph.nodes[Bl(nt)[0]]),h=i.map(nt=>Bl(nt)[0]);let f=h.map(nt=>this.graph.nodes[nt]);0===f.length&&(f=this._outputs);const{usedNodes:p,missingInputs:m,dynamicNode:y,syncInputs:b}=l2(t,f,this.weightMap,this._initNodes),T=[...u,...this.graph.weights,...this._initNodes||[]].map(nt=>({node:nt,contexts:n.currentContext})),R=Object.assign({},this.weightMap);Object.keys(t).forEach(nt=>{const[dt,yt]=Bl(nt),kt=[];kt[yt]=t[nt],R[dt]=kt});const L={},V=this.getFrozenTensorIds(R),j={};for(;T.length>0;){const nt=this.processStack(u,T,n,R,j,V,h,L,p);await Promise.all(nt)}null!=y||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const H=f.filter(nt=>!c2(nt)&&!Po(nt.name,R,n)).map(nt=>nt.name);if(H.length>0){let nt="";throw null!=y&&(nt=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${b}]`),new Error(`Cannot compute the outputs [${H}] from the provided inputs [${o}]. Consider providing the following inputs: [${m}]. ${nt}`)}return R}processStack(t,n,i,a,o,u,h,f,p){const m=[];for(;n.length>0;){const y=n.pop();i.currentContext=y.contexts;let b="";if("Enter"===y.node.op&&gt("isConstant",y.node,a,i)&&([b]=vh(y.node.name,i)),null==a[y.node.name]){const T=a2(y.node,a,i,this._resourceManager);b||([b]=vh(y.node.name,i));const R=i.currentContext;ci(T)?m.push(T.then(L=>(a[b]=L,i.currentContext=R,this.checkTensorForDisposal(b,y.node,a,i,u,h,f),this.processChildNodes(y.node,n,i,a,o,p),L))):(a[b]=T,this.checkTensorForDisposal(b,y.node,a,i,u,h,f),this.processChildNodes(y.node,n,i,a,o,p))}else this.processChildNodes(y.node,n,i,a,o,p)}return m}processChildNodes(t,n,i,a,o,u){t.children.forEach(h=>{const[f]=vh(h.name,i);!o[f]&&u.has(h.name)&&("Merge"===h.op?h.inputNames.some(p=>!!Po(p,a,i))&&(o[f]=!0,n.push({contexts:i.currentContext,node:h})):h.inputNames.every(p=>!!Po(p,a,i))&&(o[f]=!0,n.push({contexts:i.currentContext,node:h})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{const i=t[n],[a]=Bl(n),o=this.graph.nodes[a];if(o.attrParams.shape&&o.attrParams.shape.value){const u=o.attrParams.shape.value;Z(u.length===i.shape.length&&i.shape.every((h,f)=>-1===u[f]||u[f]===h),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${u}], but was [${i.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&Z(i.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${i.dtype}`)})}mapInputs(t){const n={};for(const i in t)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[i]?n[this._signature.inputs[i].name]=t[i]:n[i]=t[i];return n}checkInputs(t){const n=Object.keys(t).filter(i=>{const[a]=Bl(i);return null==this.graph.nodes[a]});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[n]?this._signature.outputs[n].name:n,{})}checkOutputs(t){t.forEach(n=>{const[i]=Bl(n);if(!this.graph.nodes[i])throw new Error(`The output '${n}' is not found in the graph`)})}}class KM{constructor(t={},n={}){this.hashTableNameToHandle=t,this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class u2{constructor(t,n={}){this.modelUrl=t,this.loadOptions=n,this.version="n/a",null==n&&(this.loadOptions={}),this.resourceManager=new KM}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=su(t,this.loadOptions);else{const n=os(t,this.loadOptions);if(0===n.length)n.push(su(t,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`);this.handler=n[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;const n=this.artifacts.modelTopology;let i;i=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=i,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const a=gf(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new eb(t2.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const o=t2.Instance.transformGraph(t.modelInitializer);this.initializer=new eb(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,n){if("string"==typeof t){const i=np(t);if(0===i.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(i.length>1)throw new Error(`Found more than one (${i.length}) save handlers for URL '${t}'`);t=i[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,n){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof Zr||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((n,i,a)=>(n[i]=t[a],n),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,n){t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const i=this.executor.execute(t,n);return i.length>1?i:i[0]}async executeAsync(t,n){t=this.normalizeInputs(t),n=this.normalizeOutputs(n);const i=await this.executor.executeAsync(t,n);return i.length>1?i:i[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,i)=>(n[i]=[t[i]],n),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function JM(r,t={}){if(null==r)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==r.load&&(r.endsWith("/")||(r+="/"),r=`${r}model.json?tfjs-format=file`);const n=new u2(r,t);return await n.load(),n}const h2="3.13.0";function nb(r,t,n=new Map,i=new Set){if(null==r)return null;if("function"==typeof Blob&&r instanceof Blob)return r.slice();if(i.has(r))throw new Error("Circular references are not supported.");if(n.has(r))return n.get(r);const a=t(r);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(BA(r)){const o=Array.isArray(r)?[]:{};i.add(r);for(const u in r){const h=nb(r[u],t,n,i);o[u]=h}return i.delete(r),r.__proto__&&(o.__proto__=r.__proto__),o}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return n.set(r,a.value),a.value}function ZM(r,t=p2){return d2(r,t)}function d2(r,t,n=new Set){const i=r[0];if(n.has(i))throw new Error("Circular references are not supported.");const a=t(r);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(BA(i)){const o=Array.isArray(i)?[]:{};n.add(i);for(const u in i){const h=d2(r.map(f=>f[u]),t,n);o[u]=h}return n.delete(i),o}throw new Error(`Can't recurse into non-iterable type: ${i}`)}return a.value}function p2(r){return null===r?null:BA(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function f2(r,t){const n=new Map;nb(r,t,n);for(const i of Array.from(n.keys())){const a=n.get(i);if(ci(a)){const o=await a;n.set(i,o)}}return nb(r,t,n)}function BA(r){let t=!1;if(de().get("IS_BROWSER"))t=r instanceof TextDecoder;else{const{StringDecoder:n}=I(4589);t=r instanceof n}return null!=r&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||"object"==typeof r&&!(r instanceof Zr)&&!(r instanceof Promise)&&!t)}function tT(r){return r instanceof Zr?{value:r.clone(),recurse:!1}:BA(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}class m2{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,n){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=n}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const n of t)this.push(n)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const n=this.wrap(this.begin+t),i=this.get(n);return this.set(n,this.pop()),i}}class rb extends m2{constructor(){super(rb.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,n=new Array(t),i=this.length();for(let a=0;a<i;a++)n[a]=this.get(this.wrap(this.begin+a));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=i}}function g2(r){return new eT(r)}function eE(r){return new nT(r)}rb.INITIAL_CAPACITY=32;class ja{async toArray(){const t=[];let n=await this.next();for(;!n.done;)t.push(n.value),n=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),n=[];let i=await t.next();for(;!i.done;)n.push(i.value),i=await t.next();return n}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let n=await this.next(),i=t(n.value);for(;!n.done&&i;)n=await this.next(),i=t(n.value)}handleErrors(t){return new cT(this,t)}filter(t){return new oT(this,t)}map(t){return new lT(this,t)}mapAsync(t){return new A2(this,t)}serialMapAsync(t){return new A2(this,t).serial()}flatmap(t){return new uT(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(n=>!0===n)}rowMajorBatch(t,n=!0){return new aT(this,t,n)}columnMajorBatch(t,n=!0,i=p2){return this.rowMajorBatch(t,n).map(a=>ZM(a,i))}concatenate(t,n){return new y2(g2([this,t]),n)}take(t){return t<0||null==t?this:new sT(this,t)}skip(t){return t<0||null==t?this:new iT(this,t)}prefetch(t){return new v2(this,t)}shuffle(t,n){return new dT(this,t,n)}serial(){return new rT(this)}}class eT extends ja{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:(n=t,i=n,a=tT,nb(i,a)),done:!1};var i,a,n}}class nT extends ja{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class rT extends ja{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class iT extends ja{constructor(t,n){super(),this.upstream=t,this.maxCount=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;Dr(t.value)}return this.upstream.next()}}class sT extends ja{constructor(t,n){super(),this.upstream=t,this.maxCount=n,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class aT extends ja{constructor(t,n,i=!0){super(),this.upstream=t,this.batchSize=n,this.enableSmallLastBatch=i,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}}}class oT extends ja{constructor(t,n){super(),this.upstream=t,this.predicate=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;Dr(t.value)}}}class lT extends ja{constructor(t,n){super(),this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const n=qo(t.value),i=this.transform(t.value),a=qo(i);for(const o of n)$a(o,a)||o.dispose();return{value:i,done:!1}}}class cT extends ja{constructor(t,n){super(),this.upstream=t,this.handler=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class A2 extends ja{constructor(t,n){super(),this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const n=qo(t.value),i=await this.transform(t.value),a=qo(i);for(const o of n)$a(o,a)||o.dispose();return{value:i,done:!1}}}class nE extends ja{constructor(){super(),this.outputQueue=new rb,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class uT extends nE{constructor(t,n){super(),this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const n=qo(t.value),i=this.transform(t.value),a=qo(i);this.outputQueue.pushAll(i);for(const o of n)$a(o,a)||o.dispose();return!0}}class y2 extends ja{constructor(t,n){super(),this.baseErrorHandler=n,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const i=await this.moreIterators.next();if(i.done)return{value:null,done:!0};this.iterator=i.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(t)):n}}var jp;!function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"}(jp||(jp={}));class hT extends ja{constructor(t,n=jp.FAIL){super(),this.iterators=t,this.mismatchMode=n,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let n=0,i=0;const a=await f2(this.iterators,function(o){return o instanceof ja?{value:o.next().then(u=>(n++,u.done&&i++,u.value)),recurse:!1}:{value:null,recurse:!0}});if(n===i)return{value:null,done:!0};if(i>0)switch(this.mismatchMode){case jp.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case jp.SHORTEST:return{value:null,done:!0}}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class v2 extends ja{constructor(t,n){super(),this.upstream=t,this.bufferSize=n,this.buffer=new m2(n)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class dT extends v2{constructor(t,n,i){super(t,n),this.upstream=t,this.windowSize=n,this.upstreamExhausted=!1,this.random=rh.alea(i||ga().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),n=await this.buffer.shuffleExcise(t);if(!n.done)return this.refill(),n;this.upstreamExhausted=!0}return{value:null,done:!0}}}class NA{constructor(){this.size=null}batch(t,n=!0){const i=this;let a;return Z(t>0,()=>`batchSize needs to be positive, but it is\n      ${t}`),a=this.size===1/0||null==this.size?this.size:n?Math.ceil(this.size/t):Math.floor(this.size/t),Nl(async()=>(await i.iterator()).columnMajorBatch(t,n,mT),a)}concatenate(t){const n=this;let i;return i=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,Nl(async()=>(await n.iterator()).concatenate(await t.iterator()),i)}filter(t){const n=this;let i;return i=this.size===1/0?1/0:null,Nl(async()=>(await n.iterator()).filter(a=>me(()=>t(a))),i)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const n=this;return Nl(async()=>(await n.iterator()).map(i=>me(()=>t(i))),this.size)}mapAsync(t){const n=this;return Nl(async()=>(await n.iterator()).mapAsync(t),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const n=this;return Nl(async()=>(await n.iterator()).prefetch(t),this.size)}repeat(t){const n=this;let i;return i=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,Nl(async()=>{return a=eE(async()=>({value:await n.iterator(),done:!1})).take(t),new y2(a,void 0);var a},i)}skip(t){const n=this;let i;return i=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,Nl(async()=>(await n.iterator()).skip(t),i)}shuffle(t,n,i=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const a=this,o=rh.alea(n||ga().toString());return Nl(async()=>{let u=o.int32();return i&&(u+=o.int32()),(await a.iterator()).shuffle(t,u.toString())},this.size)}take(t){const n=this;let i;return i=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,Nl(async()=>(await n.iterator()).take(t),i)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function Nl(r,t=null){return new class extends NA{constructor(){super(...arguments),this.size=t}async iterator(){return r()}}}function pT(r){return Nl(async()=>g2(r),r.length)}function fT(r){if(!BA(r))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(r))for(let n=0;n<r.length;n++)t=null==t?r[n].size:Math.min(t,r[n].size);else if(r instanceof Object)for(const n in r)t=null==t?r[n].size:Math.min(t,r[n].size);return Nl(async()=>function(n,i=jp.FAIL){return new hT(n,i)}(await f2(r,n=>{if(n instanceof NA)return{value:n.iterator(),recurse:!1};if(BA(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),jp.SHORTEST),t)}function mT(r){return null===r?null:null==(t=r[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof Zr||ke(t)?{value:function(i){if(0===i.length)throw new Error("Can't make a batch of zero elements.");return i[0]instanceof Zr?Co(i):Yo(i)}(r),recurse:!1}:{value:null,recurse:!0};var t,n}NA.MAX_BUFFER_SIZE=1e4;class b2 extends NA{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map(t=>(t.endsWith("\r")&&(t=t.slice(0,-1)),t))}}const Ky=Symbol("out"),x2=Symbol("field"),sb=Symbol("quote"),rE=Symbol("quoteafterquote"),w2=Symbol("quoteinquote");class E2 extends NA{constructor(t,n){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new b2(t),n||(n={}),this.hasHeader=!1!==n.hasHeader,this.fullColumnNames=n.columnNames,this.columnConfigs=n.columnConfigs,this.configuredColumnsOnly=n.configuredColumnsOnly,n.delimWhitespace?(Z(null==n.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=n.delimiter?n.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&Z(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);const n=this.fullColumnNames.reduce((a,o)=>(a[o]=a[o]+1||1,a),{}),i=Object.keys(n).filter(a=>n[a]>1);if(Z(0===i.length,()=>"Duplicate column names found: "+i.toString()),this.columnConfigs)for(const a of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(a))throw new Error('The key "'+a+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await this.base.iterator(),n=await t.next();if(n.done)throw new Error("No data was found for CSV parsing.");return this.parseRow(n.value,!1)}return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(n=>this.makeDataElement(n))}makeDataElement(t){const n=this.parseRow(t),i={},a={};for(let o=0;o<this.fullColumnNames.length;o++){const u=this.fullColumnNames[o],h=this.columnConfigs?this.columnConfigs[u]:null;if(!this.configuredColumnsOnly||h){const f=n[o];let p=null;if(""===f)if(h&&void 0!==h.default)p=h.default;else{if(h&&(h.required||h.isLabel))throw new Error(`Required column ${u} is empty in this line: ${t}`);p=void 0}else{const m=Number(f);if(isNaN(m))p=h&&"bool"===h.dtype?this.getBoolean(f):f;else if(h&&h.dtype)switch(h.dtype){case"float32":default:p=m;break;case"int32":p=Math.floor(m);break;case"bool":p=this.getBoolean(f)}else p=m}h&&h.isLabel?a[u]=p:i[u]=p}}return 0===Object.keys(a).length?i:{xs:i,ys:a}}getBoolean(t){return"1"===t||"true"===t.toLowerCase()?1:0}parseRow(t,n=!0){const i=[];let a=0;const o=t.length;let u=Ky;for(let h=0;h<o;h++)switch(u){case Ky:switch(t.charAt(h)){case'"':a=h+1,u=sb;break;case this.delimiter:if(a=h+1," "===this.delimiter&&this.delimWhitespace)break;i.push(""),u=Ky;break;default:u=x2,a=h}break;case x2:t.charAt(h)===this.delimiter&&(i.push(t.substring(a,h)),u=Ky,a=h+1);break;case sb:'"'===t.charAt(h)&&(u=rE);break;case rE:switch(t.charAt(h)){case this.delimiter:i.push(t.substring(a,h-1)),u=Ky,a=h+1;break;case'"':u=sb;break;default:u=w2}break;case w2:'"'===t.charAt(h)&&(u=sb)}if(i.push(u===rE?t.substring(a,o-1):t.substring(a)),n&&i.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${i}`);return i}}class iE extends ja{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;const n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=!1!==t.includeSpectrogram,this.includeWaveform=!0===t.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(de().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");const n=new iE(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(i){throw new Error(`Error thrown while initializing video stream: ${i.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n;const i=await this.getAudioData();if(this.includeSpectrogram){const a=this.flattenQueue(i.freqDataQueue);t=this.getTensorFromAudioDataArray(a,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const a=this.flattenQueue(i.timeDataQueue);n=this.getTensorFromAudioDataArray(a,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const t=[],n=[];let i=0;return new Promise(a=>{const o=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&a({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++i===this.numFrames&&(clearInterval(o),a({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){const n=t[0].length,i=new Float32Array(t.length*n);return t.forEach((a,o)=>i.set(a,o*n)),i}getTensorFromAudioDataArray(t,n){const i=new Float32Array(Wt(n));return i.set(t,i.length-t.length),Yo(i,n)}}class sE extends ja{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Yi([0],"int32"),this.webcamConfig.centerCrop){const i=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,a=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,o=(1-i)/2,u=(1-a)/2;this.cropBox=oh([u,o,a+u,o+i],[1,4])}else this.cropBox=oh([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(de().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}const i=new sE(t,n);return await i.start(),i}async start(){this.webcamConfig.facingMode&&Z("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=d0(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(!this.resize)return{value:t,done:!1};try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(t){return me(()=>{const n=xa(yn(t,"float32"),0);let i;return i=sl.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear"),le(i,i.shape.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class C2{}class I2 extends ja{split(t){return new gT(this,t)}}class gT extends I2{constructor(t,n){super(),this.upstream=t,this.impl=new AT(t,n)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class AT extends nE{constructor(t,n){super(),this.upstream=t,this.separator=n,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const t=await this.upstream.next();if(t.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const n=t.value.split(this.separator);n[0]=this.carryover+n[0];for(const i of n.slice(0,-1))this.outputQueue.push(i);return this.carryover=n[n.length-1],!0}}class yT extends ja{decodeUTF8(){return new vT(this)}}class vT extends I2{constructor(t){super(),this.upstream=t,this.impl=new bT(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class bT extends nE{constructor(t){if(super(),this.upstream=t,de().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:n}=I(4589);this.decoder=new n("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const t=await this.upstream.next();let n,i;return!t.done&&(n=t.value,i=de().get("IS_BROWSER")?this.decoder.decode(n,{stream:!0}):this.decoder.write(Buffer.from(n.buffer)),this.outputQueue.push(i),!0)}}class S2 extends yT{constructor(t,n={}){super(),this.file=t,this.options=n,Z(t instanceof Uint8Array||!!de().get("IS_BROWSER")&&(t instanceof File||t instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=n.offset||0,this.chunkSize=n.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((n,i)=>{const a=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)n(new Uint8Array(this.file.slice(this.offset,a)));else{const o=new FileReader;o.onload=h=>{let f=o.result;if(f instanceof ArrayBuffer&&(f=new Uint8Array(f)),!(f instanceof Uint8Array))return i(new TypeError("FileReader returned unknown type."));n(f)},o.onabort=h=>i(new Error("Aborted")),o.onerror=h=>i(new Error(h.type));const u=this.file.slice(this.offset,a);o.readAsArrayBuffer(u)}this.offset=a}),done:!1}}}function M2(r){return"string"==typeof r&&"file://"===r.substr(0,7)}class T2 extends C2{constructor(t,n={}){super(),this.input=t,this.options=n}async iterator(){if(M2(this.input)&&de().get("IS_NODE")){const t=I(2993);this.input=t.readFileSync(this.input.substr(7))}return new S2(this.input,this.options)}}class _2 extends C2{constructor(t,n={}){super(),this.url=t,this.fileOptions=n}async iterator(){return M2(this.url)?new T2(this.url,this.fileOptions).iterator():async function(t,n={},i){let a,o;var u;"string"==typeof t?a=t:(a=t.url,o={method:(u=t).method,headers:u.headers,body:u.body,mode:u.mode,credentials:u.credentials,cache:u.cache,redirect:u.redirect,referrer:u.referrer,integrity:u.integrity});const h=await(i||t0)(a,o);if(h.ok){const f=new Uint8Array(await h.arrayBuffer());return new S2(f,n)}throw new Error(h.statusText)}(this.url,this.fileOptions)}}function xT(r,t={}){return new E2(new _2(r),t)}function wT(r){const t=eE(r);return Nl(async()=>t)}function ET(r){return Nl(async()=>{const t=await r();return eE(()=>t.next())})}async function CT(r,t){return sE.create(r,t)}async function IT(r){return iE.create(r)}const k2="3.13.0";function Hn(r,t){Array.isArray(r)||(r=[r]),r.forEach(n=>{null!=n&&Z("complex64"!==n.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const ST=ad;class ab extends Ya{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Xa(this,au())}nextDataId(){return ab.nextDataId++}write(t,n,i){this.firstUse&&(this.firstUse=!1,de().get("IS_NODE")&&Fs("\n============================\nHi there \u{1f44b}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:t,dtype:i,refCount:1}),a}makeTensorInfo(t,n,i){let a;if("string"===n&&null!=i&&i.length>0&&bn(i[0])){const o=i.map(u=>jl(u));a=this.write(o,t,n)}else a=this.write(i,t,n);return{dataId:a,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,n,i,a,o){this.data.set(t,{values:n,dtype:a,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:i}=this.data.get(t);return"complex64"===n?wu(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.data.get(t).values}bufferSync(t){const n=this.readSync(t.dataId);let i=n;if("string"===t.dtype)try{i=n.map(a=>Dh(a))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return $r(t.shape,t.dtype,i)}makeOutput(t,n,i){const a=this.write(t,n,i);return au().makeTensorFromDataId(a,n,i,this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:i}=this.data.get(t);null!=i&&(this.disposeData(i.real.dataId,!0),this.disposeData(i.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=ga();return t(),{kernelMs:ga()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Hn([t],"where");const n=this.readSync(t.dataId);return ST(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function ji(r,t,n){return({inputs:i,attrs:a,backend:o})=>{const{x:u}=i;if(Hn(u,r),"string"===u.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const h=o,f=h.data.get(u.dataId).values,p=Wt(u.shape),m=n||u.dtype,y=jt(m,p);for(let b=0;b<p;++b)y[b]=t(f[b],a);return h.makeTensorInfo(u.shape,m,y)}}function DA(r,t,n){return({inputs:i,attrs:a,backend:o})=>{const{x:u}=i;if(Hn(u,r),"string"===u.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const h=o,f=h.data.get(u.dataId).values,p=n||u.dtype,m=t(f,p,a);return h.makeTensorInfo(u.shape,p,m)}}ab.nextDataId=0,cg("cpu",()=>new ab,1);const R2=ji(yo,r=>r>=0?r:Math.exp(r)-1),MT={kernelName:yo,backendName:"cpu",kernelFunc:R2};function bh(r){const{inputs:t,backend:n}=r,{x:i}=t;return n.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const TT={kernelName:Sd,backendName:"cpu",kernelFunc:bh};function B2(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{alpha:o}=i;Hn([a],"leakyRelu");const u=Wt(a.shape),h=n.data.get(a.dataId).values,f=Ut("float32",u);for(let p=0;p<h.length;p++)f[p]=h[p]<0?o*h[p]:h[p];return n.makeTensorInfo(a.shape,"float32",f)}const _T={kernelName:Kp,backendName:"cpu",kernelFunc:B2};function Ma(r){return(t,n,i,a,o)=>{const u=Nr(t,n),h=u.length,f=gn(u),p=Ut(o,Wt(u)),m=t.length,y=n.length,b=gn(t),T=gn(n),R=$h(t,u),L=$h(n,u);if(R.length+L.length===0)for(let V=0;V<p.length;++V)p[V]=r(i[V%i.length],a[V%a.length]);else for(let V=0;V<p.length;++V){const j=ai(V,h,f),H=j.slice(-m);R.forEach(kt=>H[kt]=0);const nt=cr(H,m,b),dt=j.slice(-y);L.forEach(kt=>dt[kt]=0);const yt=cr(dt,y,T);p[V]=r(i[nt],a[yt])}return[p,u]}}const kT=Ma((r,t)=>r<0?t*r:r);function N2(r){const{inputs:t,backend:n}=r,{x:i,alpha:a}=t;Hn([i,a],"prelu");const o=n.data.get(i.dataId).values,u=n.data.get(a.dataId).values,[h,f]=kT(i.shape,a.shape,o,u,"float32");return n.makeTensorInfo(f,"float32",h)}const RT={kernelName:ma,backendName:"cpu",kernelFunc:N2},D2=ji(Ou,r=>Math.max(0,r)),BT={kernelName:Ou,backendName:"cpu",kernelFunc:D2},L2=ji(Ih,r=>Math.min(Math.max(0,r),6)),NT={kernelName:Ih,backendName:"cpu",kernelFunc:L2};function qp(r){return(t,n,i)=>{const a=Ut(n,t.length);for(let o=0;o<t.length;++o)a[o]=r(t[o],i);return a}}const DT=qp(r=>1/(1+Math.exp(-r))),F2=ji(zd,r=>1/(1+Math.exp(-r))),LT={kernelName:zd,backendName:"cpu",kernelFunc:F2};function aE(r,t,n,i,a){if("linear"===n)return bh({inputs:{x:t},backend:r});if("relu"===n)return D2({inputs:{x:t},backend:r});if("elu"===n)return R2({inputs:{x:t},backend:r});if("relu6"===n)return L2({inputs:{x:t},backend:r});if("prelu"===n)return N2({inputs:{x:t,alpha:i},backend:r});if("leakyrelu"===n)return B2({inputs:{x:t},backend:r,attrs:{alpha:a}});if("sigmoid"===n)return F2({inputs:{x:t},backend:r});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Dl(r){const{inputs:t,backend:n}=r,{real:i,imag:a}=t,o=n.data.get(i.dataId).values,u=n.data.get(a.dataId).values,h=n.makeTensorInfo(i.shape,"complex64");return n.data.get(h.dataId).complexTensorInfos={real:n.makeTensorInfo(i.shape,"float32",o),imag:n.makeTensorInfo(a.shape,"float32",u)},h}const FT={kernelName:Xn,backendName:"cpu",kernelFunc:Dl};function ob(r,t,n="float32"){if("complex64"===n)return Dl({inputs:{real:ob(r,t,"float32"),imag:ob(r,t,"float32")},backend:r});const i=wn(Wt(t),n);return r.makeTensorInfo(t,n,i)}function Tm(r){const{inputs:t,backend:n}=r,{input:i}=t,a=n.data.get(i.dataId).complexTensorInfos.real,o=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,o)}const OT={kernelName:Ye,backendName:"cpu",kernelFunc:Tm};function Xp(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{dtype:o}=i;if("complex64"===o){if("complex64"===a.dtype)return bh({inputs:{x:a},backend:n});const u=ob(n,a.shape,a.dtype),h=Xp({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),f=Dl({inputs:{real:h,imag:u},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),f}if("complex64"===a.dtype){const u=Tm({inputs:{input:a},backend:n}),h=Xp({inputs:{x:u},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(u),h}if(!tn(a.dtype,o)){const u=bh({inputs:{x:a},backend:n});return{dataId:u.dataId,shape:u.shape,dtype:o}}if("int32"===o){const u=n.data.get(a.dataId).values,h=Int32Array.from(u);return n.makeTensorInfo(a.shape,"int32",h)}if("bool"===o){const u=n.data.get(a.dataId).values,h=Jc([0],a.dtype),[f,p]=Ma((m,y)=>m!==y?1:0)(a.shape,[],u,h,"bool");return n.makeTensorInfo(p,"bool",f)}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${o}`)}const PT={kernelName:Ie,backendName:"cpu",kernelFunc:Xp};function qa(r,t,n,i){return null==n?({inputs:a,backend:o})=>{const{a:u,b:h}=a,f=o;Hn([u,h],r);const p=f.data.get(u.dataId).values,m=f.data.get(h.dataId).values,y="string"===u.dtype?Fo(p):p,b="string"===u.dtype?Fo(m):m,T=i||u.dtype,[R,L]=t(u.shape,h.shape,y,b,T);return f.makeTensorInfo(L,T,R)}:({inputs:a,backend:o})=>{const{a:u,b:h}=a,f=o;if("complex64"===u.dtype||"complex64"===h.dtype){const p=Xp({inputs:{x:u},backend:f,attrs:{dtype:"complex64"}}),m=f.data.get(p.dataId),b=m.complexTensorInfos.imag,T=f.data.get(m.complexTensorInfos.real.dataId).values,R=f.data.get(b.dataId).values,L=Xp({inputs:{x:h},backend:f,attrs:{dtype:"complex64"}}),V=f.data.get(L.dataId),H=V.complexTensorInfos.imag,nt=f.data.get(V.complexTensorInfos.real.dataId).values,dt=f.data.get(H.dataId).values,[yt,kt,Ot]=n(u.shape,h.shape,T,R,nt,dt),Nt=f.makeTensorInfo(Ot,"float32",yt),Vt=f.makeTensorInfo(Ot,"float32",kt),qt=Dl({inputs:{real:Nt,imag:Vt},backend:f});return f.disposeIntermediateTensorInfo(p),f.disposeIntermediateTensorInfo(L),f.disposeIntermediateTensorInfo(Nt),f.disposeIntermediateTensorInfo(Vt),qt}{const p=f.data.get(u.dataId).values,m=f.data.get(h.dataId).values,y=i||u.dtype,[b,T]=t(u.shape,h.shape,p,m,y);return f.makeTensorInfo(T,y,b)}}}function oE(r){return(t,n,i,a,o,u)=>{const h=Nr(t,n),f=Wt(h),p=h.length,m=gn(h),y=Ut("float32",f),b=Ut("float32",f),T=$h(t,h),R=$h(n,h),L=wu(i,a),V=wu(o,u),j=t.length,H=gn(t),nt=n.length,dt=gn(n);if(T.length+R.length===0)for(let yt=0;yt<y.length;yt++){const kt=yt%L.length,Ot=yt%V.length,Nt=r(L[2*kt],L[2*kt+1],V[2*Ot],V[2*Ot+1]);y[yt]=Nt.real,b[yt]=Nt.imag}else for(let yt=0;yt<y.length;yt++){const kt=ai(yt,p,m),Ot=kt.slice(-j);T.forEach(te=>Ot[te]=0);const Nt=cr(Ot,j,H),Vt=kt.slice(-nt);R.forEach(te=>Vt[te]=0);const qt=cr(Vt,nt,dt),Zt=r(L[2*Nt],L[2*Nt+1],V[2*qt],V[2*qt+1]);y[yt]=Zt.real,b[yt]=Zt.imag}return[y,b,h]}}const O2=Ma((r,t)=>r+t),UT=oE((r,t,n,i)=>({real:r+n,imag:t+i})),Jy=qa(Xs,O2,UT),zT={kernelName:Xs,backendName:"cpu",kernelFunc:Jy};function Es(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{shape:o}=i,u=Wt(a.shape),h=si(o,u),f=Wt(h);Z(u===f,()=>`The new shape (${h}) has ${f} elements and the old shape (${a.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`),n.incRef(a.dataId);const p=n.data.get(a.dataId);if(null!=p.complexTensorInfos){const y=p.complexTensorInfos.imag;p.complexTensorInfos.real.shape=h,y.shape=h}return{dataId:a.dataId,shape:h,dtype:a.dtype}}const $T={kernelName:Pd,backendName:"cpu",kernelFunc:Es};function P2(r){const{inputs:t,backend:n,attrs:i}=r,{a,b:o}=t,{transposeA:u,transposeB:h}=i;Hn([a,o],"matMul");const f=a.shape.length,p=o.shape.length,m=u?a.shape[f-2]:a.shape[f-1],y=h?o.shape[p-1]:o.shape[p-2],b=u?a.shape[f-1]:a.shape[f-2],T=h?o.shape[p-2]:o.shape[p-1],R=a.shape.slice(0,-2),L=o.shape.slice(0,-2),V=Wt(R),j=Wt(L),H=Nr(a.shape.slice(0,-2),o.shape.slice(0,-2)).concat([b,T]);Z(m===y,()=>`Error in matMul: inner shapes (${m}) and (${y}) of Tensors with shapes ${a.shape} and ${o.shape} and transposeA=${u} and transposeB=${h} must match.`);const nt=h?[j,T,y]:[j,y,T],dt=Es({inputs:{x:a},backend:n,attrs:{shape:u?[V,m,b]:[V,b,m]}}),yt=Es({inputs:{x:o},backend:n,attrs:{shape:nt}}),kt=u?dt.shape[1]:dt.shape[2],Ot=u?dt.shape[2]:dt.shape[1],Nt=h?yt.shape[1]:yt.shape[2],Vt=Math.max(V,j),qt=n.data.get(dt.dataId).values,Zt=n.data.get(yt.dataId).values,te=gn(dt.shape),ue=gn(yt.shape),[Ee,De,we]=u?[te[0],1,te[1]]:[te[0],te[1],1],[Te,Le,$e]=h?[1,ue[1],ue[0]]:[ue[1],1,ue[0]],je=Ot*Nt,Ne=$r([Vt,Ot,Nt],dt.dtype),He=Ne.values,Je=n.blockSize;for(let dn=0;dn<Vt;dn++)for(let mn=0;mn<Ot;mn+=Je)for(let Ln=0;Ln<Nt;Ln+=Je)for(let Rn=0;Rn<kt;Rn+=Je){const tr=Math.min(mn+Je,Ot),ur=Math.min(Ln+Je,Nt),ir=Math.min(Rn+Je,kt);for(let er=mn;er<tr;er++)for(let Sr=Ln;Sr<ur;Sr++){let Vr=0;for(let gi=Rn;gi<ir;gi++){const Cr=Math.min(dn,V-1)*Ee,Rr=Math.min(dn,j-1)*$e;Vr+=qt[Cr+er*De+gi*we]*Zt[gi*Te+Sr*Le+Rr]}He[dn*je+(er*Nt+Sr)]+=Vr}}return n.disposeIntermediateTensorInfo(dt),n.disposeIntermediateTensorInfo(yt),n.makeTensorInfo(H,Ne.dtype,Ne.values)}const VT={kernelName:Gt,backendName:"cpu",kernelFunc:P2},GT={kernelName:qc,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{a,b:o,bias:u,preluActivationWeights:h}=t,{transposeA:f,transposeB:p,activation:m,leakyreluAlpha:y}=i;let b,T,R;const L=[];b=P2({inputs:{a,b:o},attrs:{transposeA:f,transposeB:p},backend:n}),u&&(T=Jy({inputs:{a:b,b:u},backend:n}),L.push(b),b=T),m&&(R=aE(n,b,m,h,y),L.push(b),b=R);for(const V of L)n.disposeIntermediateTensorInfo(V);return b}};function U2(r){const t=new Float32Array(r.length);for(let n=0;n<r.length;++n)t[n]=Math.abs(r[n]);return t}const QT={kernelName:da,backendName:"cpu",kernelFunc:r=>{const{x:t}=r.inputs,n=r.backend;Hn(t,"abs");let i=new Float32Array(Wt(t.shape));return i=U2(n.data.get(t.dataId).values),n.makeOutput(i,t.shape,t.dtype)}},HT=ji(pa,r=>Math.acos(r)),WT={kernelName:pa,backendName:"cpu",kernelFunc:HT},jT=ji(Ss,r=>Math.acosh(r)),qT={kernelName:Ss,backendName:"cpu",kernelFunc:jT},XT={kernelName:Ms,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,i=t;Hn(t,"addN");const a=i.map(h=>n.data.get(h.dataId).values),o=$r(i[0].shape,i[0].dtype),u=o.values;for(let h=0;h<i.length;h++){const f=a[h];for(let p=0;p<u.length;p++)u[p]+=f[p]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}};function lE(r,t,n,i,a){const o=t.length,u=Wt(t),h=gn(t),f=gn(a),p=Ut(n,Wt(a));for(let m=0;m<u;++m){const y=ai(m,o,h),b=new Array(y.length);for(let T=0;T<b.length;T++)b[T]=y[i[T]];p[cr(b,o,f)]=r[m]}return p}function ic(r){const{inputs:t,attrs:n,backend:i}=r,{x:a}=t,{perm:o}=n;Hn(a,"transpose");const h=new Array(a.shape.length);for(let p=0;p<h.length;p++)h[p]=a.shape[o[p]];const f=lE(i.data.get(a.dataId).values,a.shape,a.dtype,o,h);return{dataId:i.write(f,h,a.dtype),shape:h,dtype:a.dtype}}const YT={kernelName:gl,backendName:"cpu",kernelFunc:ic},KT={kernelName:_a,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i;Hn(a,"all");const h=lr(o,a.shape);let f=h;const p=vs(f,a.shape.length);let m=a;null!=p&&(m=ic({inputs:{x:a},backend:n,attrs:{perm:p}}),f=Ai(f.length,a.shape.length)),zs("all",f,m.shape.length);const[y,b]=sa(m.shape,f),T=Wt(b),R=wn(Wt(y),m.dtype),L=n.data.get(m.dataId).values;for(let j=0;j<R.length;++j){const H=j*T;let nt=L[H];for(let dt=0;dt<T;++dt)nt=nt&&L[H+dt];R[j]=nt}null!=p&&n.disposeIntermediateTensorInfo(m);const V=n.makeTensorInfo(y,m.dtype,R);if(u){const j=Es({inputs:{x:V},backend:n,attrs:{shape:Ni(y,h)}});return n.disposeIntermediateTensorInfo(V),j}return V}},JT={kernelName:Pa,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i;Hn(a,"any");const h=lr(o,a.shape);let f=h;const p=vs(f,a.shape.length);let m=a;null!=p&&(m=ic({inputs:{x:a},backend:n,attrs:{perm:p}}),f=Ai(f.length,a.shape.length)),zs("any",f,m.shape.length);const[y,b]=sa(m.shape,f),T=Wt(b),R=wn(Wt(y),m.dtype),L=n.data.get(m.dataId).values;for(let j=0;j<R.length;++j){const H=j*T;let nt=L[H];for(let dt=0;dt<T;++dt)nt=nt||L[H+dt];R[j]=nt}null!=p&&n.disposeIntermediateTensorInfo(m);const V=n.makeTensorInfo(y,m.dtype,R);if(u){const j=Es({inputs:{x:V},backend:n,attrs:{shape:Ni(y,h)}});return n.disposeIntermediateTensorInfo(V),j}return V}},ZT={kernelName:Ys,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o}=i;Hn(a,"argMax");let u=lr(o,a.shape);const h=vs(u,a.shape.length);let f=a;const p=[];null!=h&&(f=ic({inputs:{x:a},backend:n,attrs:{perm:h}}),p.push(f),u=Ai(u.length,f.shape.length)),u=[u[0]],zs("argMax",u,f.shape.length);const[m,y]=sa(f.shape,u),b=wn(Wt(m),"int32"),T=Wt(y),R=n.data.get(f.dataId).values;for(let L=0;L<b.length;++L){const V=L*T;let j=R[V],H=0;for(let nt=0;nt<T;++nt){const dt=R[V+nt];dt>j&&(j=dt,H=nt)}b[L]=H}return p.forEach(L=>n.disposeIntermediateTensorInfo(L)),n.makeTensorInfo(m,"int32",b)}},t_={kernelName:Ks,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o}=i;Hn(a,"argMin");let u=lr(o,a.shape);const h=vs(u,a.shape.length);let f=a;const p=[];null!=h&&(f=ic({inputs:{x:a},backend:n,attrs:{perm:h}}),p.push(f),u=Ai(u.length,f.shape.length)),u=[u[0]],zs("argMin",u,f.shape.length);const[m,y]=sa(f.shape,u),b=wn(Wt(m),"int32"),T=Wt(y),R=n.data.get(f.dataId).values;for(let L=0;L<b.length;++L){const V=L*T;let j=R[V],H=0;for(let nt=0;nt<T;++nt){const dt=R[V+nt];dt<j&&(j=dt,H=nt)}b[L]=H}return p.forEach(L=>n.disposeIntermediateTensorInfo(L)),n.makeTensorInfo(m,"int32",b)}},e_=ji(Ka,r=>Math.asin(r)),n_={kernelName:Ka,backendName:"cpu",kernelFunc:e_},r_=ji(oi,r=>Math.asinh(r)),i_={kernelName:oi,backendName:"cpu",kernelFunc:r_},s_=ji(Ol,r=>Math.atan(r)),a_={kernelName:Ol,backendName:"cpu",kernelFunc:s_},o_=Ma((r,t)=>Math.atan2(r,t)),l_=qa(Li,o_),c_={kernelName:Li,backendName:"cpu",kernelFunc:l_},u_=ji(Go,r=>Math.atanh(r)),h_={kernelName:Go,backendName:"cpu",kernelFunc:u_};function cE(r,t,n,i,a,o){const u=a.strideHeight,h=a.strideWidth,f=a.dilationHeight,p=a.dilationWidth,m=a.effectiveFilterHeight,y=a.effectiveFilterWidth,b=a.padInfo.top,T=a.padInfo.left,R="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,L=$r(a.outShape,n),V=L.values,j=a.outShape[1]*a.outShape[2]*a.outShape[3],H=a.outShape[2]*a.outShape[3],nt=a.outShape[3];for(let dt=0;dt<a.batchSize;++dt){const yt=dt*j,kt=dt*i[0];for(let Ot=0;Ot<a.inChannels;++Ot)for(let Nt=0;Nt<a.outHeight;++Nt){const Vt=Nt*u-b,qt=Math.max(0,Vt),Zt=Math.min(a.inHeight,m+Vt),te=yt+Nt*H;for(let ue=0;ue<a.outWidth;++ue){const Ee=ue*h-T,De=Math.max(0,Ee),we=Math.min(a.inWidth,y+Ee);let Te=R,Le=0,$e=0;for(let je=qt;je<Zt;je+=f){const Ne=kt+je*i[1];for(let He=De;He<we;He+=p){const Je=r[Ne+He*i[2]+Ot];"max"===o&&Je>Te?Te=Je:"avg"===o&&(Le+=Je,$e++)}if(isNaN(Te))break}V[te+ue*nt+Ot]="avg"===o?Le/$e:Te}}}return L}function z2(r,t,n,i,a=!1,o=!1){const u=$r(i.outShape,"int32"),h=i.strideHeight,f=i.strideWidth,p=i.dilationHeight,m=i.dilationWidth,y=i.effectiveFilterHeight,b=i.effectiveFilterWidth,T=i.padInfo.top,R=i.padInfo.left,L=$r(t,n,r);for(let V=0;V<i.batchSize;++V)for(let j=0;j<i.inChannels;++j)for(let H=0;H<i.outHeight;++H){const nt=H*h-T;let dt=nt;for(;dt<0;)dt+=p;const yt=Math.min(i.inHeight,y+nt);for(let kt=0;kt<i.outWidth;++kt){const Ot=kt*f-R;let Nt=Ot;for(;Nt<0;)Nt+=m;const Vt=Math.min(i.inWidth,b+Ot);let qt=Number.NEGATIVE_INFINITY,Zt=-1;for(let te=dt;te<yt;te+=p){const ue=te-nt;for(let Ee=Nt;Ee<Vt;Ee+=m){const De=Ee-Ot,we=L.get(V,te,Ee,j);we>qt&&(qt=we,Zt=a?o?((V*i.inHeight+te)*i.inWidth+Ee)*i.inChannels+j:(te*i.inWidth+Ee)*i.inChannels+j:ue*b+De)}}u.set(Zt,V,H,kt,j)}}return u}function $2(r,t,n,i,a,o){const u=a.strideDepth,h=a.strideHeight,f=a.strideWidth,p=a.dilationDepth,m=a.dilationHeight,y=a.dilationWidth,b=a.effectiveFilterDepth,T=a.effectiveFilterHeight,R=a.effectiveFilterWidth,L=a.padInfo.front,V=a.padInfo.top,j=a.padInfo.left,H="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,nt=$r(a.outShape,n),dt=nt.values,yt=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],kt=a.outShape[2]*a.outShape[3]*a.outShape[4],Ot=a.outShape[3]*a.outShape[4],Nt=a.outShape[4];for(let Vt=0;Vt<a.batchSize;++Vt){const qt=Vt*yt,Zt=Vt*i[0];for(let te=0;te<a.inChannels;++te)for(let ue=0;ue<a.outDepth;++ue){const Ee=ue*u-L;let De=Ee;for(;De<0;)De+=p;const we=Math.min(a.inDepth,b+Ee),Te=qt+ue*kt;for(let Le=0;Le<a.outHeight;++Le){const $e=Le*h-V;let je=$e;for(;je<0;)je+=m;const Ne=Math.min(a.inHeight,T+$e),He=Te+Le*Ot;for(let Je=0;Je<a.outWidth;++Je){const dn=Je*f-j;let mn=dn;for(;mn<0;)mn+=y;const Ln=Math.min(a.inWidth,R+dn),Rn=He+Je*Nt;let tr=H,ur=0,ir=0;for(let er=De;er<we;er+=p){const Sr=Zt+er*i[1];for(let Vr=je;Vr<Ne;Vr+=m){const gi=Sr+Vr*i[2];for(let Cr=mn;Cr<Ln;Cr+=y){const Rr=r[gi+Cr*i[3]+te];if("max"===o&&Rr>tr?tr=Rr:"avg"===o&&(ur+=Rr,ir++),isNaN(tr))break}if(isNaN(tr))break}if(isNaN(tr))break}dt[Rn+te]="avg"===o?ur/ir:tr}}}}return nt}const d_={kernelName:K,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t;Hn(a,"avgPool");const{filterSize:o,strides:u,pad:h,dimRoundingMode:f}=i;Z(Na(u,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`);const p=el(a.shape,o,u,1,h,f);let m;if(1===p.filterWidth&&1===p.filterHeight&&We(p.inShape,p.outShape))m=bh({inputs:{x:a},backend:n});else{const y=n.data.get(a.dataId).values,b=gn(a.shape),T=cE(y,0,a.dtype,b,p,"avg");m=n.makeTensorInfo(p.outShape,a.dtype,T.values)}return m}},p_={kernelName:It,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{filterSize:o,strides:u,pad:h,dimRoundingMode:f,dataFormat:p}=i;Hn(a,"avgPool3d");const m=yc(a.shape,o,u,1,h,f,p),y=$2(n.data.get(a.dataId).values,0,a.dtype,gn(a.shape),m,"avg");return n.makeTensorInfo(y.shape,"float32",y.values)}},f_={kernelName:Mt,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,input:o}=t,{filterSize:u,strides:h,pad:f,dimRoundingMode:p}=i;Hn([a,o],"avgPool3DGrad");const m=yc(o.shape,u,h,1,f,p),y=m.strideDepth,b=m.strideHeight,T=m.strideWidth,R=m.filterDepth,L=m.filterHeight,V=m.filterWidth,j=m.dilationDepth,H=m.dilationHeight,nt=m.dilationWidth,dt=m.effectiveFilterDepth,yt=m.effectiveFilterHeight,kt=m.effectiveFilterWidth,Ot=dt-1-m.padInfo.front,Nt=kt-1-m.padInfo.left,Vt=yt-1-m.padInfo.top,qt=$r(o.shape,"float32"),Zt=1/(R*L*V),te=n.bufferSync(a);for(let ue=0;ue<m.batchSize;++ue)for(let Ee=0;Ee<m.inChannels;++Ee)for(let De=0;De<m.inDepth;++De)for(let we=0;we<m.inHeight;++we)for(let Te=0;Te<m.inWidth;++Te){const Le=De-Ot,$e=we-Vt,je=Te-Nt;let Ne=0;for(let He=0;He<dt;He+=j){const Je=(Le+He)/y;if(!(Je<0||Je>=m.outDepth||Math.floor(Je)!==Je))for(let dn=0;dn<yt;dn+=H){const mn=($e+dn)/b;if(!(mn<0||mn>=m.outHeight||Math.floor(mn)!==mn))for(let Ln=0;Ln<kt;Ln+=nt){const Rn=(je+Ln)/T;Rn<0||Rn>=m.outWidth||Math.floor(Rn)!==Rn||(Ne+=te.get(ue,Je,mn,Rn,Ee))}}}qt.set(Ne*Zt,ue,De,we,Te,Ee)}return n.makeTensorInfo(qt.shape,qt.dtype,qt.values)}},m_={kernelName:mt,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,input:o}=t,u=o;Hn([a,o],"avgPoolGrad");const{filterSize:h,strides:f,pad:p}=i,m=el(u.shape,h,f,1,p),y=m.strideHeight,b=m.strideWidth,T=m.filterHeight,R=m.filterWidth,L=m.dilationHeight,V=m.dilationWidth,j=m.effectiveFilterHeight,H=m.effectiveFilterWidth,nt=H-1-m.padInfo.left,dt=j-1-m.padInfo.top,yt=$r(u.shape,"float32"),kt=1/(T*R),Ot=n.data.get(a.dataId).values,Nt=$r(a.shape,"float32",Ot);for(let Vt=0;Vt<m.batchSize;++Vt)for(let qt=0;qt<m.inChannels;++qt)for(let Zt=0;Zt<m.inHeight;++Zt)for(let te=0;te<m.inWidth;++te){const ue=Zt-dt,Ee=te-nt;let De=0;for(let we=0;we<j;we+=L){const Te=(ue+we)/y;if(!(Te<0||Te>=m.outHeight||Math.floor(Te)!==Te))for(let Le=0;Le<H;Le+=V){const $e=(Ee+Le)/b;$e<0||$e>=m.outWidth||Math.floor($e)!==$e||(De+=Nt.get(Vt,Te,$e,qt))}}yt.set(De*kt,Vt,Zt,te,qt)}return n.makeTensorInfo(yt.shape,yt.dtype,yt.values)}},g_={kernelName:zc,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,scale:o,offset:u,mean:h,variance:f}=t;Z(h.shape.length===f.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Z(null==u||h.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Z(null==o||h.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Hn([a,h,f,o,u],"batchNorm");let{varianceEpsilon:p}=i;null==p&&(p=.001);const m=n.data.get(a.dataId).values,y=n.data.get(h.dataId).values,b=n.data.get(f.dataId).values,T=o?n.data.get(o.dataId).values:new Float32Array([1]),R=u?n.data.get(u.dataId).values:new Float32Array([0]),L=new Float32Array(m.length),V=R.length,j=T.length,H=b.length,nt=y.length;let dt=0,yt=0,kt=0,Ot=0;for(let Nt=0;Nt<m.length;++Nt)L[Nt]=R[dt++]+(m[Nt]-y[yt++])*T[kt++]/Math.sqrt(b[Ot++]+p),dt>=V&&(dt=0),yt>=nt&&(yt=0),kt>=j&&(kt=0),Ot>=H&&(Ot=0);return n.makeTensorInfo(a.shape,a.dtype,L)}};function V2(r,t,n,i,a){const o=f0(i,t,n),u=Wt(n),h=gn(i);if(o){const m=m0(t,h);return"string"===a?r.slice(m,m+u):r.subarray(m,m+u)}const f=$r(i,a,"string"===a?Fo(r):r),p=$r(n,a);for(let m=0;m<p.size;++m){const y=p.indexToLoc(m),b=y.map((T,R)=>T+t[R]);p.set(f.get(...b),...y)}return"string"===a?hm(p.values):p.values}function _m(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{begin:o,size:u}=i;Hn(a,"slice");const[h,f]=og(a,o,u);sg(a,h,f);const p=V2(n.data.get(a.dataId).values,h,f,a.shape,a.dtype);return n.makeTensorInfo(f,a.dtype,p)}const A_={kernelName:cc,backendName:"cpu",kernelFunc:_m},y_={kernelName:Xt,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{blockShape:o,crops:u}=i;Hn([a],"batchToSpaceND");const h=o.reduce((j,H)=>j*H),f=Fp(a.shape,o,h),p=Op(f.length,o.length),m=nc(a.shape,o,h),y=qg(u,o.length),b=sy(m,u,o.length),T=Es({inputs:{x:a},backend:n,attrs:{shape:f}}),R=ic({inputs:{x:T},backend:n,attrs:{perm:p}}),L=Es({inputs:{x:R},backend:n,attrs:{shape:m}}),V=_m({inputs:{x:L},backend:n,attrs:{begin:y,size:b}});return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(L),V}};function uE(r,t,n,i,a){const o=Wt(i),u=wn(a,n);for(let h=0;h<r.length;h++){const f=r[h];if(f<0)throw new Error("Input x must be non-negative!");f>=a||(u[f]+=o>0?t[h]:1)}return u}function G2(r,t,n,i=!1){const a=r.shape[0],o=r.shape[1],u=$r([a,n],t.dtype);for(let h=0;h<a;h++)for(let f=0;f<o;f++){const p=r.get(h,f);if(p<0)throw new Error("Input x must be non-negative!");p>=n||u.set(i?1:t.size>0?u.get(h,p)+t.get(h,f):u.get(h,p)+1,h,p)}return u}const v_={kernelName:Me,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,weights:o}=t,{size:u}=i,h=uE(n.data.get(a.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,u);return n.makeTensorInfo([u],o.dtype,h)}},b_={kernelName:un,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{s0:i,s1:a}=t,o=n.data.get(i.dataId).values,u=n.data.get(a.dataId).values,h=Nr(Array.from(o),Array.from(u));return n.makeTensorInfo([h.length],"int32",Int32Array.from(h))}},Q2=qp(r=>Math.ceil(r)),x_=DA(Be,Q2),w_={kernelName:Be,backendName:"cpu",kernelFunc:x_},E_=ji(Pn,(r,t)=>r>t.clipValueMax?t.clipValueMax:r<t.clipValueMin?t.clipValueMin:r),C_={kernelName:Pn,backendName:"cpu",kernelFunc:E_},I_={kernelName:dr,backendName:"cpu",kernelFunc:r=>{const{x:t}=r.inputs,n=r.backend,i=new Float32Array(Wt(t.shape)),a=n.data.get(t.dataId),u=a.complexTensorInfos.imag,h=n.data.get(a.complexTensorInfos.real.dataId).values,f=n.data.get(u.dataId).values;for(let p=0;p<h.length;p++)i[p]=Math.hypot(h[p],f[p]);return n.makeOutput(i,t.shape,"float32")}};function H2(r,t,n,i){const a=jt(n,Wt(t));if(i&&"string"!==n){let o=0;r.forEach(u=>{const h=Wt(u.shape);a.set(u.vals,o),o+=h})}else{let o=0;r.forEach(u=>{const h="string"===n?Fo(u.vals):u.vals;let f=0;for(let p=0;p<u.shape[0];++p){const m=p*t[1]+o;for(let y=0;y<u.shape[1];++y)a[m+y]=h[f++]}o+=u.shape[1]})}return a}function LA(r){const{inputs:t,backend:n}=r,{input:i}=t,a=n.data.get(i.dataId).complexTensorInfos.imag,o=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,o)}const S_={kernelName:Pm,backendName:"cpu",kernelFunc:LA};function FA(r){const{inputs:t,backend:n,attrs:i}=r,{axis:a}=i,o=lr(a,t[0].shape)[0];let u=ec(t.map(R=>R.shape),o);if(0===Wt(u))return n.makeTensorInfo(u,t[0].dtype,[]);const h=t.filter(R=>Wt(R.shape)>0);if(1===h.length)return bh({inputs:{x:h[0]},backend:n});if(ry(h.map(R=>R.shape),o),"complex64"===h[0].dtype){const R=h.map(nt=>Tm({inputs:{input:nt},backend:n})),L=h.map(nt=>LA({inputs:{input:nt},backend:n})),V=FA({inputs:R,backend:n,attrs:{axis:o}}),j=FA({inputs:L,backend:n,attrs:{axis:o}}),H=Dl({inputs:{real:V,imag:j},backend:n});return R.forEach(nt=>n.disposeIntermediateTensorInfo(nt)),L.forEach(nt=>n.disposeIntermediateTensorInfo(nt)),n.disposeIntermediateTensorInfo(V),n.disposeIntermediateTensorInfo(j),H}const f=h.map(R=>{const L=Wt(R.shape.slice(o));return Es({inputs:{x:R},backend:n,attrs:{shape:[-1,L]}})}),p=f.map(R=>({vals:n.data.get(R.dataId).values,shape:R.shape}));u=ec(f.map(R=>R.shape),1);const y=H2(p,u,t[0].dtype,1===f[0].shape[0]),b=ec(h.map(R=>R.shape),o),T=n.makeTensorInfo(b,t[0].dtype,y);return f.forEach(R=>n.disposeIntermediateTensorInfo(R)),T}const M_={kernelName:Ar,backendName:"cpu",kernelFunc:FA};function W2(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o}=t,{strides:u,pad:h,dataFormat:f,dilations:p,dimRoundingMode:m}=i;Hn([a,o],"conv2d");const y=uu(f),b=ra(a.shape,o.shape,u,p,h,m,!1,y),T=b.filterHeight,R=b.filterWidth,L=b.dilationHeight,V=b.dilationWidth,j=b.padInfo.left,H=b.padInfo.top,nt="channelsLast"===b.dataFormat,dt=new is(b.outShape,a.dtype),yt=gn(a.shape),kt=gn(o.shape),Ot=yt[0],Nt=nt?yt[1]:yt[2],Vt=nt?yt[2]:1,qt=nt?1:yt[1],Zt=dt.strides[0],te=nt?dt.strides[1]:dt.strides[2],ue=nt?dt.strides[2]:1,Ee=nt?1:dt.strides[1],De=n.data.get(a.dataId).values,we=n.data.get(o.dataId).values,Te=dt.values;for(let Le=0;Le<b.batchSize;++Le){const $e=Le*Ot,je=Le*Zt;for(let Ne=0;Ne<b.outHeight;++Ne){const He=je+Ne*te,Je=Ne*b.strideHeight-H;for(let dn=0;dn<T;++dn){const mn=Je+dn*L;if(mn<0||mn>=b.inHeight)continue;const Ln=dn*kt[0],Rn=$e+mn*Nt;for(let tr=0;tr<b.outWidth;++tr){const ur=He+tr*ue,ir=tr*b.strideWidth-j;for(let er=0;er<R;++er){const Sr=ir+er*V;if(Sr<0||Sr>=b.inWidth)continue;const Vr=Rn+Sr*Vt;let gi=Ln+er*kt[1];for(let Cr=0;Cr<b.inChannels;++Cr){const Rr=De[Vr+Cr*qt];for(let Kr=0;Kr<b.outChannels;++Kr)Te[ur+Kr*Ee]+=Rr*we[gi+Kr];gi+=b.outChannels}}}}}}return n.makeTensorInfo(dt.shape,dt.dtype,Te)}const T_={kernelName:xr,backendName:"cpu",kernelFunc:W2},__={kernelName:_r,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,dy:o}=t,{strides:u,pad:h,dataFormat:f,dimRoundingMode:p,filterShape:m}=i;Hn([a,o],"conv2dBackpropFilter");const y=uu(f),b=ra(a.shape,m,u,1,h,p,!1,y),{strideHeight:T,strideWidth:R,filterHeight:L,filterWidth:V}=b,j="channelsLast"===b.dataFormat,H=new is(b.filterShape,"float32"),nt=b.padInfo.left,dt=b.padInfo.top,yt=n.data.get(a.dataId).values,kt=n.data.get(o.dataId).values,Ot=new is(a.shape,a.dtype,yt),Nt=new is(o.shape,o.dtype,kt);for(let Vt=0;Vt<L;++Vt){const qt=Math.max(0,Math.ceil((dt-Vt)/T)),Zt=Math.min(b.outHeight,(b.inHeight+dt-Vt)/T);for(let te=0;te<V;++te){const ue=Math.max(0,Math.ceil((nt-te)/R)),Ee=Math.min(b.outWidth,(b.inWidth+nt-te)/R);for(let De=0;De<b.inChannels;++De)for(let we=0;we<b.outChannels;++we){let Te=0;for(let Le=0;Le<b.batchSize;++Le)for(let $e=qt;$e<Zt;++$e){const je=Vt+$e*T-dt;for(let Ne=ue;Ne<Ee;++Ne){const He=te+Ne*R-nt;Te+=j?Ot.get(Le,je,He,De)*Nt.get(Le,$e,Ne,we):Ot.get(Le,De,je,He)*Nt.get(Le,we,$e,Ne)}}H.set(Te,Vt,te,De,we)}}}return n.makeTensorInfo(H.shape,H.dtype,H.values)}},k_={kernelName:Pr,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,filter:o}=t,{inputShape:u,strides:h,pad:f,dataFormat:p,dimRoundingMode:m}=i;Hn([a,o],"conv2dBackpropInput");const y=gn(o.shape),b=gn(a.shape);let T=uu(p);const R=ra(u,o.shape,h,1,f,m,!1,T),L=new is(R.inShape,"float32"),V=L.values,j=n.data.get(a.dataId).values,H=n.data.get(o.dataId).values,[nt,dt,yt]=y,{batchSize:kt,filterHeight:Ot,filterWidth:Nt,inChannels:Vt,inHeight:qt,inWidth:Zt,outChannels:te,outHeight:ue,outWidth:Ee,strideHeight:De,strideWidth:we}=R;T=R.dataFormat;const Te=Ot-1-R.padInfo.top,Le=Nt-1-R.padInfo.left,$e="channelsLast"===T,je=L.strides[0],Ne=$e?L.strides[1]:L.strides[2],He=$e?L.strides[2]:1,Je=$e?1:L.strides[1],dn=b[0],mn=$e?b[1]:b[2],Ln=$e?b[2]:1,Rn=$e?1:b[1];for(let tr=0;tr<kt;++tr)for(let ur=0;ur<Vt;++ur)for(let ir=0;ir<qt;++ir){const er=ir-Te,Sr=Math.max(0,Math.ceil(er/De)),Vr=Math.min(ue,(Ot+er)/De);for(let gi=0;gi<Zt;++gi){const Cr=gi-Le,Rr=Math.max(0,Math.ceil(Cr/we)),Kr=Math.min(Ee,(Nt+Cr)/we);let la=0;for(let ho=Sr;ho<Vr;++ho){const po=ho*De-er;for(let ca=Rr;ca<Kr;++ca){const wd=dn*tr+mn*ho+Ln*ca,Fa=nt*(Ot-1-po)+dt*(Nt-1-(ca*we-Cr))+yt*ur;for(let fo=0;fo<te;++fo)la+=j[wd+Rn*fo]*H[Fa+fo]}}V[je*tr+Ne*ir+He*gi+Je*ur]=la}}return n.makeTensorInfo(L.shape,L.dtype,L.values)}},R_={kernelName:ui,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o}=t,{strides:u,pad:h,dilations:f}=i;Hn([a,o],"conv3d");const p=Xu(a.shape,o.shape,u,f,h),{filterDepth:m,filterHeight:y,filterWidth:b,dilationDepth:T,dilationHeight:R,dilationWidth:L,padInfo:V}=p,j=V.front,H=V.left,nt=V.top,dt=new is(p.outShape,a.dtype),yt=n.data.get(a.dataId).values,kt=n.data.get(o.dataId).values,Ot=dt.values,Nt=gn(a.shape),Vt=gn(o.shape);for(let qt=0;qt<p.batchSize;++qt){const Zt=qt*Nt[0],te=qt*dt.strides[0];for(let ue=0;ue<p.outDepth;++ue){const Ee=te+ue*dt.strides[1],De=ue*p.strideDepth-j;for(let we=0;we<m;++we){const Te=De+we*T;if(Te<0||Te>=p.inDepth)continue;const Le=we*Vt[0],$e=Zt+Te*Nt[1];for(let je=0;je<p.outHeight;++je){const Ne=Ee+je*dt.strides[2],He=je*p.strideHeight-nt;for(let Je=0;Je<y;++Je){const dn=He+Je*R;if(dn<0||dn>=p.inHeight)continue;const mn=Le+Je*Vt[1],Ln=$e+dn*Nt[2];for(let Rn=0;Rn<p.outWidth;++Rn){const tr=Ne+Rn*p.outChannels,ur=Rn*p.strideWidth-H;for(let ir=0;ir<b;++ir){const er=ur+ir*L;if(er<0||er>=p.inWidth)continue;const Vr=Ln+er*p.inChannels;let gi=mn+ir*Vt[2];for(let Cr=0;Cr<p.inChannels;++Cr){const Rr=yt[Vr+Cr];for(let Kr=0;Kr<p.outChannels;++Kr)Ot[tr+Kr]+=Rr*kt[gi+Kr];gi+=p.outChannels}}}}}}}}return n.makeTensorInfo(dt.shape,dt.dtype,dt.values)}},B_={kernelName:us,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,dy:o}=t,{strides:u,pad:h,filterShape:f}=i;Hn([a,o],"conv3dBackpropFilterV2");const p=gn(a.shape),m=gn(o.shape),y=Xu(a.shape,f,u,1,h),b=y.strideDepth,T=y.strideHeight,R=y.strideWidth,L=y.filterDepth,V=y.filterHeight,j=y.filterWidth,H=new is(y.filterShape,"float32"),nt=H.values,[dt,yt,kt,Ot]=H.strides,Nt=n.data.get(o.dataId).values,[Vt,qt,Zt,te]=m,ue=n.data.get(a.dataId).values,[Ee,De,we,Te]=p,Le=y.padInfo.front,$e=y.padInfo.left,je=y.padInfo.top;for(let Ne=0;Ne<L;++Ne){const He=Math.max(0,Math.ceil((Le-Ne)/b)),Je=Math.min(y.outDepth,(y.inDepth+Le-Ne)/b),dn=Ne*dt;for(let mn=0;mn<V;++mn){const Ln=Math.max(0,Math.ceil((je-mn)/T)),Rn=Math.min(y.outHeight,(y.inHeight+je-mn)/T),tr=mn*yt+dn;for(let ur=0;ur<j;++ur){const ir=Math.max(0,Math.ceil(($e-ur)/R)),er=Math.min(y.outWidth,(y.inWidth+$e-ur)/R),Sr=ur*kt+tr;for(let Vr=0;Vr<y.inChannels;++Vr){const gi=Vr*Ot+Sr;for(let Cr=0;Cr<y.outChannels;++Cr){let Rr=0;for(let Kr=0;Kr<y.batchSize;++Kr){const la=Kr*Ee,ho=Kr*Vt;for(let po=He;po<Je;++po){const ca=(Ne+po*b-Le)*De+la,wd=po*qt+ho;for(let Fa=Ln;Fa<Rn;++Fa){const fo=(mn+Fa*T-je)*we+ca,Vo=Fa*Zt+wd;for(let Bu=ir;Bu<er;++Bu)Rr+=ue[(ur+Bu*R-$e)*Te+fo+Vr]*Nt[Bu*te+Vo+Cr]}}}nt[gi+Cr]=Rr}}}}}return n.makeTensorInfo(H.shape,H.dtype,H.values)}},N_={kernelName:Fi,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,filter:o}=t,{pad:u,strides:h,inputShape:f}=i;Hn([a],"conv3dBackpropInputV2");const p=gn(a.shape),m=gn(o.shape),y=Xu(f,o.shape,h,1,u),b=new is(y.inShape,"float32"),T=b.values,[R,L,V,j]=b.strides,H=n.data.get(a.dataId).values,[nt,dt,yt,kt]=p,Ot=n.data.get(o.dataId).values,[Nt,Vt,qt,Zt]=m,{batchSize:te,filterDepth:ue,filterHeight:Ee,filterWidth:De,inChannels:we,inDepth:Te,inHeight:Le,inWidth:$e,outChannels:je,outDepth:Ne,outHeight:He,outWidth:Je,strideDepth:dn,strideHeight:mn,strideWidth:Ln}=y,Rn=ue-1-y.padInfo.front,tr=Ee-1-y.padInfo.top,ur=De-1-y.padInfo.left;for(let ir=0;ir<te;++ir)for(let er=0;er<we;++er)for(let Sr=0;Sr<Te;++Sr){const Vr=Sr-Rn,gi=Math.max(0,Math.ceil(Vr/dn)),Cr=Math.min(Ne,(ue+Vr)/dn);for(let Rr=0;Rr<Le;++Rr){const Kr=Rr-tr,la=Math.max(0,Math.ceil(Kr/mn)),ho=Math.min(He,(Ee+Kr)/mn);for(let po=0;po<$e;++po){const ca=po-ur,wd=Math.max(0,Math.ceil(ca/Ln)),Fa=Math.min(Je,(De+ca)/Ln);let fo=0;for(let Vo=gi;Vo<Cr;++Vo){const Bu=Vo*dn-Vr;for(let Ed=la;Ed<ho;++Ed){const KF=Ed*mn-Kr;for(let Ib=wd;Ib<Fa;++Ib){const JF=nt*ir+dt*Vo+yt*Ed+kt*Ib,ZF=Nt*(ue-1-Bu)+Vt*(Ee-1-KF)+qt*(De-1-(Ib*Ln-ca))+Zt*er;for(let Sb=0;Sb<je;++Sb)fo+=H[JF+Sb]*Ot[ZF+Sb]}}}T[R*ir+L*Sr+V*Rr+j*po+er]=fo}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},D_=ji(rs,r=>Math.cos(r)),L_={kernelName:rs,backendName:"cpu",kernelFunc:D_},F_=ji(Ts,r=>Math.cosh(r)),O_={kernelName:Ts,backendName:"cpu",kernelFunc:F_},P_={kernelName:hs,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{image:a,boxes:o,boxInd:u}=t,{cropSize:h,method:f,extrapolationValue:p}=i,[m,y,b,T]=a.shape,R=o.shape[0],[L,V]=h,j=$r([R,L,V,T],"float32"),H=n.data.get(o.dataId).values,nt=n.data.get(u.dataId).values,dt=n.data.get(a.dataId).values,yt=gn(a.shape),kt=gn(j.shape);for(let Ot=0;Ot<R;Ot++){const Nt=4*Ot,Vt=H[Nt],qt=H[Nt+1],Zt=H[Nt+2],te=H[Nt+3],ue=nt[Ot];if(ue>=m)continue;const Ee=L>1?(Zt-Vt)*(y-1)/(L-1):0,De=V>1?(te-qt)*(b-1)/(V-1):0;for(let we=0;we<L;we++){const Te=L>1?Vt*(y-1)+we*Ee:.5*(Vt+Zt)*(y-1);if(Te<0||Te>y-1)for(let Le=0;Le<V;Le++)for(let $e=0;$e<T;$e++)j.values[$e+Le*kt[2]+we*kt[1]+Ot*kt[0]]=p;else if("bilinear"===f){const Le=Math.floor(Te),$e=Math.ceil(Te),je=Te-Le;for(let Ne=0;Ne<V;Ne++){const He=V>1?qt*(b-1)+Ne*De:.5*(qt+te)*(b-1);if(He<0||He>b-1){for(let Ln=0;Ln<T;Ln++)j.values[Ln+Ne*kt[2]+we*kt[1]+Ot*kt[0]]=p;continue}const Je=Math.floor(He),dn=Math.ceil(He),mn=He-Je;for(let Ln=0;Ln<T;Ln++){let Rn=Ln+Je*yt[2]+Le*yt[1]+ue*yt[0];const tr=dt[Rn];Rn=Ln+dn*yt[2]+Le*yt[1]+ue*yt[0];const ur=dt[Rn];Rn=Ln+Je*yt[2]+$e*yt[1]+ue*yt[0];const ir=dt[Rn];Rn=Ln+dn*yt[2]+$e*yt[1]+ue*yt[0];const er=tr+(ur-tr)*mn,Sr=ir+(dt[Rn]-ir)*mn;Rn=Ln+Ne*kt[2]+we*kt[1]+Ot*kt[0],j.values[Rn]=er+(Sr-er)*je}}}else for(let Le=0;Le<V;++Le){const $e=V>1?qt*(b-1)+Le*De:.5*(qt+te)*(b-1);if($e<0||$e>b-1){for(let He=0;He<T;He++)j.values[He+Le*kt[2]+we*kt[1]+Ot*kt[0]]=p;continue}const je=Math.round($e),Ne=Math.round(Te);for(let He=0;He<T;He++)j.values[He+Le*kt[2]+we*kt[1]+Ot*kt[0]]=dt[He+je*yt[2]+Ne*yt[1]+ue*yt[0]]}}}return n.makeTensorInfo(j.shape,j.dtype,j.values)}},U_={kernelName:Js,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,exclusive:u,reverse:h}=i;Hn(a,"cumsum");const f=vs([o],a.shape.length);let p=a;null!=f&&(p=ic({inputs:{x:a},backend:n,attrs:{perm:f}}));const m=Ai(1,a.shape.length)[0];if(m!==p.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${m}`);const y=di(p.dtype,"int32"),b=wn(Wt(p.shape),y),T=n.data.get(p.dataId).values,R=p.shape[p.shape.length-1],L=h?(j,H)=>j+R-H-1:(j,H)=>j+H;for(let j=0;j<T.length;j+=R)for(let H=0;H<R;H++){const nt=L(j,H);if(0===H)b[nt]=u?0:T[nt];else{const dt=L(j,H-1);b[nt]=u?T[dt]+b[dt]:T[nt]+b[dt]}}const V=n.makeTensorInfo(p.shape,y,b);if(null!=f){const j=ic({inputs:{x:V},backend:n,attrs:{perm:Jh(f)}});return n.disposeIntermediateTensorInfo(V),n.disposeIntermediateTensorInfo(p),j}return V}},z_={kernelName:ds,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,weights:o}=t,{size:u,binaryOutput:h}=i;if(1===a.shape.length){const f=uE(n.data.get(a.dataId).values,n.data.get(o.dataId).values,o.dtype,o.shape,u);return n.makeTensorInfo([u],o.dtype,f)}if(2===a.shape.length){const f=G2(n.bufferSync(a),n.bufferSync(o),u,h);return n.makeTensorInfo(f.shape,o.dtype,f.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},$_={kernelName:$i,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{blockSize:o,dataFormat:u}=i;Z("NHWC"===u,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${u}`);const h=a.shape[0],f=a.shape[1],p=a.shape[2],m=a.shape[3],y=f*o,b=p*o,T=m/(o*o),R=n.data.get(a.dataId).values,L=new Float32Array(h*y*b*T);let V=0;for(let j=0;j<h;++j)for(let H=0;H<y;++H){const nt=Math.floor(H/o),dt=H%o;for(let yt=0;yt<b;++yt){const kt=Math.floor(yt/o),Ot=(dt*o+yt%o)*T;for(let Nt=0;Nt<T;++Nt)L[V++]=R[Nt+Ot+m*(kt+p*(nt+f*j))]}}return n.makeTensorInfo([h,y,b,T],a.dtype,L)}};function j2(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o}=t,{strides:u,pad:h,dilations:f,dimRoundingMode:p}=i;Hn([a,o],"depthwiseConv2DNative");const m=gn(a.shape),y=gn(o.shape);let b=f;null==b&&(b=[1,1]),Z(Na(u,b),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${b}'`);const T=ra(a.shape,o.shape,u,b,h,p,!0),{filterHeight:R,filterWidth:L,dilationHeight:V,dilationWidth:j,padInfo:H}=T,nt=H.left,dt=H.top,yt=T.outChannels/T.inChannels,kt=new is(T.outShape,a.dtype),Ot=n.data.get(a.dataId).values,Nt=n.data.get(o.dataId).values,Vt=kt.values;for(let qt=0;qt<T.batchSize;++qt){const Zt=qt*m[0],te=qt*kt.strides[0];for(let ue=0;ue<T.outHeight;++ue){const Ee=te+ue*kt.strides[1],De=ue*T.strideHeight-dt;for(let we=0;we<R;++we){const Te=De+we*V;if(Te<0||Te>=T.inHeight)continue;const Le=we*y[0],$e=Zt+Te*m[1];for(let je=0;je<T.outWidth;++je){const Ne=Ee+je*kt.strides[2],He=je*T.strideWidth-nt;for(let Je=0;Je<L;++Je){const dn=He+Je*j;if(dn<0||dn>=T.inWidth)continue;const Ln=$e+dn*T.inChannels;let Rn=Ne,tr=Le+Je*y[1];for(let ur=0;ur<T.inChannels;++ur){const ir=Ot[Ln+ur];for(let er=0;er<yt;++er)Vt[Rn+er]+=ir*Nt[tr+er];Rn+=yt,tr+=yt}}}}}}return n.makeTensorInfo(kt.shape,kt.dtype,kt.values)}const V_={kernelName:Zs,backendName:"cpu",kernelFunc:j2},G_={kernelName:Qo,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,dy:o}=t,{strides:u,dilations:h,pad:f,dimRoundingMode:p,filterShape:m}=i;Hn([a,o],"depthwiseConv2dNativeBackpropFilter");const y=ra(a.shape,m,u,h,f,p,!0),{strideHeight:b,strideWidth:T,filterHeight:R,filterWidth:L}=y,V=new is(y.filterShape,"float32"),j=y.padInfo.left,H=y.padInfo.top,nt=y.outChannels/y.inChannels,dt=n.data.get(a.dataId).values,yt=new is(a.shape,a.dtype,dt),kt=n.data.get(o.dataId).values,Ot=new is(o.shape,o.dtype,kt);for(let Nt=0;Nt<R;++Nt){const Vt=Math.max(0,Math.ceil((H-Nt)/b)),qt=Math.min(y.outHeight,(y.inHeight+H-Nt)/b);for(let Zt=0;Zt<L;++Zt){const te=Math.max(0,Math.ceil((j-Zt)/T)),ue=Math.min(y.outWidth,(y.inWidth+j-Zt)/T);for(let Ee=0;Ee<y.outChannels;++Ee){const De=Math.trunc(Ee/nt),we=Ee%nt;let Te=0;for(let Le=0;Le<y.batchSize;++Le)for(let $e=Vt;$e<qt;++$e){const je=Nt+$e*b-H;for(let Ne=te;Ne<ue;++Ne)Te+=yt.get(Le,je,Zt+Ne*T-j,De)*Ot.get(Le,$e,Ne,Ee)}V.set(Te,Nt,Zt,De,we)}}}return n.makeTensorInfo(V.shape,V.dtype,V.values)}},Q_={kernelName:Ja,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,filter:o}=t,{strides:u,dilations:h,pad:f,dimRoundingMode:p,inputShape:m}=i;Hn([a,o],"depthwiseConv2DNativeBackpropInput");const y=gn(a.shape),b=gn(o.shape),T=ra(m,o.shape,u,h,f,p,!0),R=new is(T.inShape,"float32"),L=R.values,[V,j,H]=R.strides,nt=n.data.get(a.dataId).values,[dt,yt,kt]=y,Ot=n.data.get(o.dataId).values,[Nt,Vt,qt]=b,{batchSize:Zt,filterHeight:te,filterWidth:ue,inChannels:Ee,inHeight:De,inWidth:we,outChannels:Te,outHeight:Le,outWidth:$e,strideHeight:je,strideWidth:Ne}=T,He=te-1-T.padInfo.top,Je=ue-1-T.padInfo.left,dn=Te/Ee;for(let mn=0;mn<Zt;++mn)for(let Ln=0;Ln<Ee;++Ln)for(let Rn=0;Rn<De;++Rn){const tr=Rn-He,ur=Math.max(0,Math.ceil(tr/je)),ir=Math.min(Le,(te+tr)/je);for(let er=0;er<we;++er){const Sr=er-Je,Vr=Math.max(0,Math.ceil(Sr/Ne)),gi=Math.min($e,(ue+Sr)/Ne);let Cr=0;for(let Rr=ur;Rr<ir;++Rr){const Kr=Rr*je-tr;for(let la=Vr;la<gi;++la){const ho=dt*mn+yt*Rr+kt*la,po=Nt*(te-1-Kr)+Vt*(ue-1-(la*Ne-Sr))+qt*Ln;for(let ca=0;ca<dn;++ca)Cr+=nt[ho+(Ln*dn+ca)]*Ot[po+ca]}}L[V*mn+j*Rn+H*er+Ln]=Cr}}return n.makeTensorInfo(R.shape,R.dtype,R.values)}},H_={kernelName:Za,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{x:i}=t,a=Wt(i.shape),o=n.data.get(i.dataId).values,u=$r([a,a],i.dtype),h=u.values;for(let p=0;p<o.length;p++)h[p*a+p]=o[p];const f=[...i.shape,...i.shape];return n.makeTensorInfo(f,u.dtype,u.values)}},W_={kernelName:Ao,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:n})=>{const{x:i,filter:a}=r,{strides:o,pad:u,dilations:h}=n,f=t,p=f.data.get(i.dataId).values,m=i.shape.length,y=f.data.get(a.dataId).values,b=a.shape.length,{batchSize:T,inHeight:R,inWidth:L,inChannels:V,outHeight:j,outWidth:H,padInfo:nt,strideHeight:dt,strideWidth:yt,filterHeight:kt,filterWidth:Ot,dilationHeight:Nt,dilationWidth:Vt,outShape:qt}=cp(i.shape,a.shape,o,u,"NHWC",h),Zt=Wt(qt),te=qt.length,ue=jt(i.dtype,Zt);for(let Ee=0;Ee<T;++Ee)for(let De=0;De<j;++De){const we=De*dt-nt.top;for(let Te=0;Te<H;++Te){const Le=Te*yt-nt.left;for(let $e=0;$e<V;++$e){let je=Number.MIN_SAFE_INTEGER;for(let Ne=0;Ne<kt;++Ne){const He=we+Ne*Nt;if(He>=0&&He<R)for(let Je=0;Je<Ot;++Je){const dn=Le+Je*Vt;if(dn>=0&&dn<L){const mn=cr([Ee,He,dn,$e],m,gn(i.shape)),Ln=cr([Ne,Je,$e],b,gn(a.shape)),Rn=p[mn]+y[Ln];Rn>je&&(je=Rn)}}}ue[cr([Ee,De,Te,$e],te,gn(qt))]=je}}}return{dataId:f.write(Jc(ue,i.dtype),qt,i.dtype),shape:qt,dtype:i.dtype}}},j_={kernelName:dl,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:n})=>{const{x:i,filter:a,dy:o}=r,{strides:u,pad:h,dilations:f}=n,p=t,m=Tr(i.shape,p.data.get(i.dataId).values),y=Tr(a.shape,p.data.get(a.dataId).values),{batchSize:b,inHeight:T,inWidth:R,inChannels:L,outHeight:V,outWidth:j,padInfo:H,strideHeight:nt,strideWidth:dt,filterHeight:yt,filterWidth:kt,dilationHeight:Ot,dilationWidth:Nt,outShape:Vt}=cp(i.shape,a.shape,u,h,"NHWC",f);Z(o.rank===Vt.length,()=>`Error in ${dl}, dy must have the same rank as output ${Vt.length}, but got ${o.rank}`);const qt=Tr(Vt,p.data.get(o.dataId).values),Zt=br(a.shape,a.dtype);for(let te=0;te<b;++te)for(let ue=0;ue<V;++ue){const Ee=ue*nt-H.top;for(let De=0;De<j;++De){const we=De*dt-H.left;for(let Te=0;Te<L;++Te){let Le=Number.MIN_SAFE_INTEGER,$e=0,je=0;for(let Ne=0;Ne<yt;++Ne){const He=Ee+Ne*Ot;if(He>=0&&He<T)for(let Je=0;Je<kt;++Je){const dn=we+Je*Nt;if(dn>=0&&dn<R){const mn=m[te][He][dn][Te]+y[Ne][Je][Te];mn>Le&&(Le=mn,$e=Ne,je=Je)}}}Zt[$e][je][Te]+=qt[te][ue][De][Te]}}}return{dataId:p.write(Jc(Zt,i.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},q_={kernelName:hl,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:n})=>{const{x:i,filter:a,dy:o}=r,{strides:u,pad:h,dilations:f}=n,p=t,m=Tr(i.shape,p.data.get(i.dataId).values),y=Tr(a.shape,p.data.get(a.dataId).values),{batchSize:b,inHeight:T,inWidth:R,inChannels:L,outHeight:V,outWidth:j,padInfo:H,strideHeight:nt,strideWidth:dt,filterHeight:yt,filterWidth:kt,dilationHeight:Ot,dilationWidth:Nt,outShape:Vt}=cp(i.shape,a.shape,u,h,"NHWC",f);Z(o.rank===Vt.length,()=>`Error in ${hl}, dy must have the same rank as output ${Vt.length}, but got ${o.rank}`);const qt=Tr(Vt,p.data.get(o.dataId).values),Zt=br(i.shape,i.dtype);for(let te=0;te<b;++te)for(let ue=0;ue<V;++ue){const Ee=ue*nt-H.top;for(let De=0;De<j;++De){const we=De*dt-H.left;for(let Te=0;Te<L;++Te){let Le=Number.MIN_SAFE_INTEGER,$e=Ee<0?0:Ee,je=we<0?0:we;for(let Ne=0;Ne<yt;++Ne){const He=Ee+Ne*Ot;if(He>=0&&He<T)for(let Je=0;Je<kt;++Je){const dn=we+Je*Nt;if(dn>=0&&dn<R){const mn=m[te][He][dn][Te]+y[Ne][Je][Te];mn>Le&&(Le=mn,$e=He,je=dn)}}}Zt[te][$e][je][Te]+=qt[te][ue][De][Te]}}}return{dataId:p.write(Jc(Zt,i.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},hE=Ma((r,t)=>r*t),X_=oE((r,t,n,i)=>({real:r*n-t*i,imag:r*i+t*n})),lb=qa(Lu,hE,X_),Y_={kernelName:Lu,backendName:"cpu",kernelFunc:lb};function Zy(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i;let h;Hn(a,"sum"),h="bool"===a.dtype?Xp({inputs:{x:a},backend:n,attrs:{dtype:"int32"}}):bh({inputs:{x:a},backend:n});const f=h.shape.length,p=lr(o,h.shape),m=vs(p,f);let y=p,b=h;null!=m&&(b=ic({inputs:{x:h},backend:n,attrs:{perm:m}}),y=Ai(y.length,f)),zs("sum",y,b.shape.length);const[T,R]=sa(b.shape,y);let L=ob(n,T,di(b.dtype,"int32"));const V=Wt(R),j=n.data.get(L.dataId).values,H=n.data.get(b.dataId).values;for(let nt=0;nt<j.length;++nt){const dt=nt*V;let yt=0;for(let kt=0;kt<V;++kt)yt+=H[dt+kt];j[nt]=yt}if(u){const nt=L;L=Es({inputs:{x:L},backend:n,attrs:{shape:Ni(L.shape,p)}}),n.disposeIntermediateTensorInfo(nt)}return n.disposeIntermediateTensorInfo(h),null!=m&&n.disposeIntermediateTensorInfo(b),L}const K_={kernelName:uf,backendName:"cpu",kernelFunc:Zy},J_={kernelName:pl,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{equation:a}=i,o=t,{allDims:u,summedDims:h,idDims:f}=cy(a,o.length);uy(u.length,f,o);const{path:p,steps:m}=hy(h,f),y=m.length;let b=null,T=u.length;const R=[];for(let L=0;L<y;++L){for(const V of m[L]){const{permutationIndices:j,expandDims:H}=Zg(T,f[V]);let nt;cm(j)?nt=o[V]:(nt=ic({inputs:{x:o[V]},backend:n,attrs:{perm:j}}),R.push(nt));const dt=nt.shape.slice();for(let yt=0;yt<H.length;++yt)dt.splice(H[yt],0,1);We(nt.shape,dt)||(nt=Es({inputs:{x:nt},backend:n,attrs:{shape:dt}}),R.push(nt)),null===b?b=nt:(b=lb({inputs:{a:nt,b},backend:n}),R.push(b))}L<y-1&&(p[L]>=0&&(b=Zy({inputs:{x:b},backend:n,attrs:{axis:p[L]-(u.length-T),keepDims:!1}}),R.push(b)),T--)}for(const L of R)L!==b&&n.disposeIntermediateTensorInfo(L);return b}},Z_={kernelName:Pl,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{dy:i,y:a}=t;Hn([i,a],"eluGrad");const o=new Float32Array(Wt(a.shape)),u=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values;for(let f=0;f<u.length;++f){const p=u[f];o[f]=p>=1?h[f]:h[f]*(p+1)}return n.makeTensorInfo(a.shape,"float32",o)}},q2=Ma((r,t)=>r===t?1:0),X2=qa(wi,q2,null,"bool"),t3={kernelName:wi,backendName:"cpu",kernelFunc:X2},e3=Yg,n3=bu,r3=Kg,i3=ay,s3=xu,a3=oy,o3=ji(Wo,r=>{const t=Math.sign(r),n=Math.abs(r),i=1/(1+e3*n);return t*(1-((((a3*i+s3)*i+i3)*i+r3)*i+n3)*i*Math.exp(-n*n))}),l3={kernelName:Wo,backendName:"cpu",kernelFunc:o3},Y2=qp(r=>Math.exp(r)),K2=DA(xh,Y2,"float32"),c3={kernelName:xh,backendName:"cpu",kernelFunc:K2};function cb(r){const{inputs:t,backend:n,attrs:i}=r,{input:a}=t,{dim:o}=i,u=a.shape.length,h=a.shape.slice();let f=o;return o<0&&(Z(-(u+1)<=o,()=>`Axis must be in the interval [${-(u+1)}, ${u}]`),f=u+o+1),h.splice(f,0,1),Es({inputs:{x:a},backend:n,attrs:{shape:h}})}const u3={kernelName:vo,backendName:"cpu",kernelFunc:cb},J2=qp(r=>Math.expm1(r)),h3=DA(qi,J2),d3={kernelName:qi,backendName:"cpu",kernelFunc:h3},p3=Ma((r,t)=>r/t),dE=qa(Ho,p3),pE={kernelName:Ho,backendName:"cpu",kernelFunc:dE},Z2=Ma((r,t)=>r-t),f3=oE((r,t,n,i)=>({real:r-n,imag:t-i})),fE=qa(eo,Z2,f3),m3={kernelName:eo,backendName:"cpu",kernelFunc:fE};function tC(r,t,n){const i=r.shape,a=i[0],o=i[1],u=n.data.get(r.dataId),h=u.complexTensorInfos.real,f=u.complexTensorInfos.imag,p=[a,o],m=Wt(p),y=Ut("float32",m),b=Ut("float32",m);for(let V=0;V<a;V++){const j=_m({inputs:{x:h},backend:n,attrs:{begin:[V,0],size:[1,o]}}),H=_m({inputs:{x:f},backend:n,attrs:{begin:[V,0],size:[1,o]}}),nt=Dl({inputs:{real:j,imag:H},backend:n}),{real:dt,imag:yt}=g3(nt,t,n),kt=wu(dt,yt);for(let Ot=0;Ot<o;Ot++){const Nt=lm(kt,Ot);y[V*o+Ot]=Nt.real,b[V*o+Ot]=Nt.imag}n.disposeIntermediateTensorInfo(j),n.disposeIntermediateTensorInfo(H),n.disposeIntermediateTensorInfo(nt)}const T=n.makeTensorInfo(p,"float32",y),R=n.makeTensorInfo(p,"float32",b),L=Dl({inputs:{real:T,imag:R},backend:n});return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(R),L}function g3(r,t,n){const i=Wt(r.shape),a=n.data.get(r.dataId),o=n.data.get(a.complexTensorInfos.real.dataId).values,u=n.data.get(a.complexTensorInfos.imag.dataId).values;if(!((h=i)&h-1)){const f=mE(o,u,i,t,n),p=[r.shape[0],r.shape[1]];if(t){const m=n.makeTensorInfo(p,"float32",f.real),y=n.makeTensorInfo(p,"float32",f.imag),b=n.makeTensorInfo([],"float32",Kc(i,"float32")),T=bh({inputs:{x:b},backend:n}),R=pE.kernelFunc({inputs:{a:m,b},backend:n}),L=pE.kernelFunc({inputs:{a:y,b:T},backend:n}),V=n.data.get(R.dataId).values,j=n.data.get(L.dataId).values;return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(L),{real:V,imag:j}}return f}return ly(function(f,p,m){const y=new Float32Array(2*p);for(let b=0;b<p;b++){let T=0,R=0;for(let L=0;L<p;L++){const V=lv(b*L,p,m),j=lm(f,L);T+=j.real*V.real-j.imag*V.imag,R+=j.real*V.imag+j.imag*V.real}m&&(T/=p,R/=p),av(y,T,R,b)}return y}(wu(o,u),i,t));var h}function mE(r,t,n,i,a){if(1===n)return{real:r,imag:t};const o=wu(r,t),u=n/2,h=Jg(o),f=h.real,p=h.imag,m=[f.length],y=a.makeTensorInfo(m,"float32",f),b=a.makeTensorInfo(m,"float32",p),T=Dl({inputs:{real:y,imag:b},backend:a}),R=sv(o),L=R.real,V=R.imag,j=[L.length],H=a.makeTensorInfo(j,"float32",L),nt=a.makeTensorInfo(j,"float32",V),dt=Dl({inputs:{real:H,imag:nt},backend:a}),yt=mE(f,p,u,i,a),kt=yt.real,Ot=yt.imag,Nt=[kt.length],Vt=a.makeTensorInfo(Nt,"float32",kt),qt=a.makeTensorInfo(Nt,"float32",Ot),Zt=Dl({inputs:{real:Vt,imag:qt},backend:a}),te=mE(L,V,u,i,a),ue=te.real,Ee=te.imag,De=[ue.length],we=a.makeTensorInfo(De,"float32",ue),Te=a.makeTensorInfo(De,"float32",Ee),Le=Dl({inputs:{real:we,imag:Te},backend:a}),$e=ov(n,i),je=[$e.real.length],Ne=a.makeTensorInfo(je,"float32",$e.real),He=a.makeTensorInfo(je,"float32",$e.imag),Je=Dl({inputs:{real:Ne,imag:He},backend:a}),dn=lb({inputs:{a:Je,b:Le},backend:a}),mn=Jy({inputs:{a:Zt,b:dn},backend:a}),Ln=fE({inputs:{a:Zt,b:dn},backend:a}),Rn=Tm({inputs:{input:mn},backend:a}),tr=Tm({inputs:{input:Ln},backend:a}),ur=LA({inputs:{input:mn},backend:a}),ir=LA({inputs:{input:Ln},backend:a}),er=FA({inputs:[Rn,tr],backend:a,attrs:{axis:0}}),Sr=FA({inputs:[ur,ir],backend:a,attrs:{axis:0}}),Vr=a.data.get(er.dataId).values,gi=a.data.get(Sr.dataId).values;return a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(nt),a.disposeIntermediateTensorInfo(dt),a.disposeIntermediateTensorInfo(Vt),a.disposeIntermediateTensorInfo(qt),a.disposeIntermediateTensorInfo(Zt),a.disposeIntermediateTensorInfo(we),a.disposeIntermediateTensorInfo(Te),a.disposeIntermediateTensorInfo(Le),a.disposeIntermediateTensorInfo(Ne),a.disposeIntermediateTensorInfo(He),a.disposeIntermediateTensorInfo(Je),a.disposeIntermediateTensorInfo(dn),a.disposeIntermediateTensorInfo(mn),a.disposeIntermediateTensorInfo(Ln),a.disposeIntermediateTensorInfo(Rn),a.disposeIntermediateTensorInfo(ur),a.disposeIntermediateTensorInfo(tr),a.disposeIntermediateTensorInfo(ir),a.disposeIntermediateTensorInfo(er),a.disposeIntermediateTensorInfo(Sr),{real:Vr,imag:gi}}const A3={kernelName:ps,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{input:i}=t,a=Wt(i.shape),o=i.shape[i.shape.length-1],u=Es({inputs:{x:i},backend:n,attrs:{shape:[a/o,o]}}),h=tC(u,!1,n),f=Es({inputs:{x:h},backend:n,attrs:{shape:i.shape}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),f}};function gE(r){const{backend:t,attrs:n}=r,{shape:i,value:a,dtype:o}=n,u=o||Mr(a),h=jt(u,Wt(i));return h.fill(a),t.makeTensorInfo(i,u,h)}const y3={kernelName:Nu,backendName:"cpu",kernelFunc:gE},v3={kernelName:Uc,backendName:"cpu",kernelFunc:({inputs:r,backend:n})=>{const{image:i}=r,a=n,o=Ut(i.dtype,Wt(i.shape)),[u,h,f,p]=i.shape,m=a.data.get(i.dataId).values;for(let y=0;y<u;y++){const b=y*f*h*p;for(let T=0;T<h;T++){const R=T*(f*p);for(let L=0;L<f;L++){const V=L*p;for(let j=0;j<p;j++){const H=Math.round(f-L-1),nt=b+R+V+j;let dt=m[nt];H>=0&&H<f&&(dt=m[b+R+H*p+j]),o[nt]=dt}}}}return{dataId:a.write(o,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},eC=qp(r=>Math.floor(r)),b3=DA(ac,eC),x3={kernelName:ac,backendName:"cpu",kernelFunc:b3},w3=Ma((r,t)=>Math.floor(r/t)),E3=qa(Ii,w3,null,"int32"),C3={kernelName:Ii,backendName:"cpu",kernelFunc:E3},I3={kernelName:Bh,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o,bias:u,preluActivationWeights:h}=t,{strides:f,pad:p,dataFormat:m,dilations:y,dimRoundingMode:b,activation:T,leakyreluAlpha:R}=i;let L=W2({inputs:{x:a,filter:o},backend:n,attrs:{strides:f,pad:p,dataFormat:m,dilations:y,dimRoundingMode:b}});if(u){const V=L;L=Jy({inputs:{a:L,b:u},backend:n}),n.disposeIntermediateTensorInfo(V)}if(T){const V=L;L=aE(n,L,T,h,R),n.disposeIntermediateTensorInfo(V)}return L}},S3={kernelName:Ls,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o,bias:u,preluActivationWeights:h}=t,{strides:f,pad:p,dataFormat:m,dilations:y,dimRoundingMode:b,activation:T,leakyreluAlpha:R}=i;let L=j2({inputs:{x:a,filter:o},backend:n,attrs:{strides:f,pad:p,dataFormat:m,dilations:y,dimRoundingMode:b}});if(u){const V=L;L=Jy({inputs:{a:L,b:u},backend:n}),n.disposeIntermediateTensorInfo(V)}if(T){const V=L;L=aE(n,L,T,h,R),n.disposeIntermediateTensorInfo(V)}return L}};function nC(r,t,n,i,a,o,u,h,f){const p=$r([i,o],n);for(let m=0;m<i;m++){const y=[];let b=0;for(let T=0;T<a;T++){const R=r[m*a+T];b+=R*u[T],y.push(R)}if(b<0||b>=f/o)throw new Error(`Invalid indices: ${y} does not index into ${h}`);for(let T=0;T<o;T++)p.values[m*o+T]=t.get(...t.indexToLoc(b*o+T))}return p}const M3={kernelName:Fm,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{params:i,indices:a}=t,o=Wt(i.shape),u=a.shape,h=u[u.length-1],[f,p,m,y]=Ef(i,a);if(0===p)return n.makeTensorInfo(f,i.dtype,[]);const b=nC(n.data.get(a.dataId).values,n.bufferSync(i),i.dtype,p,h,m,y,i.shape,o);return n.makeTensorInfo(f,i.dtype,b.values)}};function rC(r,t,n){const i=$r(n,r.dtype);for(let a=0;a<i.size;++a){const o=i.indexToLoc(a).slice(),f=t.locToIndex([o[0],o[2]]);o[2]=t.values[f];const p=r.locToIndex(o);0<=p&&p<r.values.length&&(i.values[a]=r.values[p])}return i}const T3={kernelName:$c,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,indices:o}=t,{axis:u,batchDims:h}=i;Hn([a,o],"gatherV2");const f=lr(u,a.shape)[0],p=n.data.get(o.dataId).values,m=a.shape[f];for(let nt=0;nt<p.length;++nt){const dt=p[nt];Z(dt<=m-1&&dt>=0,()=>`GatherV2: the index value ${dt} is not in [0, ${m-1}]`)}let y=h;null==h&&(y=0);const b=Wt(o.shape),T=yy(a,o,f,y),R=Es({inputs:{x:a},backend:n,attrs:{shape:[T.batchSize,T.outerSize,T.dimSize,T.sliceSize]}}),L=Es({inputs:{x:o},backend:n,attrs:{shape:[T.batchSize,b/T.batchSize]}}),V=[T.batchSize,T.outerSize,b/T.batchSize,T.sliceSize],j=n.bufferSync(L),H=rC(n.bufferSync(R),j,V);return n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(L),n.makeTensorInfo(T.outputShape,H.dtype,H.values)}},iC=Ma((r,t)=>r>t?1:0),_3=qa(Ul,iC,null,"bool"),k3={kernelName:Ul,backendName:"cpu",kernelFunc:_3},sC=Ma((r,t)=>r>=t?1:0),R3=qa(Id,sC,null,"bool"),B3={kernelName:Id,backendName:"cpu",kernelFunc:R3},N3={kernelName:Om,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{input:i}=t,a=Wt(i.shape),o=i.shape[i.shape.length-1],u=Es({inputs:{x:i},backend:n,attrs:{shape:[a/o,o]}}),h=tC(u,!0,n),f=Es({inputs:{x:h},backend:n,attrs:{shape:i.shape}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),f}},D3=ji(Md,r=>Number.isFinite(r)?1:0,"bool"),L3={kernelName:Md,backendName:"cpu",kernelFunc:D3},F3=ji(Td,r=>Math.abs(r)===1/0?1:0,"bool"),O3={kernelName:Td,backendName:"cpu",kernelFunc:F3},P3=ji(_d,r=>Number.isNaN(r)?1:0,"bool"),U3={kernelName:_d,backendName:"cpu",kernelFunc:P3},aC=Ma((r,t)=>r<t?1:0),z3=qa(Jp,aC,null,"bool"),$3={kernelName:Jp,backendName:"cpu",kernelFunc:z3},oC=Ma((r,t)=>r<=t?1:0),V3=qa(Zp,oC,null,"bool"),G3={kernelName:Zp,backendName:"cpu",kernelFunc:V3};function lC(r,t,n){const i=(t-r)/(n-1),a=wn(n,"float32");a[0]=r;for(let o=1;o<a.length;o++)a[o]=a[o-1]+i;return a}const Q3={kernelName:Um,backendName:"cpu",kernelFunc:function(r){const{backend:t,attrs:n}=r,{start:i,stop:a,num:o}=n,u=lC(i,a,o);return t.makeTensorInfo([u.length],"float32",u)}},cC=qp(r=>Math.log(r)),H3=DA(kd,cC),W3={kernelName:kd,backendName:"cpu",kernelFunc:H3},j3=ji(Rd,r=>Math.log1p(r)),q3={kernelName:Rd,backendName:"cpu",kernelFunc:j3},X3=Ma((r,t)=>r&&t),Y3=qa(wh,X3,null,"bool"),K3={kernelName:wh,backendName:"cpu",kernelFunc:Y3},J3=ji(Bd,r=>r?0:1,"bool"),Z3={kernelName:Bd,backendName:"cpu",kernelFunc:J3},tk=Ma((r,t)=>r||t),ek=qa(Nd,tk,null,"bool"),nk={kernelName:Nd,backendName:"cpu",kernelFunc:ek},rk={kernelName:Eh,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{depthRadius:o,bias:u,alpha:h,beta:f}=i;Hn(a,"LRN");const p=a.shape[3],m=p-1,y=n.data.get(a.dataId).values,b=Wt(a.shape),T=new Float32Array(b);function R(L){const V=L%p;let j=L-V+Math.max(0,V-o);const H=L-V+Math.min(V+o,m);let nt=0;for(;j<=H;j++){const dt=y[j];nt+=dt*dt}return nt}for(let L=0;L<b;L++){const V=R(L),j=y[L]*Math.pow(u+h*V,-f);T[L]=j}return n.makeTensorInfo(a.shape,a.dtype,T)}},ik={kernelName:tf,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,y:o,dy:u}=t,{depthRadius:h,bias:f,alpha:p,beta:m}=i;Hn(u,"LRNGrad");const y=Wt(u.shape),b=u.shape[3],T=n.data.get(u.dataId).values,R=n.data.get(a.dataId).values,L=n.data.get(o.dataId).values,V=new Float32Array(y),j=y;for(let H=0;H<j;H++){const nt=H%b,dt=H-nt+Math.max(0,nt-h),yt=H-nt+Math.min(b,nt+h+1);let kt=0;for(let Ot=dt;Ot<yt;Ot++)kt+=Math.pow(R[Ot],2);kt=p*kt+f;for(let Ot=dt;Ot<yt;Ot++){let Nt=-2*p*m*R[Ot]*L[H]/kt;H===Ot&&(Nt+=Math.pow(kt,-m)),Nt*=T[H],V[Ot]+=Nt}}return n.makeTensorInfo(u.shape,a.dtype,V)}};function uC(r,t,n,i){const a=Ut(i,Wt(n));for(let o=0;o<a.length;++o){const u=o*t;let h=r[u];for(let f=0;f<t;++f){const p=r[u+f];(Number.isNaN(p)||p>h)&&(h=p)}a[o]=h}return a}function hC(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{reductionIndices:o,keepDims:u}=i,h=n;let f=a.shape;const p=f.length,m=lr(o,f);let y=m;const b=vs(y,p);let T=h.data.get(a.dataId).values;if(null!=b){const nt=new Array(p);for(let dt=0;dt<nt.length;dt++)nt[dt]=f[b[dt]];T=lE(T,f,a.dtype,b,nt),y=Ai(y.length,p),f=nt}Hn(a,"max"),zs("max",y,p);const[R,L]=sa(f,y),V=uC(T,Wt(L),R,a.dtype),j=h.write(V,R,a.dtype);let H=R;return u&&(H=Ni(R,m)),{dataId:j,shape:H,dtype:a.dtype}}const sk={kernelName:Dd,backendName:"cpu",kernelFunc:hC},dC=Ma((r,t)=>Math.max(r,t)),ak=qa(Ch,dC),ok={kernelName:Ch,backendName:"cpu",kernelFunc:ak},lk={kernelName:Ld,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t;Hn(a,"maxPool");const{filterSize:o,strides:u,pad:h,dimRoundingMode:f}=i;Z(Na(u,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`);const p=el(a.shape,o,u,1,h,f);let m;if(1===p.filterWidth&&1===p.filterHeight&&We(p.inShape,p.outShape))m=bh({inputs:{x:a},backend:n});else{const y=n.data.get(a.dataId).values,b=gn(a.shape),T=cE(y,0,a.dtype,b,p,"max");m=n.makeTensorInfo(p.outShape,a.dtype,T.values)}return m}},ck={kernelName:ef,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{filterSize:o,strides:u,pad:h,dimRoundingMode:f,dataFormat:p}=i;Hn(a,"maxPool3d");const m=yc(a.shape,o,u,1,h,f,p),y=$2(n.data.get(a.dataId).values,0,a.dtype,gn(a.shape),m,"max");return n.makeTensorInfo(y.shape,"float32",y.values)}},uk={kernelName:zm,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,input:o}=t,{filterSize:u,strides:h,pad:f,dimRoundingMode:p}=i;Hn([a,o],"maxPool3DGrad");const m=yc(o.shape,u,h,1,f,p),y=function(qt,Zt){const te=$r(Zt.outShape,"int32"),ue=Zt.strideDepth,Ee=Zt.strideHeight,De=Zt.strideWidth,we=Zt.dilationDepth,Te=Zt.dilationHeight,Le=Zt.dilationWidth,$e=Zt.effectiveFilterDepth,je=Zt.effectiveFilterHeight,Ne=Zt.effectiveFilterWidth,He=Zt.padInfo.front,Je=Zt.padInfo.top,dn=Zt.padInfo.left;for(let mn=0;mn<Zt.batchSize;++mn)for(let Ln=0;Ln<Zt.inChannels;++Ln)for(let Rn=0;Rn<Zt.outDepth;++Rn){const tr=Rn*ue-He;let ur=tr;for(;ur<0;)ur+=we;const ir=Math.min(Zt.inDepth,$e+tr);for(let er=0;er<Zt.outHeight;++er){const Sr=er*Ee-Je;let Vr=Sr;for(;Vr<0;)Vr+=Te;const gi=Math.min(Zt.inHeight,je+Sr);for(let Cr=0;Cr<Zt.outWidth;++Cr){const Rr=Cr*De-dn;let Kr=Rr;for(;Kr<0;)Kr+=Le;const la=Math.min(Zt.inWidth,Ne+Rr);let ho=Number.NEGATIVE_INFINITY,po=-1;for(let ca=ur;ca<ir;ca+=we){const wd=ca-tr;for(let Fa=Vr;Fa<gi;Fa+=Te){const fo=Fa-Sr;for(let Vo=Kr;Vo<la;Vo+=Le){const Bu=Vo-Rr,Ed=qt.get(mn,ca,Fa,Vo,Ln);Ed>=ho&&(ho=Ed,po=wd*je*Ne+fo*je+Bu)}}}te.set(po,mn,Rn,er,Cr,Ln)}}}return te}(n.bufferSync(o),m),b=m.strideDepth,T=m.strideHeight,R=m.strideWidth,L=m.dilationDepth,V=m.dilationHeight,j=m.dilationWidth,H=m.effectiveFilterDepth,nt=m.effectiveFilterHeight,dt=m.effectiveFilterWidth,yt=H-1-m.padInfo.front,kt=dt-1-m.padInfo.left,Ot=nt-1-m.padInfo.top,Nt=$r(o.shape,"float32"),Vt=n.bufferSync(a);for(let qt=0;qt<m.batchSize;++qt)for(let Zt=0;Zt<m.inChannels;++Zt)for(let te=0;te<m.inDepth;++te)for(let ue=0;ue<m.inHeight;++ue)for(let Ee=0;Ee<m.inWidth;++Ee){const De=te-yt,we=ue-Ot,Te=Ee-kt;let Le=0;for(let $e=0;$e<H;$e+=L){const je=(De+$e)/b;if(!(je<0||je>=m.outDepth||Math.floor(je)!==je))for(let Ne=0;Ne<nt;Ne+=V){const He=(we+Ne)/T;if(!(He<0||He>=m.outHeight||Math.floor(He)!==He))for(let Je=0;Je<dt;Je+=j){const dn=(Te+Je)/R;if(dn<0||dn>=m.outWidth||Math.floor(dn)!==dn)continue;const mn=H*nt*dt-1-y.get(qt,je,He,dn,Zt)===$e*nt*dt+Ne*dt+Je?1:0;0!==mn&&(Le+=Vt.get(qt,je,He,dn,Zt)*mn)}}}Nt.set(Le,qt,te,ue,Ee,Zt)}return n.makeTensorInfo(Nt.shape,Nt.dtype,Nt.values)}},hk={kernelName:Du,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,input:o,output:u}=t,h=o;Hn([o,u],"maxPoolGrad");const{filterSize:f,strides:p,pad:m,dimRoundingMode:y}=i,b=el(h.shape,f,p,1,m,y),T=n.data.get(h.dataId).values,R=$r(b.outShape,h.dtype,z2(T,h.shape,h.dtype,b).values),L=b.strideHeight,V=b.strideWidth,j=b.dilationHeight,H=b.dilationWidth,nt=b.effectiveFilterHeight,dt=b.effectiveFilterWidth,yt=dt-1-b.padInfo.left,kt=nt-1-b.padInfo.top,Ot=$r(h.shape,"float32"),Nt=n.data.get(a.dataId).values,Vt=$r(a.shape,"float32",Nt);for(let qt=0;qt<b.batchSize;++qt)for(let Zt=0;Zt<b.inChannels;++Zt)for(let te=0;te<b.inHeight;++te)for(let ue=0;ue<b.inWidth;++ue){const Ee=te-kt,De=ue-yt;let we=0;for(let Te=0;Te<nt;Te+=j){const Le=(Ee+Te)/L;if(!(Le<0||Le>=b.outHeight||Math.floor(Le)!==Le))for(let $e=0;$e<dt;$e+=H){const je=(De+$e)/V;if(je<0||je>=b.outWidth||Math.floor(je)!==je)continue;const Ne=nt*dt-1-R.get(qt,Le,je,Zt)===Te*dt+$e?1:0;0!==Ne&&(we+=Vt.get(qt,Le,je,Zt)*Ne)}}Ot.set(we,qt,te,ue,Zt)}return n.makeTensorInfo(Ot.shape,Ot.dtype,Ot.values)}},dk={kernelName:$m,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:n})=>{const{x:i}=r,{filterSize:a,strides:o,pad:u,includeBatchInIndex:h}=t,f=n;Hn(i,"MaxPoolWithArgmax");const p=f.data.get(i.dataId).values,m=el(i.shape,a,o,[1,1],u),[y,b]=function(L,V,j,H,nt){const dt=cE(L,0,j,gn(V),nt,"max"),yt=z2(L,V,j,nt,!0,H);return[dt.values,yt.values]}(p,i.shape,i.dtype,h,m),T=f.write(y,m.outShape,i.dtype),R=f.write(b,m.outShape,i.dtype);return[{dataId:T,shape:m.outShape,dtype:i.dtype},{dataId:R,shape:m.outShape,dtype:"int32"}]}},pk={kernelName:nf,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i,h=lr(o,a.shape),f=Wt(sa(a.shape,h)[1]),p=[],m=n.makeTensorInfo([],"float32",new Float32Array([f]));p.push(m);const y=Xp({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});p.push(y);const b=dE({inputs:{a:y,b:m},backend:n});p.push(b);const T=Zy({inputs:{x:b},backend:n,attrs:{axis:o,keepDims:u}});return p.forEach(R=>n.disposeIntermediateTensorInfo(R)),T}},fk={kernelName:rf,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i;Hn(a,"min");const h=lr(o,a.shape);let f=h;const p=vs(f,a.shape.length);let m=a;null!=p&&(m=ic({inputs:{x:a},backend:n,attrs:{perm:p}}),f=Ai(f.length,a.shape.length)),zs("min",f,m.shape.length);const[y,b]=sa(m.shape,f),T=Wt(b),R=wn(Wt(y),m.dtype),L=n.data.get(m.dataId).values;for(let j=0;j<R.length;++j){const H=j*T;let nt=L[H];for(let dt=0;dt<T;++dt){const yt=L[H+dt];(Number.isNaN(yt)||yt<nt)&&(nt=yt)}R[j]=nt}null!=p&&n.disposeIntermediateTensorInfo(m);const V=n.makeTensorInfo(y,m.dtype,R);if(u){const j=Es({inputs:{x:V},backend:n,attrs:{shape:Ni(y,h)}});return n.disposeIntermediateTensorInfo(V),j}return V}},pC=Ma((r,t)=>Math.min(r,t)),mk=qa(Fd,pC),gk={kernelName:Fd,backendName:"cpu",kernelFunc:mk},Ak={kernelName:sf,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{paddings:o,mode:u}=i;Hn(a,"mirrorPad");const h=o.map((H,nt)=>H[0]+a.shape[nt]+H[1]),f=o.map(H=>H[0]),p=o.map((H,nt)=>H[0]+a.shape[nt]),m="reflect"===u?0:1,y=n.data.get(a.dataId).values,b=a.shape.length,T=gn(a.shape),R=Wt(h),L=h.length,V=gn(h),j=Ut(a.dtype,R);for(let H=0;H<R;H++){let nt=ai(H,L,V);for(let yt=0;yt<L;yt++)nt[yt]<f[yt]?nt[yt]=2*f[yt]-nt[yt]-m:nt[yt]>=p[yt]&&(nt[yt]=2*(p[yt]-1)-nt[yt]+m);nt=nt.map((yt,kt)=>yt-f[kt]);const dt=cr(nt,b,T);j[H]=y[dt]}return{dataId:n.write(j,h,a.dtype),shape:h,dtype:a.dtype}}},yk=Ma((r,t)=>{const n=r%t;return r<0&&t<0||r>=0&&t>=0?n:(n+t)%t}),vk=qa(Od,yk),bk={kernelName:Od,backendName:"cpu",kernelFunc:vk};function fC(r){const{inputs:t,backend:n,attrs:i}=r,{logits:a}=t,{dim:o}=i,u=a.shape.length;let h=o;if(-1===h&&(h=u-1),h!==u-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${u} and dim was ${h}`);const f=lr([h],a.shape),p=hC({inputs:{x:a},backend:n,attrs:{reductionIndices:f,keepDims:!1}}),m=Ni(p.shape,f),y=Es({inputs:{x:p},backend:n,attrs:{shape:m}}),b=fE({inputs:{a,b:y},backend:n}),T=K2({inputs:{x:b},backend:n}),R=Zy({inputs:{x:T},backend:n,attrs:{axis:f,keepDims:!1}}),L=Es({inputs:{x:R},backend:n,attrs:{shape:m}}),V=dE({inputs:{a:T,b:L},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(L),V}const xk={kernelName:$d,backendName:"cpu",kernelFunc:fC},wk={kernelName:Vm,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{logits:a}=t,{numSamples:o,seed:u,normalized:h}=i;Hn(a,"multinomial");const f=h?a:fC({inputs:{logits:a},backend:n,attrs:{dim:-1}}),p=f.shape[0],m=f.shape[1],y=n.data.get(f.dataId).values,b=[p,o],T=wn(Wt(b),"int32");for(let R=0;R<p;++R){const L=R*m,V=new Float32Array(m-1);V[0]=y[L];for(let nt=1;nt<V.length;++nt)V[nt]=V[nt-1]+y[L+nt];const j=rh.alea(u.toString()),H=R*o;for(let nt=0;nt<o;++nt){const dt=j();T[H+nt]=V.length;for(let yt=0;yt<V.length;yt++)if(dt<V[yt]){T[H+nt]=yt;break}}}return h||n.disposeIntermediateTensorInfo(f),n.makeTensorInfo(b,"int32",T)}};function mC(r,t,n){const i=Kc(-1,n);return hE([],t,i,r,n)}const Ek={kernelName:ko,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{x:i}=t;Hn(i,"neg");const a=n.data.get(i.dataId).values,[o,u]=mC(a,i.shape,i.dtype);return n.makeTensorInfo(u,i.dtype,o)}},Ck=Vg,Ik={kernelName:to,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{boxes:a,scores:o}=t,{maxOutputSize:u,iouThreshold:h,scoreThreshold:f}=i;Hn(a,"NonMaxSuppression");const p=n.data.get(a.dataId).values,m=n.data.get(o.dataId).values,{selectedIndices:y}=Ck(p,m,u,h,f);return n.makeTensorInfo([y.length],"int32",new Int32Array(y))}},Sk=Il,Mk={kernelName:fa,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{boxes:a,scores:o}=t,{maxOutputSize:u,iouThreshold:h,scoreThreshold:f,padToMaxOutputSize:p}=i;Hn(a,"NonMaxSuppressionPadded");const m=n.data.get(a.dataId).values,y=n.data.get(o.dataId).values,{selectedIndices:b,validOutputs:T}=Sk(m,y,u,h,f,p);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([],"int32",new Int32Array([T]))]}},Tk=Bp,_k={kernelName:af,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{boxes:a,scores:o}=t,{maxOutputSize:u,iouThreshold:h,scoreThreshold:f,softNmsSigma:p}=i;Hn(a,"NonMaxSuppressionWithScore");const m=n.data.get(a.dataId).values,y=n.data.get(o.dataId).values,b=u,T=h,R=f,L=p,{selectedIndices:V,selectedScores:j}=Tk(m,y,b,T,R,L);return[n.makeTensorInfo([V.length],"int32",new Int32Array(V)),n.makeTensorInfo([j.length],"float32",new Float32Array(j))]}},gC=Ma((r,t)=>r!==t?1:0),kk=qa(Vc,gC,null,"bool"),Rk={kernelName:Vc,backendName:"cpu",kernelFunc:kk},Bk={kernelName:oc,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{indices:a}=t,{depth:o,onValue:u,offValue:h}=i;Hn(a,"oneHot");const f=Wt(a.shape),p=new Float32Array(f*o);p.fill(h);const m=n.data.get(a.dataId).values;for(let y=0;y<f;++y)m[y]>=0&&m[y]<o&&(p[y*o+m[y]]=u);return n.makeTensorInfo([...a.shape,o],"int32",p)}};function ub(r){const{inputs:t,backend:n}=r,{x:i}=t;if("string"===i.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===i.dtype){const a=Tm({inputs:{input:i},backend:n}),o=ub({inputs:{x:a},backend:n}),u=LA({inputs:{input:i},backend:n}),h=ub({inputs:{x:u},backend:n}),f=Dl({inputs:{real:o,imag:h},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),f}return gE({backend:n,attrs:{shape:i.shape,value:0,dtype:i.dtype}})}const Nk={kernelName:$u,backendName:"cpu",kernelFunc:ub},Dk={kernelName:zl,backendName:"cpu",kernelFunc:function r(t){const{inputs:n,backend:i}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){const o=Tm({inputs:{input:a},backend:i}),u=r({inputs:{x:o},backend:i}),h=LA({inputs:{input:a},backend:i}),f=ub({inputs:{x:h},backend:i}),p=Dl({inputs:{real:u,imag:f},backend:i});return i.disposeIntermediateTensorInfo(o),i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(f),p}return gE({backend:i,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function AC(r){const{inputs:t,backend:n,attrs:i}=r,{axis:a}=i;if(1===t.length)return cb({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const o=t[0].shape,u=t[0].dtype;t.forEach(p=>{_t(o,p.shape,"All tensors passed to stack must have matching shapes"),Z(u===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const h=[],f=FA({inputs:t.map(p=>{const m=cb({inputs:{input:p},backend:n,attrs:{dim:a}});return h.push(m),m}),backend:n,attrs:{axis:a}});return h.forEach(p=>n.disposeIntermediateTensorInfo(p)),f}const Lk={kernelName:Ua,backendName:"cpu",kernelFunc:AC},yC={kernelName:Ki,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{paddings:o,constantValue:u}=i;Hn(a,"pad");const h=o.map((j,H)=>j[0]+a.shape[H]+j[1]),f=o.map(j=>j[0]),p=n.data.get(a.dataId).values,m=Wt(a.shape),y=a.shape.length,b=gn(a.shape),T=Wt(h),R=h.length,L=gn(h),V=Ut(a.dtype,T);0!==u&&V.fill(u);for(let j=0;j<m;j++)V[cr(ai(j,y,b).map((H,nt)=>H+f[nt]),R,L)]=p[j];return{dataId:n.write(V,h,a.dtype),shape:h,dtype:a.dtype}}},Fk=Ma((r,t)=>Math.pow(r,t)),Ok=qa(lc,Fk),Pk={kernelName:lc,backendName:"cpu",kernelFunc:Ok};function vC(r,t,n,i){const[a,o]=sa(r,i),u=di(t,"int32"),h=wn(Wt(a),u),f=Wt(o);for(let p=0;p<h.length;++p){const m=p*f;let y=1;for(let b=0;b<f;++b)y*=n[m+b];h[p]=y}return{outVals:h,outShape:a,outDtype:u}}const Uk={kernelName:Br,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i;Hn(a,"prod");const h=a.shape.length,f=lr(o,a.shape),p=vs(f,h);let m=f,y=a;const b=[];null!=p&&(y=ic({inputs:{x:a},backend:n,attrs:{perm:p}}),b.push(y),m=Ai(m.length,h));const T=n.data.get(y.dataId).values,{outVals:R,outShape:L,outDtype:V}=vC(y.shape,y.dtype,T,m);let j=L;return u&&(j=Ni(L,f)),b.forEach(H=>n.disposeIntermediateTensorInfo(H)),n.makeTensorInfo(j,V,R)}};function bC(r,t,n,i){if(r===t||r<t&&n<0||t<r&&n>1)return wn(0,i);const a=wn(Math.abs(Math.ceil((t-r)/n)),i);t<r&&1===n&&(n=-1),a[0]=r;for(let o=1;o<a.length;o++)a[o]=a[o-1]+n;return a}const zk={kernelName:Fu,backendName:"cpu",kernelFunc:function(r){const{backend:t,attrs:n}=r,{start:i,stop:a,dtype:o,step:u}=n,h=bC(i,a,u,o);return t.makeTensorInfo([h.length],o,h)}},$k=ji(yr,r=>1/r),Vk={kernelName:yr,backendName:"cpu",kernelFunc:$k},Gk={kernelName:Qc,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{images:a}=t,{alignCorners:o,halfPixelCenters:u,size:h}=i;Hn(a,"resizeBilinear");const f=gn(a.shape),[p,m]=h,[y,b,T,R]=a.shape,L=n.data.get(a.dataId).values,V=new Float32Array(Wt([y,p,m,R])),j=[o&&p>1?b-1:b,o&&m>1?T-1:T],H=[o&&p>1?p-1:p,o&&m>1?m-1:m];let nt=0;const dt=j[0]/H[0],yt=j[1]/H[1];for(let kt=0;kt<y;kt++)for(let Ot=0;Ot<p;Ot++){let Nt;Nt=u?dt*(Ot+.5)-.5:dt*Ot;const Vt=Math.max(0,Math.floor(Nt)),qt=Nt-Vt,Zt=Math.min(b-1,Math.ceil(Nt)),te=kt*f[0]+Vt*f[1],ue=kt*f[0]+Zt*f[1];for(let Ee=0;Ee<m;Ee++){let De;De=u?yt*(Ee+.5)-.5:yt*Ee;const we=Math.max(0,Math.floor(De)),Te=De-we,Le=Math.min(T-1,Math.ceil(De)),$e=te+we*f[2],je=ue+we*f[2],Ne=te+Le*f[2],He=ue+Le*f[2];for(let Je=0;Je<R;Je++){const dn=L[$e+Je],mn=L[je+Je],Ln=dn+(L[Ne+Je]-dn)*Te;V[nt++]=Ln+(mn+(L[He+Je]-mn)*Te-Ln)*qt}}}return n.makeTensorInfo([y,p,m,R],"float32",V)}},Qk={kernelName:lf,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{images:a,dy:o}=t,{alignCorners:u}=i;Hn([o,a],"resizeBilinearGrad");const h=gn(a.shape),[f,p,m,y]=a.shape,[,b,T]=o.shape,R=new Float32Array(f*p*m*y),L=[u&&b>1?p-1:p,u&&T>1?m-1:m],V=[u&&b>1?b-1:b,u&&T>1?T-1:T],j=L[0]/V[0],H=L[1]/V[1],nt=n.data.get(o.dataId).values;let dt=0;for(let yt=0;yt<f;yt++){const kt=yt*h[0];for(let Ot=0;Ot<b;Ot++){const Nt=Ot*j,Vt=Math.floor(Nt),qt=Math.min(Math.ceil(Nt),p-1),Zt=kt+Vt*h[1],te=kt+qt*h[1],ue=Nt-Vt,Ee=1-ue;for(let De=0;De<T;De++){const we=De*H,Te=Math.floor(we),Le=Math.min(Math.ceil(we),m-1),$e=we-Te,je=1-$e,Ne=Zt+Te*h[2],He=Zt+Le*h[2],Je=te+Te*h[2],dn=te+Le*h[2],mn=Ee*je,Ln=Ee*$e,Rn=ue*je,tr=ue*$e;for(let ur=0;ur<y;ur++){const ir=nt[dt++];R[Ne+ur]+=ir*mn,R[He+ur]+=ir*Ln,R[Je+ur]+=ir*Rn,R[dn+ur]+=ir*tr}}}}return n.makeTensorInfo([f,m,p,y],"float32",R)}},Hk={kernelName:of,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{images:a}=t,{alignCorners:o,halfPixelCenters:u,size:h}=i;Hn(a,"resizeNearestNeighbor");const f=gn(a.shape),[p,m]=h,[y,b,T,R]=a.shape,L=n.data.get(a.dataId).values,V=new Float32Array(y*p*m*R),j=[o&&p>1?b-1:b,o&&m>1?T-1:T],H=[o&&p>1?p-1:p,o&&m>1?m-1:m],nt=j[0]/H[0],dt=j[1]/H[1];let yt=0;for(let kt=0;kt<y;kt++){const Ot=kt*f[0];for(let Nt=0;Nt<p;Nt++){const Vt=u?nt*(Nt+.5):nt*Nt;let qt=Math.min(b-1,o?Math.round(Vt):Math.floor(Vt));u&&(qt=Math.max(0,qt));const Zt=Ot+qt*f[1];for(let te=0;te<m;te++){const ue=u?dt*(te+.5):dt*te;let Ee=Math.min(T-1,o?Math.round(ue):Math.floor(ue));u&&(Ee=Math.max(0,Ee));const De=Zt+Ee*f[2];for(let we=0;we<R;we++)V[yt++]=L[De+we]}}}return n.makeTensorInfo([y,p,m,R],a.dtype,V)}},Wk={kernelName:Gc,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{images:a,dy:o}=t,{alignCorners:u}=i;Hn([o,a],"resizeNearestNeighborGrad");const h=gn(a.shape),f=gn(o.shape),[p,m,y,b]=a.shape,[,T,R]=o.shape,L=new Float32Array(p*m*y*b),V=n.data.get(o.dataId).values,j=[u&&T>1?m-1:m,u&&R>1?y-1:y],H=[u&&T>1?T-1:T,u&&R>1?R-1:R],nt=j[0]/H[0],dt=j[1]/H[1],yt=1/nt,kt=1/dt,Ot=2*Math.ceil(yt)+2,Nt=2*Math.ceil(kt)+2;for(let Vt=0;Vt<p;Vt++){const qt=Vt*h[0];for(let Zt=0;Zt<m;Zt++){const te=qt+Zt*h[1],ue=Math.floor(Zt*yt),Ee=Math.floor(ue-Ot/2);for(let De=0;De<y;De++){const we=te+De*h[2],Te=Math.floor(De*kt),Le=Math.floor(Te-Nt/2);for(let $e=0;$e<b;$e++){let je=0;for(let Ne=0;Ne<Ot;Ne++){const He=Ne+Ee;if(He<0||He>=T)continue;const Je=qt+He*f[1],dn=He*nt;if(Zt===Math.min(m-1,u?Math.round(dn):Math.floor(dn)))for(let mn=0;mn<Nt;mn++){const Ln=mn+Le;if(Ln<0||Ln>=R)continue;const Rn=Je+Ln*f[2],tr=Ln*dt;De===Math.min(y-1,u?Math.round(tr):Math.floor(tr))&&(je+=V[Rn+$e])}}L[we+$e]=je}}}}return n.makeTensorInfo(a.shape,a.dtype,L)}},jk={kernelName:Ud,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{dims:o}=i;Hn(a,"reverse");const u=a.shape.length,h=lr(o,a.shape);if(0===u)return bh({inputs:{x:a},backend:n});const f=new is(a.shape,a.dtype),p=n.bufferSync(a);for(let m=0;m<f.size;m++){const y=f.indexToLoc(m),b=y.slice();h.forEach(T=>b[T]=a.shape[T]-1-b[T]),f.set(p.get(...b),...y)}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},qk={kernelName:Hm,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:n})=>{const{image:i}=r,{radians:a,fillValue:o,center:u}=t,h=n,f=Ut(i.dtype,Wt(i.shape)),[p,m,y,b]=i.shape,[T,R]=iy(u,m,y),L=Math.sin(a),V=Math.cos(a),j=h.data.get(i.dataId).values;for(let H=0;H<p;H++){const nt=H*y*m*b;for(let dt=0;dt<m;dt++){const yt=dt*(y*b);for(let kt=0;kt<y;kt++){const Ot=kt*b;for(let Nt=0;Nt<b;Nt++){const Vt=[p,dt,kt,Nt],qt=Vt[2],Zt=Vt[1];let te=(qt-T)*V-(Zt-R)*L,ue=(qt-T)*L+(Zt-R)*V;te=Math.round(te+T),ue=Math.round(ue+R);let Ee=o;"number"!=typeof o&&(Ee=3===Nt?255:o[Nt]),te>=0&&te<y&&ue>=0&&ue<m&&(Ee=j[nt+ue*(y*b)+te*b+Nt]),f[nt+yt+Ot+Nt]=Ee}}}}return{dataId:h.write(f,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},Xk=ji(Sh,r=>{const t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2==0?t:t+1}),Yk={kernelName:Sh,backendName:"cpu",kernelFunc:Xk},xC=qp(r=>1/Math.sqrt(r)),Kk=DA(Mh,xC),Jk={kernelName:Mh,backendName:"cpu",kernelFunc:Kk};function wC(r,t,n,i,a,o,u,h,f,p){const m=[i/a,a],y=r.values,b=t.values;if(0===i)return $r(n,t.dtype);const T=$r(m,t.dtype);T.values.fill(f);for(let R=0;R<o;R++){const L=[];let V=0;for(let j=0;j<u;j++){const H=y[R*u+j];L.push(H),V+=H*h[j]}if(V<0||V>=i/a)throw new Error(`Invalid indices: ${L} does not index into ${n}`);for(let j=0;j<a;j++)p?T.values[V*a+j]+=b[R*a+j]:T.values[V*a+j]=0===t.rank?b[0]:b[R*a+j]}return T}const Zk={kernelName:Th,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{indices:a,updates:o}=t,{shape:u}=i,{sliceRank:h,numUpdates:f,sliceSize:p,strides:m,outputSize:y}=Gh(0,a,u),b=wC(n.bufferSync(a),n.bufferSync(o),u,y,p,f,h,m,0,!0);return n.makeTensorInfo(u,b.dtype,b.values)}},tR={kernelName:cf,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{condition:i,t:a,e:o}=t;Hn([i,a,o],"select");const u=i.shape.length,h=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,p=n.data.get(o.dataId).values,m=di(a.dtype,o.dtype),y=wn(Wt(a.shape),m);let b=0;const T=0===u||u>1||1===a.shape.length?1:Wt(a.shape.slice(1));for(let R=0;R<h.length;R++)for(let L=0;L<T;L++)y[b++]=1===h[R]?f[R]:p[R];return n.makeTensorInfo(a.shape,m,y)}},eR=_c,nR=Xg,rR=ji(Jr,r=>r>=0?nR*r:eR*(Math.exp(r)-1)),iR={kernelName:Jr,backendName:"cpu",kernelFunc:rR},sR=ji(_h,r=>r<0?-1:r>0?1:0),aR={kernelName:_h,backendName:"cpu",kernelFunc:sR},oR=ji(Pu,r=>Math.sin(r)),lR={kernelName:Pu,backendName:"cpu",kernelFunc:oR},cR=ji($l,r=>Math.sinh(r)),uR={kernelName:$l,backendName:"cpu",kernelFunc:cR},EC=Math.log(1.1920928955078125e-7)+2,hR=ji(fl,r=>{const t=r>-EC,n=r<EC,i=Math.exp(r);let a;return a=n?i:t?r:Math.log(1+i),a}),dR={kernelName:fl,backendName:"cpu",kernelFunc:hR},pR={kernelName:Vi,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{blockShape:o,paddings:u}=i;Hn([a],"spaceToBatchND");const h=Wt(o),f=[[0,0]];f.push(...u);for(let V=1+o.length;V<a.shape.length;++V)f.push([0,0]);const p=yC.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:f,constantValue:0}}),m=Fp(p.shape,o,h,!1),y=Op(m.length,o.length,!1),b=nc(p.shape,o,h,!1),T=Es({inputs:{x:p},backend:n,attrs:{shape:m}}),R=ic({inputs:{x:T},backend:n,attrs:{perm:y}}),L=Es({inputs:{x:R},backend:n,attrs:{shape:b}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(R),L}};function CC(r,t,n,i,a,o,u){const h=t[0],f=o[0],p=new Array(f),m=new Array(h),y=t[1];if(0===f){if(0!==h)throw new Error(cv(h));return[jt(n,0),[0,y],jt(a,0),p,m]}let b=!0,T=0;const R=new Array(f).fill(0);for(let V=0;V<h;++V){const j=r[V*y];if(j<0)throw new Error(uv(V,j));if(j>=f)throw new Error(py(V,j,f));++R[j],b=b&&j>=T,T=j}let L=!0;for(let V=0;V<f;++V){const j=0===R[V];p[V]=j,L=L&&!j,R[V]=Math.max(R[V],1),V>0&&(R[V]+=R[V-1])}if(L&&b){const V=r,j=i;for(let H=0;H<h;++H)m[H]=H;return[V,[h,y],j,p,m]}{const V=R[f-1],j=jt(n,V*y),H=jt(a,V),nt=new Array(f).fill(0);for(let dt=0;dt<h;++dt){const yt=r[dt*y],Ot=(0===yt?0:R[yt-1])+nt[yt];nt[yt]++;for(let Nt=0;Nt<y;++Nt)j[Ot*y+Nt]=r[dt*y+Nt];H[Ot]=i[dt],m[dt]=Ot}for(let dt=0;dt<f;++dt)if(0===nt[dt]){const yt=0===dt?0:R[dt-1];j[yt*y+0]=dt;for(let kt=1;kt<y;++kt)j[yt*y+kt]=0;H[yt]=u}return[j,[V,y],H,p,m]}}const fR={kernelName:bo,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{indices:i,values:a,denseShape:o,defaultValue:u}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==i.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${i.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==u.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${u.shape}`);const h=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,p=n.data.get(o.dataId).values,m=n.data.get(u.dataId).values[0],[y,b,T,R,L]=CC(h,i.shape,i.dtype,f,a.dtype,p,m);return[n.makeTensorInfo(b,i.dtype,y),n.makeTensorInfo([b[0]],a.dtype,T),n.makeTensorInfo([R.length],"bool",new Uint8Array(R.map(V=>Number(V)))),n.makeTensorInfo([L.length],i.dtype,new Int32Array(L))]}};function IC(r,t,n,i,a){const o=Wt(i),u=t[0],h=a.length,f=[];let p=1,m=-1;for(let L=0;L<h;++L){const V=a[L];if(-1===V){if(-1!==m)throw new Error(hv(m,L));m=L,f.push(1)}else{if(V<0)throw new Error(fy(L,V));p*=V,f.push(V)}}if(-1!==m){if(p<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const L=Math.trunc(o/p);if(p*L!==o)throw new Error(dv(i,f));f[m]=L}if(Wt(f)!==o)throw new Error(pv(i,f));const y=i.length,b=[];if(y>0){b[y-1]=1;for(let L=y-2;L>=0;--L)b[L]=b[L+1]*i[L+1]}const T=[];if(h>0){T[h-1]=1;for(let L=h-2;L>=0;--L)T[L]=T[L+1]*f[L+1]}const R=jt(n,u*h);for(let L=0;L<u;++L){let V=0;for(let j=0;j<y;++j)V+=r[L*y+j]*b[j];for(let j=0;j<h;++j)R[L*h+j]=Math.trunc(V/T[j]),V%=T[j]}return[R,[u,h],f]}const mR={kernelName:kh,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{inputIndices:i,inputShape:a,newShape:o}=t;if(2!==i.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${i.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const u=Array.from(n.data.get(a.dataId).values),h=n.data.get(i.dataId).values,f=Array.from(n.data.get(o.dataId).values),[p,m,y]=IC(h,i.shape,i.dtype,u,f);return[n.makeTensorInfo(m,i.dtype,p),n.makeTensorInfo([y.length],o.dtype,new Int32Array(y))]}};function AE(r,t,n,i,a,o=!1,u=0){const h=i.length,f=[t[0],r.length/t[0]],p=f[1],m=h>0?a[h-1]+1:0;if(m<0)throw new Error("segment ids must be >= 0");const y=t.slice();y[0]=m;const b=jt(n,y.reduce((j,H)=>j*H,1));if(0===h)return m>0&&b.fill(u),[b,y];if(m<=0)throw new Error("segment ids must be >= 0");let T=0,R=1,L=0,V=a[T];for(;;){let j=0;if(R<h){if(j=a[R],V===j){++R;continue}if(V>=j)throw new Error("segment ids are not increasing")}if(V<0||V>=m)throw new Error(gy(V,m));V>L&&b.fill(u,L*p,V*p);for(let H=T;H<R;++H){const nt=i[H];if(nt<0||nt>=f[0])throw new Error(um(H,i[H],f[0]));for(let dt=0;dt<p;dt++)b[V*p+dt]+=r[nt*p+dt]}if(o)for(let H=0;H<p;H++)b[V*p+H]/=R-T;if(T=R,++R,L=V+1,V=j,R>h)break}return L<m&&b.fill(u,L*p,m*p),[b,y]}const gR={kernelName:Gm,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{data:i,indices:a,segmentIds:o}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(a.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const u=n.data.get(i.dataId).values,h=n.data.get(a.dataId).values,f=n.data.get(o.dataId).values,[p,m]=AE(u,i.shape,i.dtype,h,f,!0);return n.makeTensorInfo(m,i.dtype,p)}},AR={kernelName:Rh,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n}=r,{data:i,indices:a,segmentIds:o}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(a.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const u=n.data.get(i.dataId).values,h=n.data.get(a.dataId).values,f=n.data.get(o.dataId).values,[p,m]=AE(u,i.shape,i.dtype,h,f);return n.makeTensorInfo(m,i.dtype,p)}},yR={kernelName:Qm,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{sparseIndices:a,sparseValues:o,defaultValue:u}=t,{outputShape:h}=i,{sliceRank:f,numUpdates:p,sliceSize:m,strides:y,outputSize:b}=Gh(0,a,h),T=wC(n.bufferSync(a),n.bufferSync(o),h,b,m,p,f,y,n.data.get(u.dataId).values[0],!1);return n.makeTensorInfo(h,T.dtype,T.values)}},vR={kernelName:li,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{numOrSizeSplits:o,axis:u}=i,h=lr(u,a.shape)[0],f=dy(a,o,h),p=new Array(a.shape.length).fill(0),m=a.shape.slice();return f.map(y=>{const b=[...m];b[h]=y;const T=_m({inputs:{x:a},backend:n,attrs:{begin:p,size:b}});return p[h]+=y,T})}},bR=qp(r=>Math.sqrt(r)),xR=ji(Uu,r=>Math.sqrt(r)),wR={kernelName:Uu,backendName:"cpu",kernelFunc:xR},ER={kernelName:Dt,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{const{x:n}=r,i=t;Hn(n,"square");const a=i.data.get(n.dataId).values,o=new Float32Array(a.length);for(let u=0;u<a.length;++u){const h=a[u];o[u]=h*h}return{dataId:i.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},SC=Ma((r,t)=>{const n=r-t;return n*n}),CR=qa(_s,SC),IR={kernelName:_s,backendName:"cpu",kernelFunc:CR},SR=ji(Al,(r,t)=>{const n=t;return isNaN(r)?NaN:r>0?1:n.alpha}),MR={kernelName:Al,backendName:"cpu",kernelFunc:SR};function MC(r,t,n,i){const a=$r(r,t.dtype);for(let o=0;o<a.size;o++){const u=a.indexToLoc(o),h=new Array(u.length);for(let f=0;f<h.length;f++)h[f]=u[f]*n[f]+i[f];a.set(t.get(...h),...u)}return a}const TR={kernelName:Vd,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{begin:o,end:u,strides:h,beginMask:f,endMask:p,ellipsisMask:m,newAxisMask:y,shrinkAxisMask:b}=i;Hn(a,"stridedSlice");const{finalShapeSparse:T,finalShape:R,isIdentity:L,sliceDim0:V,isSimpleSlice:j,begin:H,end:nt,strides:dt}=g0(a.shape,o,u,h,f,p,m,y,b);let yt;if(L)yt=Es({inputs:{x:a},backend:n,attrs:{shape:R}});else if(V||j){Z(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);const kt=ag(H,nt,dt),Ot=_m({inputs:{x:a},backend:n,attrs:{begin:H,size:kt}});yt=Es({inputs:{x:Ot},backend:n,attrs:{shape:R}}),n.disposeIntermediateTensorInfo(Ot)}else{const kt=MC(T,n.bufferSync(a),dt,H);yt=n.makeTensorInfo(R,kt.dtype,kt.values)}return yt}};class _R{constructor(t,n,i,a,o,u){this.separator=jl(t),this.nGramWidths=n,this.leftPad=jl(i),this.rightPad=jl(a),this.padWidth=o,this.preserveShort=u}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const i=this.getPadWidth(n);return Math.max(0,t+2*i-n+1)}createNGrams(t,n,i,a,o,u){for(let h=0;h<o;++h){const f=this.getPadWidth(u),p=Math.max(0,f-h),m=Math.max(0,f-(o-(h+1))),y=u-(p+m),b=n+(p>0?0:h-f);let T=0;T+=p*this.leftPad.length;for(let j=0;j<y;++j)T+=t[b+j].length;T+=m*this.rightPad.length,T+=(p+m+y-1)*this.separator.length,i[a+h]=new Uint8Array(T);const R=i[a+h];let L=0;const V=j=>j.forEach(H=>R[L++]=H);for(let j=0;j<p;++j)V(this.leftPad),V(this.separator);for(let j=0;j<y-1;++j)V(t[b+j]),V(this.separator);if(y>0){V(t[b+y-1]);for(let j=0;j<m;++j)V(this.separator),V(this.rightPad)}else{for(let j=0;j<m-1;++j)V(this.rightPad),V(this.separator);V(this.rightPad)}}}compute(t,n){const i=t.length,a=n.length;if(a>0){let f=n[0];if(0!==f)throw new Error(`First split value must be 0, got ${f}`);for(let p=1;p<a;++p){let m=n[p]>=f;if(m=m&&n[p]<=i,!m)throw new Error(`Invalid split value ${n[p]}, must be in [${f}, ${i}]`);f=n[p]}if(f!==i)throw new Error(`Last split value must be data size. Expected ${i}, got ${f}`)}const o=a-1,u=jt("int32",a);if(0===i||0===a){const f=new Array(i);for(let p=0;p<=o;++p)u[p]=0;return[f,u]}u[0]=0;for(let f=1;f<=o;++f){const p=n[f]-n[f-1];let m=0;this.nGramWidths.forEach(y=>{m+=this.getNumNGrams(p,y)}),this.preserveShort&&p>0&&0===m&&(m=1),u[f]=u[f-1]+m}const h=new Array(u[o]);for(let f=0;f<o;++f){const p=n[f];let m=u[f];if(this.nGramWidths.forEach(y=>{const T=this.getNumNGrams(n[f+1]-n[f],y);this.createNGrams(t,p,h,m,T,y),m+=T}),this.preserveShort&&m===u[f]){const y=n[f+1]-n[f];if(0===y)continue;this.createNGrams(t,p,h,m,1,y+2*this.padWidth)}}return[h,u]}}function TC(r,t,n,i,a,o,u,h){return new _R(n,i,a,o,u,h).compute(r,t)}const kR={kernelName:hf,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{separator:a,nGramWidths:o,leftPad:u,rightPad:h,padWidth:f,preserveShortSequences:p}=i,{data:m,dataSplits:y}=t,b=n.data.get(m.dataId).values,T=n.data.get(y.dataId).values,[R,L]=TC(b,T,a,o,u,h,f,p);return[n.makeTensorInfo([R.length],"string",R),n.makeTensorInfo(y.shape,"int32",L)]}};function RR(r,t,n,i){if(!r.length)return;if(0===t.length){for(let o=0;o<r.length;++o)i.push(r.subarray(o,o+1));return}if(1===t.length){const o=t[0];let u=r.indexOf(o);for(;-1!==u;){const h=r.subarray(0,u);n&&0===h.length||i.push(h),u=(r=r.subarray(u+1)).indexOf(o)}return void(n&&0===r.length||i.push(r))}let a=0;for(let o=0;o<r.length+1;o++)if(o===r.length||-1!==t.indexOf(r[o])){const u=r.subarray(a,o);n&&0===u.length||i.push(u),a=o+1}}function _C(r,t,n){const i=r.length,a=[];let o=0,u=0;const h=new Array(i);for(let b=0;b<i;++b){const T=a.length;RR(r[b],t,n,a);const R=a.length-T;h[b]=R,o+=R,u=Math.max(u,R)}const f=jt("int32",2*o),p=new Array(o),m=[i,u];let y=0;for(let b=0;b<i;++b)for(let T=0;T<h[b];++T)f[2*y]=b,f[2*y+1]=T,p[y]=a[y],++y;return[f,p,m]}const BR={kernelName:ta,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{skipEmpty:a}=i,{input:o,delimiter:u}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==u.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${u.shape}`);const h=n.data.get(o.dataId).values,f=n.data.get(u.dataId).values[0],[p,m,y]=_C(h,f,a),b=m.length;return[n.makeTensorInfo([b,2],"int32",p),n.makeTensorInfo([b],"string",m),n.makeTensorInfo([2],"int32",new Int32Array(y))]}};function kC(r,t){const n=jt("int32",r.length);for(let i=0;i<r.length;++i)n[i]=h1(r[i]).modulo(t).getLowBitsUnsigned();return n}const NR={kernelName:ml,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{numBuckets:a}=i,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const u=kC(n.data.get(o.dataId).values,a);return n.makeTensorInfo(o.shape,"int32",u)}},DR=ji(Hc,r=>Math.tan(r)),LR={kernelName:Hc,backendName:"cpu",kernelFunc:DR},FR=ji(Vl,r=>Math.tanh(r));function RC(r,t){const n=new Array(r.rank);for(let a=0;a<n.length;a++)n[a]=r.shape[a]*t[a];const i=$r(n,r.dtype);for(let a=0;a<i.values.length;++a){const o=i.indexToLoc(a),u=new Array(r.rank);for(let f=0;f<u.length;f++)u[f]=o[f]%r.shape[f];const h=r.locToIndex(u);i.values[a]=r.values[h]}return i}const t1=(r,t)=>{const n=t.value-r.value;return 0===n?r.index-t.index:n};function BC(r,t,n=0,i=r.length-1){for(;i>n;){if(i-n>600){const h=i-n+1,f=t-n+1,p=Math.log(h),m=.5*Math.exp(2*p/3),y=.5*Math.sqrt(p*m*(h-m)/h)*Math.sign(f-h/2);BC(r,t,Math.max(n,Math.floor(t-f*m/h+y)),Math.min(i,Math.floor(t+(h-f)*m/h+y)))}const a=r[t];let o=n,u=i;for(Ct(r,n,t),t1(r[i],a)>0&&Ct(r,n,i);o<u;){for(Ct(r,o,u),o++,u--;t1(r[o],a)<0;)o+=1;for(;t1(r[u],a)>0;)u-=1}0===t1(r[n],a)?Ct(r,n,u):(u+=1,Ct(r,u,i)),u<=t&&(n=u+1),t<=u&&(i=u-1)}}function NC(r,t,n,i,a){const o=t[t.length-1],[u,h]=[r.length/o,o],f=Ut(n,u*i),p=Ut("int32",u*i);for(let y=0;y<u;y++){const b=y*h,T=r.subarray(b,b+h);let R=new Array(T.length);T.forEach((H,nt)=>R[nt]={value:H,index:nt}),i<R.length&&(BC(R,i),R=R.slice(0,i)),a&&R.sort(t1);const L=y*i,V=f.subarray(L,L+i),j=p.subarray(L,L+i);for(let H=0;H<i;H++)V[H]=R[H].value,j[H]=R[H].index}const m=t.slice();return m[m.length-1]=i,[$r(m,n,f),$r(m,"int32",p)]}function DC(r,t,n){switch(n){case"reflect":return function(i,a){let o=i;if(o<0)if(a<=1)o=0;else{const u=2*a;o<u&&(o=u*Math.trunc(-o/u)+o),o=o<-a?o+u:-o-1}else if(o>a-1)if(a<=1)o=0;else{const u=2*a;o-=u*Math.trunc(o/u),o>=a&&(o=u-o-1)}return qs(0,o,a-1)}(r,t);case"wrap":return function(i,a){let o=i;return o<0?a<=1?o=0:o+=a*(Math.trunc(-o/(a-1))+1):o>a-1&&(a<=1?o=0:o-=a*Math.trunc(o/(a-1))),qs(0,o,a-1)}(r,t);case"nearest":return qs(0,r,t-1);default:return r}}function e1(r,t,n,i,a,o,u,h,f,p,m){return 0<=h&&h<t&&0<=f&&f<n?r[u*i+h*a+f*o+p]:m}function OR(r,t,n,i,a,o,u,h,f,p,m){return e1(r,t,n,i,a,o,u,Math.round(h),Math.round(f),p,m)}function PR(r,t,n,i,a,o,u,h,f,p,m){const y=Math.floor(h),b=Math.floor(f),T=y+1,R=b+1;return(T-h)*((R-f)*e1(r,t,n,i,a,o,u,y,b,p,m)+(f-b)*e1(r,t,n,i,a,o,u,y,R,p,m))+(h-y)*((R-f)*e1(r,t,n,i,a,o,u,T,b,p,m)+(f-b)*e1(r,t,n,i,a,o,u,T,R,p,m))}function LC(r,t,n,i){const a=lr(t,n)[0],o=[1,n[0],1];for(let R=0;R<a;R++)o[0]*=n[R];o[1]=n[a];for(let R=a+1;R<n.length;R++)o[2]*=n[R];const u={},h=new Int32Array(n[a]),f=new is(o,i,r),p=[],m=1===o[0]&&1===o[2];for(let R=0;R<n[a];R++){let L;if(m)L=r[R].toString();else{const V=[];for(let j=0;j<o[0];j++)for(let H=0;H<o[2];H++)V.push(f.get(j,R,H));L=V.join(",")}if(void 0!==u[L])h[R]=u[L];else{const V=Object.keys(u).length;u[L]=V,h[R]=V,p.push(R)}}const y=o.slice();y[1]=Object.keys(u).length;const b=new is(y,i);p.forEach((R,L)=>{for(let V=0;V<o[0];V++)for(let j=0;j<o[2];j++)b.set(f.get(V,R,j),V,L,j)});const T=n.slice();return T[a]=y[1],{outputValues:b.values,outputShape:T,indices:h}}const UR=[GT,QT,WT,qT,zT,XT,KT,JT,ZT,t_,n_,i_,a_,c_,h_,d_,p_,f_,m_,VT,g_,y_,v_,b_,PT,w_,C_,FT,I_,M_,T_,__,k_,R_,B_,N_,L_,O_,P_,U_,z_,$_,V_,G_,Q_,H_,W_,j_,q_,J_,MT,Z_,t3,l3,c3,u3,d3,A3,y3,v3,x3,C3,I3,S3,M3,T3,k3,B3,TT,N3,S_,L3,O3,U3,_T,$3,G3,Q3,W3,q3,K3,Z3,nk,rk,ik,sk,ok,lk,ck,uk,hk,dk,pk,fk,gk,Ak,bk,wk,Y_,Ek,Ik,Mk,_k,Rk,Bk,Dk,Lk,yC,Pk,RT,Uk,zk,OT,pE,Vk,BT,NT,$T,Gk,Qk,Hk,Wk,jk,qk,Yk,Jk,Zk,tR,iR,LT,aR,lR,uR,A_,xk,dR,pR,fR,mR,gR,AR,yR,vR,wR,ER,IR,MR,TR,kR,BR,NR,m3,K_,LR,{kernelName:Vl,backendName:"cpu",kernelFunc:FR},{kernelName:Gl,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{reps:o}=i;Hn(a,"tile");const u=RC(n.bufferSync(a),o);return n.makeTensorInfo(u.shape,u.dtype,u.values)}},{kernelName:Wc,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{k:o,sorted:u}=i;Hn(a,"topk");const h=n.data.get(a.dataId).values,[f,p]=NC(h,a.shape,a.dtype,o,u);return[n.makeTensorInfo(f.shape,f.dtype,f.values),n.makeTensorInfo(p.shape,p.dtype,p.values)]}},{kernelName:Ql,backendName:"cpu",kernelFunc:function(r){const{inputs:t,attrs:n,backend:i}=r,{image:a,transforms:o}=t,{interpolation:u,fillMode:h,fillValue:f,outputShape:p}=n,[m,y,b,T]=a.shape,[R,L]=p??[y,b],V=[m,R,L,T],j=gn(a.shape),H=j[0],nt=j[1],dt=j[2],yt=Ut(a.dtype,Wt(V));yt.fill(f);const kt=i.data.get(a.dataId).values,Ot=i.data.get(o.dataId).values;for(let Nt=0;Nt<m;++Nt){const Vt=1===o.shape[0]?Ot:Ot.subarray(8*Nt,8*Nt+8);for(let qt=0;qt<R;++qt)for(let Zt=0;Zt<L;++Zt)for(let te=0;te<T;++te){let ue;const Ee=Vt[6]*Zt+Vt[7]*qt+1;if(0===Ee)continue;const we=(Vt[3]*Zt+Vt[4]*qt+Vt[5])/Ee,Te=DC((Vt[0]*Zt+Vt[1]*qt+Vt[2])/Ee,b,h),Le=DC(we,y,h);switch(u){case"nearest":ue=OR(kt,y,b,H,nt,dt,Nt,Le,Te,te,f);break;case"bilinear":ue=PR(kt,y,b,H,nt,dt,Nt,Le,Te,te,f);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${u}`)}yt[Nt*H+qt*nt+Zt*dt+te]=ue}return i.makeTensorInfo(V,a.dtype,yt)}return{dataId:i.write(yt,V,a.dtype),shape:a.shape,dtype:a.dtype}}},YT,{kernelName:uc,backendName:"cpu",kernelFunc:function(r){const{inputs:t,attrs:n,backend:i}=r,{axis:a}=n,{x:o}=t;Hn(o,"unique");const u=i.data.get(o.dataId).values,{outputValues:h,outputShape:f,indices:p}=LC(u,a,o.shape,o.dtype);return[i.makeTensorInfo(f,o.dtype,h),i.makeTensorInfo([p.length],"int32",p)]}},{kernelName:jc,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{value:a}=t;let{axis:o}=i;o<0&&(o+=a.shape.length);const u=a.shape.length,h=a.shape[o],f=new Array(u-1);let p=0;for(let T=0;T<u;T++)T!==o&&(f[p++]=a.shape[T]);const m=new Array(u).fill(0),y=a.shape.slice();y[o]=1;const b=new Array(h);for(let T=0;T<b.length;T++){m[o]=T;const R=_m({inputs:{x:a},backend:n,attrs:{begin:m,size:y}});b[T]=Es({inputs:{x:R},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(R)}return b}},{kernelName:zu,backendName:"cpu",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,segmentIds:o}=t,{numSegments:u}=i;Hn(a,"unsortedSegmentSum");const h=[],f=[],p=a.shape.length-o.shape.length;let m=o;for(let b=0;b<p;++b){const T=cb({inputs:{input:m},backend:n,attrs:{dim:b+1}});m=T,f.push(T)}for(let b=0;b<u;++b){const T=Kc(b,"int32"),R=n.makeTensorInfo([],"int32",T),L=X2({inputs:{a:R,b:m},backend:n}),V=Xp({inputs:{x:L},backend:n,attrs:{dtype:"float32"}}),j=lb({inputs:{a:V,b:a},backend:n}),H=Zy({inputs:{x:j},backend:n,attrs:{axis:0,keepDims:!1}});h.push(H),f.push(R),f.push(L),f.push(V),f.push(j),f.push(H)}const y=AC({inputs:h,backend:n,attrs:{axis:0}});return f.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}},Nk];for(const r of UR)hc(r);const km={},yE={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ru(r,t){if(!(r in km)){const i=function(a,o){if(1!==a&&2!==a)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const u=o??function(h){if(typeof OffscreenCanvas<"u"&&2===h)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(a);return u.addEventListener("webglcontextlost",h=>{h.preventDefault(),delete km[a]},!1),1===a?u.getContext("webgl",yE)||u.getContext("experimental-webgl",yE):u.getContext("webgl2",yE)}(r,t);if(null===i)return console.log("Could not get context for WebGL version",r),null;km[r]=i}const n=km[r];return null==n||n.isContextLost()?(delete km[r],Ru(r)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),km[r])}var n1,sc,co;function r1(r,t){return[t,r]}function hb(r){const t=Wt(r);return Hr(Math.ceil(t/4))}function OA(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function vE(r,t){const n=r;let i,a,o,u,h,f,p,m,y,b;return 2===de().getNumber("WEBGL_VERSION")?(i=n.R32F,a=n.R16F,o=n.RGBA16F,u=n.RGBA32F,h=n.RED,p=4,m=1,y=n.HALF_FLOAT,b=n.FLOAT,f=n.RGBA8):(i=r.RGBA,a=r.RGBA,o=r.RGBA,u=n.RGBA,h=r.RGBA,p=4,m=4,y=null!=t?t.HALF_FLOAT_OES:null,b=r.FLOAT,f=r.RGBA),{internalFormatFloat:i,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:u,textureFormatFloat:h,downloadTextureFormat:f,downloadUnpackNumChannels:p,defaultNumChannels:m,textureTypeHalfFloat:y,textureTypeFloat:b}}function Wn(r,t){const n=t();return de().getBool("DEBUG")&&function(i){const a=i.getError();if(a!==i.NO_ERROR)throw new Error("WebGL Error: "+function(o,u){switch(u){case o.NO_ERROR:return"NO_ERROR";case o.INVALID_ENUM:return"INVALID_ENUM";case o.INVALID_VALUE:return"INVALID_VALUE";case o.INVALID_OPERATION:return"INVALID_OPERATION";case o.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case o.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case o.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${u}`}}(i,a))}(r),n}function zR(r){return!!(de().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===r||5.96e-8<Math.abs(r)&&Math.abs(r)<65504)}function db(r,t){return bd(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(n1||(n1={})),function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"}(sc||(sc={})),function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(co||(co={}));const $R=/ERROR: [0-9]+:([0-9]+):/g;function bE(r,t){if(Wn(r,()=>r.validateProgram(t)),!1===r.getProgramParameter(t,r.VALIDATE_STATUS))throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function FC(r,t,n,i,a,o,u){const h=r.getAttribLocation(t,n);return-1!==h&&(Wn(r,()=>r.bindBuffer(r.ARRAY_BUFFER,i)),Wn(r,()=>r.vertexAttribPointer(h,a,r.FLOAT,!1,o,u)),Wn(r,()=>r.enableVertexAttribArray(h)),!0)}function xE(r,t,n){Wn(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,n)),Wn(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function OC(r,t){Wn(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Wn(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function pb(r){const t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(n,i){switch(i){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${i}`}}(r,t))}function bd(r,t,n){const i=Wn(r,()=>t());if(null==i)throw new Error(n);return i}function PA(r,t=2){return Wt(r.slice(0,r.length-t))}function UA(r){if(0===r.length)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function wE(r){let t=[1,1,1];return 0===r.length||1===r.length&&1===r[0]||(t=[PA(r),...UA(r)]),t}function fb(r){return r%2==0}function mb(r,t){if(We(r=r.slice(-2),t=t.slice(-2))||!r.length||!t.length||0===r[0]||0===r[1]||0===t[0]||0===t[1])return!0;if(r.length!==t.length){const n=r.slice(-1)[0],i=t.slice(-1)[0];if(n===i||fb(n)&&fb(i)&&(1===r[0]||1===t[0]))return!0}return r[1]===t[1]&&fb(r[0])&&fb(t[0])}let EE,CE;function Pc(r,t){return null!=r.getExtension(t)}function PC(r){try{if(null!=Ru(r))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function IE(r){const t=vE(r),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n),r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);const a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(i),a}function i1(r,t){Array.isArray(r)||(r=[r]),r.forEach(n=>{null!=n&&Z("complex64"!==n.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const mr=de();function Uo(){let r,t,n,i,a,o,u,h,f,p;return 2===de().getNumber("WEBGL_VERSION")?(r="#version 300 es",t="in",n="out",i="in",a="texture",o="outputColor",u="out vec4 outputColor;",h="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",f="",p="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(r="",t="attribute",n="varying",i="varying",a="texture2D",o="gl_FragColor",u="",h="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",f="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",p="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:r,attribute:t,varyingVs:n,varyingFs:i,texture2D:a,output:o,defineOutput:u,defineSpecialNaN:h,defineSpecialInf:f,defineRound:p}}function Rm(r,t,n="index"){const i=gn(t);return i.map((a,o)=>`int ${r[o]} = ${n} / ${a}; ${o===i.length-1?`int ${r[o+1]} = ${n} - ${r[o]} * ${a}`:`index -= ${r[o]} * ${a}`};`).join("")}function gb(r,t,n="index"){const i=gn(t);return i.map((a,o)=>`int ${r[o]} = ${n} / outShapeStrides[${o}]; ${o===i.length-1?`int ${r[o+1]} = ${n} - ${r[o]} * outShapeStrides[${o}]`:`index -= ${r[o]} * outShapeStrides[${o}]`};`).join("")}function SE(r){const t=gn(r).map(n=>n.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}mr.registerFlag("HAS_WEBGL",()=>mr.getNumber("WEBGL_VERSION")>0),mr.registerFlag("WEBGL_VERSION",()=>PC(2)?2:PC(1)?1:0),mr.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),mr.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===mr.get("WEBGL_VERSION")),mr.registerFlag("WEBGL_CPU_FORWARD",()=>!0),mr.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),mr.registerFlag("WEBGL_PACK",()=>mr.getBool("HAS_WEBGL")),mr.registerFlag("WEBGL_PACK_NORMALIZATION",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_PACK_CLIP",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_PACK_REDUCE",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_LAZILY_UNPACK",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_CONV_IM2COL",()=>mr.getBool("WEBGL_PACK")),mr.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(r){if(null==EE){const t=Ru(r);EE=t.getParameter(t.MAX_TEXTURE_SIZE)}return EE}(mr.getNumber("WEBGL_VERSION"))),mr.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(r){if(null==CE){const t=Ru(r);CE=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,CE)}(mr.getNumber("WEBGL_VERSION"))),mr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const r=mr.getNumber("WEBGL_VERSION");return 0===r?0:function(t){if(0===t)return 0;let n;const i=Ru(t);return n=Pc(i,"EXT_disjoint_timer_query_webgl2")&&2===t?2:Pc(i,"EXT_disjoint_timer_query")?1:0,n}(r)}),mr.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>mr.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!s0()),mr.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(r){if(0===r)return!1;const t=Ru(r);if(1===r){if(!Pc(t,"OES_texture_float"))return!1}else if(!Pc(t,"EXT_color_buffer_float"))return!1;return IE(t)}(mr.getNumber("WEBGL_VERSION"))),mr.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!mr.getBool("WEBGL_FORCE_F16_TEXTURES")&&mr.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),mr.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(r){if(0===r)return!1;const t=Ru(r);if(1!==r){if(Pc(t,"EXT_color_buffer_float"))return IE(t);const n="EXT_color_buffer_half_float";if(Pc(t,n)){const i=t.getExtension(n);return function(a,o){const u=vE(a,o),h=a.createTexture();a.bindTexture(a.TEXTURE_2D,h),a.texImage2D(a.TEXTURE_2D,0,u.internalFormatHalfFloat,1,1,0,u.textureFormatFloat,u.textureTypeHalfFloat,null);const f=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,f),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,h,0);const p=a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE;return a.bindTexture(a.TEXTURE_2D,null),a.bindFramebuffer(a.FRAMEBUFFER,null),a.deleteTexture(h),a.deleteFramebuffer(f),p}(t,i)}return!1}return!!Pc(t,"OES_texture_float")&&!!Pc(t,"WEBGL_color_buffer_float")&&IE(t)}(mr.getNumber("WEBGL_VERSION"))),mr.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(r=mr.getNumber("WEBGL_VERSION"))&&null!=Ru(r).fenceSync;var r}),mr.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>mr.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),mr.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&-1!==r)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)}),mr.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>s0()?1:-1,r=>{if(r<0&&-1!==r)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)}),mr.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),mr.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),mr.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),mr.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);const UC="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:zC}=X;function GR(r,t,n){const i=[];if(r.forEach(b=>{const T=Wt(b.shapeInfo.logicalShape);if(b.shapeInfo.isUniform?i.push(`uniform float ${b.name}${T>1?`[${T}]`:""};`):(i.push(`uniform sampler2D ${b.name};`),i.push(`uniform int offset${b.name};`)),n.enableShapeUniforms){const{uniformShape:R}=ME(n.packedInputs,b.shapeInfo.logicalShape,b.shapeInfo.texShape);switch(R.length){case 1:i.push(`uniform int ${b.name}Shape;`);break;case 2:i.push(`uniform ivec2 ${b.name}Shape;`);break;case 3:i.push(`uniform ivec3 ${b.name}Shape;`);break;case 4:i.push(`uniform ivec4 ${b.name}Shape;`)}i.push(`uniform ivec2 ${b.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:i.push("uniform int outShape;");break;case 2:i.push("uniform ivec2 outShape;"),i.push("uniform int outShapeStrides;");break;case 3:i.push("uniform ivec3 outShape;"),i.push("uniform ivec2 outShapeStrides;");break;case 4:i.push("uniform ivec4 outShape;"),i.push("uniform ivec3 outShapeStrides;")}i.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(b=>{i.push(`uniform ${b.type} ${b.name}${b.arrayIndex?`[${b.arrayIndex}]`:""};`)});const a=i.join("\n"),o=r.map(b=>function(T,R,L=!1,V){let j="";return j+=L?$C(T,V):zA(T,V),T.shapeInfo.logicalShape.length<=R.logicalShape.length&&(j+=L?function(dt,yt){const kt=dt.name,Ot=kt.charAt(0).toUpperCase()+kt.slice(1),Nt="get"+Ot+"AtOutCoords",Vt=dt.shapeInfo.logicalShape.length,qt=yt.logicalShape.length,Zt=zC(dt.shapeInfo.logicalShape,yt.logicalShape),te=ns(qt),ue=qt-Vt;let Ee;const De=["x","y","z","w","u","v"];Ee=0===Vt?"":qt<2&&Zt.length>=1?"coords = 0;":Zt.map(je=>`coords.${De[je+ue]} = 0;`).join("\n");let we="";we=qt<2&&Vt>0?"coords":dt.shapeInfo.logicalShape.map((je,Ne)=>`coords.${De[Ne+ue]}`).join(", ");let Te="return outputValue;";const Le=1===Wt(dt.shapeInfo.logicalShape),$e=1===Wt(yt.logicalShape);if(1!==Vt||Le||$e){if(Le&&!$e)Te=1===qt?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(Zt.length){const je=Vt-2,Ne=Vt-1;Zt.indexOf(je)>-1&&Zt.indexOf(Ne)>-1?Te="return vec4(outputValue.x);":Zt.indexOf(je)>-1?Te="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":Zt.indexOf(Ne)>-1&&(Te="return vec4(outputValue.xx, outputValue.zz);")}}else Te="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${Nt}() {\n      ${te} coords = getOutputCoords();\n      ${Ee}\n      vec4 outputValue = get${Ot}(${we});\n      ${Te}\n    }\n  `}(T,R):function(dt,yt){const kt=dt.name,Ot=kt.charAt(0).toUpperCase()+kt.slice(1),Nt="get"+Ot+"AtOutCoords",Zt=dt.shapeInfo.logicalShape.length,te=yt.logicalShape.length;if(!dt.shapeInfo.isUniform&&Zt===te&&null==dt.shapeInfo.flatOffset&&We(dt.shapeInfo.texShape,yt.texShape))return`\n      float ${Nt}() {\n        return sampleTexture(${kt}, resultUV);\n      }\n    `;const ue=ns(te),Ee=zC(dt.shapeInfo.logicalShape,yt.logicalShape),De=te-Zt;let we;const Te=["x","y","z","w","u","v"];we=0===Zt?"":te<2&&Ee.length>=1?"coords = 0;":Ee.map($e=>`coords.${Te[$e+De]} = 0;`).join("\n");let Le="";return Le=te<2&&Zt>0?"coords":dt.shapeInfo.logicalShape.map(($e,je)=>`coords.${Te[je+De]}`).join(", "),`\n    float ${Nt}() {\n      ${ue} coords = getOutputCoords();\n      ${we}\n      return get${Ot}(${Le});\n    }\n  `}(T,R)),j}(b,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),u=t.texShape,h=Uo(),f=`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${h.texture2D}(textureSampler, uv).r;\n    }\n  `;let p,m,y=`${(b=h).version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${b.varyingFs} vec2 resultUV;\n    ${b.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${b.defineSpecialNaN}\n    ${b.defineSpecialInf}\n    ${b.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${QR}\n    ${HR}\n    ${WR}\n  `;var b;return t.isPacked?(p=function(b,T,R){switch(b.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(L,V,j){const H=[Math.ceil(V[0]/2),Math.ceil(V[1]/2)];return 1===H[0]?j?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${H[1]}.0);\n      }\n    `:1===H[1]?j?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${H[0]}.0);\n      }\n    `:j?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${H[0]}, ${H[1]}));\n      return 2 * (resTexRC.x * ${H[1]} + resTexRC.y);\n    }\n  `}(0,T,R);case 2:return function(L,V,j){const H=[Math.ceil(V[0]/2),Math.ceil(V[1]/2)];if(We(L,V))return j?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${H[0]}, ${H[1]}));\n      }\n    `;const nt=Math.ceil(L[1]/2);return j?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${H[0]}, ${H[1]}));\n\n      int index = resTexRC.x * ${H[1]} + resTexRC.y;\n      int r = 2 * (index / ${nt});\n      int c = imod(index, ${nt}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(b,T,R);case 3:return function(L,V,j){if(j)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const H=[Math.ceil(V[0]/2),Math.ceil(V[1]/2)],nt=Math.ceil(L[2]/2),dt=nt*Math.ceil(L[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${H[0]}, ${H[1]}));\n      int index = resTexRC.x * ${H[1]} + resTexRC.y;\n\n      int b = index / ${dt};\n      index -= b * ${dt};\n\n      int r = 2 * (index / ${nt});\n      int c = imod(index, ${nt}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(b,T,R);default:return function(L,V,j){if(j)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const H=[Math.ceil(V[0]/2),Math.ceil(V[1]/2)],nt=Math.ceil(L[L.length-1]/2),dt=nt*Math.ceil(L[L.length-2]/2);let yt=dt,kt="",Ot="b, r, c";for(let Nt=2;Nt<L.length-1;Nt++)yt*=L[L.length-Nt-1],kt=`\n      int b${Nt} = index / ${yt};\n      index -= b${Nt} * ${yt};\n    `+kt,Ot=`b${Nt}, `+Ot;return`\n    ivec${L.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${H[0]}, ${H[1]}));\n      int index = resTexRC.x * ${H[1]} + resTexRC.y;\n\n      ${kt}\n\n      int b = index / ${dt};\n      index -= b * ${dt};\n\n      int r = 2 * (index / ${nt});\n      int c = imod(index, ${nt}) * 2;\n\n      return ivec${L.length}(${Ot});\n    }\n  `}(b,T,R)}}(t.logicalShape,u,n.enableShapeUniforms),m=function(b){return`\n    void setOutput(vec4 val) {\n      ${b.output} = val;\n    }\n  `}(h)):(p=function(b,T,R){switch(b.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return j=R,1===(V=T)[0]?j?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${V[1]}.0);\n      }\n    `:1===V[1]?j?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${V[0]}.0);\n      }\n    `:j?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${V[0]}, ${V[1]}));\n      return resTexRC.x * ${V[1]} + resTexRC.y;\n    }\n  `;case 2:return function(L,V,j){return We(L,V)?j?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${V[0]}, ${V[1]}));\n      }\n    `:1===L[1]?j?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${V[0]}, ${V[1]}));\n        int index = resTexRC.x * ${V[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===L[0]?j?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${V[0]}, ${V[1]}));\n        int index = resTexRC.x * ${V[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:j?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${V[0]}, ${V[1]}));\n      int index = resTexRC.x * ${V[1]} + resTexRC.y;\n      int r = index / ${L[1]};\n      int c = index - r * ${L[1]};\n      return ivec2(r, c);\n    }\n  `}(b,T,R);case 3:return function(L,V,j){if(j)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${gb(["r","c","d"],L)}\n    return ivec3(r, c, d);\n  }\n`;const H=Rm(["r","c","d"],L);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${V[0]}, ${V[1]}));\n      int index = resTexRC.x * ${V[1]} + resTexRC.y;\n      ${H}\n      return ivec3(r, c, d);\n    }\n  `}(b,T,R);case 4:return function(L,V,j){if(j)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${gb(["r","c","d","d2"],L)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const H=Rm(["r","c","d","d2"],L);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${V[0]}, ${V[1]}));\n      int index = resTexRC.x * ${V[1]} + resTexRC.y;\n      ${H}\n      return ivec4(r, c, d, d2);\n    }\n  `}(b,T,R);case 5:return function(L,V){const j=Rm(["r","c","d","d2","d3"],L);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${V[0]},\n                             ${V[1]}));\n\n      int index = resTexRC.x * ${V[1]} + resTexRC.y;\n\n      ${j}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(b,T);case 6:return function(L,V){const j=Rm(["r","c","d","d2","d3","d4"],L);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${V[0]}, ${V[1]}));\n      int index = resTexRC.x * ${V[1]} + resTexRC.y;\n\n      ${j}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(b,T);default:throw new Error(`${b.length}-D output sampling is not yet supported`)}var V,j}(t.logicalShape,u,n.enableShapeUniforms),m=function(b){return`\n    void setOutput(float val) {\n      ${b.output} = vec4(val, 0, 0, 0);\n    }\n  `}(h)),n.packedInputs&&(y+=jR),[y,f,m,a,p,o,n.userCode].join("\n")}function zA(r,t=!1){const n=r.shapeInfo.logicalShape;switch(n.length){case 0:return function(i,a){const o=i.name,u="get"+o.charAt(0).toUpperCase()+o.slice(1);if(i.shapeInfo.isUniform)return`float ${u}() {return ${o};}`;const[h,f]=i.shapeInfo.texShape;if(1===h&&1===f)return`\n      float ${u}() {\n        return sampleTexture(${o}, halfCR);\n      }\n    `;const p=Bm(o);if(a)return`\n    float ${u}() {\n      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], ${p});\n      return sampleTexture(${o}, uv);\n    }\n  `;const[m,y]=i.shapeInfo.texShape;return`\n    float ${u}() {\n      vec2 uv = uvFromFlat(${m}, ${y}, ${p});\n      return sampleTexture(${o}, uv);\n    }\n  `}(r,t);case 1:return function(i,a){const o=i.name,u="get"+o.charAt(0).toUpperCase()+o.slice(1);if(i.shapeInfo.isUniform)return`\n      float ${u}(int index) {\n        ${$A(i)}\n      }\n    `;const h=i.shapeInfo.texShape,f=h[0],p=h[1];if(1===p&&1===f)return`\n      float ${u}(int index) {\n        return sampleTexture(${o}, halfCR);\n      }\n    `;const m=Bm(o);return 1===p?a?`\n      float ${u}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${m}) + 0.5) / float(${o}TexShape[0]));\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n      float ${u}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${m}) + 0.5) / ${f}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `:1===f?a?`\n      float ${u}(int index) {\n        vec2 uv = vec2((float(index + ${m}) + 0.5) / float(${o}TexShape[1]), 0.5);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n      float ${u}(int index) {\n        vec2 uv = vec2((float(index + ${m}) + 0.5) / ${p}.0, 0.5);\n        return sampleTexture(${o}, uv);\n      }\n    `:a?`\n    float ${u}(int index) {\n      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index + ${m});\n      return sampleTexture(${o}, uv);\n    }\n  `:`\n    float ${u}(int index) {\n      vec2 uv = uvFromFlat(${f}, ${p}, index + ${m});\n      return sampleTexture(${o}, uv);\n    }\n  `}(r,t);case 2:return function(i,a){const o=i.shapeInfo.logicalShape,u=i.name,h="get"+u.charAt(0).toUpperCase()+u.slice(1),f=i.shapeInfo.texShape;if(null!=f&&We(o,f))return a?`\n      float ${h}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}TexShape[1], ${u}TexShape[0]);\n        return sampleTexture(${u}, uv);\n      }\n    `:`\n    float ${h}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f[1]}.0, ${f[0]}.0);\n      return sampleTexture(${u}, uv);\n    }\n  `;const{newShape:p,keptDims:m}=ki(o);if(p.length<o.length){const L=["row","col"];return`\n      ${zA(VA(i,p),a)}\n      float ${h}(int row, int col) {\n        return ${h}(${GA(L,m)});\n      }\n    `}if(i.shapeInfo.isUniform)return`\n      float ${h}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${o[1]}, 1)));\n        ${$A(i)}\n      }\n    `;const b=f[0],T=f[1],R=Bm(u);return 1===T?a?`\n      float ${h}(int row, int col) {\n        float index = dot(vec3(row, col, ${R}), vec3(${u}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${u}TexShape[0]));\n        return sampleTexture(${u}, uv);\n      }\n    `:`\n    float ${h}(int row, int col) {\n      float index = dot(vec3(row, col, ${R}), vec3(${o[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${b}.0);\n      return sampleTexture(${u}, uv);\n    }\n  `:1===b?a?`\n      float ${h}(int row, int col) {\n        float index = dot(vec3(row, col, ${R}), vec3(${u}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${u}TexShape[1]), 0.5);\n        return sampleTexture(${u}, uv);\n      }\n    `:`\n    float ${h}(int row, int col) {\n      float index = dot(vec3(row, col, ${R}), vec3(${o[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${T}.0, 0.5);\n      return sampleTexture(${u}, uv);\n    }\n  `:a?`\n      float ${h}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${u}Shape[1] + col + ${R};\n        vec2 uv = uvFromFlat(${u}TexShape[0], ${u}TexShape[1], index);\n        return sampleTexture(${u}, uv);\n      }\n    `:`\n  float ${h}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${o[1]} + col + ${R};\n    vec2 uv = uvFromFlat(${b}, ${T}, index);\n    return sampleTexture(${u}, uv);\n  }\n`}(r,t);case 3:return function(i,a){const o=i.shapeInfo.logicalShape,u=i.name,h="get"+u.charAt(0).toUpperCase()+u.slice(1),f=o[1]*o[2],p=o[2],{newShape:m,keptDims:y}=ki(o);if(m.length<o.length){const H=["row","col","depth"];return`\n        ${zA(VA(i,m),a)}\n        float ${h}(int row, int col, int depth) {\n          return ${h}(${GA(H,y)});\n        }\n      `}if(i.shapeInfo.isUniform)return`\n      float ${h}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${f}, ${p}, 1)));\n        ${$A(i)}\n      }\n    `;const T=i.shapeInfo.texShape,R=T[0],L=T[1],V=i.shapeInfo.flatOffset;if(L===f&&null==V)return a?`\n      float ${h}(int row, int col, int depth) {\n        int stride1 = ${u}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${u}TexShape[1], ${u}TexShape[0]);\n        return sampleTexture(${u}, uv);\n      }\n    `:`\n        float ${h}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${p}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${L}.0, ${R}.0);\n          return sampleTexture(${u}, uv);\n        }\n      `;if(L===p&&null==V)return a?`\n      float ${h}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${u}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}TexShape[1], ${u}TexShape[0]);\n        return sampleTexture(${u}, uv);\n      }\n    `:`\n    float ${h}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${o[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${L}.0, ${R}.0);\n      return sampleTexture(${u}, uv);\n    }\n  `;const j=Bm(u);return a?`\n    float ${h}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${u}Shape[1] * ${u}Shape[2];\n      int stride1 = ${u}Shape[2];\n      int index = row * ${f} + col * ${p} + depth + ${j};\n      vec2 uv = uvFromFlat(${u}TexShape[0], ${u}TexShape[1], index);\n      return sampleTexture(${u}, uv);\n    }\n    `:`\n      float ${h}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${f} + col * ${p} + depth + ${j};\n        vec2 uv = uvFromFlat(${R}, ${L}, index);\n        return sampleTexture(${u}, uv);\n      }\n  `}(r,t);case 4:return function(i,a){const o=i.shapeInfo.logicalShape,u=i.name,h="get"+u.charAt(0).toUpperCase()+u.slice(1),f=o[3],p=o[2]*f,m=o[1]*p,{newShape:y,keptDims:b}=ki(o);if(y.length<o.length){const yt=["row","col","depth","depth2"];return`\n      ${zA(VA(i,y),a)}\n      float ${h}(int row, int col, int depth, int depth2) {\n        return ${h}(${GA(yt,b)});\n      }\n    `}if(i.shapeInfo.isUniform)return`\n      float ${h}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${m}, ${p}, ${f}, 1)));\n        ${$A(i)}\n      }\n    `;const T=i.shapeInfo.flatOffset,R=i.shapeInfo.texShape,L=R[0],V=R[1],j=`int stride2 = ${u}Shape[3];`,H=`int stride1 = ${u}Shape[2] * stride2;`,nt=`int stride0 = ${u}Shape[1] * stride1;`;if(V===m&&null==T)return a?`\n      float ${h}(int row, int col, int depth, int depth2) {\n        ${j}\n        ${H}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${u}TexShape[1], ${u}TexShape[0]);\n        return sampleTexture(${u}, uv);\n      }\n    `:`\n      float ${h}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${p}, ${f}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${V}.0, ${L}.0);\n        return sampleTexture(${u}, uv);\n      }\n    `;if(V===f&&null==T)return a?`\n      float ${h}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${u}Shape[1] * ${u}Shape[2], ${u}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${u}TexShape[1], ${u}TexShape[0]);\n        return sampleTexture(${u}, uv);\n      }\n    `:`\n      float ${h}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${o[1]*o[2]}, ${o[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${V}.0, ${L}.0);\n        return sampleTexture(${u}, uv);\n      }\n    `;const dt=Bm(u);return a?`\n    float ${h}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${j}\n      ${H}\n      ${nt}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${u}TexShape[0], ${u}TexShape[1], index + ${dt});\n      return sampleTexture(${u}, uv);\n    }\n  `:`\n    float ${h}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${m} + col * ${p} +\n          depth * ${f} + depth2;\n      vec2 uv = uvFromFlat(${L}, ${V}, index + ${dt});\n      return sampleTexture(${u}, uv);\n    }\n  `}(r,t);case 5:return function(i){const a=i.shapeInfo.logicalShape,o=i.name,u="get"+o.charAt(0).toUpperCase()+o.slice(1),h=a[4],f=a[3]*h,p=a[2]*f,m=a[1]*p,{newShape:y,keptDims:b}=ki(a);if(y.length<a.length){const j=["row","col","depth","depth2","depth3"];return`\n      ${zA(VA(i,y))}\n      float ${u}(int row, int col, int depth, int depth2, int depth3) {\n        return ${u}(${GA(j,b)});\n      }\n    `}if(i.shapeInfo.isUniform)return`\n      float ${u}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${m}, ${p}, ${f}, ${h})) +\n          depth3;\n        ${$A(i)}\n      }\n    `;const T=i.shapeInfo.flatOffset,R=i.shapeInfo.texShape,L=R[0],V=R[1];return V===m&&null==T?`\n      float ${u}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${p}, ${f}, ${h}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${V}.0, ${L}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `:V===h&&null==T?`\n      float ${u}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a[1]*a[2]*a[3]},\n               ${a[2]*a[3]}, ${a[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${V}.0, ${L}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n    float ${u}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${m} + col * ${p} + depth * ${f} +\n          depth2 * ${h} + depth3 + ${Bm(o)};\n      vec2 uv = uvFromFlat(${L}, ${V}, index);\n      return sampleTexture(${o}, uv);\n    }\n  `}(r);case 6:return function(i){const a=i.shapeInfo.logicalShape,o=i.name,u="get"+o.charAt(0).toUpperCase()+o.slice(1),{newShape:h,keptDims:f}=ki(a);if(h.length<a.length){const H=["row","col","depth","depth2","depth3","depth4"];return`\n      ${zA(VA(i,h))}\n      float ${u}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${u}(${GA(H,f)});\n      }\n    `}const p=a[5],m=a[4]*p,y=a[3]*m,b=a[2]*y,T=a[1]*b;if(i.shapeInfo.isUniform)return`\n      float ${u}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${T}, ${b}, ${y}, ${m})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${p}, 1)));\n        ${$A(i)}\n      }\n    `;const R=i.shapeInfo.flatOffset,L=i.shapeInfo.texShape,V=L[0],j=L[1];return j===T&&null==R?`\n      float ${u}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${b}, ${y}, ${m}, ${p})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${j}.0, ${V}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `:j===p&&null==R?`\n      float ${u}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${a[1]*a[2]*a[3]*a[4]},\n               ${a[2]*a[3]*a[4]},\n               ${a[3]*a[4]},\n               ${a[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${j}.0, ${V}.0);\n        return sampleTexture(${o}, uv);\n      }\n    `:`\n    float ${u}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${T} + col * ${b} + depth * ${y} +\n          depth2 * ${m} + depth3 * ${p} + depth4 + ${Bm(o)};\n      vec2 uv = uvFromFlat(${V}, ${j}, index);\n      return sampleTexture(${o}, uv);\n    }\n  `}(r);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function $C(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return function(n){const i=n.name;return`\n    vec4 ${"get"+i.charAt(0).toUpperCase()+i.slice(1)}() {\n      return ${Uo().texture2D}(${i}, halfCR);\n    }\n  `}(r);case 1:return function(n,i){const a=n.name,o="get"+a.charAt(0).toUpperCase()+a.slice(1),u=n.shapeInfo.texShape,h=Uo();if(i)return`\n    vec4 ${o}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${h.texture2D}(${a}, uv);\n    }\n  `;const f=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];return`\n    vec4 ${o}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${f[0]}, ${f[1]}, index);\n      return ${h.texture2D}(${a}, uv);\n    }\n  `}(r,t);case 2:return function(n,i){const a=n.shapeInfo.logicalShape,o=n.name,u="get"+o.charAt(0).toUpperCase()+o.slice(1),h=n.shapeInfo.texShape,f=h[0],p=h[1],m=Uo();if(null!=h&&We(a,h))return i?`\n      vec4 ${u}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n\n        return ${m.texture2D}(${o}, uv);\n      }\n    `:`\n      vec4 ${u}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${f}.0);\n\n        return ${m.texture2D}(${o}, uv);\n      }\n    `;if(i)return`\n    vec4 ${u}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${m.texture2D}(${o}, uv);\n    }\n  `;const y=[Math.ceil(h[0]/2),Math.ceil(h[1]/2)];return`\n    vec4 ${u}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(a[1]/2)}, ${y[0]}, ${y[1]}, row, col);\n      return ${m.texture2D}(${o}, uv);\n    }\n  `}(r,t);case 3:return function(n,i){const a=n.shapeInfo.logicalShape,o=n.name,u="get"+o.charAt(0).toUpperCase()+o.slice(1),h=n.shapeInfo.texShape,f=[Math.ceil(h[0]/2),Math.ceil(h[1]/2)];if(1===a[0]){const T=[1,2],R=["b","row","col"];return`\n        ${$C(VA(n,a.slice(1)),i)}\n        vec4 ${u}(int b, int row, int col) {\n          return ${u}(${GA(R,T)});\n        }\n      `}const p=Uo();if(i)return`\n    vec4 ${u}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${o}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${o}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${p.texture2D}(${o}, uv);\n    }\n  `;const m=f[0],y=f[1],b=Math.ceil(a[2]/2);return`\n    vec4 ${u}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${m}, ${y}, ${b*Math.ceil(a[1]/2)}, ${b}, b, row, col);\n      return ${p.texture2D}(${o}, uv);\n    }\n  `}(r,t);default:return function(n,i){const a=n.name,o="get"+a.charAt(0).toUpperCase()+a.slice(1),u=Uo();if(i)return`\n    vec4 ${o}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${a}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${a}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${u.texture2D}(${a}, uv);\n    }\n  `;const h=n.shapeInfo.logicalShape,f=h.length,p=n.shapeInfo.texShape,m=[Math.ceil(p[0]/2),Math.ceil(p[1]/2)],y=m[0],b=m[1],T=Math.ceil(h[f-1]/2);let R=T*Math.ceil(h[f-2]/2),L="int b, int row, int col",V=`b * ${R} + (row / 2) * ${T} + (col / 2)`;for(let j=2;j<f-1;j++)L=`int b${j}, `+L,R*=h[f-j-1],V=`b${j} * ${R} + `+V;return`\n    vec4 ${o}(${L}) {\n      int index = ${V};\n      int texR = index / ${b};\n      int texC = index - texR * ${b};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${b}, ${y});\n      return ${u.texture2D}(${a}, uv);\n    }\n  `}(r,t)}}const QR="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",HR="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",WR="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",jR="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Bm(r){return`offset${r}`}function $A(r){const t=r.name,n=Wt(r.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function ns(r){if(r<=1)return"int";if(2===r)return"ivec2";if(3===r)return"ivec3";if(4===r)return"ivec4";if(5===r)return"ivec5";if(6===r)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function ME(r,t,n){const{newShape:i,keptDims:a}=ki(t),o=t.length,u=r&&3===o&&1===t[0],h=u?t.slice(1):i,f=!r&&o>1&&!We(t,n)&&i.length<o||u;return{useSqueezeShape:f,uniformShape:f?h:t,keptDims:a}}function VA(r,t){const n=JSON.parse(JSON.stringify(r));return n.shapeInfo.logicalShape=t,n}function GA(r,t){return t.map(n=>r[n]).join(", ")}function VC(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((n,i)=>{const a=n.logicalShape,o=t[i],u=o.shape;if(!We(a,u))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${u} must match`);if(n.isUniform&&o.isUniform)return;const h=n.texShape,f=o.isUniform?null:o.texData.texShape;if(!We(h,f))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${h} and ${f} must match`)})}function ul(r){return de().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}class qR{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=n1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Uo();this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?gb(["r","c","d"],t):Rm(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class XR{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=n1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Uo();this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?gb(["r","c","d"],t):Rm(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class YR{constructor(t){this.variableNames=["A"],this.outTexUsage=sc.DOWNLOAD;const n=Uo();this.outputShape=t,this.userCode=`\n      ${UC}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${n.output} = encode_float(x);\n      }\n    `}}class KR{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=sc.DOWNLOAD;const n=Uo();this.outputShape=t,this.userCode=`\n      ${UC}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${n.output} = encode_float(x);\n      }\n    `}}class JR{constructor(t,n=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Uo();this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":SE(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${i.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${i.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class ZR{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Uo();this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length);let a="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let h=0;h<=1;h++){const f=2*u+h;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${h} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${h};\n          if (localCoords[1] + ${u} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${u};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${i.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${f}] = values[0];\n            } else if (offset == 1) {\n              result[${f}] = values[1];\n            } else if (offset == 2) {\n              result[${f}] = values[2];\n            } else {\n              result[${f}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":SE(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${i.output} = ${o};\n        }\n    `}}function s1(r,t,n,i,a,o){!function(f,p){const m=de().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(f<=0||p<=0)throw new Error(`Requested texture size [${f}x${p}] is invalid.`);if(f>m||p>m)throw new Error(`Requested texture size [${f}x${p}] greater than WebGL maximum on this browser / GPU [${m}x${m}].`)}(t,n);const u=bd(f=r,()=>f.createTexture(),"Unable to create WebGLTexture."),h=r.TEXTURE_2D;var f;return Wn(r,()=>r.bindTexture(h,u)),Wn(r,()=>r.texParameteri(h,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Wn(r,()=>r.texParameteri(h,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Wn(r,()=>r.texParameteri(h,r.TEXTURE_MIN_FILTER,r.NEAREST)),Wn(r,()=>r.texParameteri(h,r.TEXTURE_MAG_FILTER,r.NEAREST)),1===de().getNumber("WEBGL_VERSION")?Wn(r,()=>r.texImage2D(h,0,i,t,n,0,a,o,null)):Wn(r,()=>r.texStorage2D(h,1,i,t,n)),Wn(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:u,texShape:[n,t]}}function GC(r){return r.internalFormatFloat}function QC(r){return r.internalFormatHalfFloat}function HC(r){return r.downloadTextureFormat}function WC(r){return r.internalFormatPackedFloat}function jC(r){return r.internalFormatPackedHalfFloat}class TE{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const n=de().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,km[n]=t):this.gl=Ru(n);let i="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(1===de().getNumber("WEBGL_VERSION")){const u="OES_texture_half_float";if(this.textureFloatExtension=db(this.gl,"OES_texture_float"),Pc(this.gl,u))this.textureHalfFloatExtension=db(this.gl,u);else if(de().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(i),Pc(this.gl,a))this.colorBufferHalfFloatExtension=db(this.gl,a);else if(de().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(i="EXT_color_buffer_float",Pc(this.gl,i))this.colorBufferFloatExtension=this.gl.getExtension(i);else{if(!Pc(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=function(u,h){const f=bd(u,()=>u.createBuffer(),"Unable to create WebGLBuffer");return Wn(u,()=>u.bindBuffer(u.ARRAY_BUFFER,f)),Wn(u,()=>u.bufferData(u.ARRAY_BUFFER,h,u.STATIC_DRAW)),f}(this.gl,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])),this.indexBuffer=function(o){return function(u,h){const f=bd(u,()=>u.createBuffer(),"Unable to create WebGLBuffer");return Wn(u,()=>u.bindBuffer(u.ELEMENT_ARRAY_BUFFER,f)),Wn(u,()=>u.bufferData(u.ELEMENT_ARRAY_BUFFER,h,u.STATIC_DRAW)),f}(o,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(o){return bd(o,()=>o.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=vE(this.gl,this.textureHalfFloatExtension)}get debug(){return de().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Wn(t,()=>t.finish()),Wn(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Wn(t,()=>t.deleteFramebuffer(this.framebuffer)),Wn(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Wn(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Wn(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),function(i,a,o,u){const[h,f]=r1(a,o);return s1(i,h,f,GC(u),u.textureFormatFloat,i.FLOAT)}(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),function(i,a,o,u){const[h,f]=r1(a,o);return s1(i,h,f,QC(u),u.textureFormatFloat,u.textureTypeHalfFloat)}(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),function(i,a,o,u){const[h,f]=r1(a,o);return s1(i,h,f,HC(u),i.RGBA,i.UNSIGNED_BYTE)}(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){var i,a,o;this.throwIfDisposed(),a=t,o=n,Wn(i=this.gl,()=>i.bindTexture(i.TEXTURE_2D,a)),o.data instanceof Uint8Array?2===de().getNumber("WEBGL_VERSION")?Wn(i,()=>i.texSubImage2D(i.TEXTURE_2D,0,0,0,o.width,o.height,i.RGBA,i.UNSIGNED_BYTE,o.data)):Wn(i,()=>i.texImage2D(i.TEXTURE_2D,0,i.RGBA,o.width,o.height,0,i.RGBA,i.UNSIGNED_BYTE,o.data)):2===de().getNumber("WEBGL_VERSION")?Wn(i,()=>i.texSubImage2D(i.TEXTURE_2D,0,0,0,i.RGBA,i.UNSIGNED_BYTE,o)):Wn(i,()=>i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,o)),Wn(i,()=>i.bindTexture(i.TEXTURE_2D,null))}uploadDenseMatrixToTexture(t,n,i,a){this.throwIfDisposed(),function(o,u,h,f,p,m){let y,b,T;Wn(o,()=>o.bindTexture(o.TEXTURE_2D,u)),p instanceof Uint8Array?(y=new Uint8Array(h*f*4),b=o.UNSIGNED_BYTE,T=o.RGBA):(y=new Float32Array(h*f*4),b=o.FLOAT,T=m.internalFormatPackedFloat),y.set(p),2===de().getNumber("WEBGL_VERSION")?Wn(o,()=>o.texSubImage2D(o.TEXTURE_2D,0,0,0,h,f,o.RGBA,b,y)):Wn(o,()=>o.texImage2D(o.TEXTURE_2D,0,T,h,f,0,o.RGBA,b,y)),Wn(o,()=>o.bindTexture(o.TEXTURE_2D,null))}(this.gl,t,n,i,a,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),function(i,a,o,u){const[h,f]=OA(a,o);return s1(i,h,f,jC(u),i.RGBA,u.textureTypeHalfFloat)}(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),function(i,a,o,u){const[h,f]=OA(a,o);return s1(i,h,f,WC(u),i.RGBA,i.FLOAT)}(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(OC(this.gl,this.framebuffer),this.outputTexture=null),Wn(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,i){return this.downloadMatrixDriver(t,()=>function(a,o,u,h){const[f,p]=r1(o,u),m=new Uint8Array(o*u*4);return Wn(a,()=>a.readPixels(0,0,f,p,h.downloadTextureFormat,a.UNSIGNED_BYTE,m)),new Float32Array(m.buffer)}(this.gl,n,i,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,i,a,o,u){return function(h,f,p,m,y,b,T,R){const L=h,V=new Float32Array(function(j,H){const[nt,dt]=OA(j,H);return nt*dt*4}(b,T));return L.bindBuffer(L.PIXEL_PACK_BUFFER,f),L.getBufferSubData(L.PIXEL_PACK_BUFFER,0,V),L.bindBuffer(L.PIXEL_PACK_BUFFER,null),V}(this.gl,t,0,0,0,o,u)}downloadFloat32MatrixFromBuffer(t,n){return function(i,a,o){const u=i,h=new Float32Array(o);return u.bindBuffer(u.PIXEL_PACK_BUFFER,a),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,h),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),h}(this.gl,t,n)}createBufferFromTexture(t,n,i){this.bindTextureToFrameBuffer(t);const a=function(o,u,h,f){const p=o.createBuffer();Wn(o,()=>o.bindBuffer(o.PIXEL_PACK_BUFFER,p));const m=16*u*h;return Wn(o,()=>o.bufferData(o.PIXEL_PACK_BUFFER,m,o.STREAM_READ)),Wn(o,()=>o.readPixels(0,0,h,u,o.RGBA,o.FLOAT,0)),Wn(o,()=>o.bindBuffer(o.PIXEL_PACK_BUFFER,null)),p}(this.gl,n,i);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,i;if(de().getBool("WEBGL_FENCE_API_ENABLED")){const a=t,o=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),i=()=>{const u=a.clientWaitSync(o,0,0);return u===a.ALREADY_SIGNALED||u===a.CONDITION_SATISFIED},n=o}else de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),i=()=>this.isQueryAvailable(n,de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):i=()=>!0;return{query:n,isFencePassed:i}}downloadMatrixFromPackedTexture(t,n,i){return this.downloadMatrixDriver(t,()=>function(a,o,u){const h=new Float32Array(o*u*4);return Wn(a,()=>a.readPixels(0,0,u,o,a.RGBA,a.FLOAT,h)),h}(this.gl,n,i))}createProgram(t){this.throwIfDisposed();const n=this.gl;null==this.vertexShader&&(this.vertexShader=function(a){const o=Uo();return function(u,h){const f=bd(u,()=>u.createShader(u.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Wn(u,()=>u.shaderSource(f,h)),Wn(u,()=>u.compileShader(f)),!1===u.getShaderParameter(f,u.COMPILE_STATUS))throw console.log(u.getShaderInfoLog(f)),new Error("Failed to compile vertex shader.");return f}(a,`${o.version}\n    precision highp float;\n    ${o.attribute} vec3 clipSpacePos;\n    ${o.attribute} vec2 uv;\n    ${o.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(n));const i=bd(a=n,()=>a.createProgram(),"Unable to create WebGLProgram.");var a;return Wn(n,()=>n.attachShader(i,this.vertexShader)),Wn(n,()=>n.attachShader(i,t)),function(a,o){if(Wn(a,()=>a.linkProgram(o)),!1===a.getProgramParameter(o,a.LINK_STATUS))throw console.log(a.getProgramInfoLog(o)),new Error("Failed to link vertex and fragment shaders.")}(n,i),this.debug&&bE(n,i),this.vertexAttrsAreBound||(this.setProgram(i),this.vertexAttrsAreBound=function(a,o,u){return Wn(a,()=>a.bindBuffer(a.ARRAY_BUFFER,u)),FC(a,o,"clipSpacePos",u,3,20,0)&&FC(a,o,"uv",u,2,20,12)}(n,this.program,this.vertexBuffer)),i}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&Wn(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&bE(this.gl,this.program),Wn(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,i=!0){return this.throwIfDisposed(),i?(o=t,bd(a=this.gl,()=>a.getUniformLocation(o,u),'uniform "'+(u=n)+'" not present in program.')):function(a,o,u){return a.getUniformLocation(o,u)}(this.gl,t,n);var a,o,u}getAttributeLocation(t,n){return this.throwIfDisposed(),Wn(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,i){this.throwIfDisposed(),this.throwIfNoProgram(),function VR(r,t,n,i){Wn(r,()=>{return o=t,function(h,f){const p=h.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,m=f+h.TEXTURE0;if(m<h.TEXTURE0||m>p)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${p}].`)}(a=r,u=i),Wn(a,()=>a.activeTexture(a.TEXTURE0+u)),void Wn(a,()=>a.bindTexture(a.TEXTURE_2D,o));var a,o,u}),Wn(r,()=>r.uniform1i(n,i))}(this.gl,t,n,i)}setOutputMatrixTexture(t,n,i){this.setOutputMatrixTextureDriver(t,i,n)}setOutputPackedMatrixTexture(t,n,i){this.throwIfDisposed();const[a,o]=OA(n,i);this.setOutputMatrixTextureDriver(t,a,o)}setOutputMatrixWriteRegion(t,n,i,a){this.setOutputMatrixWriteRegionDriver(i,t,a,n)}setOutputPackedMatrixWriteRegion(t,n,i,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&bE(this.gl,this.program),pb(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),Wn(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Wn(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=db(this.gl,2===de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const i=this.gl,a=this.getQueryTimerExtensionWebGL2(),o=i.createQuery();return i.beginQuery(a.TIME_ELAPSED_EXT,o),o}const t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if(2===de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const n=this.gl,i=this.getQueryTimerExtensionWebGL2();return void n.endQuery(i.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await mo(()=>this.disposed||this.isQueryAvailable(t,de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(0===n)return null;if(2===n){const i=this.gl;return i.getQueryParameter(t,i.QUERY_RESULT)/1e6}{const i=this.getQueryTimerExtensionWebGL1();return i.getQueryObjectEXT(t,i.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(0===n)return!0;if(2===n){const i=this.gl,a=this.getQueryTimerExtensionWebGL2(),o=i.getQueryParameter(t,i.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const i=this.getQueryTimerExtensionWebGL1(),a=i.getQueryObjectEXT(t,i.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){const t=function(n){let i=0;for(;i<n.length&&n[i]();++i);return i-1}(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){const{resolveFn:i}=this.itemsToPoll[n];i()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),this.itemsToPoll.length>1||mo(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),xE(this.gl,t,this.framebuffer),this.debug&&pb(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(xE(this.gl,this.outputTexture,this.framebuffer),this.debug&&pb(this.gl)):OC(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const i=n();return this.unbindTextureToFrameBuffer(),i}setOutputMatrixTextureDriver(t,n,i){this.throwIfDisposed();const a=this.gl;xE(a,t,this.framebuffer),this.debug&&pb(a),this.outputTexture=t,Wn(a,()=>a.viewport(0,0,n,i)),Wn(a,()=>a.scissor(0,0,n,i))}setOutputMatrixWriteRegionDriver(t,n,i,a){this.throwIfDisposed(),Wn(this.gl,()=>this.gl.scissor(t,n,i,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:tB,bincountImpl:qC,bincountReduceImpl:eB,ceilImpl:nB,concatImpl:rB,equalImpl:iB,expImpl:sB,expm1Impl:aB,floorImpl:oB,gatherNdImpl:lB,gatherV2Impl:cB,greaterImpl:uB,greaterEqualImpl:hB,lessImpl:dB,lessEqualImpl:pB,linSpaceImpl:fB,logImpl:mB,maxImpl:gB,maximumImpl:AB,minimumImpl:yB,multiplyImpl:vB,negImpl:bB,notEqualImpl:xB,prodImpl:wB,rangeImpl:EB,rsqrtImpl:CB,sigmoidImpl:IB,simpleAbsImpl:XC,sliceImpl:SB,sparseFillEmptyRowsImpl:MB,sparseReshapeImpl:TB,sparseSegmentReductionImpl:YC,sqrtImpl:_B,stridedSliceImpl:kB,stringNGramsImpl:RB,stringSplitImpl:BB,stringToHashBucketFastImpl:NB,subImpl:DB,tileImpl:LB,topKImpl:FB,transposeImpl:_E,uniqueImpl:OB}=js;function KC(r,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${r}.${n}`)}function zo(r,t){return 1===t?[r]:KC(r,t)}class PB{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ul(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=zo("rc",this.rank),i=ns(this.rank),a=this.getOutOfBoundsCondition(n),o=this.getSetup(n),u=this.getOutput(n);this.userCode=`\n        void main() {\n          ${i} rc = getOutputCoords();\n\n          if(${a}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${u}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const n=[];for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let o=`${0===i?"r":"rp1"}, ${0===a?"c":"cp1"}`;for(let u=2;u<this.rank;u++)o=`${t[t.length-1-u]},`+o;n.push(o)}return n}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let i=this.rank-2;i<this.rank;i++)n+=`${t[i]} >= ${this.enableShapeUniforms?`outShape[${i}]`:this.outputShape[i]}`,i<this.rank-1&&(n+="||");return n}getSetup(t){if(1===this.rank)return"";const n=t.slice(-2);return`\n      int r = ${n[0]};\n      int c = ${n[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const n=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),\n            cEdge ? 0. : getA(${n[1]}),\n            rEdge ? 0. : getA(${n[2]}),\n            rEdge || cEdge ? 0. : getA(${n[3]})`}}class JC{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length);let i="";for(let u=0;u<4;u++){let h="thisRC = rc;";u%2==1&&(h+="thisRC.z += 1;"),u>1&&(h+="thisRC.y += 1;"),i+=`\n        ${h}\n        ${u>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${u}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${u>0?"}":""}\n      `}var a,o;this.userCode=`\n      ${a=n,o=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${o?function(u,h,f="index"){const p=function(m,y){const b=m.length,T=m.map(L=>`${y}[${L}]`),R=new Array(b-1);R[b-2]=T[b-1];for(let L=b-3;L>=0;--L)R[L]=`(${R[L+1]} * ${T[L+1]})`;return R}(u.map((m,y)=>y),h);return p.map((m,y)=>`int ${u[y]} = ${f} / ${p[y]}; ${y===p.length-1?`int ${u[y+1]} = ${f} - ${u[y]} * ${p[y]}`:`index -= ${u[y]} * ${p[y]}`};`).join("")}(["r","c","d"],"inputShape"):Rm(["r","c","d"],a)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":SE(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${i}\n\n        setOutput(result);\n      }\n    `}}class UB{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,n,i){const a=tI(n,i),o=eI(t,a,i);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const u=ZC(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,i);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=u,this.log();const f=this.freeTextures[o].shift();return this.usedTextures[o].push(f),f}let h;return a===co.PACKED_2X2_FLOAT32?h=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):a===co.PACKED_2X2_FLOAT16?h=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):a===co.UNPACKED_FLOAT32?h=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):a===co.UNPACKED_FLOAT16?h=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):a===co.PACKED_4X1_UNSIGNED_BYTE&&(h=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(h),this.numUsedTextures++,this._numBytesAllocated+=u,this.log(),h}releaseTexture(t,n,i,a){if(null==this.freeTextures)return;const o=tI(i,a),u=eI(n,o,a);u in this.freeTextures||(this.freeTextures[u]=[]);const h=ZC(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,a),f=de().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==f&&this._numBytesAllocated>f?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=h):(this.freeTextures[u].push(t),this.numFreeTextures++,this._numBytesFree+=h),this.numUsedTextures--;const p=this.usedTextures[u],m=p.indexOf(t);if(m<0)throw new Error("Cannot release a texture that was never provided by this texture manager");p.splice(m,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function ZC(r,t,n,i,a){const o=function(h,f){switch(h){case co.PACKED_2X2_FLOAT32:return WC(f);case co.PACKED_2X2_FLOAT16:return jC(f);case co.UNPACKED_FLOAT32:return GC(f);case co.UNPACKED_FLOAT16:return QC(f);case co.PACKED_4X1_UNSIGNED_BYTE:return HC(f);default:throw new Error(`Unknown physical texture type ${h}`)}}(t,i);let u;if(a){const[h,f]=OA(r[0],r[1]);u=h*f}else{const[h,f]=r1(r[0],r[1]);u=h*f}return u*function(h,f){if(f===h.R32F)return 4;if(f===h.R16F)return 2;if(f===h.RGBA32F||f===h.RGBA)return 16;if(f===h.RGBA16F)return 8;if(f===h.RGBA8)return 4;throw new Error(`Unknown internal format ${f}`)}(n,o)}function tI(r,t){if(r===sc.UPLOAD)return co.PACKED_2X2_FLOAT32;if(r===sc.RENDER||null==r)return n=t,de().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?co.PACKED_2X2_FLOAT32:co.UNPACKED_FLOAT32:n?co.PACKED_2X2_FLOAT16:co.UNPACKED_FLOAT16;var n;if(r===sc.DOWNLOAD||r===sc.PIXELS)return co.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function eI(r,t,n){return`${r[0]}_${r[1]}_${t}_${n}`}class xd{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${n}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const nI="return abs(x);",QA="return x;";class Nm{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${n}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class zB{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length);const n=t.length,i=zo("rc",n),a=ns(n),o=function(f,p){if(1===f)return"rc";let m="";for(let y=0;y<f;y++)m+=p[y],y<f-1&&(m+=",");return m}(n,i),u=i.slice(-2),h=n<=1?"rc":`vec2(${u.join(",")})`;this.userCode=`\n      void main() {\n        ${a} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${h}));\n      }\n    `}}const $B=ad,kE={},VB=de().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class Ab extends Ya{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!de().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(null!=t){if(t instanceof TE)n=t;else{const a=Ru(de().getNumber("WEBGL_VERSION"),t);n=new TE(a)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const a=Ru(de().getNumber("WEBGL_VERSION"));n=new TE(a),this.binaryCache=((i=de().getNumber("WEBGL_VERSION"))in kE||(kE[i]={}),kE[i]),this.gpgpuCreatedLocally=!0}var i;this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new UB(this.gpgpu),this.numMBBeforeWarning=null==de().global.screen?1024:de().global.screen.height*de().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Xa(this,au())}nextDataId(){return Ab.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,n,i){if((de().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||de().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===i&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:n,dtype:i,values:t,usage:sc.UPLOAD,refCount:1}),a}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,n,i,a,o){if(de().getBool("DEBUG")&&this.checkNumericalProblems(n),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:i,dtype:a,values:n,usage:sc.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t),{values:i,dtype:a,complexTensorInfos:o,slice:u,shape:h,isPacked:f}=n;if(null!=u){let b;b=f?new Nm(h,QA):new xd(h,QA);const T=this.runWebGLProgram(b,[{dataId:t,shape:h,dtype:a}],a),R=this.readSync(T.dataId);return this.disposeIntermediateTensorInfo(T),R}if(null!=i)return this.convertAndCacheOnCPU(t);if("string"===a)return i;const p=null!=this.activeTimers;let m,y;return p&&(m=ga()),y="complex64"===a?wu(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(t),p&&(this.downloadWaitMs+=ga()-m),this.convertAndCacheOnCPU(t,y)}async read(t){if(this.pendingRead.has(t)){const R=this.pendingRead.get(t);return new Promise(L=>R.push(L))}const n=this.texData.get(t),{values:i,shape:a,slice:o,dtype:u,complexTensorInfos:h,isPacked:f}=n;if(null!=o){let R;R=f?new Nm(a,QA):new xd(a,QA);const L=this.runWebGLProgram(R,[{dataId:t,shape:a,dtype:u}],u),V=this.read(L.dataId);return this.disposeIntermediateTensorInfo(L),V}if(null!=i)return this.convertAndCacheOnCPU(t);if(de().getBool("DEBUG")&&!de().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===de().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let p,m,y=null;if("complex64"!==u&&de().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(t);const R=this.texData.get(p.dataId);y=this.gpgpu.createBufferFromTexture(R.texture.texture,...hb(a))}if(this.pendingRead.set(t,[]),"complex64"!==u&&await this.gpgpu.createAndWaitForFence(),"complex64"===u){const R=await Promise.all([this.read(h.real.dataId),this.read(h.imag.dataId)]);m=wu(R[0],R[1])}else if(null==y)m=this.getValuesFromTexture(t);else{const R=Wt(a);m=this.gpgpu.downloadFloat32MatrixFromBuffer(y,R)}if(null!=p&&this.disposeIntermediateTensorInfo(p),null!=y){const R=this.gpgpu.gl;Wn(R,()=>R.deleteBuffer(y))}const b=this.convertAndCacheOnCPU(t,m),T=this.pendingRead.get(t);return this.pendingRead.delete(t),T.forEach(R=>R(b)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&au().removeDataId(t,this),this.pendingDeletes--),b}readToGPU(t,n={}){const i=this.texData.get(t),{values:a,shape:o,slice:u,dtype:h,isPacked:f,texture:p}=i;if("complex64"===h)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=u){let T;T=f?new Nm(o,QA):new xd(o,QA);const R=this.runWebGLProgram(T,[{dataId:t,shape:o,dtype:h}],h),L=this.readToGPU(R,n);return this.disposeIntermediateTensorInfo(R),L}if(null==p)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const m=this.decode(t,n.customTexShape),y=au().makeTensorFromDataId(m.dataId,m.shape,m.dtype),b=this.texData.get(m.dataId);return Object.assign({tensorRef:y},b.texture)}bufferSync(t){const n=this.readSync(t.dataId);let i=n;if("string"===t.dtype)try{i=n.map(a=>Dh(a))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return $r(t.shape,t.dtype,i)}checkNumericalProblems(t){if(null!=t)for(let n=0;n<t.length;n++){const i=t[n];if(!zR(i))throw de().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${i} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${i} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:n,dtype:i,isPacked:a}=this.texData.get(t),o=Wt(n);if(de().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const b=this.decode(t),T=this.texData.get(b.dataId),R=this.gpgpu.downloadMatrixFromPackedTexture(T.texture.texture,...hb(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(b),R}const u=de().getBool("WEBGL_PACK")&&!0===a,h=u?wE(n):n,f=u?new KR(h):new YR(h),p=this.runWebGLProgram(f,[{shape:h,dtype:i,dataId:t}],"float32"),m=this.texData.get(p.dataId),y=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(m.texture.texture,m.texShape[0],m.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(p),y}timerAvailable(){return de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers,i=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=i,a=!0):this.activeTimers.push(i),this.activeTimers=i,t();const o=Ae(this.activeTimers.map(f=>f.query)).filter(f=>null!=f),u=Ae(this.activeTimers.map(f=>f.name)).filter(f=>null!=f);this.activeTimers=n,a&&(this.programTimersStack=null);const h={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const f=await Promise.all(o);h.kernelMs=q(f),h.getExtraProfileInfo=()=>f.map((p,m)=>({name:u[m],ms:p})).map(p=>`${p.name}: ${p.ms}`).join(", ")}else h.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,h})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ga(),endMs:null}}endTimer(t){return de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=ga(),t)}async getQueryTime(t){return de().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:i}=this.texData.get(t);return null!=i&&(this.disposeData(i.real.dataId,n),this.disposeData(i.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:n,dtype:i,texShape:a,usage:o,isPacked:u,slice:h}=this.texData.get(t),f=h&&h.origDataId||t,p=this.dataRefCount.get(f);p>1?this.dataRefCount.set(f,p-1):(this.dataRefCount.delete(f),null!=n&&(this.numBytesInGPU-=this.computeBytes(a,i),this.textureManager.releaseTexture(n,a,o,u)));const m=this.texData.get(t);m.texture=null,m.texShape=null,m.isPacked=!1,m.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=VB){return de().getBool("WEBGL_CPU_FORWARD")&&t.every(i=>null==this.texData.get(i.dataId).texture&&Wt(i.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){Fs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=t.dataSync();return $B(t.shape,n)}packedUnaryOp(t,n,i){const a=new Nm(t.shape,n),o=this.compileAndRun(a,[t],i);return au().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const a=XC(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,a)}if(de().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,nI,t.dtype);const n=new xd(t.shape,nI),i=this.compileAndRun(n,[t]);return au().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}makeTensorInfo(t,n,i){let a;if("string"===n&&null!=i&&i.length>0&&bn(i[0])){const o=i.map(u=>jl(u));a=this.write(o,t,n)}else a=this.write(i,t,n);return this.texData.get(a).usage=null,{dataId:a,shape:t,dtype:n}}makeOutput(t,n,i){const{dataId:a}=this.makeTensorInfo(t,n,i);return au().makeTensorFromDataId(a,t,n,this)}unpackTensor(t){const n=new zB(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new PB(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){const i=[PA(t.shape),...UA(t.shape)],a={dtype:t.dtype,shape:i,dataId:t.dataId},o=[PA(n),...UA(n)],u=new JC(o,i),f=this.runWebGLProgram(u,[a],t.dtype,[i],!0);return{dataId:f.dataId,shape:n,dtype:f.dtype}}decode(t,n){const i=this.texData.get(t),{isPacked:a,shape:o,dtype:u}=i;null!=n&&Z(Wt(o)<=n[0]*n[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const h=wE(o);let f;f=a?new XR(h):new qR(h);const p=[n??hb(h)];return{dtype:u,shape:o,dataId:this.runWebGLProgram(f,[{shape:h,dtype:u,dataId:t}],u,p,!0,n).dataId}}runWebGLProgram(t,n,i,a,o=!1,u){const h=this.makeTensorInfo(t.outputShape,i),f=this.texData.get(h.dataId);if(t.packedOutput&&(f.isPacked=!0),t.outPackingScheme===n1.DENSE){const j=u??hb(t.outputShape);f.texShape=j.map(H=>2*H)}if(null!=t.outTexUsage&&(f.usage=t.outTexUsage),0===Wt(h.shape))return f.values=Ut(h.dtype,0),h;const p=[],m=n.map(j=>{if("complex64"===j.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let H=this.texData.get(j.dataId);if(null==H.texture){if(!t.packedInputs&&Wt(j.shape)<=de().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:j.shape,texData:null,isUniform:!0,uniformValues:H.values};t.packedInputs&&(H.isPacked=!0,H.shape=j.shape)}if(this.uploadToGPU(j.dataId),!!H.isPacked!=!!t.packedInputs)j=H.isPacked?this.unpackTensor(j):this.packTensor(j),p.push(j),H=this.texData.get(j.dataId);else if(H.isPacked&&!mb(H.shape,j.shape)){const nt=j,dt=j.shape;j.shape=H.shape,j=this.packedReshape(j,dt),p.push(j),H=this.texData.get(j.dataId),nt.shape=dt}return{shape:j.shape,texData:H,isUniform:!1}});this.uploadToGPU(h.dataId);const y={shape:h.shape,texData:f,isUniform:!1},b=function(j,H,nt){let dt="";H.concat(nt).forEach(Ot=>{const Nt=null!=Ot.texData&&null!=Ot.texData.slice&&Ot.texData.slice.flatOffset>0;if(j.enableShapeUniforms&&!Ot.isUniform){const Vt=Ot.texData.texShape,{useSqueezeShape:qt,uniformShape:Zt,keptDims:te}=ME(j.packedInputs,Ot.shape,Vt);let ue="",Ee="",De="";if(1===Zt.length&&j.packedInputs){const He=[Math.ceil(Vt[0]/2),Math.ceil(Vt[1]/2)];ue=`${He[0]>1}_${He[1]>1}`}else if(2!==Zt.length||j.packedInputs){if(Zt.length>2&&!j.packedInputs){const He=gn(Zt);De=`${He[0]===Vt[1]}_${He[He.length-1]===Vt[1]}`}}else Ee=`${Zt[0]>1}_${Zt[1]>1}`;const we=Ot.shape.length,Te=2===Zt.length&&We(Ot.shape,Vt),Le=1===Wt(Ot.shape),$e=$h(Ot.shape,nt.shape),je=!j.packedInputs&&we===nt.shape.length&&We(Vt,nt.texData.texShape);dt+=`${we}_${je}_${qt?te:""}_${Zt.length}_${Le}_${$e}_${Te}_${ue}_${Ee}_${De}_${j.packedInputs||Zt.length>2?"":`${Vt[0]>1}_${Vt[1]>1}`}_${Nt}`}else dt+=`${Ot.shape}_${Ot.isUniform?"uniform":Ot.texData.texShape}_${Nt}`});let kt=j.constructor.name;return kt+="_"+dt+"_"+j.userCode+`${de().getNumber("WEBGL_VERSION")}`,kt}(t,m,y),T=this.getAndSaveBinary(b,()=>function(j,H,nt,dt){const yt=nt.map((Ne,He)=>{const Je={logicalShape:Ne.shape,texShape:Ne.isUniform?null:Ne.texData.texShape,isUniform:Ne.isUniform,isPacked:!Ne.isUniform&&Ne.texData.isPacked,flatOffset:null};return null!=Ne.texData&&null!=Ne.texData.slice&&Ne.texData.slice.flatOffset>0&&(Je.flatOffset=Ne.texData.slice.flatOffset),{name:H.variableNames[He],shapeInfo:Je}}),kt=yt.map(Ne=>Ne.shapeInfo),Ot={logicalShape:dt.shape,texShape:dt.texData.texShape,isUniform:!1,isPacked:dt.texData.isPacked,flatOffset:null},Nt=GR(yt,Ot,H),Vt=function(Ne,He){const Je=bd(Ne,()=>Ne.createShader(Ne.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Wn(Ne,()=>Ne.shaderSource(Je,He)),Wn(Ne,()=>Ne.compileShader(Je)),!1===Ne.getShaderParameter(Je,Ne.COMPILE_STATUS))throw function(dn,mn){const Ln=$R.exec(mn);if(null==Ln)return console.log(`Couldn't parse line number in error: ${mn}`),void console.log(dn);const Rn=+Ln[1],tr=dn.split("\n"),ur=tr.length.toString().length+2,ir=tr.map((Cr,Rr)=>ii((Rr+1).toString(),ur)+Cr);let er=0;for(let Cr=0;Cr<ir.length;Cr++)er=Math.max(ir[Cr].length,er);const Sr=ir.slice(0,Rn-1),Vr=ir.slice(Rn-1,Rn),gi=ir.slice(Rn);console.log(Sr.join("\n")),console.log(mn.split("\n")[0]),console.log(`%c ${ii(Vr[0],er)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(gi.join("\n"))}(He,Ne.getShaderInfoLog(Je)),new Error("Failed to compile fragment shader.");return Je}(j.gl,Nt),qt=j.createProgram(Vt);let Zt=null;const te=j.getUniformLocation(qt,"NAN",!1);1===de().getNumber("WEBGL_VERSION")&&(Zt=j.getUniformLocation(qt,"INFINITY",!1));const ue=!1,Ee={},De={},we={};for(let Ne=0;Ne<H.variableNames.length;Ne++){const He=H.variableNames[Ne];Ee[He]=j.getUniformLocation(qt,He,ue),Ee[`offset${He}`]=j.getUniformLocation(qt,`offset${He}`,ue),H.enableShapeUniforms&&(De[`${He}Shape`]=j.getUniformLocation(qt,`${He}Shape`,ue),we[`${He}TexShape`]=j.getUniformLocation(qt,`${He}TexShape`,ue))}let Te,Le,$e;H.enableShapeUniforms&&(Te=j.getUniformLocation(qt,"outShape",ue),$e=j.getUniformLocation(qt,"outShapeStrides",ue),Le=j.getUniformLocation(qt,"outTexShape",ue));const je=[];return H.customUniforms&&H.customUniforms.forEach((Ne,He)=>{je[He]=j.getUniformLocation(qt,Ne.name,ue)}),{program:H,fragmentShader:Vt,source:Nt,webGLProgram:qt,uniformLocations:Ee,customUniformLocations:je,inShapeInfos:kt,outShapeInfo:Ot,infLoc:Zt,nanLoc:te,inShapesLocations:De,inTexShapesLocations:we,outShapeLocation:Te,outShapeStridesLocation:$e,outTexShapeLocation:Le}}(this.gpgpu,t,m,y)),R=null!=this.activeTimers;let L;R&&(L=this.startTimer()),function(j,H,nt,dt,yt){H.program.enableShapeUniforms||(VC(H.inShapeInfos,nt),VC([H.outShapeInfo],[dt]));const kt=dt.texData.texture,Ot=dt.texData.texShape;dt.texData.isPacked?j.setOutputPackedMatrixTexture(kt.texture,Ot[0],Ot[1]):j.setOutputMatrixTexture(kt.texture,Ot[0],Ot[1]),j.setProgram(H.webGLProgram),1===de().getNumber("WEBGL_VERSION")&&null!==H.infLoc&&j.gl.uniform1f(H.infLoc,1/0),null!==H.nanLoc&&j.gl.uniform1f(H.nanLoc,NaN),nt.forEach((Vt,qt)=>{const Zt=H.program.variableNames[qt],te=H.uniformLocations[Zt],ue=H.uniformLocations[`offset${Zt}`],Ee=H.inShapesLocations[`${Zt}Shape`],De=H.inTexShapesLocations[`${Zt}TexShape`];if(Ee){const{uniformShape:we}=ME(H.program.packedInputs,Vt.shape,Vt.texData.texShape);switch(we.length){case 1:j.gl.uniform1iv(Ee,new Int32Array(we));break;case 2:j.gl.uniform2iv(Ee,new Int32Array(we));break;case 3:j.gl.uniform3iv(Ee,new Int32Array(we));break;case 4:j.gl.uniform4iv(Ee,new Int32Array(we))}}if(De&&j.gl.uniform2i(De,Vt.texData.texShape[0],Vt.texData.texShape[1]),null!=te)if(Vt.isUniform)if(Wt(Vt.shape)<2)j.gl.uniform1f(te,Vt.uniformValues[0]);else{let we=Vt.uniformValues;we instanceof Float32Array||(we=new Float32Array(we)),j.gl.uniform1fv(te,we)}else null!=Vt.texData.slice&&null!=ue&&j.gl.uniform1i(ue,Vt.texData.slice.flatOffset),j.setInputMatrixTexture(Vt.texData.texture.texture,te,qt)});const Nt=H.outShapeLocation;if(Nt)switch(dt.shape.length){case 1:j.gl.uniform1iv(Nt,new Int32Array(dt.shape));break;case 2:j.gl.uniform2iv(Nt,new Int32Array(dt.shape));break;case 3:j.gl.uniform3iv(Nt,new Int32Array(dt.shape));break;case 4:j.gl.uniform4iv(Nt,new Int32Array(dt.shape))}if(H.outShapeStridesLocation){const Vt=gn(dt.shape);switch(dt.shape.length){case 2:j.gl.uniform1iv(H.outShapeStridesLocation,new Int32Array(Vt));break;case 3:j.gl.uniform2iv(H.outShapeStridesLocation,new Int32Array(Vt));break;case 4:j.gl.uniform3iv(H.outShapeStridesLocation,new Int32Array(Vt))}}H.outTexShapeLocation&&j.gl.uniform2i(H.outTexShapeLocation,dt.texData.texShape[0],dt.texData.texShape[1]),H.program.customUniforms&&yt&&H.program.customUniforms.forEach((Vt,qt)=>{const Zt=H.customUniformLocations[qt],te=yt[qt];if("float"===Vt.type)j.gl.uniform1fv(Zt,te);else if("vec2"===Vt.type)j.gl.uniform2fv(Zt,te);else if("vec3"===Vt.type)j.gl.uniform3fv(Zt,te);else if("vec4"===Vt.type)j.gl.uniform4fv(Zt,te);else if("int"===Vt.type)j.gl.uniform1iv(Zt,te);else if("ivec2"===Vt.type)j.gl.uniform2iv(Zt,te);else if("ivec3"===Vt.type)j.gl.uniform3iv(Zt,te);else{if("ivec4"!==Vt.type)throw Error(`uniform type ${Vt.type} is not supported yet.`);j.gl.uniform4iv(Zt,te)}}),j.executeProgram()}(this.gpgpu,T,m,y,a),p.forEach(j=>this.disposeIntermediateTensorInfo(j)),R&&(L=this.endTimer(L),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(L)}));const V=de().get("WEBGL_FLUSH_THRESHOLD");if(V>0){const j=ga();j-this.lastGlFlushTime>V&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=j)}if(!de().getBool("WEBGL_LAZILY_UNPACK")&&f.isPacked&&!1===o){const j=this.unpackTensor(h);return this.disposeIntermediateTensorInfo(h),j}return h}compileAndRun(t,n,i,a,o=!1){return this.runWebGLProgram(t,n,i=i||n[0].dtype,a,o)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(de().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=me(()=>{if(!de().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=de().getBool("DEBUG");de().set("DEBUG",!1);const n=this.abs(Jn(1e-8)).dataSync()[0];if(de().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const n=this.texData.get(t),{shape:i,dtype:a,values:o,texture:u,usage:h,isPacked:f}=n;if(null!=u)return;const p=null!=this.activeTimers;let m;p&&(m=ga());let y=n.texShape;if(null==y&&(y=function(b,T=!1){let R=de().getNumber("WEBGL_MAX_TEXTURE_SIZE");T&&(R*=2,1===(b=b.map((V,j)=>j>=b.length-2?se(b[j]):b[j])).length&&(b=[2,b[0]])),2!==b.length&&(b=ki(b).newShape);let L=Wt(b);if(b.length<=1&&L<=R)return[1,L];if(2===b.length&&b[0]<=R&&b[1]<=R)return b;if(3===b.length&&b[0]*b[1]<=R&&b[2]<=R)return[b[0]*b[1],b[2]];if(3===b.length&&b[0]<=R&&b[1]*b[2]<=R)return[b[0],b[1]*b[2]];if(4===b.length&&b[0]*b[1]*b[2]<=R&&b[3]<=R)return[b[0]*b[1]*b[2],b[3]];if(4===b.length&&b[0]<=R&&b[1]*b[2]*b[3]<=R)return[b[0],b[1]*b[2]*b[3]];if(T){const V=PA(b);let j=2,H=2;return b.length&&([j,H]=UA(b)),L=V*(j/2)*(H/2),Hr(L).map(nt=>2*nt)}return Hr(L)}(i,f),n.texShape=y),null!=o){const b=wE(i);let T,R=y[1],L=y[0];const V=o instanceof Uint8Array||o instanceof Uint8ClampedArray;!f&&V||([R,L]=OA(y[0],y[1])),T=f?new ZR(b,V):new JR(b,V);const j=V?[L,R]:y,H=this.makeTensorInfo(j,a),nt=this.texData.get(H.dataId);nt.usage=V?sc.PIXELS:sc.UPLOAD,nt.texShape=j,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(H.dataId),R,L,o);const kt=this.runWebGLProgram(T,[H],a,[[L,R]],!0),Ot=this.texData.get(kt.dataId);n.texture=Ot.texture,n.texShape=Ot.texShape,n.isPacked=Ot.isPacked,n.usage=Ot.usage,this.disposeIntermediateTensorInfo(H),this.texData.delete(kt.dataId),n.values=null,p&&(this.uploadWaitMs+=ga()-m)}else{const b=this.acquireTexture(y,h,a,f);n.texture=b}}convertAndCacheOnCPU(t,n){const i=this.texData.get(t),{dtype:a}=i;return this.releaseGPUData(t),null!=n&&(i.values=function(o,u){if("float32"===u||"complex64"===u)return o;if("int32"===u||"bool"===u){const h="int32"===u?new Int32Array(o.length):new Uint8Array(o.length);for(let f=0;f<h.length;++f)h[f]=Math.round(o[f]);return h}throw new Error(`Unknown dtype ${u}`)}(n,a)),i.values}acquireTexture(t,n,i,a){if(this.numBytesInGPU+=this.computeBytes(t,i),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,a)}computeBytes(t,n){return t[0]*t[1]*pn(n)}}Ab.nextDataId=0,mf()&&cg("webgl",()=>new Ab,2);class HA{constructor(t,n,i){this.variableNames=["A","B"],this.outputShape=Nr(n,i),this.enableShapeUniforms=ul(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class a1{constructor(t,n,i,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Nr(n,i);const o=this.outputShape.length;this.enableShapeUniforms=ul(o);let u="";if(a)if(0===o||1===Wt(this.outputShape))u="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(u=`\n          ${ns(o)} coords = getOutputCoords();\n        `,1===o)u+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const h=zo("coords",o);u+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${h[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${h[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${h[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${h[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${u}\n\n        setOutput(result);\n      }\n    `}}function Ll(r){const{inputs:t,backend:n}=r,{x:i}=t;return n.incRef(i.dataId),{dataId:i.dataId,shape:i.shape,dtype:i.dtype}}const GB={kernelName:Sd,backendName:"webgl",kernelFunc:Ll};function Yp(r){const{inputs:t,backend:n}=r,{real:i,imag:a}=t,o=n.makeTensorInfo(i.shape,"complex64"),u=n.texData.get(o.dataId),h=Ll({inputs:{x:i},backend:n}),f=Ll({inputs:{x:a},backend:n});return u.complexTensorInfos={real:h,imag:f},o}const QB={kernelName:Xn,backendName:"webgl",kernelFunc:Yp},rI="return (a < 0.) ? b * a : a;",iI="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",HB={kernelName:Kp,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{alpha:o}=i,u=n.makeTensorInfo([],"float32",Kc(o,"float32")),h=de().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a1(iI,a.shape,u.shape):new HA(rI,a.shape,u.shape),f=n.runWebGLProgram(h,[a,u],"float32");return n.disposeIntermediateTensorInfo(u),f}},sI="return (a < 0.) ? b * a : a;",aI="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",WB={kernelName:ma,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{x:i,alpha:a}=t,o=de().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a1(aI,i.shape,a.shape):new HA(sI,i.shape,a.shape);return n.runWebGLProgram(o,[i,a],"float32")}};function bi({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:n,dtype:i}){return({inputs:a,backend:o})=>{const{x:u}=a,h=o,f=i||u.dtype;if(h.shouldExecuteOnCPU([u])&&null!=n){const m=h.texData.get(u.dataId),y=n(m.values,f);return h.makeTensorInfo(u.shape,f,y)}let p;return p=de().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Nm(u.shape,t):new xd(u.shape,r),h.runWebGLProgram(p,[u],f)}}function uo({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:i=!1,cpuKernelImpl:a,dtype:o}){return({inputs:u,backend:h})=>{const{a:f,b:p}=u,m=h;if(i&&"complex64"===f.dtype){const T=m.texData.get(f.dataId),R=m.texData.get(p.dataId),[L,V]=[[T.complexTensorInfos.real,R.complexTensorInfos.real],[T.complexTensorInfos.imag,R.complexTensorInfos.imag]].map(H=>{const[nt,dt]=H,yt={dataId:nt.dataId,dtype:nt.dtype,shape:f.shape},kt={dataId:dt.dataId,dtype:dt.dtype,shape:p.shape},Ot=new HA(r,f.shape,p.shape);return m.runWebGLProgram(Ot,[yt,kt],di(nt.dtype,dt.dtype))}),j=Yp({inputs:{real:L,imag:V},backend:m});return m.disposeIntermediateTensorInfo(L),m.disposeIntermediateTensorInfo(V),j}const y=o||di(f.dtype,p.dtype);if(("string"===f.dtype||"string"===p.dtype||m.shouldExecuteOnCPU([f,p]))&&null!=a){const T=m.texData.get(f.dataId).values,R=m.texData.get(p.dataId).values,L="string"===f.dtype?Fo(T):T,V="string"===f.dtype?Fo(R):R,[j,H]=a(f.shape,p.shape,L,V,y),nt=m.makeTensorInfo(H,y);return m.texData.get(nt.dataId).values=j,nt}let b;return b=de().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new a1(t,f.shape,p.shape,n):new HA(r,f.shape,p.shape),m.runWebGLProgram(b,[f,p],y)}}function yb(r,t=!1){if("linear"===r)return"return x;";if("relu"===r)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===r)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===r)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===r)return t?aI:sI;if("leakyrelu"===r)return t?iI:rI;if("sigmoid"===r)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}class oI{constructor(t,n,i,a=!1,o=!1,u=!1,h=null,f=!1,p=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i,this.enableShapeUniforms=ul(this.outputShape.length);const y=Math.ceil((a?t[1]:t[2])/2),b=a?"i * 2, rc.y":"rc.y, i * 2",T=o?"rc.z, i * 2":"i * 2, rc.z",R=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],L=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let V="",j="";h&&(V=f?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${h}\n        }`:p?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${h}\n        }`:`vec4 activation(vec4 x) {\n          ${h}\n        }`,j="result = activation(result);");const H=u?"result += getBiasAtOutCoords();":"";u&&this.variableNames.push("bias"),f&&this.variableNames.push("preluActivationWeights"),p&&this.variableNames.push("leakyreluAlpha");let nt="rc.x",dt="rc.x";t[0]<n[0]?nt=`int(min(float(rc.x), ${t[0]-1}.))`:n[0]<t[0]&&(dt=`int(min(float(rc.x), ${n[0]-1}.))`),this.userCode=`\n      ${V}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${y}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${y}; i++) {\n          int batchA = ${nt};\n          int batchB = ${dt};\n          vec4 a = getMatrixA(batchA, ${b});\n          vec4 b = getMatrixB(batchB, ${T});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${R[0]} * ${L[0]});\n          result += (${R[1]} * ${L[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${H}\n\n        ${j}\n\n        setOutput(result);\n      }\n    `}}class lI{constructor(t,n,i){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Nr(n,i),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const cI="return a * b;";function RE(r){const{inputs:t,backend:n}=r,{a:i,b:a}=t,o=di(i.dtype,a.dtype);if("complex64"===i.dtype){const h=n.texData.get(i.dataId),f=n.texData.get(a.dataId),p=new lI("return areal * breal - aimag * bimag;",i.shape,a.shape),m=new lI("return areal * bimag + aimag * breal;",i.shape,a.shape),y=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:i.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:a.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:a.shape}],b=n.runWebGLProgram(p,y,"float32"),T=n.runWebGLProgram(m,y,"float32"),R=Yp({inputs:{real:b,imag:T},backend:n});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(T),R}if(n.shouldExecuteOnCPU([i,a])){const h=n.texData.get(i.dataId),f=n.texData.get(a.dataId),[p,m]=vB(i.shape,a.shape,h.values,f.values,o),y=n.makeTensorInfo(m,o);return n.texData.get(y.dataId).values=p,y}let u;return u=de().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a1(cI,i.shape,a.shape):new HA(cI,i.shape,a.shape),n.runWebGLProgram(u,[i,a],o)}const jB={kernelName:Lu,backendName:"webgl",kernelFunc:RE};function Gn(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{shape:o}=i,u=n,h=Wt(a.shape),f=si(o,h),p=Wt(f);Z(h===p,()=>`The new shape (${f}) has ${p} elements and the old shape (${a.shape}) has ${h} elements. The new shape and old shape must have the same number of elements.`);const m=u.texData.get(a.dataId);return!m.isPacked||mb(a.shape,f)||null!==m.texture&&mb(m.shape,f)?(u.incRef(a.dataId),{dataId:a.dataId,shape:f,dtype:a.dtype}):function(y,b,T){const R=[PA(y.shape),...UA(y.shape)],L={dtype:y.dtype,shape:R,dataId:y.dataId},V=[PA(b),...UA(b)],j=new JC(V,R),nt=T.runWebGLProgram(j,[L],y.dtype,[R],!0);return{dataId:nt.dataId,shape:b,dtype:nt.dtype}}(a,f,u)}const qB={kernelName:Pd,backendName:"webgl",kernelFunc:Gn};class uI{constructor(t,n){this.variableNames=["x"];const{windowSize:i,batchSize:a,inSize:o,outSize:u}=t;this.outputShape=[a,u];const h=4*Math.floor(i/4),f=i%4;let p="sumValue += dot(values, ones);";if(null!=n){const y=1/n;p=`sumValue += dot(values * ${hn(y)?y.toPrecision(2):y}, ones);`}let m="";o%i>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${h}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${h};\n        if (${1===f}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${p}\n        } else if (${2===f}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${p}\n        } else if (${3===f}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${p}\n        }\n        setOutput(sumValue);\n      }\n    `}}class XB{constructor(t,n){this.variableNames=["x"];const{windowSize:i,batchSize:a,inSize:o,outSize:u}=t;this.outputShape=[a,u];let h="0.0",f="";"prod"===n?h="1.0":"min"===n?(h="1.0 / 1e-20",f="min"):"max"===n&&(h="-1.0 / 1e-20",f="max");let p=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===n?p="sumValue":"prod"===n?p="prodValue":"all"===n?p="allValue":"any"===n&&(p="anyValue");const m=4*Math.floor(i/4),y=i%4;let b=`\n      if (${"sum"===n}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===n}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${f}(values, minMaxValue);\n        if (${"min"===n} || ${"max"===n}) {\n          minMaxValue = ${f}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,T="vec4";"all"===n?(h="1.0",b="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",T="bvec4"):"any"===n&&(h="0.0",b="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",T="bvec4");let R="";o%i>0&&(R=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${h};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${R}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        vec4 minMaxValue = vec4(${h});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${m}; i += 4) {\n          int inIdx = inOffset + i;\n          ${T} values = ${T}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${b}\n        }\n\n        int inIdx = inOffset + ${m};\n        if (${1===y}) {\n          ${T} values = ${T}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${b}\n        } else if (${2===y}) {\n          ${T} values = ${T}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${b}\n        } else if (${3===y}) {\n          ${T} values = ${T}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${b}\n        }\n        setOutput(${p});\n      }\n    `}}function Dm(r,t,n,i){const a=function(u){const h=[];for(;0===h.length||1!==h[h.length-1].outSize;){const f=h.length?h[h.length-1].outSize:u[1],p=Tc(f);h.push({inSize:f,windowSize:p,outSize:Math.ceil(f/p)})}return h}(r.shape);let o=r;for(let u=0;u<a.length;u++){const{inSize:h,windowSize:f,outSize:p}=a[u];let m,y;m="mean"===n?0===u?new uI({windowSize:f,inSize:h,batchSize:r.shape[0],outSize:p},h):new uI({windowSize:f,inSize:h,batchSize:r.shape[0],outSize:p}):new XB({windowSize:f,inSize:h,batchSize:r.shape[0],outSize:p},n),y=o,o=i.runWebGLProgram(m,[o],t),y.dataId!==r.dataId&&i.disposeIntermediateTensorInfo(y)}return o}class YB{constructor(t,n){this.variableNames=["A"];const i=new Array(t.length);for(let u=0;u<i.length;u++)i[u]=t[n[u]];this.outputShape=i,this.rank=i.length;const a=ns(this.rank),o=function(u){const h=u.length;if(h>6)throw Error(`Transpose for rank ${h} is not yet supported`);const f=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],p=new Array(h);for(let m=0;m<u.length;m++)p[u[m]]=f[m];return p.join()}(n);this.userCode=`\n    void main() {\n      ${a} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class KB{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const i=new Array(t.length);for(let m=0;m<i.length;m++)i[m]=t[n[m]];if(this.outputShape=i,this.rank=i.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const a=ns(this.rank),o=KC("rc",this.rank),u=new Array(this.rank);for(let m=0;m<n.length;m++)u[n[m]]=o[m];const h=`vec2(${u.slice(-2).join()})`,f=`++${o[this.rank-1]} < ${i[this.rank-1]}`,p=`getChannel(getA(${u.join()}), ${h})`;this.userCode=`\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${p};\n      if(${f}) {\n        result[1] = ${p};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${i[this.rank-2]}) {\n        result[2] = ${p};\n        if(${f}) {\n          result[3] = ${p};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function vb(r,t,n){const i=de().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new KB(r.shape,t):new YB(r.shape,t);return n.runWebGLProgram(i,[r],r.dtype)}function bb(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i;return function(h,f,p,m){const b=h.shape.length,T=lr(f,h.shape);let R=T;const L=vs(R,b),V=null!=L;let j=h;V&&(j=vb(h,L,m),R=Ai(R.length,b)),zs("sum",R,b);const[H,nt]=sa(j.shape,R);let dt=H;p&&(dt=Ni(H,T));const yt=Wt(nt),kt=Gn({inputs:{x:j},attrs:{shape:[Wt(h.shape)/yt,yt]},backend:m}),Ot=Dm(kt,no(h.dtype),"sum",m),Nt=Gn({inputs:{x:Ot},attrs:{shape:dt},backend:m});return m.disposeIntermediateTensorInfo(kt),m.disposeIntermediateTensorInfo(Ot),V&&m.disposeIntermediateTensorInfo(j),Nt}(a,o,u,n)}const JB={kernelName:uf,backendName:"webgl",kernelFunc:bb};function $o(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{perm:o}=i,u=n,f=new Array(a.shape.length);for(let m=0;m<f.length;m++)f[m]=a.shape[o[m]];let p;if(u.shouldExecuteOnCPU([a])){const m=u.texData.get(a.dataId).values,y=_E(m,a.shape,a.dtype,o,f);p=u.makeTensorInfo(f,a.dtype),u.texData.get(p.dataId).values=y}else p=vb(a,o,u);return p}const ZB={kernelName:gl,backendName:"webgl",kernelFunc:$o};function xb({a:r,b:t,transposeA:n,transposeB:i,backend:a,bias:o=null,preluActivationWeights:u=null,leakyreluAlpha:h=0,activation:f=null}){const p=r.shape.length,m=t.shape.length,y=n?r.shape[p-2]:r.shape[p-1],b=i?t.shape[m-1]:t.shape[m-2],T=n?r.shape[p-1]:r.shape[p-2],R=i?t.shape[m-2]:t.shape[m-1],L=r.shape.slice(0,-2),V=t.shape.slice(0,-2),j=Wt(L),H=Wt(V),nt=Nr(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([T,R]);Z(y===b,()=>`Error in matMul: inner shapes (${y}) and (${b}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${n} and transposeB=${i} must match.`);const dt=n?[j,y,T]:[j,T,y],yt=i?[H,R,b]:[H,b,R],kt=Gn({inputs:{x:r},backend:a,attrs:{shape:dt}}),Ot=Gn({inputs:{x:t},backend:a,attrs:{shape:yt}}),Nt=[kt,Ot],Vt=Math.max(j,H),qt=n?kt.shape[1]:kt.shape[2],Zt=null!=o,te=null!=u,ue="leakyrelu"===f,Ee=null!=f?yb(f,!0):null;let De;if((1===T||1===R)&&qt>1e3&&!1===(Zt||te||ue||null!=Ee)){let Te=kt,Le=Ot;n&&(Te=$o({inputs:{x:kt},backend:a,attrs:{perm:[0,2,1]}}),Nt.push(Te)),i&&(Le=$o({inputs:{x:Ot},backend:a,attrs:{perm:[0,2,1]}}),Nt.push(Le));const $e=1===R;let je=Te;1!==R&&(je=Gn({inputs:{x:Te},backend:a,attrs:{shape:[Vt,qt,1]}}),Nt.push(je));const Ne=1===R?2:1;let He=Le;$e&&(He=Gn({inputs:{x:Le},backend:a,attrs:{shape:[Vt,1,qt]}}),Nt.push(He));const Je=RE({inputs:{a:je,b:He},backend:a});De=bb({inputs:{x:Je},backend:a,attrs:{axis:Ne,keepDims:!0}}),Nt.push(Je)}else{const Te=di(r.dtype,t.dtype),Le=new oI(dt,yt,[Vt,T,R],n,i,Zt,Ee,te,ue),$e=[kt,Ot];if(null!=o&&$e.push(o),te&&$e.push(u),ue){const je=a.makeTensorInfo([],"float32",Kc(h,"float32"));$e.push(je),Nt.push(je)}De=a.runWebGLProgram(Le,$e,Te)}const we=Gn({inputs:{x:De},backend:a,attrs:{shape:nt}});Nt.push(De);for(const Te of Nt)a.disposeIntermediateTensorInfo(Te);return we}const tN={kernelName:qc,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{a,b:o,bias:u,preluActivationWeights:h}=t,{transposeA:f,transposeB:p,activation:m,leakyreluAlpha:y}=i;return xb({a,b:o,transposeA:f,transposeB:p,backend:n,bias:u,preluActivationWeights:h,leakyreluAlpha:y,activation:m})}},hI="return abs(x);",eN={kernelName:da,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{x:i}=t;if(n.shouldExecuteOnCPU([i])&&"complex64"!==i.dtype){const o=n.texData.get(i.dataId),u=XC(o.values);return n.makeTensorInfo(i.shape,i.dtype,u)}let a;return a=de().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Nm(i.shape,hI):new xd(i.shape,hI),n.runWebGLProgram(a,[i],i.dtype)}},nN=bi({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),rN={kernelName:pa,backendName:"webgl",kernelFunc:nN},iN=bi({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),sN={kernelName:Ss,backendName:"webgl",kernelFunc:iN},dI="return a + b;",aN=uo({opSnippet:dI,packedOpSnippet:dI,supportsComplex:!0,cpuKernelImpl:tB}),oN={kernelName:Xs,backendName:"webgl",kernelFunc:aN};class lN{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((o,u)=>`T${u}`);const i=[];this.variableNames.forEach(o=>{i.push(`float v${o} = get${o}AtOutCoords();`)});const a=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${i.join("\n        ")}\n\n        float result = ${a};\n        setOutput(result);\n      }\n    `}}class cN{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((o,u)=>`T${u}`);const i=[];this.variableNames.forEach(o=>{i.push(`vec4 v${o} = get${o}AtOutCoords();`)});const a=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${i.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}const uN={kernelName:Ms,backendName:"webgl",kernelFunc:function r(t){const{inputs:n,backend:i}=t,a=n;if(1===a.length)return Ll({inputs:{x:a[0]},backend:i});if(a.length>de().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const f=Math.floor(a.length/2),p=r({inputs:a.slice(0,f),backend:i}),m=r({inputs:a.slice(f),backend:i});return r({inputs:[p,m],backend:i})}const o=a.map(f=>f.dtype).reduce((f,p)=>di(f,p)),u=a.map(f=>f.shape),h=de().getBool("WEBGL_PACK")?new cN(a[0].shape,u):new lN(a[0].shape,u);return i.runWebGLProgram(h,a,o)}},hN={kernelName:_a,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i,h=a.shape.length,f=lr(o,a.shape);let p=f;const m=vs(p,h);let y=a;null!=m&&(y=$o({inputs:{x:a},backend:n,attrs:{perm:m}}),p=Ai(p.length,h)),zs("all",p,h);const[b,T]=sa(y.shape,p),R=Gn({inputs:{x:y},backend:n,attrs:{shape:[-1,Wt(T)]}}),L=Dm(R,R.dtype,"all",n);let V;return V=Gn(u?{inputs:{x:L},backend:n,attrs:{shape:Ni(b,f)}}:{inputs:{x:L},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(L),null!=m&&n.disposeIntermediateTensorInfo(y),V}},dN={kernelName:Pa,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i,h=a.shape.length,f=lr(o,a.shape);let p=f;const m=vs(p,h);let y=a;null!=m&&(y=$o({inputs:{x:a},backend:n,attrs:{perm:m}}),p=Ai(p.length,h)),zs("any",p,h);const[b,T]=sa(y.shape,p),R=Gn({inputs:{x:y},backend:n,attrs:{shape:[-1,Wt(T)]}}),L=Dm(R,R.dtype,"any",n);let V;return V=Gn(u?{inputs:{x:L},backend:n,attrs:{shape:Ni(b,f)}}:{inputs:{x:L},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(L),null!=m&&n.disposeIntermediateTensorInfo(y),V}};class pN{constructor(t,n,i){this.variableNames=["A"];const{windowSize:a,batchSize:o,outSize:u}=t;i||this.variableNames.push("bestIndicesA"),this.outputShape=[o,u],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${a}; i++) {\n          int inIdx = ${i?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===n?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class fN{constructor(t,n,i,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Z(t.length>2,()=>`Packed arg${i.charAt(0).toUpperCase()+i.slice(1)} supports only inputs with rank above 2.`);const u=Math.ceil(t[t.length-1]/n);this.outputShape=t.slice(0,-1),u>1&&this.outputShape.push(u),a||this.variableNames.push("bestIndicesA");const h=this.outputShape,f=h.length,p=ns(f),m=zo("coords",f);let y,b;if(1===u){b=f+1;const Nt=ns(b);y=`\n        ${Nt} sourceLocR = ${Nt}(${m.join()}, 0);\n        ++${m[f-1]};\n        ${Nt} sourceLocG = ${Nt}(${m.join()}, 0);\n        ++${m[f-2]};\n        ${Nt} sourceLocA = ${Nt}(${m.join()}, 0);\n        --${m[f-1]};\n        ${Nt} sourceLocB = ${Nt}(${m.join()}, 0);\n        --${m[f-2]};`}else b=f,y=`\n        ${p} sourceLocR = coords;\n        ++${m[f-1]};\n        ${p} sourceLocG = coords;\n        ++${m[f-2]};\n        ${p} sourceLocA = coords;\n        --${m[f-1]};\n        ${p} sourceLocB = coords;\n        --${m[f-2]};`;const T=["x","y","z","w","u","v"].slice(0,b),R="."+T[b-1],L=T.map(Nt=>"int "+Nt),V=zo("sourceLocR",b-1).concat("inIdx.r"),j=zo("sourceLocG",b-1).concat("inIdx.g"),H=zo("sourceLocB",b-1).concat("inIdx.b"),nt=zo("sourceLocA",b-1).concat("inIdx.a"),dt="max"===i?"greaterThan":"lessThan",yt=a?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${V.join()}),\n                             getBestIndicesAChannel(${j.join()}),\n                             getBestIndicesAChannel(${H.join()}),\n                             getBestIndicesAChannel(${nt.join()})));`,kt=`vec4(\n            getAChannel(${V.join()}),\n            hasNextCol ? getAChannel(${j.join()}) : 0.,\n            hasNextRow ? getAChannel(${H.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${nt.join()}) : 0.)`,Ot=a?"":`\n      float getBestIndicesAChannel(${L.join()}) {\n        return getChannel(getBestIndicesA(${T.join()}),\n                                          vec2(${T.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${L.join()}) {\n        return getChannel(getA(${T.join()}),\n                               vec2(${T.slice(-2).join()}));\n      }\n      ${Ot}\n      void main() {\n        ${p} coords = getOutputCoords();\n        bool hasNextCol = ${m[f-1]} < ${h[f-1]-1};\n        bool hasNextRow = ${m[f-2]} < ${h[f-2]-1};\n        ${y}\n        ivec4 srcIdx = ivec4(sourceLocR${R}, sourceLocG${R},\n          sourceLocB${R}, sourceLocA${R}) * ${n};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${kt};\n\n        for (int i = 0; i < ${n}; i++) {\n          inIdx = srcIdx;\n          ${yt}\n          vec4 candidate = ${kt};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${dt}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function pI(r,t,n,i=null){let a=t.shape[0],o=t.shape[1];null!=i&&(a=i.shape[0],o=i.shape[1]);const u=Tc(o),h={windowSize:u,inSize:o,batchSize:a,outSize:Math.ceil(o/u)},f=new pN(h,n,null==i),p=[t];null!=i&&p.push(i);const m=r.runWebGLProgram(f,p,"int32");if(1===m.shape[1])return m;const y=pI(r,t,n,m);return r.disposeIntermediateTensorInfo(m),y}function fI(r,t,n,i=null){const a=null!=i?i.shape:t.shape,o=Tc(a[a.length-1]),u=new fN(a,o,n,null==i),f=r.runWebGLProgram(u,null==i?[t]:[t,i],"int32");if(f.shape.length===t.shape.length){const p=fI(r,t,n,f);return r.disposeIntermediateTensorInfo(f),p}return f}function mI(r,t,n,i){const a=[n];if(zs("arg"+i.charAt(0).toUpperCase()+i.slice(1),a,t.shape.length),!de().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const o=[],u=r.texData.get(t.dataId);let h=t;null!==u&&u.isPacked&&(h=r.unpackTensor(t),o.push(h));const[f,p]=sa(h.shape,a),m=Wt(p),y=Gn({inputs:{x:h},backend:r,attrs:{shape:[-1,m]}});o.push(y);const b=pI(r,y,i);o.push(b);const T=Gn({inputs:{x:b},backend:r,attrs:{shape:f}});return o.forEach(R=>r.disposeIntermediateTensorInfo(R)),T}return fI(r,t,i)}const mN={kernelName:Ys,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o}=i;let u=lr(o,a.shape);const h=vs(u,a.shape.length);let f=a;const p=[];null!=h&&(f=$o({inputs:{x:a},backend:n,attrs:{perm:h}}),p.push(f),u=Ai(u.length,f.shape.length)),zs("argMax",[u[0]],f.shape.length);const m=mI(n,f,u[0],"max");return p.forEach(y=>n.disposeIntermediateTensorInfo(y)),m}},gN={kernelName:Ks,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o}=i;let u=lr(o,a.shape);const h=vs(u,a.shape.length);let f=a;const p=[];null!=h&&(f=$o({inputs:{x:a},backend:n,attrs:{perm:h}}),p.push(f),u=Ai(u.length,f.shape.length)),zs("argMin",[u[0]],f.shape.length);const m=mI(n,f,u[0],"min");return p.forEach(y=>n.disposeIntermediateTensorInfo(y)),m}},AN=bi({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),yN={kernelName:Ka,backendName:"webgl",kernelFunc:AN},vN=bi({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),bN={kernelName:oi,backendName:"webgl",kernelFunc:vN},xN=bi({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),wN={kernelName:Ol,backendName:"webgl",kernelFunc:xN},EN=uo({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),CN={kernelName:Li,backendName:"webgl",kernelFunc:EN},IN=bi({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),SN={kernelName:Go,backendName:"webgl",kernelFunc:IN};class o1{constructor(t,n,i,a=!1,o=!1){if(this.variableNames=["x"],"avg"===n&&i)throw new Error("Cannot compute positions for average pool.");const u=t.filterWidth,h=t.strideHeight,f=t.strideWidth,p=t.dilationHeight,m=t.dilationWidth,y=t.effectiveFilterHeight,b=t.effectiveFilterWidth,T=t.padInfo.top,R=t.padInfo.left;this.outputShape=t.outShape;const L="avg"===n;let H="0.0";if(L||(H="-1.0 / 1e-20"),i)return void(this.userCode=`\n        const ivec2 strides = ivec2(${h}, ${f});\n        const ivec2 pads = ivec2(${T}, ${R});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${y};\n              wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${b};\n                wC += ${m}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${a?o?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${b} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let nt=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===n&&(nt="avgValue / count");const dt=4*Math.floor(u/4),yt=u%4,kt=`\n      if (${L}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${h}, ${f});\n      const ivec2 pads = ivec2(${T}, ${R});\n      const float initializationValue = ${H};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${H});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${y};\n            wR += ${p}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${dt}; wC += 4) {\n            int xC = xCCorner + wC * ${m};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${m}, d),\n              getValue(batch, xR, xC + 2 * ${m}, d),\n              getValue(batch, xR, xC + 3 * ${m}, d)\n            );\n\n            ${kt}\n          }\n\n          int xC = xCCorner + ${dt};\n          if (${1===yt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${kt}\n          } else if (${2===yt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${m}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${kt}\n          } else if (${3===yt}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${m}, d),\n              getValue(batch, xR, xC + 2 * ${m}, d),\n              initializationValue\n            );\n\n            ${kt}\n          }\n        }\n        setOutput(${nt});\n      }\n    `}}class BE{constructor(t,n,i,a=!1,o=!1){if(this.variableNames=["x"],"avg"===n&&i)throw new Error("Cannot compute positions for average pool.");const u=t.filterWidth,h=t.strideDepth,f=t.strideHeight,p=t.strideWidth,m=t.dilationDepth,y=t.dilationHeight,b=t.dilationWidth,T=t.effectiveFilterDepth,R=t.effectiveFilterHeight,L=t.effectiveFilterWidth,V=t.padInfo.front,j=t.padInfo.top,H=t.padInfo.left;this.outputShape=t.outShape;const nt="avg"===n;let dt="0.0";if(nt||(dt="-1.0 / 1e-20"),i)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${h}, ${f}, ${p});\n        const ivec3 pads = ivec3(${V}, ${j}, ${H});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${T};\n              wD += ${m}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${R};\n                wR += ${y}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${L};\n                  wC += ${b}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${a?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${R} * ${L} +\n                      wR * ${L} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let yt=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===n&&(yt="avgValue / count");const kt=4*Math.floor(u/4),Ot=u%4,Nt=`\n      if (${nt}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${h}, ${f}, ${p});\n      const ivec3 pads = ivec3(${V}, ${j}, ${H});\n      const float initializationValue = ${dt};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${dt});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${T};\n            wD += ${m}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${R};\n            wR += ${y}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${kt}; wC += 4) {\n              int xC = xCCorner + wC * ${b};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${b}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${b}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${b}, ch)\n              );\n\n              ${Nt}\n            }\n\n            int xC = xCCorner + ${kt};\n            if (${1===Ot}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${Nt}\n            } else if (${2===Ot}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${b}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${Nt}\n            } else if (${3===Ot}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${b}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${b}, ch),\n                initializationValue\n              );\n\n              ${Nt}\n            }\n          }\n          setOutput(${yt});\n        }\n      }\n    `}}const MN={kernelName:K,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t;i1(a,"avgPool");const{filterSize:o,strides:u,pad:h,dimRoundingMode:f}=i;Z(Na(u,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`);const p=el(a.shape,o,u,1,h,f);if(1===p.filterWidth&&1===p.filterHeight&&We(p.inShape,p.outShape))return Ll({inputs:{x:a},backend:n});const m=new o1(p,"avg",!1);return n.runWebGLProgram(m,[a],"float32")}},TN={kernelName:It,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{filterSize:o,strides:u,pad:h,dimRoundingMode:f,dataFormat:p}=i,m=yc(a.shape,o,u,[1,1,1],h,f,p),y=new BE(m,"avg",!1);return n.runWebGLProgram(y,[a],"float32")}};class _N{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const f=t.effectiveFilterHeight,p=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${f-1-t.padInfo.top}, ${p-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${f};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${p};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class kN{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const y=t.effectiveFilterDepth,b=t.effectiveFilterHeight,T=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${y-1-t.padInfo.front}, ${b-1-t.padInfo.top}, ${T-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${y};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${b};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${T};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const RN={kernelName:Mt,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,input:o}=t,u=o,{filterSize:h,strides:f,pad:p,dimRoundingMode:m}=i,y=yc(u.shape,h,f,[1,1,1],p,m),b=new kN(y);return n.runWebGLProgram(b,[a],u.dtype)}},BN={kernelName:mt,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,input:o}=t,u=o;i1([a,o],"avgPoolGrad");const{filterSize:h,strides:f,pad:p}=i,m=el(u.shape,h,f,1,p),y=new _N(m);return n.runWebGLProgram(y,[a],u.dtype)}},NN={kernelName:Gt,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{a,b:o}=t,{transposeA:u,transposeB:h}=i;return xb({a,b:o,transposeA:u,transposeB:h,backend:n})}};class DN{constructor(t,n,i,a,o,u){this.outputShape=[],this.variableNames=["x","mean","variance"],Nr(t,n),Nr(t,i);let h="0.0";null!=a&&(Nr(t,a),this.variableNames.push("offset"),h="getOffsetAtOutCoords()");let f="1.0";null!=o&&(Nr(t,o),this.variableNames.push("scale"),f="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${h};\n        float scale = ${f};\n        float inv = scale * inversesqrt(variance + float(${u}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class LN{constructor(t,n,i,a,o,u){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Nr(t,n),Nr(t,i);let h="vec4(0.0)";null!=a&&(Nr(t,a),this.variableNames.push("offset"),h="getOffsetAtOutCoords()");let f="vec4(1.0)";null!=o&&(Nr(t,o),this.variableNames.push("scale"),f="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${h};\n        vec4 scale = ${f};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${u}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const FN={kernelName:zc,backendName:"webgl",kernelFunc:({inputs:r,backend:t,attrs:n})=>{const{x:i,mean:a,variance:o,offset:u,scale:h}=r;Z(a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Z(null==u||a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Z(null==h||a.shape.length===h.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:f}=n;null==f&&(f=.001);const p=[i,a,o];let m=null;null!=u&&(m=u.shape,p.push(u));let y=null;null!=h&&(y=h.shape,p.push(h));const b=de().getBool("WEBGL_PACK_NORMALIZATION")?new LN(i.shape,a.shape,o.shape,m,y,f):new DN(i.shape,a.shape,o.shape,m,y,f);return t.runWebGLProgram(b,p,p[0].dtype)}};class ON{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const n=ns(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const i=function(o){if(1===o)return"sourceLoc";if(o<=6)return NE.slice(0,o).map(u=>"sourceLoc."+u).join(",");throw Error(`Slicing for rank ${o} is not yet supported`)}(this.rank);let a;a=`\n        ${n} sourceLoc;\n        ${n} coords = getOutputCoords();\n        ${t.map((o,u)=>`sourceLoc.${NE[u]} = start[${u}] + coords.${NE[u]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${a}\n        setOutput(getSource(${i}));\n      }\n    `}}const NE=["x","y","z","w","u","v"];class PN{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=ns(this.rank),i=zo("coords",this.rank),a=zo("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${a.slice(-2).join()})`,u=`getChannel(getSource(${a.join()}), ${o})`,h=`\n      result.x = ${u};\n      if (++${i[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${a[this.rank-1]};\n        result.y = ${u};\n        --${a[this.rank-1]};\n      }\n    `,f=1===this.rank?"":`\n      --${i[this.rank-1]};\n      if (++${i[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${a[this.rank-2]};\n        result.z = ${u};\n        if (++${i[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${a[this.rank-1]};\n          result.w = ${u};\n        }\n      }\n    `,p=this.rank<=4?`sourceLoc = coords +\n            ${n}(${t.map((m,y)=>`start[${y}]`).join()});`:t.map((m,y)=>`${a[y]} = ${i[y]} + start[${y}];`).join("\n");this.userCode=`\n      void main() {\n        ${n} coords = getOutputCoords();\n        ${n} sourceLoc;\n        ${p}\n        vec4 result = vec4(0.);\n        ${h}\n        ${f}\n        setOutput(result);\n      }\n    `}}function WA(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{begin:o,size:u}=i,[h,f]=og(a,o,u);if(sg(a,h,f),0===Wt(f))return n.makeTensorInfo(f,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){const y=n.texData.get(a.dataId),b=SB(y.values,h,f,a.shape,a.dtype);return n.makeTensorInfo(f,a.dtype,b)}const{isPacked:p}=n.texData.get(a.dataId),m=f0(a.shape,h,f);if(p||!m){const y=de().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PN(f):new ON(f);return n.runWebGLProgram(y,[a],a.dtype,[h])}return n.uploadToGPU(a.dataId),function(y,b,T,R){const L=R.texData.get(y.dataId),V=R.makeTensorInfo(T,y.dtype),j=R.texData.get(V.dataId);Object.assign(j,L),j.refCount=1,j.shape=T,j.dtype=y.dtype;let H=m0(b,gn(y.shape));L.slice&&(H+=L.slice.flatOffset),j.slice={flatOffset:H,origDataId:L.slice&&L.slice.origDataId||y.dataId};const nt=R.dataRefCount.get(j.slice.origDataId)||1;return R.dataRefCount.set(j.slice.origDataId,nt+1),V}(a,h,f,n)}const UN={kernelName:cc,backendName:"webgl",kernelFunc:WA},zN={kernelName:Xt,backendName:"webgl",kernelFunc:r=>{const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{blockShape:o,crops:u}=i;Z(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const h=o.reduce((H,nt)=>H*nt),f=Fp(a.shape,o,h),p=Op(f.length,o.length),m=nc(a.shape,o,h),y=qg(u,o.length),b=sy(m,u,o.length),T=[],R=Gn({inputs:{x:a},backend:n,attrs:{shape:f}}),L=$o({inputs:{x:R},backend:n,attrs:{perm:p}}),V=Gn({inputs:{x:L},backend:n,attrs:{shape:m}}),j=WA({inputs:{x:V},backend:n,attrs:{begin:y,size:b}});return T.push(R),T.push(L),T.push(V),T.forEach(H=>n.disposeIntermediateTensorInfo(H)),j}},$N={kernelName:Me,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,weights:o}=t,{size:u}=i,h=n.readSync(a.dataId),f=n.readSync(o.dataId),p=qC(h,f,o.dtype,o.shape,u);return n.makeTensorInfo([u],o.dtype,p)}},VN={kernelName:un,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{s0:i,s1:a}=t,o=n.readSync(i.dataId),u=n.readSync(a.dataId),h=Nr(Array.from(o),Array.from(u));return n.makeTensorInfo([h.length],"int32",Int32Array.from(h))}},gI=uo({opSnippet:"return float(a != b);",cpuKernelImpl:xB,dtype:"bool"}),GN={kernelName:Vc,backendName:"webgl",kernelFunc:gI};function l1(r){const{inputs:t,backend:n}=r,{input:i}=t;return Ll({inputs:{x:n.texData.get(i.dataId).complexTensorInfos.real},backend:n})}const QN={kernelName:Ye,backendName:"webgl",kernelFunc:l1},HN={kernelName:Ie,backendName:"webgl",kernelFunc:function r(t){const{inputs:n,backend:i,attrs:a}=t,{x:o}=n,{dtype:u}=a;if("complex64"===u){if("complex64"===o.dtype)return Ll({inputs:{x:o},backend:i});const h=$s(o.shape),f=r({inputs:{x:o},backend:i,attrs:{dtype:"float32"}}),p=Yp({inputs:{real:f,imag:h},backend:i});return h.dispose(),i.disposeIntermediateTensorInfo(f),p}if("complex64"===o.dtype){const h=l1({inputs:{input:o},backend:i}),f=r({inputs:{x:h},backend:i,attrs:{dtype:u}});return i.disposeIntermediateTensorInfo(h),f}if(!tn(o.dtype,u)){const h=Ll({inputs:{x:o},backend:i});return{dataId:h.dataId,shape:h.shape,dtype:u}}if("int32"===u)return function(h,f){const p=new xd(h.shape,"return float(int(x));"),m=f.runWebGLProgram(p,[h],"int32");return{dataId:m.dataId,shape:m.shape,dtype:m.dtype}}(o,i);if("bool"===u){const h=i.makeTensorInfo([],"bool",Ut("bool",1)),f=gI({inputs:{a:o,b:h},backend:i});return i.disposeIntermediateTensorInfo(h),f}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${u}`)}},AI="return ceil(x);",WN=bi({opSnippet:AI,packedOpSnippet:AI,cpuKernelImpl:nB}),jN={kernelName:Be,backendName:"webgl",kernelFunc:WN};class qN{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class XN{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const YN={kernelName:Pn,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{clipValueMin:o,clipValueMax:u}=i;let h;return h=de().getBool("WEBGL_PACK_CLIP")?new XN(a.shape):new qN(a.shape),n.runWebGLProgram(h,[a],a.dtype,[[o],[u]])}};class KN{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function yI(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}const JN={kernelName:dr,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{x:i}=t,a=n.texData.get(i.dataId),o=new KN(i.shape),u=[yI(i,a.complexTensorInfos.real),yI(i,a.complexTensorInfos.imag)];return n.runWebGLProgram(o,u,u[0].dtype)}};class ZN{constructor(t){this.outputShape=[],this.outputShape=ec(t,1),this.variableNames=t.map((u,h)=>`T${h}`);const n=new Array(t.length-1);n[0]=t[0][1];for(let u=1;u<n.length;u++)n[u]=n[u-1]+t[u][1];const i=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let u=1;u<n.length;u++)i.push(`else if (yC < ${n[u]}) setOutput(getT${u}(yR, yC-${n[u-1]}));`);i.push(`else setOutput(getT${n.length}(yR, yC-${n[n.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${i.join("\n        ")}\n      }\n    `}}class tD{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ec(t,n);const i=this.outputShape,a=i.length,o=ns(a),u=zo("coords",a),h=["x","y","z","w","u","v"].slice(0,a);this.variableNames=t.map((L,V)=>`T${V}`);const f=new Array(t.length-1);f[0]=t[0][n];for(let L=1;L<f.length;L++)f[L]=f[L-1]+t[L][n];const p=h[n],m=h.slice(-2),y=h.join();let b=`if (${p} < ${f[0]}) {\n        return getChannel(\n            getT0(${y}), vec2(${m.join()}));\n        }`;for(let L=1;L<f.length;L++){const V=f[L-1];b+=`\n        if (${p} < ${f[L]}  && ${p} >= ${f[L-1]}) {\n          return getChannel(\n            getT${L}(${wb(h,p,V)}),\n            vec2(${wb(m,p,V)}));\n        }`}const R=f[f.length-1];b+=`\n        return getChannel(\n          getT${f.length}(${wb(h,p,R)}),\n          vec2(${wb(m,p,R)}));`,this.userCode=`\n      float getValue(${h.map(L=>"int "+L)}) {\n        ${b}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${u}), 0., 0., 0.);\n\n        ${u[a-1]} = ${u[a-1]} + 1;\n        if (${u[a-1]} < ${i[a-1]}) {\n          result.g = getValue(${u});\n        }\n\n        ${u[a-2]} = ${u[a-2]} + 1;\n        if (${u[a-2]} < ${i[a-2]}) {\n          result.a = getValue(${u});\n        }\n\n        ${u[a-1]} = ${u[a-1]} - 1;\n        if (${u[a-2]} < ${i[a-2]} &&\n            ${u[a-1]} < ${i[a-1]}) {\n          result.b = getValue(${u});\n        }\n        setOutput(result);\n      }\n    `}}function wb(r,t,n){const i=r.indexOf(t);return r.map((a,o)=>o===i?`${a} - ${n}`:a).join()}function Eb(r){const{inputs:t,backend:n}=r,{input:i}=t;return Ll({inputs:{x:n.texData.get(i.dataId).complexTensorInfos.imag},backend:n})}const eD={kernelName:Pm,backendName:"webgl",kernelFunc:Eb};function jA(r,t,n){const i=r[0].dtype;if("complex64"===i){const m=r.map(L=>l1({inputs:{input:L},backend:n})),y=r.map(L=>Eb({inputs:{input:L},backend:n})),b=jA(m,t,n),T=jA(y,t,n),R=Yp({inputs:{real:b,imag:T},backend:n});return m.forEach(L=>n.disposeIntermediateTensorInfo(L)),y.forEach(L=>n.disposeIntermediateTensorInfo(L)),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(T),R}let a=n.shouldExecuteOnCPU(r);if("string"===i&&(a=!0),a){const m=r.map(j=>{const H=Wt(j.shape.slice(t));return Gn({inputs:{x:j},backend:n,attrs:{shape:[-1,H]}})}),y=m.map(j=>({vals:n.readSync(j.dataId),shape:j.shape})),b=ec(m.map(j=>j.shape),1),R=rB(y,b,i,1===m[0].shape[0]),L=ec(r.map(j=>j.shape),t),V=n.makeTensorInfo(L,i,R);return m.forEach(j=>n.disposeIntermediateTensorInfo(j)),V}if(r.length>de().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const m=Math.floor(r.length/2),y=jA(r.slice(0,m),t,n),b=jA(r.slice(m),t,n),T=jA([y,b],t,n);return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),T}if(de().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){const m=new tD(r.map(y=>y.shape),t);return n.runWebGLProgram(m,r,i)}const{tensors2D:o,outShape:u}=function(m,y,b){const T=ec(m.map(R=>R.shape),y);return{tensors2D:m.map(R=>Gn({inputs:{x:R},attrs:{shape:[-1,Wt(R.shape.slice(y))]},backend:b})),outShape:T}}(r,t,n),h=new ZN(o.map(m=>m.shape)),f=n.runWebGLProgram(h,o,i);o.forEach(m=>n.disposeIntermediateTensorInfo(m));const p=Gn({inputs:{x:f},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(f),p}function vI(r){const{inputs:t,backend:n,attrs:i}=r,{axis:a}=i,o=lr(a,t[0].shape)[0],u=ec(t.map(f=>f.shape),o);if(0===Wt(u))return n.makeTensorInfo(u,t[0].dtype,[]);const h=t.filter(f=>Wt(f.shape)>0);return 1===h.length?Ll({inputs:{x:h[0]},backend:n}):(ry(h.map(f=>f.shape),o),jA(h,o,n))}const nD={kernelName:Ar,backendName:"webgl",kernelFunc:vI};class bI{constructor(t,n=!1,i=null,a=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const u=t.padInfo.top,h=t.padInfo.left,f=t.strideHeight,p=t.strideWidth,m=t.dilationHeight,y=t.dilationWidth,b=t.filterHeight,T=t.filterWidth,R=4*Math.floor(t.inChannels/4),L=t.inChannels%4,V="channelsLast"===t.dataFormat,j=V?1:2,H=V?2:3,nt=V?3:1;let dt="",yt="";i&&(dt=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`\n          float activation(float x) {\n            ${i}\n          }\n        `,yt="result = activation(result);");const kt=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${dt}\n\n      const ivec2 strides = ivec2(${f}, ${p});\n      const ivec2 pads = ivec2(${u}, ${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${nt}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${j}], coords[${H}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${b}; wR++) {\n          int xR = xRCorner + wR * ${m};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${T}; wC++) {\n            int xC = xCCorner + wC * ${y};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${R}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${V}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===L}) {\n\n              if (${V}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${R}) *\n                    getW(wR, wC, ${R}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${R}, xR, xC) *\n                    getW(wR, wC, ${R}, d2);\n              }\n\n            } else if (${2===L}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${R}, d2),\n                getW(wR, wC, ${R} + 1, d2)\n              );\n\n              if (${V}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${R}),\n                  getX(batch, xR, xC, ${R} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${R}, xR, xC),\n                  getX(batch, ${R} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===L}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${R}, d2),\n                getW(wR, wC, ${R} + 1, d2),\n                getW(wR, wC, ${R} + 2, d2)\n              );\n\n              if (${V}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${R}),\n                  getX(batch, xR, xC, ${R} + 1),\n                  getX(batch, xR, xC, ${R} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${R}, xR, xC),\n                  getX(batch, ${R} + 1, xR, xC),\n                  getX(batch, ${R} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${kt}\n        ${yt}\n        setOutput(result);\n      }\n    `}}class rD{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const n=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left,o=t.strideDepth,u=t.strideHeight,h=t.strideWidth,f=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,y=t.filterDepth,b=t.filterHeight,T=t.filterWidth,R=4*Math.floor(t.inChannels/4),L=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${u}, ${h});\n      const ivec3 pads = ivec3(${n}, ${i}, ${a});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${y}; wF++) {\n          int xF = xFCorner + wF * ${f};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${b}; wR++) {\n            int xR = xRCorner + wR * ${p};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${T}; wC++) {\n              int xC = xCCorner + wC * ${m};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${R}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===L}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${R}) *\n                  getW(wF, wR, wC, ${R}, d2);\n              } else if (${2===L}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${R}),\n                  getX(batch, xF, xR, xC, ${R} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${R}, d2),\n                  getW(wF, wR, wC, ${R} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===L}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${R}),\n                  getX(batch, xF, xR, xC, ${R} + 1),\n                  getX(batch, xF, xR, xC, ${R} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${R}, d2),\n                  getW(wF, wR, wC, ${R} + 1, d2),\n                  getW(wF, wR, wC, ${R} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class iD{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ul(this.outputShape.length);const{dataFormat:i}=n,a=Uo(),o="channelsLast"===i,u=o?0:1,h=o?1:2,f=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${t[1]} && pos < ${t[0]}) {`;let p="";for(let m=0;m<=1;m++)for(let y=0;y<=1;y++)p+=`\n          blockIndex = rc.y + ${y};\n          pos = rc.x + ${m};\n\n          ${f}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${u}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${h}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*m+y}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*m+y}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${p}\n\n        ${a.output} = result;\n      }\n    `}}function xI({x:r,filter:t,convInfo:n,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:h=null}){const f=r.shape,p=i.texData.get(r.dataId),T="channelsLast"===n.dataFormat;let R;const L=[];if((1!=f[0]*f[1]*f[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&p.isPacked&&T&&null!=p.texture&&f[2]%2!=0&&We(p.shape.slice(-3),f.slice(-3))){const j={dataId:r.dataId,shape:[1,f[0]*f[1]*(f[2]+1),n.inChannels],dtype:r.dtype},H=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,Z(mb(p.shape,j.shape),()=>`packed reshape ${p.shape} to ${j.shape} isn't free`);const nt=Gn({inputs:{x:t},backend:i,attrs:{shape:[1,n.inChannels,n.outChannels]}});L.push(nt);const dt=xb({a:j,b:nt,backend:i,transposeA:!1,transposeB:!1,bias:a,activation:h,preluActivationWeights:o,leakyreluAlpha:u}),yt=i.texData.get(dt.dataId);Z(yt.isPacked,()=>"batchMatMul result is expected to be packed"),p.shape=H,yt.shape=n.outShape,R=Ll({inputs:{x:dt},backend:i}),R.shape=n.outShape,L.push(dt)}else{const V=Gn({inputs:{x:r},backend:i,attrs:{shape:[1,T?f[0]*f[1]*f[2]:f[0]*f[2]*f[3],n.inChannels]}}),j=Gn({inputs:{x:t},backend:i,attrs:{shape:[1,n.inChannels,n.outChannels]}}),H=xb({a:V,b:j,transposeA:!1,transposeB:!1,backend:i,bias:a,activation:h,preluActivationWeights:o,leakyreluAlpha:u});R=Gn({inputs:{x:H},backend:i,attrs:{shape:n.outShape}}),L.push(V),L.push(j),L.push(H)}for(const V of L)i.disposeIntermediateTensorInfo(V);return R}function wI({x:r,filter:t,convInfo:n,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:h=null}){const{filterWidth:f,filterHeight:p,inChannels:m,outWidth:y,outHeight:b,dataFormat:T}=n,R="channelsLast"===T,L=f*p*m,V=b*y,j=[L,V],H=[],nt=Gn({inputs:{x:r},backend:i,attrs:{shape:r.shape.slice(1)}}),dt=Gn({inputs:{x:t},backend:i,attrs:{shape:[1,L,Wt(t.shape)/L]}});H.push(nt),H.push(dt);const yt=new iD(j,n),Ot=i.runWebGLProgram(yt,[nt],"float32",[nt.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]]),Nt=Gn({inputs:{x:Ot},backend:i,attrs:{shape:[1,j[0],j[1]]}});H.push(Ot),H.push(Nt);const Vt=null!=a,qt=null!=o,Zt="leakyrelu"===h,te=h?yb(h,!0):null,ue=new oI(Nt.shape,dt.shape,[1,V,n.outChannels],!0,!1,Vt,te,qt,Zt),Ee=[Nt,dt];if(a&&Ee.push(a),qt&&Ee.push(o),Zt){const Te=i.makeTensorInfo([],"float32",Kc(u,"float32"));Ee.push(Te),H.push(Te)}const De=i.runWebGLProgram(ue,Ee,"float32"),we=Gn({inputs:{x:De},backend:i,attrs:{shape:R?[1,b,y,n.outChannels]:[1,n.outChannels,b,y]}});H.push(De);for(const Te of H)i.disposeIntermediateTensorInfo(Te);return we}const sD={kernelName:xr,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o}=t,{strides:u,pad:h,dataFormat:f,dilations:p,dimRoundingMode:m}=i,y=uu(f),b=ra(a.shape,o.shape,u,p,h,m,!1,y);let T;if(1!==b.filterHeight||1!==b.filterWidth||1!==b.dilationHeight||1!==b.dilationWidth||1!==b.strideHeight||1!==b.strideWidth||"SAME"!==b.padInfo.type&&"VALID"!==b.padInfo.type)if(de().getBool("WEBGL_CONV_IM2COL")&&1===a.shape[0])T=wI({x:a,filter:o,convInfo:b,backend:n});else{const L=new bI(b);T=n.runWebGLProgram(L,[a,o],"float32")}else T=xI({x:a,filter:o,convInfo:b,backend:n});const R=Gn({inputs:{x:T},backend:n,attrs:{shape:b.outShape}});return n.disposeIntermediateTensorInfo(T),R}};class aD{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class oD{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,i=t.filterWidth,u="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${n-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${u?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${u?1:2}], coords[${u?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${i} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${u}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class lD{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class cD{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterDepth,i=t.filterHeight,a=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${n-1-t.padInfo.front}, ${i-1-t.padInfo.top}, ${a-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${n}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${n} - 1 - wF;\n\n          for (int wR = 0; wR < ${i}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${i} - 1 - wR;\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${a} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const uD={kernelName:_r,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,dy:o}=t,{strides:u,pad:h,dataFormat:f,dimRoundingMode:p,filterShape:m}=i,y=uu(f),b=ra(a.shape,m,u,1,h,p,!1,y),T=new aD(b);return n.runWebGLProgram(T,[a,o],"float32")}},hD={kernelName:Pr,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,filter:o}=t,{inputShape:u,strides:h,pad:f,dataFormat:p,dimRoundingMode:m}=i,y=uu(p),b=ra(u,o.shape,h,1,f,m,!1,y),T=new oD(b);return n.runWebGLProgram(T,[a,o],"float32")}},dD={kernelName:ui,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o}=t,{strides:u,pad:h,dilations:f}=i,p=Xu(a.shape,o.shape,u,f,h),m=new rD(p);return n.runWebGLProgram(m,[a,o],"float32")}},pD={kernelName:us,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,dy:o}=t,{strides:u,pad:h,filterShape:f}=i,p=Xu(a.shape,f,u,1,h),m=new lD(p);return n.runWebGLProgram(m,[a,o],"float32")}},fD={kernelName:Fi,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,filter:o}=t,{pad:u,strides:h,inputShape:f}=i,p=Xu(f,o.shape,h,1,u),m=new cD(p);return n.runWebGLProgram(m,[a,o],"float32")}},mD=bi({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),gD={kernelName:rs,backendName:"webgl",kernelFunc:mD},AD=bi({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),yD={kernelName:Ts,backendName:"webgl",kernelFunc:AD};class vD{constructor(t,n,i,a,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[u,h,f,p]=t,[m]=n,[y,b]=i;this.outputShape=[m,y,b,p];const T="bilinear"===a?1:0,[R,L]=[h-1+".0",f-1+".0"],[V,j,H]=y>1?[""+(h-1)/(y-1),"(y2-y1) * height_ratio",`y1*${R} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${R}`],[nt,dt,yt]=b>1?[""+(f-1)/(b-1),"(x2-x1) * width_ratio",`x1*${L} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${L}`];this.userCode=`\n      const float height_ratio = float(${V});\n      const float width_ratio = float(${nt});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${u}) {\n          return;\n        }\n\n        float height_scale = ${j};\n        float width_scale = ${dt};\n\n        float in_y = ${H};\n        if( in_y < 0.0 || in_y > ${R} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${yt};\n        if( in_x < 0.0 || in_x > ${L} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${T} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const bD={kernelName:hs,backendName:"webgl",kernelFunc:r=>{const{inputs:t,backend:n,attrs:i}=r,{image:a,boxes:o,boxInd:u}=t,{cropSize:h,method:f,extrapolationValue:p}=i,m=new vD(a.shape,o.shape,h,f,p);return n.runWebGLProgram(m,[a,o,u],"float32")}};class EI{constructor(t,n,i){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;const a=t.length,o=n?"0.0":`getX(${CI(a,"coords")})`,u=t[t.length-1];let h="",f="";n?(h=i?"end != "+(u-1):"end != 0",f=i?"end + 1":"end - 1"):(h=i?`end + pow2 < ${u}`:"end >= pow2",f=i?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${ns(a)} coords = getOutputCoords();\n        int end = ${II(a,"coords")};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${h}) {\n          int idx = ${f};\n          ${II(a,"coords")} = idx;\n          val += getX(${CI(a,"coords")});\n        }\n        setOutput(val);\n      }\n    `}}function CI(r,t){if(1===r)return`${t}`;if(2===r)return`${t}.x, ${t}.y`;if(3===r)return`${t}.x, ${t}.y, ${t}.z`;if(4===r)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function II(r,t){if(1===r)return`${t}`;if(2===r)return`${t}.y`;if(3===r)return`${t}.z`;if(4===r)return`${t}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}const xD={kernelName:Js,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,exclusive:u,reverse:h}=i,f=a.shape.length,p=vs([o],f);let m=a;null!=p&&(m=$o({inputs:{x:a},backend:n,attrs:{perm:p}}));const y=Ai(1,f)[0];if(y!==f-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${a.shape.length-1} but got axis=${o}`);const b=m.shape[y];let T=Ll({inputs:{x:m},backend:n});for(let R=0;R<=Math.ceil(Math.log2(b))-1;R++){const L=new EI(m.shape,!1,h),j=T;T=n.runWebGLProgram(L,[T],T.dtype,[[R]]),n.disposeIntermediateTensorInfo(j)}if(u){const R=new EI(m.shape,u,h),L=T;T=n.runWebGLProgram(R,[T],T.dtype),n.disposeIntermediateTensorInfo(L)}if(null!=p){const R=$o({inputs:{x:T},backend:n,attrs:{perm:Jh(p)}});return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(m),R}return T}},wD={kernelName:ds,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,weights:o}=t,{size:u,binaryOutput:h}=i;if(1===a.shape.length){const f=n.readSync(a.dataId),p=n.readSync(o.dataId),m=qC(f,p,o.dtype,o.shape,u);return n.makeTensorInfo([u],o.dtype,m)}if(2===a.shape.length){const f=n.bufferSync(a),p=n.bufferSync(o),m=eB(f,p,u,h);return n.makeTensorInfo(m.shape,o.dtype,m.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};class ED{constructor(t,n,i){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=i,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${n};\n      int offset_h = imod(h, ${n});\n      int in_w = w / ${n};\n      int offset_w = imod(w, ${n});\n      int offset_d = (offset_h * ${n} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const CD={kernelName:$i,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{blockSize:o,dataFormat:u}=i,h=a.shape[0],f=("NHWC"===u?a.shape[1]:a.shape[2])*o,p=("NHWC"===u?a.shape[2]:a.shape[3])*o,m=("NHWC"===u?a.shape[3]:a.shape[1])/(o*o),y=new ED("NHWC"===u?[h,f,p,m]:[h,m,f,p],o,u);return n.runWebGLProgram(y,[a],a.dtype)}};class SI{constructor(t,n=!1,i=null,a=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ul(this.outputShape.length);const u=t.filterHeight,h=t.filterWidth,f=t.outChannels/t.inChannels;let p="",m="";i&&(p=a?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`\n          float activation(float x) {\n            ${i}\n          }\n        `,m="result = activation(result);");const y=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${f};\n        int q = d2 - d1 * ${f};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${u}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${y}\n        ${m}\n        setOutput(result);\n      }\n    `}}class MI{constructor(t,n=!1,i=null,a=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ul(this.outputShape.length);const u=t.outChannels/t.inChannels,h=t.padInfo.left,f=t.strideWidth,p=t.dilationWidth,m=t.filterHeight,y=t.filterWidth,b=y;let T="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let j=0;j<y;j++)T+=`\n          vec4 xTexelC${2*j};\n          int xTexelC${2*j}Ready;\n          vec4 xTexelC${2*j+1};\n          int xTexelC${2*j+1}Ready;\n          vec4 xC${j};`;T+=`\n    for (int r = 0; r < ${m}; r++) {\n      `;for(let j=0;j<y;j++)T+=`\n          xTexelC${2*j} = vec4(0.0);\n          xTexelC${2*j}Ready = 0;\n          xTexelC${2*j+1} = vec4(0.0);\n          xTexelC${2*j+1}Ready = 0;\n          xC${j} = vec4(0.0);`;T+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let j=0;j<(b+1)/2;j++){const H=2*j;if(T+=`\n          xC = xCCorner + ${H*p};\n          `,1===f){if(H<y&&(h%2==1?(T+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${H}Ready == 0) {\n                  xTexelC${H} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${H}.zw = vec2(0.0);\n                  }\n                  xTexelC${H}Ready = 1;\n                }\n              `,T+=1===p&&H>0?`\n                xC${H} = vec4(xTexelC${H-2}.zw, xTexelC${H}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${H} = vec4(previous.zw, xTexelC${H}.xy);\n                  } else {\n                    xC${H} = vec4(0.0, 0.0, xTexelC${H}.xy);\n                  }\n                  `):T+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${H}Ready == 0) {\n                  xTexelC${H} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${H}.zw = vec2(0.0);\n                  }\n                  xTexelC${H}Ready = 1;\n                }\n\n                xC${H} = xTexelC${H};\n                `,H+1<y)){const nt=h%2==0?se(p):p;p%2==0&&h%2==1||p%2!=0&&h%2!=1?(T+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${nt};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${H+1}Ready == 0) {\n                    xTexelC${H+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${H+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${H+1}Ready = 1;\n                  }\n                  `,p>1&&(T+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${H}Ready == 0) {\n                      xTexelC${H} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${H}Ready = 1;\n                    }\n                    `),T+=`\n                  xC${H+1} = vec4(xTexelC${H}.zw, xTexelC${H+1}.xy);\n                  `):T+=1===nt?`\n                    xC${H+1} = xTexelC${H};\n                    `:`\n                    xCOffset = xC + ${nt};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${H+1}Ready == 0) {\n                      xTexelC${H+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${H+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${H+1}Ready = 1;\n                    }\n\n                    xC${H+1} = xTexelC${H+1};\n                    `}}else H<y&&(h%2==1?(T+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${H}Ready == 0) {\n                  xTexelC${H} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${H}.zw = vec2(0.0);\n                  }\n                  xTexelC${H}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${H+1}Ready == 0) {\n                  xTexelC${H+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${H+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${H+1}Ready = 1;\n                }\n\n                xC${H} = vec4(xTexelC${H}.zw, xTexelC${H+1}.zw);\n              `,H+1<y&&(T+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${H+1} = vec4(xTexelC${H+1}.xy, final.xy);\n                `)):(T+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${H}Ready == 0) {\n                  xTexelC${H} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${H}.zw = vec2(0.0);\n                  }\n                  xTexelC${H}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${H+1}Ready == 0) {\n                  xTexelC${H+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${H+1}.zw = vec2(0.);\n                  }\n                  xTexelC${H+1}Ready = 1;\n                }\n\n                xC${H} = vec4(\n                  xTexelC${H}.xy, xTexelC${H+1}.xy);\n              `,H+1<y&&(T+=`\n                  xC${H+1} = vec4(xTexelC${H}.zw, xTexelC${H+1}.zw);\n                `)));H<y&&(T+=`\n            wTexel = getW(r, ${H}, d1, q);\n            dotProd += xC${H} * vec4(wTexel.xz, wTexel.xz);\n          `,H+1<y&&(T+=`\n              wTexel = getW(r, ${H+1}, d1, q);\n              dotProd += xC${H+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}T+="\n    }\n  ",T+="\n      }\n    ";let R="",L="";i&&(R=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,L="result = activation(result);");const V=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${R}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${u};\n        int q = d2 - d1 * ${u};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${T}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${V}\n        ${L}\n        setOutput(result);\n      }\n    `}}const ID={kernelName:Zs,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o}=t,{strides:u,pad:h,dilations:f,dimRoundingMode:p}=i;let m=f;null==m&&(m=[1,1]),Z(Na(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const y=ra(a.shape,o.shape,u,m,h,p,!0);let b;return b=de().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels==1?new MI(y):new SI(y),n.runWebGLProgram(b,[a,o],"float32",[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]])}};class SD{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class MD{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,i=t.filterWidth,f=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${n-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${i} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${f}; dm++) {\n              int d2 = d1 * ${f} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const TD={kernelName:Qo,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,dy:o}=t,{strides:u,dilations:h,pad:f,dimRoundingMode:p,filterShape:m}=i,y=ra(a.shape,m,u,h,f,p,!0),b=new SD(y);return n.runWebGLProgram(b,[a,o],"float32")}},_D={kernelName:Ja,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,filter:o}=t,{strides:u,dilations:h,pad:f,dimRoundingMode:p,inputShape:m}=i,y=ra(m,o.shape,u,h,f,p,!0),b=new MD(y);return n.runWebGLProgram(b,[a,o],"float32")}};class kD{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const RD={kernelName:Za,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{x:i}=t,a=[...i.shape,...i.shape],o=Wt(i.shape),u=Gn({inputs:{x:i},backend:n,attrs:{shape:[o]}}),h=new kD(o),f=n.runWebGLProgram(h,[u],u.dtype),p=Gn({inputs:{x:f},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(f),p}};class BD{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:n,inWidth:i,padInfo:a,strideHeight:o,strideWidth:u,filterHeight:h,filterWidth:f,dilationHeight:p,dilationWidth:m}=t,{top:y,left:b}=a;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${y}, ${b});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${h}; h++) {\n          int hIn = hBeg + h * ${p};\n\n          if (hIn >= 0 && hIn < ${n}) {\n            for (int w = 0; w < ${f}; w++) {\n              int wIn = wBeg + w * ${m};\n\n              if (wIn >= 0 && wIn < ${i}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const ND={kernelName:Ao,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o}=t,{strides:u,pad:h,dilations:f}=i,p=cp(a.shape,o.shape,u,h,"NHWC",f);let m;const y=new BD(p);m=n.runWebGLProgram(y,[a,o],"float32");const b=Gn({inputs:{x:m},backend:n,attrs:{shape:p.outShape}});return n.disposeIntermediateTensorInfo(m),b}},DD={kernelName:pl,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{equation:a}=i,o=t,{allDims:u,summedDims:h,idDims:f}=cy(a,o.length);uy(u.length,f,o);const{path:p,steps:m}=hy(h,f),y=m.length;let b=null,T=u.length;const R=[];for(let L=0;L<y;++L){for(const V of m[L]){const{permutationIndices:j,expandDims:H}=Zg(T,f[V]);let nt;cm(j)?nt=o[V]:(nt=$o({inputs:{x:o[V]},backend:n,attrs:{perm:j}}),R.push(nt));const dt=nt.shape.slice();for(let yt=0;yt<H.length;++yt)dt.splice(H[yt],0,1);We(nt.shape,dt)||(nt=Gn({inputs:{x:nt},backend:n,attrs:{shape:dt}}),R.push(nt)),null===b?b=nt:(b=RE({inputs:{a:nt,b},backend:n}),R.push(b))}L<y-1&&(p[L]>=0&&(b=bb({inputs:{x:b},backend:n,attrs:{axis:p[L]-(u.length-T),keepDims:!1}}),R.push(b)),T--)}for(const L of R)L!==b&&n.disposeIntermediateTensorInfo(L);return b}},LD=bi({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),FD={kernelName:yo,backendName:"webgl",kernelFunc:LD},OD={kernelName:Pl,backendName:"webgl",kernelFunc:r=>{const{inputs:t,backend:n}=r,{dy:i,y:a}=t,o=de().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a1("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",i.shape,a.shape):new HA("return (b >= 1.0) ? a : a * (b + 1.0);",i.shape,a.shape);return n.runWebGLProgram(o,[i,a],i.dtype)}},PD=uo({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:iB}),UD={kernelName:wi,backendName:"webgl",kernelFunc:PD},zD=bi({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Yg};\n  float a1 = ${bu};\n  float a2 = ${Kg};\n  float a3 = ${ay};\n  float a4 = ${xu};\n  float a5 = ${oy};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),$D={kernelName:Wo,backendName:"webgl",kernelFunc:zD},TI=bi({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:sB,dtype:"float32"}),VD={kernelName:xh,backendName:"webgl",kernelFunc:TI};function DE(r){const{inputs:t,attrs:n,backend:i}=r,{dim:a}=n,{input:o}=t,u=o.shape.length,h=o.shape.slice();let f=a;return a<0&&(Z(-(u+1)<=a,()=>`Axis must be in the interval [${-(u+1)}, ${u}]`),f=u+a+1),h.splice(f,0,1),Gn({inputs:{x:o},backend:i,attrs:{shape:h}})}const GD={kernelName:vo,backendName:"webgl",kernelFunc:DE},_I="return exp(x) - 1.0;",QD=bi({opSnippet:_I,packedOpSnippet:_I,cpuKernelImpl:aB}),HD={kernelName:qi,backendName:"webgl",kernelFunc:QD};class kI{constructor(t,n,i){this.variableNames=["real","imag"];const a=n[1];this.outputShape=n;const o=i?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,u=i?`${a}.0`:"1.0";let h;if("real"===t)h="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);h="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${h}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${a});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${a}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${u};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function RI(r,t,n){const i=n.texData.get(r.dataId),a=Wt(r.shape),o=r.shape[r.shape.length-1],u=Gn({inputs:{x:r},backend:n,attrs:{shape:[a/o,o]}}),h=u.shape,f=new kI("real",h,t),p=new kI("imag",h,t),m=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:h},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:h}],y=n.runWebGLProgram(f,m,"float32"),b=n.runWebGLProgram(p,m,"float32"),T=Yp({inputs:{real:y,imag:b},backend:n});n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b);const R=Gn({inputs:{x:T},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(T),R}const WD={kernelName:ps,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{input:i}=t;return RI(i,!1,n)}};class jD{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function c1(r){const{backend:t,attrs:n}=r,{shape:i,value:a}=n;let{dtype:o}=n;if(o=o||Mr(a),"string"===o){const u=jt(o,Wt(i));return u.fill(a),t.makeTensorInfo(i,o,u)}{const u=new jD(i,a);return t.runWebGLProgram(u,[],o,[[a]])}}const qD={kernelName:Nu,backendName:"webgl",kernelFunc:c1};class XD{constructor(t){this.variableNames=["Image"],this.outputShape=[];const n=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${n} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${n}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const YD={kernelName:Uc,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{const{image:n}=r,i=t,a=new XD(n.shape);return i.runWebGLProgram(a,[n],n.dtype)}},BI="return floor(x);",KD=bi({opSnippet:BI,packedOpSnippet:BI,cpuKernelImpl:oB}),JD={kernelName:ac,backendName:"webgl",kernelFunc:KD},ZD=uo({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),tL={kernelName:Ii,backendName:"webgl",kernelFunc:ZD};class eL{constructor(t){this.variableNames=["A"];const n=Uo(),[i,a]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        vec4 values = ${n.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class nL{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=Uo(),[i,a]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${a}.0, ${i}.0);\n            vec4 values = ${n.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${n.output} = result;\n      }\n    `}}const rL={kernelName:Gd,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r;let{pixels:a}=t;const{numChannels:o}=i,u=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,h=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,[f,p]=u?[a.videoWidth,a.videoHeight]:[a.width,a.height],m=[p,f],y=[p,f,o];(h||u)&&(null==qA&&(qA=document.createElement("canvas").getContext("2d")),qA.canvas.width=f,qA.canvas.height=p,qA.drawImage(a,0,0,f,p),a=qA.canvas);const b=n.makeTensorInfo(m,"int32");n.texData.get(b.dataId).usage=sc.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(b.dataId),a);const T=de().getBool("WEBGL_PACK")?new nL(y):new eL(y),R=n.runWebGLProgram(T,[b],"int32");return n.disposeData(b.dataId),R}};let qA;const iL={kernelName:Bh,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o,bias:u,preluActivationWeights:h}=t,{strides:f,pad:p,dataFormat:m,dilations:y,dimRoundingMode:b,activation:T,leakyreluAlpha:R}=i,L=uu(m),V=ra(a.shape,o.shape,f,y,p,b,!1,L);let j;const H=[];if(1!==V.filterHeight||1!==V.filterWidth||1!==V.dilationHeight||1!==V.dilationWidth||1!==V.strideHeight||1!==V.strideWidth||"SAME"!==V.padInfo.type&&"VALID"!==V.padInfo.type)if(de().getBool("WEBGL_CONV_IM2COL")&&1===a.shape[0])j=wI({x:a,filter:o,convInfo:V,backend:n,bias:u,activation:T,preluActivationWeights:h,leakyreluAlpha:R});else{const dt=null!=u,yt=null!=h,kt="leakyrelu"===T,Ot=T?yb(T,!1):null,Nt=new bI(V,dt,Ot,yt,kt),Vt=[a,o];if(u&&Vt.push(u),h&&Vt.push(h),kt){const qt=n.makeTensorInfo([],"float32",Kc(R,"float32"));Vt.push(qt),H.push(qt)}j=n.runWebGLProgram(Nt,Vt,"float32")}else j=xI({x:a,filter:o,convInfo:V,backend:n,bias:u,activation:T,preluActivationWeights:h,leakyreluAlpha:R});const nt=Gn({inputs:{x:j},backend:n,attrs:{shape:V.outShape}});return H.push(j),H.forEach(dt=>n.disposeIntermediateTensorInfo(dt)),nt}},sL={kernelName:Ls,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,filter:o,bias:u,preluActivationWeights:h}=t,{strides:f,pad:p,dilations:m,dimRoundingMode:y,activation:b,leakyreluAlpha:T}=i,R=[];let L=m;null==L&&(L=[1,1]),Z(Na(f,L),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${f} and dilations '${L}'`);const V=ra(a.shape,o.shape,f,L,p,y,!0),j=de().getBool("WEBGL_PACK_DEPTHWISECONV")&&V.strideWidth<=2&&V.outChannels/V.inChannels==1,H=b?yb(b,j):null,nt=[a,o],dt=null!=u,yt=null!=h,kt="leakyrelu"===b;if(dt&&nt.push(u),yt&&nt.push(h),kt){const qt=n.makeTensorInfo([],"float32",Kc(T,"float32"));nt.push(qt),R.push(qt)}let Ot;Ot=j?new MI(V,dt,H,yt,kt):new SI(V,dt,H,yt,kt);const Vt=n.runWebGLProgram(Ot,nt,"float32",[[V.padInfo.top,V.padInfo.left],[V.strideHeight,V.strideWidth],[V.dilationHeight,V.dilationWidth],[V.inHeight,V.inWidth]]);return R.forEach(qt=>n.disposeIntermediateTensorInfo(qt)),Vt}};class aL{constructor(t,n,i){this.sliceDim=t,this.strides=n,this.variableNames=["x","indices"],this.outputShape=i;const a=ns(n.length),o=ns(i.length);this.userCode=`\n        ${a} strides = ${a}(${this.strides});\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const oL={kernelName:Fm,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{params:i,indices:a}=t,o=a.shape,u=o[o.length-1],h=Wt(i.shape),[f,p,m,y]=Ef(i,a),b=Gn({inputs:{x:a},backend:n,attrs:{shape:[p,u]}}),T=Gn({inputs:{x:i},backend:n,attrs:{shape:[Wt(i.shape)/m,m]}});if(n.shouldExecuteOnCPU([i,a])||"string"===i.dtype){const j=n.readSync(a.dataId),H=n.bufferSync(i),nt=lB(j,H,i.dtype,p,u,m,y,i.shape,h);return n.makeTensorInfo(f,i.dtype,nt.values)}const R=new aL(u,y,[p,m]),L=n.runWebGLProgram(R,[T,b],T.dtype),V=Gn({inputs:{x:L},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(L),V}};class lL{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const i=ns(this.rank),a=function(o,u){const h=["resRC.x","resRC.y","resRC.z","resRC.w"],f=[];for(let p=0;p<o.length;p++)f.push(2===p?"index":`${h[p]}`);return f.join()}(t);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${a}));\n      }\n    `}}function NI(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,indices:o}=t,{axis:u,batchDims:h}=i,f=lr(u,a.shape)[0];if(de().get("DEBUG")){const H=n.readSync(o.dataId),nt=a.shape[f];for(let dt=0;dt<H.length;++dt){const yt=H[dt];Z(yt<=nt-1&&yt>=0,()=>`GatherV2: the index value ${yt} is not in [0, ${nt-1}]`)}}const p=yy(a,o,f,h),m=Wt(o.shape),y=[],b=Gn({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),T=Gn({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,m/p.batchSize]}});y.push(b),y.push(T);const R=[p.batchSize,p.outerSize,m/p.batchSize,p.sliceSize];if(n.shouldExecuteOnCPU([a,o])||"string"===a.dtype){const H=n.bufferSync(T),nt=n.bufferSync(b),dt=cB(nt,H,R);return y.forEach(yt=>n.disposeIntermediateTensorInfo(yt)),n.makeTensorInfo(p.outputShape,dt.dtype,dt.values)}const L=new lL(b.shape,R),V=n.runWebGLProgram(L,[b,T],b.dtype);y.push(V);const j=Gn({inputs:{x:V},backend:n,attrs:{shape:p.outputShape}});return y.forEach(H=>n.disposeIntermediateTensorInfo(H)),j}const cL={kernelName:$c,backendName:"webgl",kernelFunc:NI},uL=uo({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:uB,dtype:"bool"}),hL={kernelName:Ul,backendName:"webgl",kernelFunc:uL},dL=uo({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:hB}),pL={kernelName:Id,backendName:"webgl",kernelFunc:dL},fL={kernelName:Om,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{input:i}=t;return RI(i,!0,n)}},mL=bi({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),gL={kernelName:Md,backendName:"webgl",kernelFunc:mL},AL=bi({opSnippet:"return float(isinf(x));",dtype:"bool"}),yL={kernelName:Td,backendName:"webgl",kernelFunc:AL},vL=bi({opSnippet:"return float(isnan(x));",dtype:"bool"}),bL={kernelName:_d,backendName:"webgl",kernelFunc:vL},xL=uo({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:dB,dtype:"bool"}),wL={kernelName:Jp,backendName:"webgl",kernelFunc:xL},EL=uo({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:pB,dtype:"bool"}),CL={kernelName:Zp,backendName:"webgl",kernelFunc:EL},IL={kernelName:Um,backendName:"webgl",kernelFunc:function(r){const{backend:t,attrs:n}=r,{start:i,stop:a,num:o}=n,u=fB(i,a,o);return t.makeTensorInfo([u.length],"float32",u)}},SL=bi({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:mB}),ML={kernelName:kd,backendName:"webgl",kernelFunc:SL},TL=bi({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),_L={kernelName:Rd,backendName:"webgl",kernelFunc:TL},kL=uo({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),RL={kernelName:wh,backendName:"webgl",kernelFunc:kL},BL=bi({opSnippet:"return float(!(x >= 1.0));"}),NL={kernelName:Bd,backendName:"webgl",kernelFunc:BL},DL=uo({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),LL={kernelName:Nd,backendName:"webgl",kernelFunc:DL};class FL{constructor(t,n,i,a,o){this.variableNames=["x"],this.outputShape=[];const u=n,h=t[3]-1;let f;this.outputShape=t;const p=`float(${i}) + float(${a}) * sum`;f=.5===o?`inversesqrt(${p})`:1===o?`1.0/(${p})`:`exp(log(${p}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${u}; j <= ${u}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${h}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${f};\n        setOutput(val);\n      }\n    `}}class OL{constructor(t,n,i,a,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const u=n,h=t[3]-1;let f;this.outputShape=t;const p=`float(${i}) + float(${a}) * sum`;f=.5===o?`inversesqrt(${p})`:1===o?`1.0/(${p})`:`exp(log(${p}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${u};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${u}; j <= ${u}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${h}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${f};\n        setOutput(result);\n      }\n    `}}const PL={kernelName:Eh,backendName:"webgl",kernelFunc:r=>{const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{depthRadius:o,bias:u,alpha:h,beta:f}=i,p=de().getBool("WEBGL_PACK_NORMALIZATION")?new OL(a.shape,o,u,h,f):new FL(a.shape,o,u,h,f);return n.runWebGLProgram(p,[a],a.dtype)}};class UL{constructor(t,n,i,a,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=i,this.alpha=a,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${n})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${n} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${a}) * norm + float(${i});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${a})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const zL={kernelName:tf,backendName:"webgl",kernelFunc:r=>{const{inputs:t,backend:n,attrs:i}=r,{x:a,y:o,dy:u}=t,{depthRadius:h,bias:f,alpha:p,beta:m}=i,y=new UL(a.shape,h,f,p,m);return n.runWebGLProgram(y,[a,o,u],a.dtype)}};function DI(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{reductionIndices:o,keepDims:u}=i,h=a.shape.length,f=lr(o,a.shape);let p=f;const m=vs(p,h),y=null!=m,b=n.shouldExecuteOnCPU([a]);let T=a;if(y){if(b){const H=n.texData.get(T.dataId).values,nt=new Array(h);for(let yt=0;yt<nt.length;yt++)nt[yt]=a.shape[m[yt]];const dt=_E(H,a.shape,a.dtype,m,nt);T=n.makeTensorInfo(nt,a.dtype),n.texData.get(T.dataId).values=dt}else T=vb(a,m,n);p=Ai(p.length,h)}zs("max",p,h);const[R,L]=sa(T.shape,p);let V,j=R;if(u&&(j=Ni(R,f)),b){const H=n.texData.get(T.dataId).values,nt=gB(H,Wt(L),j,a.dtype);V=n.makeTensorInfo(j,a.dtype),n.texData.get(V.dataId).values=nt}else V=function(H,nt,dt,yt){const kt=Wt(nt),Ot=Gn({inputs:{x:H},attrs:{shape:[Wt(H.shape)/kt,kt]},backend:yt}),Nt=Dm(Ot,H.dtype,"max",yt),Vt=Gn({inputs:{x:Nt},attrs:{shape:dt},backend:yt});return yt.disposeIntermediateTensorInfo(Ot),yt.disposeIntermediateTensorInfo(Nt),Vt}(T,L,j,n);return y&&n.disposeIntermediateTensorInfo(T),V}const $L={kernelName:Dd,backendName:"webgl",kernelFunc:DI},VL=uo({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:AB}),GL={kernelName:Ch,backendName:"webgl",kernelFunc:VL},QL={kernelName:Ld,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t;i1(a,"maxPool");const{filterSize:o,strides:u,pad:h,dimRoundingMode:f}=i;Z(Na(u,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`);const p=el(a.shape,o,u,1,h,f);if(1===p.filterWidth&&1===p.filterHeight&&We(p.inShape,p.outShape))return Ll({inputs:{x:a},backend:n});const m=new o1(p,"max",!1);return n.runWebGLProgram(m,[a],a.dtype)}},HL={kernelName:ef,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{filterSize:o,strides:u,pad:h,dataFormat:f,dimRoundingMode:p}=i,m=yc(a.shape,o,u,[1,1,1],h,p,f),y=new BE(m,"max",!1);return n.runWebGLProgram(y,[a],a.dtype)}};class WL{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const o=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*u-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${u} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class jL{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const f=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${f-1-t.padInfo.front}, ${p-1-t.padInfo.top}, ${m-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${f};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${p};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${m};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${f*p*m-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${p} * ${m} +\n                  wR * ${m} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const qL={kernelName:zm,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,input:o}=t,u=o,{filterSize:h,strides:f,pad:p,dimRoundingMode:m}=i,y=yc(u.shape,h,f,[1,1,1],p,m),b=new BE(y,"max",!0),T=n.runWebGLProgram(b,[u],u.dtype),R=new jL(y),L=n.runWebGLProgram(R,[a,T],u.dtype);return n.disposeIntermediateTensorInfo(T),L}},XL={kernelName:Du,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{dy:a,input:o,output:u}=t,h=o;i1([o,u],"maxPoolGrad");const{filterSize:f,strides:p,pad:m,dimRoundingMode:y}=i,b=el(h.shape,f,p,1,m,y),T=new o1(b,"max",!0),R=n.runWebGLProgram(T,[h],h.dtype),L=new WL(b),V=n.runWebGLProgram(L,[a,R],h.dtype);return n.disposeIntermediateTensorInfo(R),V}},YL={kernelName:$m,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{const{x:i}=r,{filterSize:a,strides:o,pad:u,includeBatchInIndex:h}=t,f=n;Z(4===i.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${i.shape.length}.`);const p=[1,1];Z(Na(o,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);const m=el(i.shape,a,o,p,u),[y,b]=function(T,R,L,V){let j=new o1(L,"max",!1);const H=V.runWebGLProgram(j,[T],"float32");return j=new o1(L,"max",!0,!0,R),[H,V.runWebGLProgram(j,[T],"float32")]}(i,h,m,f);return[y,b]}},KL={kernelName:nf,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{const{x:i}=r,{keepDims:a,axis:o}=t,u=n,h=i.shape.length,f=lr(o,i.shape);let p=f;const m=vs(p,h),y=null!=m,b=u.shouldExecuteOnCPU([i]),T=[];let R=i;if(y){if(b){const nt=u.texData.get(R.dataId).values,dt=new Array(h);for(let kt=0;kt<dt.length;kt++)dt[kt]=i.shape[m[kt]];const yt=_E(nt,i.shape,i.dtype,m,dt);R=u.makeTensorInfo(dt,i.dtype),u.texData.get(R.dataId).values=yt}else R=vb(i,m,u);T.push(R),p=Ai(p.length,h)}zs("sum",p,h);const[L,V]=sa(R.shape,p);let j=L;a&&(j=Ni(L,f));const H=function(nt,dt,yt,kt){const Ot=Wt(dt),Nt=Gn({inputs:{x:nt},attrs:{shape:[Wt(nt.shape)/Ot,Ot]},backend:kt}),Vt=Dm(Nt,"float32","mean",kt),qt=Gn({inputs:{x:Vt},attrs:{shape:yt},backend:kt});return kt.disposeIntermediateTensorInfo(Nt),kt.disposeIntermediateTensorInfo(Vt),qt}(R,V,j,u);for(const nt of T)u.disposeIntermediateTensorInfo(nt);return H}},JL={kernelName:rf,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i,h=a.shape.length,f=lr(o,a.shape);let p=f;const m=vs(p,h);let y=a;null!=m&&(y=$o({inputs:{x:a},backend:n,attrs:{perm:m}}),p=Ai(p.length,a.shape.length)),zs("min",p,h);const[b,T]=sa(y.shape,p),R=Gn({inputs:{x:y},backend:n,attrs:{shape:[-1,Wt(T)]}}),L=Dm(R,R.dtype,"min",n);let V;return V=Gn(u?{inputs:{x:L},backend:n,attrs:{shape:Ni(b,f)}}:{inputs:{x:L},backend:n,attrs:{shape:b}}),n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(L),null!=m&&n.disposeIntermediateTensorInfo(y),V}},ZL=uo({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:yB}),t4={kernelName:Fd,backendName:"webgl",kernelFunc:ZL};class e4{constructor(t,n,i){this.variableNames=["x"],this.outputShape=n.map((m,y)=>m[0]+t[y]+m[1]);const a=t.length,o=ns(a),u=n.map(m=>m[0]).join(","),h=n.map((m,y)=>m[0]+t[y]).join(","),f=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),p="reflect"===i?0:1;this.userCode=1!==a?`\n      ${o} start = ${o}(${u});\n      ${o} end = ${o}(${h});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${a}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${p};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${p};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${f}));\n      }\n    `:`\n        int start = ${u};\n        int end = ${h};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${p};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${p};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class n4{constructor(t,n,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((R,L)=>R[0]+t[L]+R[1]);const a=t.length,o=ns(a),u=n.map(R=>R[0]).join(","),h=n.map((R,L)=>R[0]+t[L]).join(","),f=zo("rc",a),p=zo("source",a),m=`${f[a-1]} < ${this.outputShape[a-1]}`,y=1===a?"source":`vec2(${p.slice(-2).join()})`,b="reflect"===i?0:1;let T="";if(1===a){const R=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${b};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${b};\n        }\n        source -= start;\n      `;T=`\n        ${o} rc = outputLoc;\n        ${R}\n        result[0] = getChannel(getX(${p.join()}), ${y});\n        ${f[a-1]} += 1;\n        if(${m}) {\n          ${R}\n          result[1] = getChannel(getX(${p.join()}), ${y});\n        }\n      `}else{const R=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${b}) +\n                gte * ((end - 1) * 2 - source + ${b});\n        source -= start;\n      `;T=`\n        ${o} rc = outputLoc;\n        ${R}\n        result[0] = getChannel(getX(${p.join()}), ${y});\n        ${f[a-1]} += 1;\n        if(${m}) {\n          ${R}\n          result[1] = getChannel(getX(${p.join()}), ${y});\n        }\n        rc = outputLoc;\n        ${f[a-2]} += 1;\n        if(${f[a-2]} < ${this.outputShape[a-2]}) {\n          ${R}\n          result[2] = getChannel(getX(${p.join()}), ${y});\n          ${f[a-1]} += 1;\n          if(${m}) {\n            ${R}\n            result[3] = getChannel(getX(${p.join()}), ${y});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${u});\n      const ${o} end = ${o}(${h});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${T}\n        setOutput(result);\n      }\n    `}}const r4={kernelName:sf,backendName:"webgl",kernelFunc:({inputs:r,backend:t,attrs:n})=>{const{x:i}=r,{paddings:a,mode:o}=n,u=de().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new n4(i.shape,a,o):new e4(i.shape,a,o);return t.runWebGLProgram(u,[i],i.dtype)}},i4=uo({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),s4={kernelName:Od,backendName:"webgl",kernelFunc:i4};class a4{constructor(t,n,i){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${n-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${n-1}));\n      }\n    `}}const LI=uo({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),o4={kernelName:Ho,backendName:"webgl",kernelFunc:LI},FI="return a - b;",OI=uo({opSnippet:FI,packedOpSnippet:FI,supportsComplex:!0,cpuKernelImpl:DB}),l4={kernelName:eo,backendName:"webgl",kernelFunc:OI};function PI(r){const{inputs:t,backend:n,attrs:i}=r,{logits:a}=t,{dim:o}=i,u=lr([o],a.shape),h=DI({inputs:{x:a},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),f=Ni(h.shape,u),p=Gn({inputs:{x:h},backend:n,attrs:{shape:f}}),m=OI({inputs:{a,b:p},backend:n}),y=TI({inputs:{x:m},backend:n}),b=bb({inputs:{x:y},backend:n,attrs:{axis:u,keepDims:!1}}),T=Gn({inputs:{x:b},backend:n,attrs:{shape:f}}),R=LI({inputs:{a:y,b:T},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(T),R}const c4={kernelName:$d,backendName:"webgl",kernelFunc:PI},u4={kernelName:Vm,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{logits:a}=t,{numSamples:o,seed:u,normalized:h}=i,f=h?a:PI({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),y=new a4(f.shape[0],f.shape[1],o),T=n.runWebGLProgram(y,[f],"int32",[[u]]);return h||n.disposeIntermediateTensorInfo(f),T}},h4={kernelName:ko,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{x:i}=t;if(n.shouldExecuteOnCPU([i])){const o=n.texData.get(i.dataId),[u,h]=bB(o.values,i.shape,i.dtype);return n.makeTensorInfo(h,i.dtype,u)}let a;return a=de().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Nm(i.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new xd(i.shape,"if (isnan(x)) return x;\n  return -x;\n"),n.runWebGLProgram(a,[i],i.dtype)}},d4=Vg,p4={kernelName:to,backendName:"webgl",kernelFunc:function(r){Fs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:i}=r,{boxes:a,scores:o}=t,{maxOutputSize:u,iouThreshold:h,scoreThreshold:f}=i,p=n.readSync(a.dataId),m=n.readSync(o.dataId),{selectedIndices:y}=d4(p,m,u,h,f);return n.makeTensorInfo([y.length],"int32",new Int32Array(y))}},f4=Il,m4={kernelName:fa,backendName:"webgl",kernelFunc:function(r){Fs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:i}=r,{boxes:a,scores:o}=t,{maxOutputSize:u,iouThreshold:h,scoreThreshold:f,padToMaxOutputSize:p}=i,m=n.readSync(a.dataId),y=n.readSync(o.dataId),{selectedIndices:b,validOutputs:T}=f4(m,y,u,h,f,p);return[n.makeTensorInfo([b.length],"int32",new Int32Array(b)),n.makeTensorInfo([],"int32",new Int32Array([T]))]}},g4=Bp,A4={kernelName:af,backendName:"webgl",kernelFunc:function(r){Fs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:i}=r,{boxes:a,scores:o}=t,{maxOutputSize:u,iouThreshold:h,scoreThreshold:f,softNmsSigma:p}=i,m=n.readSync(a.dataId),y=n.readSync(o.dataId),b=u,T=h,R=f,L=p,{selectedIndices:V,selectedScores:j}=g4(m,y,b,T,R,L);return[n.makeTensorInfo([V.length],"int32",new Int32Array(V)),n.makeTensorInfo([j.length],"float32",new Float32Array(j))]}};class y4{constructor(t,n,i,a){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${a}), float(${i}),\n                      float(index == coords.y)));\n      }\n    `}}const v4={kernelName:oc,backendName:"webgl",kernelFunc:r=>{const{inputs:t,backend:n,attrs:i}=r,{indices:a}=t,{depth:o,onValue:u,offValue:h}=i,f=Wt(a.shape),p=new y4(f,o,u,h),m=Gn({inputs:{x:a},backend:n,attrs:{shape:[f]}}),y=n.runWebGLProgram(p,[m],a.dtype);n.disposeIntermediateTensorInfo(m);const b=Gn({inputs:{x:y},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeIntermediateTensorInfo(y),b}};function Cb(r){const{inputs:t,backend:n}=r,{x:i}=t;if("complex64"===i.dtype){const a=l1({inputs:{input:i},backend:n}),o=Cb({inputs:{x:a},backend:n}),u=Eb({inputs:{input:i},backend:n}),h=Cb({inputs:{x:u},backend:n}),f=Yp({inputs:{real:o,imag:h},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),f}return c1({attrs:{shape:i.shape,dtype:i.dtype,value:"string"===i.dtype?"":0},backend:n})}const b4={kernelName:$u,backendName:"webgl",kernelFunc:Cb},x4={kernelName:zl,backendName:"webgl",kernelFunc:function r(t){const{inputs:n,backend:i}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){const o=l1({inputs:{input:a},backend:i}),u=r({inputs:{x:o},backend:i}),h=Eb({inputs:{input:a},backend:i}),f=Cb({inputs:{x:h},backend:i}),p=Yp({inputs:{real:u,imag:f},backend:i});return i.disposeIntermediateTensorInfo(o),i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(f),p}return c1({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:i})}},w4={kernelName:Ua,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{axis:a}=i;if(1===t.length)return DE({inputs:{input:t[0]},backend:n,attrs:{dim:a}});const o=t[0].shape,u=t[0].dtype;t.forEach(p=>{_t(o,p.shape,"All tensors passed to stack must have matching shapes"),Z(u===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});const h=[],f=vI({inputs:t.map(p=>{const m=DE({inputs:{input:p},backend:n,attrs:{dim:a}});return h.push(m),m}),backend:n,attrs:{axis:a}});return h.forEach(p=>n.disposeIntermediateTensorInfo(p)),f}};class E4{constructor(t,n,i){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((p,m)=>p[0]+t[m]+p[1]);const a=t.length,o=ns(a),u=n.map(p=>p[0]).join(","),h=n.map((p,m)=>p[0]+t[m]).join(","),f=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?`\n      ${o} start = ${o}(${u});\n      ${o} end = ${o}(${h});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${f}));\n        }\n      }\n    `:`\n        int start = ${u};\n        int end = ${h};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class C4{constructor(t,n,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((L,V)=>L[0]+t[V]+L[1]);const a=t.length,o=ns(a),u=n.map(L=>L[0]).join(","),h=n.map((L,V)=>L[0]+t[V]).join(","),f=zo("rc",a),p=zo("source",a),m=`${f[a-1]} < ${this.outputShape[a-1]}`,y=1===a?"source":`vec2(${p.slice(-2).join()})`,b=[`${o} rc = outputLoc;`,`${f[a-1]} += 1;\n       if(${m}) {\n      `,1===a?"":`}\n       rc = outputLoc;\n       ${f[a-2]} += 1;\n       if(${f[a-2]} < ${this.outputShape[a-2]}) {`,1===a?"":`  ${f[a-1]} += 1;\n         if(${m}) {`],T=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let R="";for(let L=0,V=1===a?2:4;L<V;L++)R+=`\n        ${b[L]}\n        if (${T}) {\n          result[${L}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${L}] = getChannel(getX(${p.join()}), ${y});\n        }\n      `;R+=1===a?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${u});\n      const ${o} end = ${o}(${h});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${R}\n        setOutput(result);\n      }\n    `}}const UI=r=>{const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{paddings:o,constantValue:u}=i;if(0===Wt(a.shape))return c1({backend:n,attrs:{shape:o.map((p,m)=>p[0]+a.shape[m]+p[1]),value:u,dtype:a.dtype}});const h=de().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new C4(a.shape,o,u):new E4(a.shape,o,u);return n.runWebGLProgram(h,[a],a.dtype,[[u]])},I4={kernelName:Ki,backendName:"webgl",kernelFunc:UI},S4=uo({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),M4={kernelName:lc,backendName:"webgl",kernelFunc:S4},T4={kernelName:Br,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{axis:o,keepDims:u}=i,h=a.shape.length,f=[],p=lr(o,a.shape);let m=p;const y=vs(m,h);let b,T=a;if(null!=y&&(T=$o({inputs:{x:a},backend:n,attrs:{perm:y}}),m=Ai(m.length,h),f.push(T)),zs("prod",m,h),n.shouldExecuteOnCPU([T])){const R=n.texData.get(T.dataId).values,{outVals:L,outShape:V,outDtype:j}=wB(T.shape,T.dtype,R,m);b=n.makeTensorInfo(V,j,L)}else{const[R,L]=sa(T.shape,m),V=Wt(L),j=Gn({inputs:{x:T},backend:n,attrs:{shape:[-1,V]}}),H=Dm(j,no(a.dtype),"prod",n);b=Gn({inputs:{x:H},backend:n,attrs:{shape:R}}),f.push(j),f.push(H)}if(u){f.push(b);const R=Ni(b.shape,p);b=Gn({inputs:{x:b},backend:n,attrs:{shape:R}})}return f.forEach(R=>n.disposeIntermediateTensorInfo(R)),b}},zI=r=>{const{backend:t,attrs:n}=r,{start:i,stop:a,step:o,dtype:u}=n,h=EB(i,a,o,u);return t.makeTensorInfo([h.length],u,h)},_4={kernelName:Fu,backendName:"webgl",kernelFunc:zI},k4=bi({opSnippet:"return 1.0 / x;"}),R4={kernelName:yr,backendName:"webgl",kernelFunc:k4},B4=bi({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),N4={kernelName:Ou,backendName:"webgl",kernelFunc:B4},D4=bi({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),L4={kernelName:Ih,backendName:"webgl",kernelFunc:D4};class F4{constructor(t,n,i,a,o){this.variableNames=["A"],this.outputShape=[];const[u,h,f,p]=t;this.outputShape=[u,n,i,p];const m=[a&&n>1?h-1:h,a&&i>1?f-1:f],y=[a&&n>1?n-1:n,a&&i>1?i-1:i];let b;b=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${m[0]/y[0]},\n          ${m[1]/y[1]});\n      const vec2 inputShapeRC = vec2(${h}.0, ${f}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${b};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class O4{constructor(t,n,i,a,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[u,h,f,p]=t;this.outputShape=[u,n,i,p];const m=[a&&n>1?h-1:h,a&&i>1?f-1:f],y=[a&&n>1?n-1:n,a&&i>1?i-1:i];let b;b=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${m[0]/y[0]},\n          ${m[1]/y[1]},\n          ${m[1]/y[1]});\n      const vec3 inputShapeRC = vec3(${h}.0, ${f}.0,\n                                     ${f}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${b};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${p-1};\n        bool hasNextRow = coords.z < ${i-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const P4={kernelName:Qc,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{images:a}=t,{alignCorners:o,halfPixelCenters:u,size:h}=i,[f,p]=h,m=de().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new O4(a.shape,f,p,o,u):new F4(a.shape,f,p,o,u);return n.runWebGLProgram(m,[a],"float32")}};class U4{constructor(t,n,i){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,a,o]=n,[,u,h]=t,f=[i&&u>1?a-1:a,i&&h>1?o-1:o],p=[i&&u>1?u-1:u,i&&h>1?h-1:h],m=f[0]/p[0],y=f[1]/p[1],b=1/m,T=1/y,R=2*Math.ceil(b)+2,L=2*Math.ceil(T)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${m});\n        const float widthScale = float(${y});\n\n        const float invHeightScale = float(${b});\n        const float invWidthScale = float(${T});\n\n        const int winHeight = int(${R});\n        const int winWidth = int(${L});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${u}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${h}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const z4={kernelName:lf,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{images:a,dy:o}=t,{alignCorners:u}=i,h=new U4(o.shape,a.shape,u);return n.runWebGLProgram(h,[o],o.dtype)}};class $4{constructor(t,n,i,a,o){this.variableNames=["A"],this.outputShape=[];const[u,h,f,p]=t;this.outputShape=[u,n,i,p];const m=[a&&n>1?h-1:h,a&&i>1?f-1:f],y=[a&&n>1?n-1:n,a&&i>1?i-1:i];let T;T=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${m[0]/y[0]},\n          ${m[1]/y[1]});\n      const vec2 inputShapeRC = vec2(${h}.0, ${f}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${T};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${a?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class V4{constructor(t,n,i,a,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[u,h,f,p]=t;this.outputShape=[u,n,i,p];const m=[a&&n>1?h-1:h,a&&i>1?f-1:f],y=[a&&n>1?n-1:n,a&&i>1?i-1:i];let T;T=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${m[0]/y[0]},\n          ${m[1]/y[1]},\n          ${m[1]/y[1]});\n      const vec3 inputShapeRC = vec3(${h}.0, ${f}.0,\n                                     ${f}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${T};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${a?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${p-1};\n        bool hasNextRow = coords.z < ${i-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const G4={kernelName:of,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{images:a}=t,{alignCorners:o,halfPixelCenters:u,size:h}=i,[f,p]=h,m=de().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new V4(a.shape,f,p,o,u):new $4(a.shape,f,p,o,u);return n.runWebGLProgram(m,[a],a.dtype)}};class Q4{constructor(t,n,i){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,a,o]=n,[,u,h]=t,f=[i&&u>1?a-1:a,i&&h>1?o-1:o],p=[i&&u>1?u-1:u,i&&h>1?h-1:h],m=f[0]/p[0],y=f[1]/p[1],b=1/m,T=1/y,R=2*Math.ceil(b)+2,L=2*Math.ceil(T)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${m});\n        const float widthScale = float(${y});\n\n        const float invHeightScale = float(${b});\n        const float invWidthScale = float(${T});\n\n        const int winHeight = int(${R});\n        const int winWidth = int(${L});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${u}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${h}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${f[0]}) *\n                (float(dyR) / float(${p[0]}));\n\n            float sourceFracCol =\n                float(${f[1]}) *\n                  (float(dyC) / float(${p[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${a}) - 1),\n                ${i} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${i} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const H4={kernelName:Gc,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{images:a,dy:o}=t,{alignCorners:u}=i,h=new Q4(o.shape,a.shape,u);return n.runWebGLProgram(h,[o],o.dtype)}};class W4{constructor(t,n){this.variableNames=["x"];const i=t.length;if(i>4)throw new Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);if(this.outputShape=t,1===i)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const a=t.map((u,h)=>{return-1!==n.indexOf(f=h)&&1!==t[f]?`${t[f]} - coords[${f}] - 1`:`coords[${f}]`;var f}).join(","),o=ns(i);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class j4{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const i=t.length;if(i>4)throw new Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);this.outputShape=t;const a=zo("rc",i),o=`${a[i-1]} + 1 < ${this.outputShape[i-1]}`,u=`${a[i-2]} + 1 < ${this.outputShape[i-2]}`,h=ns(i);function f(p){const m=t.map((y,b)=>{return R=p,-1!==n.indexOf(T=b)&&1!==t[T]?`${t[T]} - ${R[T]} - 1`:`${R[T]}`;var T,R});return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}var p;this.userCode=1===i?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${h} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${p=a.slice(),f(p)};\n          if(${o}){\n            result.g = ${function(p){return p[i-1]="("+p[i-1]+" + 1)",f(p)}(a.slice())};\n          }\n          if(${u}) {\n            result.b = ${function(p){return p[i-2]="("+p[i-2]+" + 1)",f(p)}(a.slice())};\n            if(${o}) {\n              result.a = ${function(p){return p[i-1]="("+p[i-1]+" + 1)",p[i-2]="("+p[i-2]+" + 1)",f(p)}(a.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const q4={kernelName:Ud,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{dims:o}=i,u=a.shape.length,h=lr(o,a.shape);if(0===u)return Ll({inputs:{x:a},backend:n});const f=de().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new j4(a.shape,h):new W4(a.shape,h);return n.runWebGLProgram(f,[a],a.dtype)}};class X4{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const i=t[1],a=t[2];this.outputShape=t;let o="";o="number"==typeof n?`float outputValue = ${n.toFixed(2)};`:`\n        vec3 fill = vec3(${n.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${i}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Y4={kernelName:Hm,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:n})=>{const{image:i}=r,{radians:a,fillValue:o,center:u}=t,h=n,f=new X4(i.shape,o),[p,m]=iy(u,i.shape[1],i.shape[2]),y=[[p,m,Math.sin(a),Math.cos(a)]];return h.runWebGLProgram(f,[i],i.dtype,y)}},K4=bi({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),J4={kernelName:Sh,backendName:"webgl",kernelFunc:K4},Z4=bi({opSnippet:"return inversesqrt(x);",cpuKernelImpl:CB}),tF={kernelName:Mh,backendName:"webgl",kernelFunc:Z4};class $I{constructor(t,n,i,a,o,u,h=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=u;const f=ns(o.length),p=ns(u.length);let m="";1===i?m="i":2===i&&(m="i, j");let b="";1===a?b="i":2===a&&(b="i, coords[1]"),this.userCode=`\n        ${f} strides = ${f}(${o});\n\n        void main() {\n          ${p} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${n}; j++) {\n              int index = round(getIndices(${m}));\n              flattenedIndex += index * ${n>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${b});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const eF={kernelName:Th,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{indices:a,updates:o}=t,{shape:u}=i,{sliceRank:h,numUpdates:f,sliceSize:p,strides:m,outputSize:y}=Gh(0,a,u),b=[y/p,p];if(0===y)return n.makeTensorInfo(u,a.dtype);const T=Gn({inputs:{x:a},backend:n,attrs:{shape:[f,h]}}),R=Gn({inputs:{x:o},backend:n,attrs:{shape:[f,p]}}),L=n.makeTensorInfo([],"float32",new Float32Array([0])),V=new $I(f,h,T.shape.length,R.shape.length,m,b),j=n.runWebGLProgram(V,[R,T,L],R.dtype),H=Gn({inputs:{x:j},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(R),n.disposeIntermediateTensorInfo(j),n.disposeIntermediateTensorInfo(L),H}};class nF{constructor(t,n,i){let a,o;if(this.variableNames=["c","a","b"],this.outputShape=n,i>4)throw Error(`Where for rank ${i} is not yet supported`);if(1===i)o="resRC",a="resRC";else{const h=["resRC.x","resRC.y","resRC.z","resRC.w"],f=[],p=[];for(let m=0;m<n.length;m++)p.push(`${h[m]}`),m<t&&f.push(`${h[m]}`);a=f.join(),o=p.join()}const u=ns(i);this.userCode=`\n      void main() {\n        ${u} resRC = getOutputCoords();\n        float cVal = getC(${a});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const rF={kernelName:cf,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{condition:i,t:a,e:o}=t,u=new nF(i.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(u,[i,a,o],di(a.dtype,o.dtype))}},iF=bi({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${_c};\n  float scale = ${Xg};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),sF={kernelName:Jr,backendName:"webgl",kernelFunc:iF},aF=bi({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:IB}),oF={kernelName:zd,backendName:"webgl",kernelFunc:aF},lF=bi({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),cF={kernelName:_h,backendName:"webgl",kernelFunc:lF},uF=bi({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),hF={kernelName:Pu,backendName:"webgl",kernelFunc:uF},dF=bi({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),pF={kernelName:$l,backendName:"webgl",kernelFunc:dF},fF=bi({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),mF={kernelName:fl,backendName:"webgl",kernelFunc:fF},gF={kernelName:Vi,backendName:"webgl",kernelFunc:r=>{const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{blockShape:o,paddings:u}=i;Z(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const h=o.reduce((j,H)=>j*H),f=[[0,0]];f.push(...u);for(let j=1+o.length;j<a.shape.length;++j)f.push([0,0]);const p=[],m=UI({inputs:{x:a},backend:n,attrs:{paddings:f,constantValue:0}}),y=Fp(m.shape,o,h,!1),b=Op(y.length,o.length,!1),T=nc(m.shape,o,h,!1),R=Gn({inputs:{x:m},backend:n,attrs:{shape:y}}),L=$o({inputs:{x:R},backend:n,attrs:{perm:b}}),V=Gn({inputs:{x:L},backend:n,attrs:{shape:T}});return p.push(m),p.push(R),p.push(L),p.forEach(j=>n.disposeIntermediateTensorInfo(j)),V}},AF={kernelName:bo,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{indices:i,values:a,denseShape:o,defaultValue:u}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==i.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${i.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==u.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${u.shape}`);const h=n.readSync(i.dataId),f=n.readSync(a.dataId),p=n.readSync(o.dataId),m=n.readSync(u.dataId)[0],[y,b,T,R,L]=MB(h,i.shape,i.dtype,f,a.dtype,p,m);return[n.makeTensorInfo(b,i.dtype,y),n.makeTensorInfo([b[0]],a.dtype,T),n.makeTensorInfo([R.length],"bool",new Uint8Array(R.map(V=>Number(V)))),n.makeTensorInfo([L.length],i.dtype,new Int32Array(L))]}},yF={kernelName:kh,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{inputIndices:i,inputShape:a,newShape:o}=t;if(2!==i.shape.length)throw new Error(`Input indices should be a matrix but received shape ${i.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const u=Array.from(n.readSync(a.dataId)),h=n.readSync(i.dataId),f=Array.from(n.readSync(o.dataId)),[p,m,y]=TB(h,i.shape,i.dtype,u,f);return[n.makeTensorInfo(m,i.dtype,p),n.makeTensorInfo([y.length],o.dtype,new Int32Array(y))]}},vF={kernelName:Gm,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{data:i,indices:a,segmentIds:o}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const u=n.readSync(i.dataId),h=n.readSync(a.dataId),f=n.readSync(o.dataId),[p,m]=YC(u,i.shape,i.dtype,h,f,!0);return n.makeTensorInfo(m,i.dtype,p)}},bF={kernelName:Rh,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n}=r,{data:i,indices:a,segmentIds:o}=t;if(i.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const u=n.readSync(i.dataId),h=n.readSync(a.dataId),f=n.readSync(o.dataId),[p,m]=YC(u,i.shape,i.dtype,h,f);return n.makeTensorInfo(m,i.dtype,p)}},xF={kernelName:Qm,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{sparseIndices:a,sparseValues:o,defaultValue:u}=t,{outputShape:h}=i,{sliceRank:f,numUpdates:p,strides:m,outputSize:y}=Gh(0,a,h),b=new $I(p,f,a.shape.length,o.shape.length,m,[y,1],!1),T=n.runWebGLProgram(b,[o,a,u],o.dtype),R=Gn({inputs:{x:T},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(T),R}},wF={kernelName:li,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{numOrSizeSplits:o,axis:u}=i,h=lr(u,a.shape)[0],f=dy(a,o,h),m=new Array(a.shape.length).fill(0),y=a.shape.slice();return f.map(b=>{const T=[...y];T[h]=b;const R=WA({inputs:{x:a},backend:n,attrs:{begin:m,size:T}});return m[h]+=b,R})}},VI="return sqrt(x);",EF=bi({opSnippet:VI,packedOpSnippet:VI,cpuKernelImpl:_B}),CF={kernelName:Uu,backendName:"webgl",kernelFunc:EF},IF=bi({opSnippet:"return x * x;"}),SF={kernelName:Dt,backendName:"webgl",kernelFunc:IF},GI="return (a - b) * (a - b);",MF=uo({opSnippet:GI,packedOpSnippet:GI}),TF={kernelName:_s,backendName:"webgl",kernelFunc:MF},_F={kernelName:Al,backendName:"webgl",kernelFunc:function({inputs:r,attrs:t,backend:n}){const{x:i}=r,o=new xd(i.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return n.runWebGLProgram(o,[i],i.dtype)}};class kF{constructor(t,n,i){this.variableNames=["x"],this.outputShape=i;const a=i.length,o=ns(i.length),u=ns(i.length);let h="";if(1===a)h="coords * strides + begin";else{let f=0;h=i.map((p,m)=>(f++,1===i.length?`coords * strides[${m}] + begin[${m}]`:`coords[${f-1}] * strides[${m}] + begin[${m}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${t});\n      ${o} strides = ${o}(${n});\n\n      void main() {\n        ${u} coords = getOutputCoords();\n        setOutput(getX(${h}));\n      }\n    `}}const RF={kernelName:Vd,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{begin:o,end:u,strides:h,beginMask:f,endMask:p,ellipsisMask:m,newAxisMask:y,shrinkAxisMask:b}=i,{finalShapeSparse:T,finalShape:R,isIdentity:L,sliceDim0:V,isSimpleSlice:j,begin:H,end:nt,strides:dt}=g0(a.shape,o,u,h,f,p,m,y,b);let yt;if(L)yt=Gn({inputs:{x:a},backend:n,attrs:{shape:R}});else if(V||j){Z(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);const Ot=ag(H,nt,dt),Nt=WA({inputs:{x:a},backend:n,attrs:{begin:H,size:Ot}});yt=Gn({inputs:{x:Nt},backend:n,attrs:{shape:R}}),n.disposeIntermediateTensorInfo(Nt)}else if(n.shouldExecuteOnCPU([a])){const Ot=n.readSync(a.dataId),Nt=$r(a.shape,a.dtype,Ot),Vt=kB(T,Nt,dt,H);yt=n.makeTensorInfo(R,a.dtype,Vt.values)}else{const Ot=new kF(H,dt,T);yt=n.runWebGLProgram(Ot,[a],a.dtype)}const kt=Gn({inputs:{x:yt},backend:n,attrs:{shape:R}});return n.disposeIntermediateTensorInfo(yt),kt}},BF={kernelName:hf,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{separator:a,nGramWidths:o,leftPad:u,rightPad:h,padWidth:f,preserveShortSequences:p}=i,{data:m,dataSplits:y}=t,b=n.readSync(m.dataId),T=n.readSync(y.dataId),[R,L]=RB(b,T,a,o,u,h,f,p);return[n.makeTensorInfo([R.length],"string",R),n.makeTensorInfo(y.shape,"int32",L)]}},NF={kernelName:ta,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{skipEmpty:a}=i,{input:o,delimiter:u}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==u.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${u.shape}`);const h=n.readSync(o.dataId),f=n.readSync(u.dataId)[0],[p,m,y]=BB(h,f,a),b=m.length;return[n.makeTensorInfo([b,2],"int32",p),n.makeTensorInfo([b],"string",m),n.makeTensorInfo([2],"int32",new Int32Array(y))]}},DF={kernelName:ml,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{numBuckets:a}=i,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const u=n.readSync(o.dataId),h=NB(u,a);return n.makeTensorInfo(o.shape,"int32",h)}},LF=bi({opSnippet:"return tan(x);"}),FF={kernelName:Hc,backendName:"webgl",kernelFunc:LF},OF=bi({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),PF={kernelName:Vl,backendName:"webgl",kernelFunc:OF};class UF{constructor(t,n){this.variableNames=["A"];const i=new Array(t.length);for(let u=0;u<i.length;u++)i[u]=t[u]*n[u];this.outputShape=i,this.rank=i.length;const a=ns(this.rank),o=function(u){const h=u.length;if(h>5)throw Error(`Tile for rank ${h} is not yet supported`);if(1===h)return`imod(resRC, ${u[0]})`;const f=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],p=[];for(let m=0;m<u.length;m++)p.push(`imod(${f[m]}, ${u[m]})`);return p.join()}(t);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function QI(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{reps:o}=i;if("string"===a.dtype||a.shape.length>5){const h=n.readSync(a.dataId),f="string"===a.dtype?h.map(y=>Dh(y)):h,p=$r(a.shape,a.dtype,f),m=LB(p,o);return n.makeTensorInfo(m.shape,m.dtype,m.values)}const u=new UF(a.shape,o);return n.runWebGLProgram(u,[a],a.dtype)}const zF={kernelName:Gl,backendName:"webgl",kernelFunc:QI};class $F{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class VF{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Lm(r,t){null!==t&&r.disposeIntermediateTensorInfo(t)}function HI(r){let t=1;for(;t<r;)t*=2;return t}const GF={kernelName:Wc,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a}=t,{k:o,sorted:u}=i,h=de().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),f=de().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),p=a.shape,m=p[p.length-1];if(n.shouldExecuteOnCPU([a])||m<h||o>f){const Vt=n.readSync(a.dataId),[qt,Zt]=FB(Vt,p,a.dtype,o,u);return[n.makeTensorInfo(qt.shape,qt.dtype,qt.values),n.makeTensorInfo(Zt.shape,Zt.dtype,Zt.values)]}if(0===o)return p[p.length-1]=0,[n.makeTensorInfo(p,a.dtype,[]),n.makeTensorInfo(p,"int32",[])];if(1===m)return[a,c1({attrs:{shape:p,dtype:"int32",value:0},backend:n})];const y=n.texData.get(a.dataId),b=null!==y&&y.isPacked,T=b?n.unpackTensor(a):a,R=Wt(p)/m,L=Gn({inputs:{x:T},attrs:{shape:[R,m]},backend:n});b&&Lm(n,T);const V=HI(o),j=HI(m);let H=null;const nt=()=>null===H?[L,L]:[L,H],dt=(Vt,qt,Zt)=>{const te=nt(),ue=new $F(Zt),De=H;H=n.runWebGLProgram(ue,te,"int32",[[m],[null===H?1:0],[Number.NEGATIVE_INFINITY],[Vt],[qt]]),Lm(n,De)};for(let Vt=1;Vt<V;Vt*=2){const qt=2*Vt;for(let Zt=Vt;Zt>=1;Zt/=2)dt(qt,Zt,[R,j])}for(let Vt=j;Vt>V;Vt/=2){const qt=nt(),Zt=new VF([R,Vt/2]),ue=H;H=n.runWebGLProgram(Zt,qt,"int32",[[m],[null===H?1:0],[V]]),Lm(n,ue);const Ee=V/2,De=2*Ee;for(let we=Ee;we>=1;we/=2)dt(De,we,H.shape)}let yt=H;H=WA({inputs:{x:H},backend:n,attrs:{begin:0,size:[R,o]}}),Lm(n,yt);let kt=NI({inputs:{x:L,indices:H},backend:n,attrs:{axis:1,batchDims:1}});Lm(n,L);const Ot=p.slice(0,-1);Ot.push(o),yt=H,H=Gn({inputs:{x:H},attrs:{shape:Ot},backend:n}),Lm(n,yt);const Nt=kt;return kt=Gn({inputs:{x:kt},attrs:{shape:Ot},backend:n}),Lm(n,Nt),[kt,H]}};class QF{constructor(t,n,i,a,o,u){this.variableNames=["Image","Transforms"],this.outputShape=u;const h="nearest"===i?1:2;let f;switch(a){case"constant":default:f=1;break;case"reflect":f=2;break;case"wrap":f=3;break;case"nearest":f=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${f} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${f} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${f} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${n}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${h} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const HF={kernelName:Ql,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{image:a,transforms:o}=t,{interpolation:u,fillMode:h,fillValue:f,outputShape:p}=i,[m,y,b,T]=a.shape,[R,L]=p??[y,b],V=new QF(y,b,u,h,f,[m,R,L,T]);return n.runWebGLProgram(V,[a,o],"float32")}},WF={kernelName:uc,backendName:"webgl",kernelFunc:function(r){const{inputs:t,attrs:n,backend:i}=r,{axis:a}=n,{x:o}=t;i1(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const u=i.readSync(o.dataId),{outputValues:h,outputShape:f,indices:p}=OB(u,a,o.shape,o.dtype);return[i.makeTensorInfo(f,o.dtype,h),i.makeTensorInfo([p.length],"int32",p)]}},jF={kernelName:jc,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{value:a}=t;let{axis:o}=i;o<0&&(o+=a.shape.length);const u=a,h=u.shape.length,f=a.shape[o],p=new Array(h-1);let m=0;for(let L=0;L<h;L++)L!==o&&(p[m++]=u.shape[L]);const y=[],b=new Array(h).fill(0),T=u.shape.slice();T[o]=1;const R=new Array(f);for(let L=0;L<R.length;L++){b[o]=L;const V=WA({inputs:{x:u},backend:n,attrs:{begin:b,size:T}}),j=Gn({inputs:{x:V},backend:n,attrs:{shape:p}});R[L]=j,y.push(V)}return y.forEach(L=>n.disposeIntermediateTensorInfo(L)),R}};class qF{constructor(t,n){this.variableNames=["x","segmentIds"];const i=t.windowSize,a=t.batchSize,o=t.inSize,u=t.numSegments,h=u*Math.ceil(o/i);this.outputShape=[a,h];const f=4*Math.floor(i/4),p=i%4,m="\n        sumValue += dot(values, segFilter);\n    ";let y="";o%i>0&&(y=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let b="";o%i>0&&(b=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${y}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${b}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${u})) * float(${i}));\n        int currentSeg = int(mod(float(outIdx), float(${u})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${f}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${m}\n        }\n\n        int inIdx = inOffset + ${f};\n        if (${1===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${m}\n        } else if (${2===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${m}\n        } else if (${3===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${m}\n        }\n        setOutput(sumValue);\n      }\n    `}}const XF=[tN,eN,rN,sN,oN,uN,hN,dN,mN,gN,yN,bN,wN,CN,SN,MN,TN,RN,BN,NN,FN,zN,$N,VN,HN,jN,YN,QB,JN,nD,sD,uD,hD,dD,pD,fD,gD,yD,bD,xD,wD,CD,ID,TD,_D,RD,ND,DD,FD,OD,UD,$D,VD,GD,HD,WD,qD,YD,JD,tL,rL,iL,sL,oL,cL,hL,pL,GB,fL,eD,gL,yL,bL,HB,wL,CL,IL,ML,_L,RL,NL,LL,PL,zL,$L,GL,QL,HL,qL,XL,YL,KL,JL,t4,r4,s4,u4,jB,h4,p4,m4,A4,GN,v4,x4,w4,I4,M4,WB,T4,_4,QN,o4,R4,N4,L4,qB,P4,z4,G4,H4,q4,Y4,J4,tF,eF,rF,sF,oF,cF,hF,pF,UN,c4,mF,gF,AF,yF,vF,bF,xF,wF,CF,SF,TF,_F,RF,BF,NF,DF,l4,JB,FF,PF,zF,GF,HF,ZB,WF,jF,{kernelName:zu,backendName:"webgl",kernelFunc:function(r){const{inputs:t,backend:n,attrs:i}=r,{x:a,segmentIds:o}=t,{numSegments:u}=i,h=a.shape.length,f=[];let p=0;const m=vs([p],h);let y=a;null!=m&&(y=$o({inputs:{x:a},backend:n,attrs:{perm:m}}),f.push(y),p=Ai(1,h)[0]);const b=Ay(y.shape,p,u),T=Wt([y.shape[p]]),R=Gn({inputs:{x:y},backend:n,attrs:{shape:[-1,T]}});f.push(R);const L=no(a.dtype),V=(nt,dt,yt,kt,Ot)=>{const Nt=nt.shape[0],Vt=nt.shape[1],qt=mv(Vt,Ot),Zt=new qF({windowSize:qt,inSize:Vt,batchSize:Nt,numSegments:Ot},dt),te=n.compileAndRun(Zt,[nt,yt],kt);if(f.push(te),te.shape[1]===Ot)return te;const ue=zI({backend:n,attrs:{start:0,stop:Ot,step:1,dtype:"float32"}}),Ee=QI({inputs:{x:ue},backend:n,attrs:{reps:[Vt/qt]}});return f.push(ue),f.push(Ee),V(te,dt,Ee,kt,Ot)},j=Gn({inputs:{x:V(R,"unsortedSegmentSum",o,L,u)},backend:n,attrs:{shape:b}});let H=j;if(null!=m){f.push(j);const nt=Jh(m);H=$o({inputs:{x:H},backend:n,attrs:{perm:nt}})}return f.forEach(nt=>n.disposeIntermediateTensorInfo(nt)),H}},b4];for(const r of XF)hc(r);const YF={"tfjs-core":N1,"tfjs-backend-cpu":"3.13.0","tfjs-backend-webgl":"3.13.0","tfjs-data":k2,"tfjs-layers":Nc,"tfjs-converter":h2,tfjs:"3.13.0"}},8485:(ot,ht,I)=>{"use strict";I.d(ht,{Z:()=>O});var U=I(3645),$=I.n(U)()(function(N){return N[1]});$.push([ot.id,".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:transparent;z-index:2}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid #fff;opacity:0.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:black;color:white;opacity:0.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media (min-aspect-ratio: 1 / 1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media (max-aspect-ratio: 1 / 1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:0.8;background:linear-gradient(to right, #fff 10px, transparent 10px) 0 0,linear-gradient(to right, #fff 10px, transparent 10px) 0 100%,linear-gradient(to left, #fff 10px, transparent 10px) 100% 0,linear-gradient(to left, #fff 10px, transparent 10px) 100% 100%,linear-gradient(to bottom, #fff 10px, transparent 10px) 0 0,linear-gradient(to bottom, #fff 10px, transparent 10px) 100% 0,linear-gradient(to top, #fff 10px, transparent 10px) 0 100%,linear-gradient(to top, #fff 10px, transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:#fff;animation:move 2s linear infinite}@keyframes move{0%,100%{top:0%}50%{top:calc(100% - 10px)}}\n",""]);const O=$},3645:ot=>{"use strict";ot.exports=function(ht){var I=[];return I.toString=function(){return this.map(function(U){var $=ht(U);return U[2]?"@media ".concat(U[2]," {").concat($,"}"):$}).join("")},I.i=function(U,$,O){"string"==typeof U&&(U=[[null,U,""]]);var N={};if(O)for(var _=0;_<this.length;_++){var E=this[_][0];null!=E&&(N[E]=!0)}for(var D=0;D<U.length;D++){var B=[].concat(U[D]);O&&N[B[0]]||($&&(B[2]=B[2]?"".concat($," and ").concat(B[2]):$),I.push(B))}},I}},7676:(ot,ht,I)=>{"use strict";I.d(ht,{Z:()=>U});const U='<div class="mindar-ui-overlay mindar-ui-compatibility"> <div class="content"> <h1>Failed to launch :(</h1> <p> Looks like your device/browser is not compatible. </p> <br/> <br/> <p> Please try the following recommended browsers: </p> <p> For Android device - Chrome </p> <p> For iOS device - Safari </p> </div> </div> '},9894:(ot,ht,I)=>{"use strict";I.d(ht,{Z:()=>U});const U='<div class="mindar-ui-overlay mindar-ui-loading"> <div class="loader"/> </div> '},2810:(ot,ht,I)=>{"use strict";I.d(ht,{Z:()=>U});const U='<div class="mindar-ui-overlay mindar-ui-scanning"> <div class="scanning"> <div class="inner"> <div class="scanline"/> </div> </div> </div> '},3720:ot=>{ot.exports=I;var ht=null;try{ht=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function I(et,xt,Rt){this.low=0|et,this.high=0|xt,this.unsigned=!!Rt}function U(et){return!0===(et&&et.__isLong__)}Object.defineProperty(I.prototype,"__isLong__",{value:!0}),I.isLong=U;var $={},O={};function N(et,xt){var Rt,Yt,ve;return xt?(ve=0<=(et>>>=0)&&et<256)&&(Yt=O[et])?Yt:(Rt=E(et,(0|et)<0?-1:0,!0),ve&&(O[et]=Rt),Rt):(ve=-128<=(et|=0)&&et<128)&&(Yt=$[et])?Yt:(Rt=E(et,et<0?-1:0,!1),ve&&($[et]=Rt),Rt)}function _(et,xt){if(isNaN(et))return xt?X:Q;if(xt){if(et<0)return X;if(et>=k)return bt}else{if(et<=-F)return ft;if(et+1>=F)return vt}return et<0?_(-et,xt).neg():E(et%M|0,et/M|0,xt)}function E(et,xt,Rt){return new I(et,xt,Rt)}I.fromInt=N,I.fromNumber=_,I.fromBits=E;var D=Math.pow;function B(et,xt,Rt){if(0===et.length)throw Error("empty string");if("NaN"===et||"Infinity"===et||"+Infinity"===et||"-Infinity"===et)return Q;if("number"==typeof xt?(Rt=xt,xt=!1):xt=!!xt,(Rt=Rt||10)<2||36<Rt)throw RangeError("radix");var Yt;if((Yt=et.indexOf("-"))>0)throw Error("interior hyphen");if(0===Yt)return B(et.substring(1),xt,Rt).neg();for(var ve=_(D(Rt,8)),xe=Q,Ge=0;Ge<et.length;Ge+=8){var en=Math.min(8,et.length-Ge),nn=parseInt(et.substring(Ge,Ge+en),Rt);if(en<8){var vn=_(D(Rt,en));xe=xe.mul(vn).add(_(nn))}else xe=(xe=xe.mul(ve)).add(_(nn))}return xe.unsigned=xt,xe}function C(et,xt){return"number"==typeof et?_(et,xt):"string"==typeof et?B(et,xt):E(et.low,et.high,"boolean"==typeof xt?xt:et.unsigned)}I.fromString=B,I.fromValue=C;var M=4294967296,k=M*M,F=k/2,G=N(1<<24),Q=N(0);I.ZERO=Q;var X=N(0,!0);I.UZERO=X;var lt=N(1);I.ONE=lt;var rt=N(1,!0);I.UONE=rt;var pt=N(-1);I.NEG_ONE=pt;var vt=E(-1,2147483647,!1);I.MAX_VALUE=vt;var bt=E(-1,-1,!0);I.MAX_UNSIGNED_VALUE=bt;var ft=E(0,-2147483648,!1);I.MIN_VALUE=ft;var wt=I.prototype;wt.toInt=function(){return this.unsigned?this.low>>>0:this.low},wt.toNumber=function(){return this.unsigned?(this.high>>>0)*M+(this.low>>>0):this.high*M+(this.low>>>0)},wt.toString=function(et){if((et=et||10)<2||36<et)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(ft)){var xt=_(et),Rt=this.div(xt),Yt=Rt.mul(xt).sub(this);return Rt.toString(et)+Yt.toInt().toString(et)}return"-"+this.neg().toString(et)}for(var ve=_(D(et,6),this.unsigned),xe=this,Ge="";;){var en=xe.div(ve),nn=(xe.sub(en.mul(ve)).toInt()>>>0).toString(et);if((xe=en).isZero())return nn+Ge;for(;nn.length<6;)nn="0"+nn;Ge=""+nn+Ge}},wt.getHighBits=function(){return this.high},wt.getHighBitsUnsigned=function(){return this.high>>>0},wt.getLowBits=function(){return this.low},wt.getLowBitsUnsigned=function(){return this.low>>>0},wt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ft)?64:this.neg().getNumBitsAbs();for(var et=0!=this.high?this.high:this.low,xt=31;xt>0&&!(et&1<<xt);xt--);return 0!=this.high?xt+33:xt+1},wt.isZero=function(){return 0===this.high&&0===this.low},wt.eqz=wt.isZero,wt.isNegative=function(){return!this.unsigned&&this.high<0},wt.isPositive=function(){return this.unsigned||this.high>=0},wt.isOdd=function(){return 1==(1&this.low)},wt.isEven=function(){return 0==(1&this.low)},wt.equals=function(et){return U(et)||(et=C(et)),(this.unsigned===et.unsigned||this.high>>>31!=1||et.high>>>31!=1)&&this.high===et.high&&this.low===et.low},wt.eq=wt.equals,wt.notEquals=function(et){return!this.eq(et)},wt.neq=wt.notEquals,wt.ne=wt.notEquals,wt.lessThan=function(et){return this.comp(et)<0},wt.lt=wt.lessThan,wt.lessThanOrEqual=function(et){return this.comp(et)<=0},wt.lte=wt.lessThanOrEqual,wt.le=wt.lessThanOrEqual,wt.greaterThan=function(et){return this.comp(et)>0},wt.gt=wt.greaterThan,wt.greaterThanOrEqual=function(et){return this.comp(et)>=0},wt.gte=wt.greaterThanOrEqual,wt.ge=wt.greaterThanOrEqual,wt.compare=function(et){if(U(et)||(et=C(et)),this.eq(et))return 0;var xt=this.isNegative(),Rt=et.isNegative();return xt&&!Rt?-1:!xt&&Rt?1:this.unsigned?et.high>>>0>this.high>>>0||et.high===this.high&&et.low>>>0>this.low>>>0?-1:1:this.sub(et).isNegative()?-1:1},wt.comp=wt.compare,wt.negate=function(){return!this.unsigned&&this.eq(ft)?ft:this.not().add(lt)},wt.neg=wt.negate,wt.add=function(et){U(et)||(et=C(et));var nn=0,vn=0,_n=0,nr=0;return _n+=(nr+=(65535&this.low)+(65535&et.low))>>>16,vn+=(_n+=(this.low>>>16)+(et.low>>>16))>>>16,nn+=(vn+=(65535&this.high)+(65535&et.high))>>>16,nn+=(this.high>>>16)+(et.high>>>16),E((_n&=65535)<<16|(nr&=65535),(nn&=65535)<<16|(vn&=65535),this.unsigned)},wt.subtract=function(et){return U(et)||(et=C(et)),this.add(et.neg())},wt.sub=wt.subtract,wt.multiply=function(et){if(this.isZero())return Q;if(U(et)||(et=C(et)),ht)return E(ht.mul(this.low,this.high,et.low,et.high),ht.get_high(),this.unsigned);if(et.isZero())return Q;if(this.eq(ft))return et.isOdd()?ft:Q;if(et.eq(ft))return this.isOdd()?ft:Q;if(this.isNegative())return et.isNegative()?this.neg().mul(et.neg()):this.neg().mul(et).neg();if(et.isNegative())return this.mul(et.neg()).neg();if(this.lt(G)&&et.lt(G))return _(this.toNumber()*et.toNumber(),this.unsigned);var Rt=65535&this.high,Yt=this.low>>>16,ve=65535&this.low,Ge=65535&et.high,en=et.low>>>16,nn=65535&et.low,vn=0,_n=0,nr=0,hr=0;return nr+=(hr+=ve*nn)>>>16,_n+=(nr+=Yt*nn)>>>16,nr&=65535,_n+=(nr+=ve*en)>>>16,vn+=(_n+=Rt*nn)>>>16,_n&=65535,vn+=(_n+=Yt*en)>>>16,_n&=65535,vn+=(_n+=ve*Ge)>>>16,vn+=(this.high>>>16)*nn+Rt*en+Yt*Ge+ve*(et.high>>>16),E((nr&=65535)<<16|(hr&=65535),(vn&=65535)<<16|(_n&=65535),this.unsigned)},wt.mul=wt.multiply,wt.divide=function(et){if(U(et)||(et=C(et)),et.isZero())throw Error("division by zero");var xt,Rt,Yt;if(ht)return this.unsigned||-2147483648!==this.high||-1!==et.low||-1!==et.high?E((this.unsigned?ht.div_u:ht.div_s)(this.low,this.high,et.low,et.high),ht.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?X:Q;if(this.unsigned){if(et.unsigned||(et=et.toUnsigned()),et.gt(this))return X;if(et.gt(this.shru(1)))return rt;Yt=X}else{if(this.eq(ft))return et.eq(lt)||et.eq(pt)?ft:et.eq(ft)?lt:(xt=this.shr(1).div(et).shl(1)).eq(Q)?et.isNegative()?lt:pt:(Rt=this.sub(et.mul(xt)),Yt=xt.add(Rt.div(et)));if(et.eq(ft))return this.unsigned?X:Q;if(this.isNegative())return et.isNegative()?this.neg().div(et.neg()):this.neg().div(et).neg();if(et.isNegative())return this.div(et.neg()).neg();Yt=Q}for(Rt=this;Rt.gte(et);){xt=Math.max(1,Math.floor(Rt.toNumber()/et.toNumber()));for(var ve=Math.ceil(Math.log(xt)/Math.LN2),xe=ve<=48?1:D(2,ve-48),Ge=_(xt),en=Ge.mul(et);en.isNegative()||en.gt(Rt);)en=(Ge=_(xt-=xe,this.unsigned)).mul(et);Ge.isZero()&&(Ge=lt),Yt=Yt.add(Ge),Rt=Rt.sub(en)}return Yt},wt.div=wt.divide,wt.modulo=function(et){return U(et)||(et=C(et)),ht?E((this.unsigned?ht.rem_u:ht.rem_s)(this.low,this.high,et.low,et.high),ht.get_high(),this.unsigned):this.sub(this.div(et).mul(et))},wt.mod=wt.modulo,wt.rem=wt.modulo,wt.not=function(){return E(~this.low,~this.high,this.unsigned)},wt.and=function(et){return U(et)||(et=C(et)),E(this.low&et.low,this.high&et.high,this.unsigned)},wt.or=function(et){return U(et)||(et=C(et)),E(this.low|et.low,this.high|et.high,this.unsigned)},wt.xor=function(et){return U(et)||(et=C(et)),E(this.low^et.low,this.high^et.high,this.unsigned)},wt.shiftLeft=function(et){return U(et)&&(et=et.toInt()),0==(et&=63)?this:et<32?E(this.low<<et,this.high<<et|this.low>>>32-et,this.unsigned):E(0,this.low<<et-32,this.unsigned)},wt.shl=wt.shiftLeft,wt.shiftRight=function(et){return U(et)&&(et=et.toInt()),0==(et&=63)?this:et<32?E(this.low>>>et|this.high<<32-et,this.high>>et,this.unsigned):E(this.high>>et-32,this.high>=0?0:-1,this.unsigned)},wt.shr=wt.shiftRight,wt.shiftRightUnsigned=function(et){if(U(et)&&(et=et.toInt()),0==(et&=63))return this;var xt=this.high;return et<32?E(this.low>>>et|xt<<32-et,xt>>>et,this.unsigned):E(32===et?xt:xt>>>et-32,0,this.unsigned)},wt.shru=wt.shiftRightUnsigned,wt.shr_u=wt.shiftRightUnsigned,wt.toSigned=function(){return this.unsigned?E(this.low,this.high,!1):this},wt.toUnsigned=function(){return this.unsigned?this:E(this.low,this.high,!0)},wt.toBytes=function(et){return et?this.toBytesLE():this.toBytesBE()},wt.toBytesLE=function(){var et=this.high,xt=this.low;return[255&xt,xt>>>8&255,xt>>>16&255,xt>>>24,255&et,et>>>8&255,et>>>16&255,et>>>24]},wt.toBytesBE=function(){var et=this.high,xt=this.low;return[et>>>24,et>>>16&255,et>>>8&255,255&et,xt>>>24,xt>>>16&255,xt>>>8&255,255&xt]},I.fromBytes=function(et,xt,Rt){return Rt?I.fromBytesLE(et,xt):I.fromBytesBE(et,xt)},I.fromBytesLE=function(et,xt){return new I(et[0]|et[1]<<8|et[2]<<16|et[3]<<24,et[4]|et[5]<<8|et[6]<<16|et[7]<<24,xt)},I.fromBytesBE=function(et,xt){return new I(et[4]<<24|et[5]<<16|et[6]<<8|et[7],et[0]<<24|et[1]<<16|et[2]<<8|et[3],xt)}},6377:(ot,ht,I)=>{var U=I(4832),$=I(8652),O=I(801),N=I(2030),_=I(3618),E=I(9049),D=I(1971);D.alea=U,D.xor128=$,D.xorwow=O,D.xorshift7=N,D.xor4096=_,D.tychei=E,ot.exports=D},4832:function(ot,ht,I){var U;!function($,O,N){function _(B){var C,M=this,k=(C=4022871197,function(F){F=F.toString();for(var G=0;G<F.length;G++){var Q=.02519603282416938*(C+=F.charCodeAt(G));Q-=C=Q>>>0,C=(Q*=C)>>>0,C+=4294967296*(Q-=C)}return 2.3283064365386963e-10*(C>>>0)});M.next=function(){var F=2091639*M.s0+2.3283064365386963e-10*M.c;return M.s0=M.s1,M.s1=M.s2,M.s2=F-(M.c=0|F)},M.c=1,M.s0=k(" "),M.s1=k(" "),M.s2=k(" "),M.s0-=k(B),M.s0<0&&(M.s0+=1),M.s1-=k(B),M.s1<0&&(M.s1+=1),M.s2-=k(B),M.s2<0&&(M.s2+=1),k=null}function E(B,C){return C.c=B.c,C.s0=B.s0,C.s1=B.s1,C.s2=B.s2,C}function D(B,C){var M=new _(B),k=C&&C.state,F=M.next;return F.int32=function(){return 4294967296*M.next()|0},F.double=function(){return F()+11102230246251565e-32*(2097152*F()|0)},F.quick=F,k&&("object"==typeof k&&E(k,M),F.state=function(){return E(M,{})}),F}O&&O.exports?O.exports=D:I.amdD&&I.amdO?void 0===(U=function(){return D}.call(ht,I,ht,O))||(O.exports=U):this.alea=D}(0,ot=I.nmd(ot))},9049:function(ot,ht,I){var U;!function($,O,N){function _(B){var C=this,M="";C.next=function(){var F=C.b,G=C.c,Q=C.d,X=C.a;return F=F<<25^F>>>7^G,G=G-Q|0,Q=Q<<24^Q>>>8^X,X=X-F|0,C.b=F=F<<20^F>>>12^G,C.c=G=G-Q|0,C.d=Q<<16^G>>>16^X,C.a=X-F|0},C.a=0,C.b=0,C.c=-1640531527,C.d=1367130551,B===Math.floor(B)?(C.a=B/4294967296|0,C.b=0|B):M+=B;for(var k=0;k<M.length+20;k++)C.b^=0|M.charCodeAt(k),C.next()}function E(B,C){return C.a=B.a,C.b=B.b,C.c=B.c,C.d=B.d,C}function D(B,C){var M=new _(B),k=C&&C.state,F=function(){return(M.next()>>>0)/4294967296};return F.double=function(){do{var G=((M.next()>>>11)+(M.next()>>>0)/4294967296)/2097152}while(0===G);return G},F.int32=M.next,F.quick=F,k&&("object"==typeof k&&E(k,M),F.state=function(){return E(M,{})}),F}O&&O.exports?O.exports=D:I.amdD&&I.amdO?void 0===(U=function(){return D}.call(ht,I,ht,O))||(O.exports=U):this.tychei=D}(0,ot=I.nmd(ot))},8652:function(ot,ht,I){var U;!function($,O,N){function _(B){var C=this,M="";C.x=0,C.y=0,C.z=0,C.w=0,C.next=function(){var F=C.x^C.x<<11;return C.x=C.y,C.y=C.z,C.z=C.w,C.w^=C.w>>>19^F^F>>>8},B===(0|B)?C.x=B:M+=B;for(var k=0;k<M.length+64;k++)C.x^=0|M.charCodeAt(k),C.next()}function E(B,C){return C.x=B.x,C.y=B.y,C.z=B.z,C.w=B.w,C}function D(B,C){var M=new _(B),k=C&&C.state,F=function(){return(M.next()>>>0)/4294967296};return F.double=function(){do{var G=((M.next()>>>11)+(M.next()>>>0)/4294967296)/2097152}while(0===G);return G},F.int32=M.next,F.quick=F,k&&("object"==typeof k&&E(k,M),F.state=function(){return E(M,{})}),F}O&&O.exports?O.exports=D:I.amdD&&I.amdO?void 0===(U=function(){return D}.call(ht,I,ht,O))||(O.exports=U):this.xor128=D}(0,ot=I.nmd(ot))},3618:function(ot,ht,I){var U;!function($,O,N){function _(B){var C=this;C.next=function(){var M,k,F=C.w,G=C.X,Q=C.i;return C.w=F=F+1640531527|0,k=G[Q+34&127],M=G[Q=Q+1&127],k^=k<<13,M^=M<<17,k=G[Q]=(k^=k>>>15)^(M^=M>>>12),C.i=Q,k+(F^F>>>16)|0},function(M,k){var F,G,Q,X,lt,rt=[],pt=128;for(k===(0|k)?(G=k,k=null):(k+="\0",G=0,pt=Math.max(pt,k.length)),Q=0,X=-32;X<pt;++X)k&&(G^=k.charCodeAt((X+32)%k.length)),0===X&&(lt=G),G^=G<<10,G^=G>>>15,G^=G<<4,G^=G>>>13,X>=0&&(Q=0==(F=rt[127&X]^=G+(lt=lt+1640531527|0))?Q+1:0);for(Q>=128&&(rt[127&(k&&k.length||0)]=-1),Q=127,X=512;X>0;--X)G=rt[Q+34&127],F=rt[Q=Q+1&127],G^=G<<13,F^=F<<17,rt[Q]=(G^=G>>>15)^(F^=F>>>12);M.w=lt,M.X=rt,M.i=Q}(C,B)}function E(B,C){return C.i=B.i,C.w=B.w,C.X=B.X.slice(),C}function D(B,C){null==B&&(B=+new Date);var M=new _(B),k=C&&C.state,F=function(){return(M.next()>>>0)/4294967296};return F.double=function(){do{var G=((M.next()>>>11)+(M.next()>>>0)/4294967296)/2097152}while(0===G);return G},F.int32=M.next,F.quick=F,k&&(k.X&&E(k,M),F.state=function(){return E(M,{})}),F}O&&O.exports?O.exports=D:I.amdD&&I.amdO?void 0===(U=function(){return D}.call(ht,I,ht,O))||(O.exports=U):this.xor4096=D}(0,ot=I.nmd(ot))},2030:function(ot,ht,I){var U;!function($,O,N){function _(B){var C=this;C.next=function(){var M,k,F=C.x,G=C.i;return M=F[G],k=(M^=M>>>7)^M<<24,k^=(M=F[G+1&7])^M>>>10,k^=(M=F[G+3&7])^M>>>3,k^=(M=F[G+4&7])^M<<7,M=F[G+7&7],k^=(M^=M<<13)^M<<9,F[G]=k,C.i=G+1&7,k},function(M,k){var F,G=[];if(k===(0|k))G[0]=k;else for(k=""+k,F=0;F<k.length;++F)G[7&F]=G[7&F]<<15^k.charCodeAt(F)+G[F+1&7]<<13;for(;G.length<8;)G.push(0);for(F=0;F<8&&0===G[F];++F);for(8==F&&(G[7]=-1),M.x=G,M.i=0,F=256;F>0;--F)M.next()}(C,B)}function E(B,C){return C.x=B.x.slice(),C.i=B.i,C}function D(B,C){null==B&&(B=+new Date);var M=new _(B),k=C&&C.state,F=function(){return(M.next()>>>0)/4294967296};return F.double=function(){do{var G=((M.next()>>>11)+(M.next()>>>0)/4294967296)/2097152}while(0===G);return G},F.int32=M.next,F.quick=F,k&&(k.x&&E(k,M),F.state=function(){return E(M,{})}),F}O&&O.exports?O.exports=D:I.amdD&&I.amdO?void 0===(U=function(){return D}.call(ht,I,ht,O))||(O.exports=U):this.xorshift7=D}(0,ot=I.nmd(ot))},801:function(ot,ht,I){var U;!function($,O,N){function _(B){var C=this,M="";C.next=function(){var F=C.x^C.x>>>2;return C.x=C.y,C.y=C.z,C.z=C.w,C.w=C.v,(C.d=C.d+362437|0)+(C.v=C.v^C.v<<4^F^F<<1)|0},C.x=0,C.y=0,C.z=0,C.w=0,C.v=0,B===(0|B)?C.x=B:M+=B;for(var k=0;k<M.length+64;k++)C.x^=0|M.charCodeAt(k),k==M.length&&(C.d=C.x<<10^C.x>>>4),C.next()}function E(B,C){return C.x=B.x,C.y=B.y,C.z=B.z,C.w=B.w,C.v=B.v,C.d=B.d,C}function D(B,C){var M=new _(B),k=C&&C.state,F=function(){return(M.next()>>>0)/4294967296};return F.double=function(){do{var G=((M.next()>>>11)+(M.next()>>>0)/4294967296)/2097152}while(0===G);return G},F.int32=M.next,F.quick=F,k&&("object"==typeof k&&E(k,M),F.state=function(){return E(M,{})}),F}O&&O.exports?O.exports=D:I.amdD&&I.amdO?void 0===(U=function(){return D}.call(ht,I,ht,O))||(O.exports=U):this.xorwow=D}(0,ot=I.nmd(ot))},1971:(ot,ht,I)=>{var U;!function($,O){var N,_=this,E=256,D=O.pow(E,6),B=O.pow(2,52),C=2*B,M=255;function k(rt,pt,vt){var bt=[],ft=X(Q((pt=1==pt?{entropy:!0}:pt||{}).entropy?[rt,lt($)]:rt??function(){try{var xt;return N&&(xt=N.randomBytes)?xt=xt(E):(xt=new Uint8Array(E),(_.crypto||_.msCrypto).getRandomValues(xt)),lt(xt)}catch{var Rt=_.navigator,Yt=Rt&&Rt.plugins;return[+new Date,_,Yt,_.screen,lt($)]}}(),3),bt),wt=new F(bt),et=function(){for(var xt=wt.g(6),Rt=D,Yt=0;xt<B;)xt=(xt+Yt)*E,Rt*=E,Yt=wt.g(1);for(;xt>=C;)xt/=2,Rt/=2,Yt>>>=1;return(xt+Yt)/Rt};return et.int32=function(){return 0|wt.g(4)},et.quick=function(){return wt.g(4)/4294967296},et.double=et,X(lt(wt.S),$),(pt.pass||vt||function(xt,Rt,Yt,ve){return ve&&(ve.S&&G(ve,wt),xt.state=function(){return G(wt,{})}),Yt?(O.random=xt,Rt):xt})(et,ft,"global"in pt?pt.global:this==O,pt.state)}function F(rt){var pt,vt=rt.length,bt=this,ft=0,wt=bt.i=bt.j=0,et=bt.S=[];for(vt||(rt=[vt++]);ft<E;)et[ft]=ft++;for(ft=0;ft<E;ft++)et[ft]=et[wt=M&wt+rt[ft%vt]+(pt=et[ft])],et[wt]=pt;(bt.g=function(xt){for(var Rt,Yt=0,ve=bt.i,xe=bt.j,Ge=bt.S;xt--;)Rt=Ge[ve=M&ve+1],Yt=Yt*E+Ge[M&(Ge[ve]=Ge[xe=M&xe+Rt])+(Ge[xe]=Rt)];return bt.i=ve,bt.j=xe,Yt})(E)}function G(rt,pt){return pt.i=rt.i,pt.j=rt.j,pt.S=rt.S.slice(),pt}function Q(rt,pt){var vt,bt=[],ft=typeof rt;if(pt&&"object"==ft)for(vt in rt)try{bt.push(Q(rt[vt],pt-1))}catch{}return bt.length?bt:"string"==ft?rt:rt+"\0"}function X(rt,pt){for(var vt,bt=rt+"",ft=0;ft<bt.length;)pt[M&ft]=M&(vt^=19*pt[M&ft])+bt.charCodeAt(ft++);return lt(pt)}function lt(rt){return String.fromCharCode.apply(0,rt)}if(O.seedrandom=k,X(O.random(),$),ot.exports){ot.exports=k;try{N=I(3906)}catch{}}else void 0===(U=function(){return k}.call(ht,I,ht,ot))||(ot.exports=U)}([],Math)},4412:(ot,ht,I)=>{"use strict";I.r(ht),I.d(ht,{default:()=>N});var U=I(3379),$=I.n(U),O=I(8485);$()(O.Z,{insert:"head",singleton:!1});const N=O.Z.locals||{}},3379:(ot,ht,I)=>{"use strict";var U,Q,$=(Q={},function(X){if(void 0===Q[X]){var lt=document.querySelector(X);if(window.HTMLIFrameElement&&lt instanceof window.HTMLIFrameElement)try{lt=lt.contentDocument.head}catch{lt=null}Q[X]=lt}return Q[X]}),O=[];function N(Q){for(var X=-1,lt=0;lt<O.length;lt++)if(O[lt].identifier===Q){X=lt;break}return X}function _(Q,X){for(var lt={},rt=[],pt=0;pt<Q.length;pt++){var vt=Q[pt],bt=X.base?vt[0]+X.base:vt[0],ft=lt[bt]||0,wt="".concat(bt," ").concat(ft);lt[bt]=ft+1;var et=N(wt),xt={css:vt[1],media:vt[2],sourceMap:vt[3]};-1!==et?(O[et].references++,O[et].updater(xt)):O.push({identifier:wt,updater:G(xt,X),references:1}),rt.push(wt)}return rt}function E(Q){var X=document.createElement("style"),lt=Q.attributes||{};if(void 0===lt.nonce){var rt=I.nc;rt&&(lt.nonce=rt)}if(Object.keys(lt).forEach(function(vt){X.setAttribute(vt,lt[vt])}),"function"==typeof Q.insert)Q.insert(X);else{var pt=$(Q.insert||"head");if(!pt)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");pt.appendChild(X)}return X}var D,B=(D=[],function(Q,X){return D[Q]=X,D.filter(Boolean).join("\n")});function C(Q,X,lt,rt){var pt=lt?"":rt.media?"@media ".concat(rt.media," {").concat(rt.css,"}"):rt.css;if(Q.styleSheet)Q.styleSheet.cssText=B(X,pt);else{var vt=document.createTextNode(pt),bt=Q.childNodes;bt[X]&&Q.removeChild(bt[X]),bt.length?Q.insertBefore(vt,bt[X]):Q.appendChild(vt)}}function M(Q,X,lt){var rt=lt.css,pt=lt.media,vt=lt.sourceMap;if(pt?Q.setAttribute("media",pt):Q.removeAttribute("media"),vt&&typeof btoa<"u"&&(rt+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(vt))))," */")),Q.styleSheet)Q.styleSheet.cssText=rt;else{for(;Q.firstChild;)Q.removeChild(Q.firstChild);Q.appendChild(document.createTextNode(rt))}}var k=null,F=0;function G(Q,X){var lt,rt,pt;if(X.singleton){var vt=F++;lt=k||(k=E(X)),rt=C.bind(null,lt,vt,!1),pt=C.bind(null,lt,vt,!0)}else lt=E(X),rt=M.bind(null,lt,X),pt=function(){!function(bt){if(null===bt.parentNode)return!1;bt.parentNode.removeChild(bt)}(lt)};return rt(Q),function(bt){if(bt){if(bt.css===Q.css&&bt.media===Q.media&&bt.sourceMap===Q.sourceMap)return;rt(Q=bt)}else pt()}}ot.exports=function(Q,X){(X=X||{}).singleton||"boolean"==typeof X.singleton||(X.singleton=(void 0===U&&(U=!(!(window&&document&&document.all)||window.atob)),U));var lt=_(Q=Q||[],X);return function(rt){if(rt=rt||[],"[object Array]"===Object.prototype.toString.call(rt)){for(var pt=0;pt<lt.length;pt++){var vt=N(lt[pt]);O[vt].references--}for(var bt=_(rt,X),ft=0;ft<lt.length;ft++){var wt=N(lt[ft]);0===O[wt].references&&(O[wt].updater(),O.splice(wt,1))}lt=bt}}}},383:(ot,ht,I)=>{ot.exports=function(){return I(9855)('(()=>{var t={508:(t,e,r)=>{const{resize:a}=r(140);t.exports={buildImageList:t=>{const e=[];let r=100/Math.min(t.width,t.height);for(;;)if(e.push(r),r*=Math.pow(2,1/3),r>=.95){r=1;break}e.push(r),e.reverse();const i=[];for(let r=0;r<e.length;r++)t.width,e[r],t.height,e[r],i.push(Object.assign(a({image:t,ratio:e[r]}),{scale:e[r]}));return i},buildTrackingImageList:t=>{const e=Math.min(t.width,t.height),r=[],i=[];r.push(256/e),r.push(128/e);for(let e=0;e<r.length;e++)i.push(Object.assign(a({image:t,ratio:r[e]}),{scale:r[e]}));return i}}},589:(t,e,r)=>{const{Cumsum:a}=r(535),i=({image:t,cx:e,cy:r,sdThresh:a,imageDataCumsum:i,imageDataSqrCumsum:s})=>{if(e-6<0||e+6>=t.width)return null;if(r-6<0||r+6>=t.height)return null;let h=i.query(e-6,r-6,e+6,r+6);h/=169;let o=s.query(e-6,r-6,e+6,r+6);return o-=2*h*i.query(e-6,r-6,e+6,r+6),o+=169*h*h,o/169<a*a?null:(o=Math.sqrt(o),o)},s=t=>{const{image:e,cx:r,cy:a,vlen:i,tx:s,ty:h,imageDataCumsum:o,imageDataSqrCumsum:l}=t,{data:u,width:n,height:m}=e;if(r-6<0||r+6>=n)return null;if(a-6<0||a+6>=m)return null;let c=o.query(r-6,a-6,r+6,a+6),f=l.query(r-6,a-6,r+6,a+6),g=0,d=(a-6)*n+(r-6),p=(h-6)*n+(s-6),w=n-13;for(let t=0;t<13;t++){for(let t=0;t<13;t++)g+=u[d]*u[p],d+=1,p+=1;d+=w,p+=w}let M=o.query(s-6,h-6,s+6,h+6);M/=169,g-=M*c;let y=f-c*c/169;return 0==y?null:(y=Math.sqrt(y),1*g/(i*y))};t.exports={extract:t=>{const{data:e,width:r,height:h,scale:o}=t,l=[r*h];for(let t=0;t<l.length;t++)l[t]=!1;const u=new Float32Array(e.length);for(let t=0;t<r;t++)u[t]=-1,u[r*(h-1)+t]=-1;for(let t=0;t<h;t++)u[t*r]=-1,u[t*r+r-1]=-1;for(let t=1;t<r-1;t++)for(let a=1;a<h-1;a++){let i=t+r*a,s=0,h=0;for(let t=-1;t<=1;t++)s+=e[i+r*t+1]-e[i+r*t-1],h+=e[i+r+t]-e[i-r+t];s/=768,h/=768,u[i]=Math.sqrt((s*s+h*h)/2)}const n=new Uint32Array(1e3);for(let t=0;t<1e3;t++)n[t]=0;const m=[-1,1,-r,r];let c=0;for(let t=1;t<r-1;t++)for(let e=1;e<h-1;e++){let a=t+r*e,i=!0;for(let t=0;t<m.length;t++)if(u[a]<=u[a+m[t]]){i=!1;break}if(i){let t=Math.floor(1e3*u[a]);t>999&&(t=999),t<0&&(t=0),n[t]+=1,c+=1,l[a]=!0}}const f=.02*r*h;let g=999,d=0;for(;g>=0&&(d+=n[g],!(d>f));)g--;for(let t=0;t<l.length;t++)l[t]&&1e3*u[t]<g&&(l[t]=!1);const p=[];for(let t=0;t<e.length;t++)p[t]=e[t]*e[t];const w=new a(e,r,h),M=new a(p,r,h),y=new Float32Array(e.length);for(let e=0;e<r;e++)for(let a=0;a<h;a++){const h=a*r+e;if(!l[h]){y[h]=1;continue}const o=i({image:t,cx:e,cy:a,sdThresh:5,imageDataCumsum:w,imageDataSqrCumsum:M});if(null===o){y[h]=1;continue}let u=-1;for(let r=-10;r<=10;r++){for(let i=-10;i<=10;i++){if(i*i+r*r<=4)continue;const h=s({image:t,cx:e+i,cy:a+r,vlen:o,tx:e,ty:a,imageDataCumsum:w,imageDataSqrCumsum:M});if(null!==h&&h>u&&(u=h,u>.95))break}if(u>.95)break}y[h]=u}return(t=>{let{image:e,featureMap:r,templateSize:a,searchSize:h,occSize:o,maxSimThresh:l,minSimThresh:u,sdThresh:n,imageDataCumsum:m,imageDataSqrCumsum:c}=t;const{data:f,width:g,height:d,scale:p}=e;o=Math.floor(Math.min(e.width,e.height)/10);const w=3*(2*a+1),M=Math.floor(g/w),y=Math.floor(d/w);let x=Math.floor(g/o)*Math.floor(d/o)+M*y;const q=[],C=new Float32Array(f.length);for(let t=0;t<C.length;t++)C[t]=r[t];let S=0;for(;S<x;){let t=l,r=-1,f=-1;for(let e=0;e<d;e++)for(let a=0;a<g;a++)C[e*g+a]<t&&(t=C[e*g+a],r=a,f=e);if(-1===r)break;const p=i({image:e,cx:r,cy:f,sdThresh:0,imageDataCumsum:m,imageDataSqrCumsum:c});if(null===p){C[f*g+r]=1;continue}if(p/(2*a+1)<n){C[f*g+r]=1;continue}let w=1,M=-1;for(let a=-h;a<=h;a++){for(let i=-h;i<=h;i++){if(i*i+a*a>h*h)continue;if(0===i&&0===a)continue;const o=s({image:e,vlen:p,cx:r+i,cy:f+a,tx:r,ty:f,imageDataCumsum:m,imageDataSqrCumsum:c});if(null!==o){if(o<w&&(w=o,w<u&&w<t))break;if(o>M&&(M=o,M>.99))break}}if(w<u&&w<t||M>.99)break}if(w<u&&w<t||M>.99)C[f*g+r]=1;else{q.push({x:r,y:f}),S+=1;for(let t=-o;t<=o;t++)for(let e=-o;e<=o;e++)f+t<0||f+t>=d||r+e<0||r+e>=g||(C[(f+t)*g+(r+e)]=1)}}return q})({image:t,featureMap:y,templateSize:6,searchSize:2,occSize:16,maxSimThresh:.9,minSimThresh:.2,sdThresh:8,imageDataCumsum:w,imageDataSqrCumsum:M})}}},535:t=>{t.exports={Cumsum:class{constructor(t,e,r){this.cumsum=[];for(let t=0;t<r;t++){this.cumsum.push([]);for(let r=0;r<e;r++)this.cumsum[t].push(0)}this.cumsum[0][0]=t[0];for(let r=1;r<e;r++)this.cumsum[0][r]=this.cumsum[0][r-1]+t[r];for(let a=1;a<r;a++)this.cumsum[a][0]=this.cumsum[a-1][0]+t[a*e];for(let a=1;a<r;a++)for(let r=1;r<e;r++)this.cumsum[a][r]=t[a*e+r]+this.cumsum[a-1][r]+this.cumsum[a][r-1]-this.cumsum[a-1][r-1]}query(t,e,r,a){let i=this.cumsum[a][r];return e>0&&(i-=this.cumsum[e-1][r]),t>0&&(i-=this.cumsum[a][t-1]),t>0&&e>0&&(i+=this.cumsum[e-1][t-1]),i}}}},140:t=>{t.exports={downsampleBilinear:({image:t})=>{const{data:e,width:r,height:a}=t,i=Math.floor(r/2),s=Math.floor(a/2),h=new Float32Array(i*s),o=[0,1,r,r+1];for(let t=0;t<s;t++)for(let a=0;a<i;a++){let s=2*t*r+2*a,l=0;for(let t=0;t<o.length;t++)l+=e[s+o[t]];l*=.25,h[t*i+a]=l}return{data:h,width:i,height:s}},upsampleBilinear:({image:t,padOneWidth:e,padOneHeight:r})=>{const{width:a,height:i,data:s}=t,h=2*t.width+(e?1:0),o=2*t.height+(r?1:0),l=new Float32Array(h*o);for(let t=0;t<h;t++){const e=.5*t-.25;let r=Math.floor(e),u=Math.ceil(e);r<0&&(r=0),u>=a&&(u=a-1);for(let n=0;n<o;n++){const o=.5*n-.25;let m=Math.floor(o),c=Math.ceil(o);m<0&&(m=0),c>=i&&(c=i-1);const f=(u-e)*(c-o)*s[m*a+r]+(u-e)*(o-m)*s[c*a+r]+(e-r)*(c-o)*s[m*a+u]+(e-r)*(o-m)*s[c*a+u];l[n*h+t]=f}}return{data:l,width:h,height:o}},resize:({image:t,ratio:e})=>{const r=Math.round(t.width*e),a=Math.round(t.height*e),i=new Uint8Array(r*a);for(let s=0;s<r;s++){let h=Math.round(1*s/e),o=Math.round(1*(s+1)/e)-1;o>=t.width&&(o=t.width-1);for(let l=0;l<a;l++){let a=Math.round(1*l/e),u=Math.round(1*(l+1)/e)-1;u>=t.height&&(u=t.height-1);let n=0,m=0;for(let e=h;e<=o;e++)for(let r=a;r<=u;r++)n+=1*t.data[r*t.width+e],m+=1;i[l*r+s]=Math.floor(n/m)}}return{data:i,width:r,height:a}}}}},e={};function r(a){if(e[a])return e[a].exports;var i=e[a]={exports:{}};return t[a](i,i.exports,r),i.exports}(()=>{const{extract:t}=r(589),{buildTrackingImageList:e}=r(508);onmessage=t=>{const{data:r}=t;if("compile"===r.type){const{targetImages:t}=r,i=50/t.length;let s=0;const h=[];for(let r=0;r<t.length;r++){const o=t[r],l=e(o),u=i/l.length,n=a(l,(t=>{s+=u,postMessage({type:"progress",percent:s})}));h.push(n)}postMessage({type:"compileDone",list:h})}};const a=(e,r)=>{const a=[];for(let i=0;i<e.length;i++){const s=e[i],h=t(s),o={data:s.data,scale:s.scale,width:s.width,height:s.height,points:h};a.push(o),r(i)}return a}})()})();',I.p+"compiler.worker.prod.js")}},1077:(ot,ht,I)=>{ot.exports=function(){return I(9855)('(()=>{var t={331:(t,e,r)=>{"use strict";r.r(e),r.d(e,{AbstractMatrix:()=>v,CHO:()=>tt,CholeskyDecomposition:()=>tt,EVD:()=>K,EigenvalueDecomposition:()=>K,LU:()=>H,LuDecomposition:()=>H,Matrix:()=>k,MatrixColumnSelectionView:()=>T,MatrixColumnView:()=>I,MatrixFlipColumnView:()=>A,MatrixFlipRowView:()=>q,MatrixRowSelectionView:()=>P,MatrixRowView:()=>C,MatrixSelectionView:()=>V,MatrixSubView:()=>N,MatrixTransposeView:()=>j,NIPALS:()=>et,Nipals:()=>et,QR:()=>$,QrDecomposition:()=>$,SVD:()=>L,SingularValueDecomposition:()=>L,WrapperMatrix1D:()=>z,WrapperMatrix2D:()=>F,correlation:()=>J,covariance:()=>B,default:()=>k,determinant:()=>X,inverse:()=>O,linearDependencies:()=>Q,pseudoInverse:()=>W,solve:()=>U,wrap:()=>D});const s=Object.prototype.toString;function o(t){return s.call(t).endsWith("Array]")}const n=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!o(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,s=void 0===r?0:r,n=e.toIndex,i=void 0===n?t.length:n;if(s<0||s>=t.length||!Number.isInteger(s))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=s||i>t.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var h=t[s],l=s+1;l<i;l++)t[l]>h&&(h=t[l]);return h},i=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!o(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,s=void 0===r?0:r,n=e.toIndex,i=void 0===n?t.length:n;if(s<0||s>=t.length||!Number.isInteger(s))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=s||i>t.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var h=t[s],l=s+1;l<i;l++)t[l]<h&&(h=t[l]);return h},h=function(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!o(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!o(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var s=i(t),h=n(t);if(s===h)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var l=r.min,u=void 0===l?r.autoMinMax?s:0:l,a=r.max,c=void 0===a?r.autoMinMax?h:1:a;if(u>=c)throw new RangeError("min option must be smaller than max option");for(var f=(c-u)/(h-s),m=0;m<t.length;m++)e[m]=(t[m]-s)*f+u;return e},l=" ".repeat(2),u=" ".repeat(4);function a(t,e={}){const{maxRows:r=15,maxColumns:s=10,maxNumSize:o=8}=e;return`${t.constructor.name} {\\n${l}[\\n${u}${function(t,e,r,s){const{rows:o,columns:n}=t,i=Math.min(o,e),h=Math.min(n,r),l=[];for(let e=0;e<i;e++){let r=[];for(let o=0;o<h;o++)r.push(c(t.get(e,o),s));l.push(`${r.join(" ")}`)}return h!==n&&(l[l.length-1]+=` ... ${n-r} more columns`),i!==o&&l.push(`... ${o-e} more rows`),l.join(`\\n${u}`)}(t,r,s,o)}\\n${l}]\\n${l}rows: ${t.rows}\\n${l}columns: ${t.columns}\\n}`}function c(t,e){const r=String(t);if(r.length<=e)return r.padEnd(e," ");const s=t.toPrecision(e-2);if(s.length<=e)return s;const o=t.toExponential(e-2),n=o.indexOf("e"),i=o.slice(n);return o.slice(0,e-i.length)+i}function f(t,e,r){let s=r?t.rows:t.rows-1;if(e<0||e>s)throw new RangeError("Row index out of range")}function m(t,e,r){let s=r?t.columns:t.columns-1;if(e<0||e>s)throw new RangeError("Column index out of range")}function g(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function w(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function p(t,e,r){return{row:d(t,e),column:y(t,r)}}function d(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for row indices");if(e.some((e=>e<0||e>=t.rows)))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function y(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for column indices");if(e.some((e=>e<0||e>=t.columns)))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function M(t,e,r,s,o){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(x("startRow",e),x("endRow",r),x("startColumn",s),x("endColumn",o),e>r||s>o||e<0||e>=t.rows||r<0||r>=t.rows||s<0||s>=t.columns||o<0||o>=t.columns)throw new RangeError("Submatrix indices are out of range")}function b(t,e=0){let r=[];for(let s=0;s<t;s++)r.push(e);return r}function x(t,e){if("number"!=typeof e)throw new TypeError(`${t} must be a number`)}function E(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}class v{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let s=new k(t,e);for(let o=0;o<t;o++)for(let t=0;t<e;t++)s.set(o,t,r[o*e+t]);return s}static rowVector(t){let e=new k(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new k(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new k(t,e)}static ones(t,e){return new k(t,e).fill(1)}static rand(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{random:s=Math.random}=r;let o=new k(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)o.set(r,t,s());return o}static randInt(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{min:s=0,max:o=1e3,random:n=Math.random}=r;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(o))throw new TypeError("max must be an integer");if(s>=o)throw new RangeError("min must be smaller than max");let i=o-s,h=new k(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=s+Math.round(n()*i);h.set(r,t,e)}return h}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let s=Math.min(t,e),o=this.zeros(t,e);for(let t=0;t<s;t++)o.set(t,t,r);return o}static diag(t,e,r){let s=t.length;void 0===e&&(e=s),void 0===r&&(r=e);let o=Math.min(s,e,r),n=this.zeros(e,r);for(let e=0;e<o;e++)n.set(e,e,t[e]);return n}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new k(r,s);for(let n=0;n<r;n++)for(let r=0;r<s;r++)o.set(n,r,Math.min(t.get(n,r),e.get(n,r)));return o}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,s=t.columns,o=new this(r,s);for(let n=0;n<r;n++)for(let r=0;r<s;r++)o.set(n,r,Math.max(t.get(n,r),e.get(n,r)));return o}static checkMatrix(t){return v.isMatrix(t)?t:new k(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);t++}return s}isReducedEchelonForm(){let t=0,e=0,r=-1,s=!0,o=!1;for(;t<this.rows&&s;){for(e=0,o=!1;e<this.columns&&!1===o;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(o=!0,r=e):(s=!1,o=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(s=!1);t++}return s}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let s=e;for(let o=e;o<t.rows;o++)t.get(o,r)>t.get(s,r)&&(s=o);if(0===t.get(s,r))r++;else{t.swapRows(e,s);let o=t.get(e,r);for(let s=r;s<t.columns;s++)t.set(e,s,t.get(e,s)/o);for(let s=e+1;s<t.rows;s++){let o=t.get(s,r)/t.get(e,r);t.set(s,r,0);for(let n=r+1;n<t.columns;n++)t.set(s,n,t.get(s,n)-t.get(e,n)*o)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,s=r-1;for(;s>=0;)if(0===t.maxRow(s))s--;else{let o=0,n=!1;for(;o<r&&!1===n;)1===t.get(s,o)?n=!0:o++;for(let r=0;r<s;r++){let n=t.get(r,o);for(let i=o;i<e;i++){let e=t.get(r,i)-n*t.get(s,i);t.set(r,i,e)}}s--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let s=new k(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)s.setSubMatrix(this,this.rows*t,this.columns*e);return s}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){f(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return k.rowVector(this.getRow(t))}setRow(t,e){f(this,t),e=g(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){f(this,t),f(this,e);for(let r=0;r<this.columns;r++){let s=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,s)}return this}getColumn(t){m(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return k.columnVector(this.getColumn(t))}setColumn(t,e){m(this,t),e=w(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){m(this,t),m(this,e);for(let r=0;r<this.rows;r++){let s=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,s)}return this}addRowVector(t){t=g(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=g(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=g(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=g(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=w(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=w(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=w(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=w(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){f(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){m(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(){if(this.isEmpty())return NaN;let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxIndex(){E(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}min(){if(this.isEmpty())return NaN;let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minIndex(){E(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t&&(t=this.get(r,s),e[0]=r,e[1]=s);return e}maxRow(t){if(f(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){f(this,t),E(this);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)>e&&(e=this.get(t,s),r[1]=s);return r}minRow(t){if(f(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){f(this,t),E(this);let e=this.get(t,0),r=[t,0];for(let s=1;s<this.columns;s++)this.get(t,s)<e&&(e=this.get(t,s),r[1]=s);return r}maxColumn(t){if(m(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){m(this,t),E(this);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)>e&&(e=this.get(s,t),r[0]=s);return r}minColumn(t){if(m(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){m(this,t),E(this);let e=this.get(0,t),r=[0,t];for(let s=1;s<this.rows;s++)this.get(s,t)<e&&(e=this.get(s,t),r[0]=s);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(t="frobenius"){let e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError(`unknown norm type: ${t}`)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){v.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let s=0;s<e.length;s++)r+=e[s]*t[s];return r}mmul(t){t=k.checkMatrix(t);let e=this.rows,r=this.columns,s=t.columns,o=new k(e,s),n=new Float64Array(r);for(let i=0;i<s;i++){for(let e=0;e<r;e++)n[e]=t.get(e,i);for(let t=0;t<e;t++){let e=0;for(let s=0;s<r;s++)e+=this.get(t,s)*n[s];o.set(t,i,e)}}return o}strassen2x2(t){t=k.checkMatrix(t);let e=new k(2,2);const r=this.get(0,0),s=t.get(0,0),o=this.get(0,1),n=t.get(0,1),i=this.get(1,0),h=t.get(1,0),l=this.get(1,1),u=t.get(1,1),a=(r+l)*(s+u),c=(i+l)*s,f=r*(n-u),m=l*(h-s),g=(r+o)*u,w=a+m-g+(o-l)*(h+u),p=f+g,d=c+m,y=a-c+f+(i-r)*(s+n);return e.set(0,0,w),e.set(0,1,p),e.set(1,0,d),e.set(1,1,y),e}strassen3x3(t){t=k.checkMatrix(t);let e=new k(3,3);const r=this.get(0,0),s=this.get(0,1),o=this.get(0,2),n=this.get(1,0),i=this.get(1,1),h=this.get(1,2),l=this.get(2,0),u=this.get(2,1),a=this.get(2,2),c=t.get(0,0),f=t.get(0,1),m=t.get(0,2),g=t.get(1,0),w=t.get(1,1),p=t.get(1,2),d=t.get(2,0),y=t.get(2,1),M=t.get(2,2),b=(r-n)*(-f+w),x=(-r+n+i)*(c-f+w),E=(n+i)*(-c+f),v=r*c,S=(-r+l+u)*(c-m+p),R=(-r+l)*(m-p),I=(l+u)*(-c+m),T=(-o+u+a)*(w+d-y),A=(o-a)*(w-y),q=o*d,C=(u+a)*(-d+y),P=(-o+i+h)*(p+d-M),V=(o-h)*(p-M),N=(i+h)*(-d+M),j=v+q+s*g,z=(r+s+o-n-i-u-a)*w+x+E+v+T+q+C,F=v+S+I+(r+s+o-i-h-l-u)*p+q+P+N,D=b+i*(-c+f+g-w-p-d+M)+x+v+q+P+V,H=b+x+E+v+h*y,_=q+P+V+N+n*m,$=v+S+R+u*(-c+m+g-w-p-d+y)+T+A+q,L=T+A+q+C+l*f,O=v+S+R+I+a*M;return e.set(0,0,j),e.set(0,1,z),e.set(0,2,F),e.set(1,0,D),e.set(1,1,H),e.set(1,2,_),e.set(2,0,$),e.set(2,1,L),e.set(2,2,O),e}mmulStrassen(t){t=k.checkMatrix(t);let e=this.clone(),r=e.rows,s=e.columns,o=t.rows,n=t.columns;function i(t,e,r){let s=t.rows,o=t.columns;if(s===e&&o===r)return t;{let s=v.zeros(e,r);return s=s.setSubMatrix(t,0,0),s}}s!==o&&console.warn(`Multiplying ${r} x ${s} and ${o} x ${n} matrix: dimensions do not match.`);let h=Math.max(r,o),l=Math.max(s,n);return e=i(e,h,l),function t(e,r,s,o){if(s<=512||o<=512)return e.mmul(r);s%2==1&&o%2==1?(e=i(e,s+1,o+1),r=i(r,s+1,o+1)):s%2==1?(e=i(e,s+1,o),r=i(r,s+1,o)):o%2==1&&(e=i(e,s,o+1),r=i(r,s,o+1));let n=parseInt(e.rows/2,10),h=parseInt(e.columns/2,10),l=e.subMatrix(0,n-1,0,h-1),u=r.subMatrix(0,n-1,0,h-1),a=e.subMatrix(0,n-1,h,e.columns-1),c=r.subMatrix(0,n-1,h,r.columns-1),f=e.subMatrix(n,e.rows-1,0,h-1),m=r.subMatrix(n,r.rows-1,0,h-1),g=e.subMatrix(n,e.rows-1,h,e.columns-1),w=r.subMatrix(n,r.rows-1,h,r.columns-1),p=t(v.add(l,g),v.add(u,w),n,h),d=t(v.add(f,g),u,n,h),y=t(l,v.sub(c,w),n,h),M=t(g,v.sub(m,u),n,h),b=t(v.add(l,a),w,n,h),x=t(v.sub(f,l),v.add(u,c),n,h),E=t(v.sub(a,g),v.add(m,w),n,h),S=v.add(p,M);S.sub(b),S.add(E);let k=v.add(y,b),R=v.add(d,M),I=v.sub(p,d);I.add(y),I.add(x);let T=v.zeros(2*S.rows,2*S.columns);return T=T.setSubMatrix(S,0,0),T=T.setSubMatrix(k,S.rows,0),T=T.setSubMatrix(R,0,S.columns),T=T.setSubMatrix(I,S.rows,S.columns),T.subMatrix(0,s-1,0,o-1)}(e,t=i(t,h,l),h,l)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new k(this.rows,this.columns);for(let t=0;t<this.rows;t++){const o=this.getRow(t);o.length>0&&h(o,{min:e,max:r,output:o}),s.setRow(t,o)}return s}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let s=new k(this.rows,this.columns);for(let t=0;t<this.columns;t++){const o=this.getColumn(t);o.length&&h(o,{min:e,max:r,output:o}),s.setColumn(t,o)}return s}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),s=this.get(e,this.columns-1-r);this.set(e,r,s),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),s=this.get(this.rows-1-r,e);this.set(r,e,s),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=k.checkMatrix(t);let e=this.rows,r=this.columns,s=t.rows,o=t.columns,n=new k(e*s,r*o);for(let i=0;i<e;i++)for(let e=0;e<r;e++)for(let r=0;r<s;r++)for(let h=0;h<o;h++)n.set(s*i+r,o*e+h,this.get(i,e)*t.get(r,h));return n}transpose(){let t=new k(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(t=S){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=S){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,s){M(this,t,e,r,s);let o=new k(e-t+1,s-r+1);for(let n=t;n<=e;n++)for(let e=r;e<=s;e++)o.set(n-t,e-r,this.get(n,e));return o}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let s=new k(t.length,r-e+1);for(let o=0;o<t.length;o++)for(let n=e;n<=r;n++){if(t[o]<0||t[o]>=this.rows)throw new RangeError(`Row index out of range: ${t[o]}`);s.set(o,n-e,this.get(t[o],n))}return s}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let s=new k(r-e+1,t.length);for(let o=0;o<t.length;o++)for(let n=e;n<=r;n++){if(t[o]<0||t[o]>=this.columns)throw new RangeError(`Column index out of range: ${t[o]}`);s.set(n-e,o,this.get(n,t[o]))}return s}setSubMatrix(t,e,r){if((t=k.checkMatrix(t)).isEmpty())return this;M(this,e,e+t.rows-1,r,r+t.columns-1);for(let s=0;s<t.rows;s++)for(let o=0;o<t.columns;o++)this.set(e+s,r+o,t.get(s,o));return this}selection(t,e){let r=p(this,t,e),s=new k(t.length,e.length);for(let t=0;t<r.row.length;t++){let e=r.row[t];for(let o=0;o<r.column.length;o++){let n=r.column[o];s.set(t,o,this.get(e,n))}}return s}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new k(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return function(t){let e=b(t.rows);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]+=t.get(r,s);return e}(this);case"column":return function(t){let e=b(t.columns);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]+=t.get(r,s);return e}(this);case void 0:return function(t){let e=0;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e+=t.get(r,s);return e}(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return function(t){let e=b(t.rows,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[r]*=t.get(r,s);return e}(this);case"column":return function(t){let e=b(t.columns,1);for(let r=0;r<t.rows;++r)for(let s=0;s<t.columns;++s)e[s]*=t.get(r,s);return e}(this);case void 0:return function(t){let e=1;for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)e*=t.get(r,s);return e}(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:s=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!Array.isArray(s))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,n=[];for(let i=0;i<s;i++){let s=0,h=0,l=0;for(let e=0;e<o;e++)l=t.get(i,e)-r[i],s+=l,h+=l*l;e?n.push((h-s*s/o)/(o-1)):n.push((h-s*s/o)/o)}return n}(this,r,s);case"column":if(!Array.isArray(s))throw new TypeError("mean must be an array");return function(t,e,r){const s=t.rows,o=t.columns,n=[];for(let i=0;i<o;i++){let o=0,h=0,l=0;for(let e=0;e<s;e++)l=t.get(e,i)-r[i],o+=l,h+=l*l;e?n.push((h-o*o/s)/(s-1)):n.push((h-o*o/s)/s)}return n}(this,r,s);case void 0:if("number"!=typeof s)throw new TypeError("mean must be a number");return function(t,e,r){const s=t.rows,o=t.columns,n=s*o;let i=0,h=0,l=0;for(let e=0;e<s;e++)for(let s=0;s<o;s++)l=t.get(e,s)-r,i+=l,h+=l*l;return e?(h-i*i/n)/(n-1):(h-i*i/n)/n}(this,r,s);default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!Array.isArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[r])}(this,r),this;case"column":if(!Array.isArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e[s])}(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)-e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.rows;r++){let s=0;for(let e=0;e<t.columns;e++)s+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(s))}return e}(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[r])}(this,r),this;case"column":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.columns;r++){let s=0;for(let e=0;e<t.rows;e++)s+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(s))}return e}(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e[s])}(this,r),this;case void 0:if(void 0===r)r=function(t){const e=t.size-1;let r=0;for(let s=0;s<t.columns;s++)for(let o=0;o<t.rows;o++)r+=Math.pow(t.get(o,s),2)/e;return Math.sqrt(r)}(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let s=0;s<t.columns;s++)t.set(r,s,t.get(r,s)/e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}toString(t){return a(this,t)}}function S(t,e){return t-e}v.prototype.klass="Matrix","undefined"!=typeof Symbol&&(v.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){return a(this)}),v.random=v.rand,v.randomInt=v.randInt,v.diagonal=v.diag,v.prototype.diagonal=v.prototype.diag,v.identity=v.eye,v.prototype.negate=v.prototype.neg,v.prototype.tensorProduct=v.prototype.kroneckerProduct;class k extends v{constructor(t,e){if(super(),k.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>=0){if(this.data=[],!(Number.isInteger(e)&&e>=0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!Array.isArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if("number"!=typeof(e=(t=r.length)?r[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<t;s++){if(r[s].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[s]))}}}this.rows=t,this.columns=e}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){return f(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),f(this,t,!0),e=Float64Array.from(g(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){m(this,t);for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let s=0;s<t;s++)r[s]=this.data[e][s];for(let s=t+1;s<this.columns;s++)r[s-1]=this.data[e][s];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),m(this,t,!0),e=w(this,e);for(let r=0;r<this.rows;r++){const s=new Float64Array(this.columns+1);let o=0;for(;o<t;o++)s[o]=this.data[r][o];for(s[o++]=e[r];o<this.columns+1;o++)s[o]=this.data[r][o-1];this.data[r]=s}return this.columns+=1,this}}!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}(v,k);class R extends v{constructor(t,e,r){super(),this.matrix=t,this.rows=e,this.columns=r}}class I extends R{constructor(t,e){m(t,e),super(t,t.rows,1),this.column=e}set(t,e,r){return this.matrix.set(t,this.column,r),this}get(t){return this.matrix.get(t,this.column)}}class T extends R{constructor(t,e){e=y(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,r){return this.matrix.set(t,this.columnIndices[e],r),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}}class A extends R{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(t,this.columns-e-1,r),this}get(t,e){return this.matrix.get(t,this.columns-e-1)}}class q extends R{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(this.rows-t-1,e,r),this}get(t,e){return this.matrix.get(this.rows-t-1,e)}}class C extends R{constructor(t,e){f(t,e),super(t,1,t.columns),this.row=e}set(t,e,r){return this.matrix.set(this.row,e,r),this}get(t,e){return this.matrix.get(this.row,e)}}class P extends R{constructor(t,e){super(t,(e=d(t,e)).length,t.columns),this.rowIndices=e}set(t,e,r){return this.matrix.set(this.rowIndices[t],e,r),this}get(t,e){return this.matrix.get(this.rowIndices[t],e)}}class V extends R{constructor(t,e,r){let s=p(t,e,r);super(t,s.row.length,s.column.length),this.rowIndices=s.row,this.columnIndices=s.column}set(t,e,r){return this.matrix.set(this.rowIndices[t],this.columnIndices[e],r),this}get(t,e){return this.matrix.get(this.rowIndices[t],this.columnIndices[e])}}class N extends R{constructor(t,e,r,s,o){M(t,e,r,s,o),super(t,r-e+1,o-s+1),this.startRow=e,this.startColumn=s}set(t,e,r){return this.matrix.set(this.startRow+t,this.startColumn+e,r),this}get(t,e){return this.matrix.get(this.startRow+t,this.startColumn+e)}}class j extends R{constructor(t){super(t,t.columns,t.rows)}set(t,e,r){return this.matrix.set(e,t,r),this}get(t,e){return this.matrix.get(e,t)}}class z extends v{constructor(t,e={}){const{rows:r=1}=e;if(t.length%r!=0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=t.length/r,this.data=t}set(t,e,r){let s=this._calculateIndex(t,e);return this.data[s]=r,this}get(t,e){let r=this._calculateIndex(t,e);return this.data[r]}_calculateIndex(t,e){return t*this.columns+e}}class F extends v{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}function D(t,e){if(Array.isArray(t))return t[0]&&Array.isArray(t[0])?new F(t):new z(t,e);throw new Error("the argument is not an array")}class H{constructor(t){let e,r,s,o,n,i,h,l,u,a=(t=F.checkMatrix(t)).clone(),c=a.rows,f=a.columns,m=new Float64Array(c),g=1;for(e=0;e<c;e++)m[e]=e;for(l=new Float64Array(c),r=0;r<f;r++){for(e=0;e<c;e++)l[e]=a.get(e,r);for(e=0;e<c;e++){for(u=Math.min(e,r),n=0,s=0;s<u;s++)n+=a.get(e,s)*l[s];l[e]-=n,a.set(e,r,l[e])}for(o=r,e=r+1;e<c;e++)Math.abs(l[e])>Math.abs(l[o])&&(o=e);if(o!==r){for(s=0;s<f;s++)i=a.get(o,s),a.set(o,s,a.get(r,s)),a.set(r,s,i);h=m[o],m[o]=m[r],m[r]=h,g=-g}if(r<c&&0!==a.get(r,r))for(e=r+1;e<c;e++)a.set(e,r,a.get(e,r)/a.get(r,r))}this.LU=a,this.pivotVector=m,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=k.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,s,o,n=t.columns,i=t.subMatrixRow(this.pivotVector,0,n-1),h=e.columns;for(o=0;o<h;o++)for(r=o+1;r<h;r++)for(s=0;s<n;s++)i.set(r,s,i.get(r,s)-i.get(o,s)*e.get(r,o));for(o=h-1;o>=0;o--){for(s=0;s<n;s++)i.set(o,s,i.get(o,s)/e.get(o,o));for(r=0;r<o;r++)for(s=0;s<n;s++)i.set(r,s,i.get(r,s)-i.get(o,s)*e.get(r,o))}return i}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let s=0;s<r;s++)e*=t.get(s,s);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,s=new k(e,r);for(let o=0;o<e;o++)for(let e=0;e<r;e++)o>e?s.set(o,e,t.get(o,e)):o===e?s.set(o,e,1):s.set(o,e,0);return s}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,s=new k(e,r);for(let o=0;o<e;o++)for(let e=0;e<r;e++)o<=e?s.set(o,e,t.get(o,e)):s.set(o,e,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function _(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class ${constructor(t){let e,r,s,o,n=(t=F.checkMatrix(t)).clone(),i=t.rows,h=t.columns,l=new Float64Array(h);for(s=0;s<h;s++){let t=0;for(e=s;e<i;e++)t=_(t,n.get(e,s));if(0!==t){for(n.get(s,s)<0&&(t=-t),e=s;e<i;e++)n.set(e,s,n.get(e,s)/t);for(n.set(s,s,n.get(s,s)+1),r=s+1;r<h;r++){for(o=0,e=s;e<i;e++)o+=n.get(e,s)*n.get(e,r);for(o=-o/n.get(s,s),e=s;e<i;e++)n.set(e,r,n.get(e,r)+o*n.get(e,s))}}l[s]=-t}this.QR=n,this.Rdiag=l}solve(t){t=k.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s,o,n,i,h=t.columns,l=t.clone(),u=e.columns;for(n=0;n<u;n++)for(o=0;o<h;o++){for(i=0,s=n;s<r;s++)i+=e.get(s,n)*l.get(s,o);for(i=-i/e.get(n,n),s=n;s<r;s++)l.set(s,o,l.get(s,o)+i*e.get(s,n))}for(n=u-1;n>=0;n--){for(o=0;o<h;o++)l.set(n,o,l.get(n,o)/this.Rdiag[n]);for(s=0;s<n;s++)for(o=0;o<h;o++)l.set(s,o,l.get(s,o)-l.get(n,o)*e.get(s,n))}return l.subMatrix(0,u-1,0,h-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,s=r.columns,o=new k(s,s);for(t=0;t<s;t++)for(e=0;e<s;e++)t<e?o.set(t,e,r.get(t,e)):t===e?o.set(t,e,this.Rdiag[t]):o.set(t,e,0);return o}get orthogonalMatrix(){let t,e,r,s,o=this.QR,n=o.rows,i=o.columns,h=new k(n,i);for(r=i-1;r>=0;r--){for(t=0;t<n;t++)h.set(t,r,0);for(h.set(r,r,1),e=r;e<i;e++)if(0!==o.get(r,r)){for(s=0,t=r;t<n;t++)s+=o.get(t,r)*h.get(t,e);for(s=-s/o.get(r,r),t=r;t<n;t++)h.set(t,e,h.get(t,e)+s*o.get(t,r))}}return h}}class L{constructor(t,e={}){if((t=F.checkMatrix(t)).isEmpty())throw new Error("Matrix must be non-empty");let r=t.rows,s=t.columns;const{computeLeftSingularVectors:o=!0,computeRightSingularVectors:n=!0,autoTranspose:i=!1}=e;let h,l=Boolean(o),u=Boolean(n),a=!1;if(r<s)if(i){h=t.transpose(),r=h.rows,s=h.columns,a=!0;let e=l;l=u,u=e}else h=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else h=t.clone();let c=Math.min(r,s),f=Math.min(r+1,s),m=new Float64Array(f),g=new k(r,c),w=new k(s,s),p=new Float64Array(s),d=new Float64Array(r),y=new Float64Array(f);for(let t=0;t<f;t++)y[t]=t;let M=Math.min(r-1,s),b=Math.max(0,Math.min(s-2,r)),x=Math.max(M,b);for(let t=0;t<x;t++){if(t<M){m[t]=0;for(let e=t;e<r;e++)m[t]=_(m[t],h.get(e,t));if(0!==m[t]){h.get(t,t)<0&&(m[t]=-m[t]);for(let e=t;e<r;e++)h.set(e,t,h.get(e,t)/m[t]);h.set(t,t,h.get(t,t)+1)}m[t]=-m[t]}for(let e=t+1;e<s;e++){if(t<M&&0!==m[t]){let s=0;for(let o=t;o<r;o++)s+=h.get(o,t)*h.get(o,e);s=-s/h.get(t,t);for(let o=t;o<r;o++)h.set(o,e,h.get(o,e)+s*h.get(o,t))}p[e]=h.get(t,e)}if(l&&t<M)for(let e=t;e<r;e++)g.set(e,t,h.get(e,t));if(t<b){p[t]=0;for(let e=t+1;e<s;e++)p[t]=_(p[t],p[e]);if(0!==p[t]){p[t+1]<0&&(p[t]=0-p[t]);for(let e=t+1;e<s;e++)p[e]/=p[t];p[t+1]+=1}if(p[t]=-p[t],t+1<r&&0!==p[t]){for(let e=t+1;e<r;e++)d[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<s;r++)d[e]+=p[r]*h.get(e,r);for(let e=t+1;e<s;e++){let s=-p[e]/p[t+1];for(let o=t+1;o<r;o++)h.set(o,e,h.get(o,e)+s*d[o])}}if(u)for(let e=t+1;e<s;e++)w.set(e,t,p[e])}}let E=Math.min(s,r+1);if(M<s&&(m[M]=h.get(M,M)),r<E&&(m[E-1]=0),b+1<E&&(p[b]=h.get(b,E-1)),p[E-1]=0,l){for(let t=M;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=M-1;t>=0;t--)if(0!==m[t]){for(let e=t+1;e<c;e++){let s=0;for(let o=t;o<r;o++)s+=g.get(o,t)*g.get(o,e);s=-s/g.get(t,t);for(let o=t;o<r;o++)g.set(o,e,g.get(o,e)+s*g.get(o,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(u)for(let t=s-1;t>=0;t--){if(t<b&&0!==p[t])for(let e=t+1;e<s;e++){let r=0;for(let o=t+1;o<s;o++)r+=w.get(o,t)*w.get(o,e);r=-r/w.get(t+1,t);for(let o=t+1;o<s;o++)w.set(o,e,w.get(o,e)+r*w.get(o,t))}for(let e=0;e<s;e++)w.set(e,t,0);w.set(t,t,1)}let v=E-1,S=0,R=Number.EPSILON;for(;E>0;){let t,e;for(t=E-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+R*Math.abs(m[t]+Math.abs(m[t+1]));if(Math.abs(p[t])<=e||Number.isNaN(p[t])){p[t]=0;break}}if(t===E-2)e=4;else{let r;for(r=E-1;r>=t&&r!==t;r--){let e=(r!==E?Math.abs(p[r]):0)+(r!==t+1?Math.abs(p[r-1]):0);if(Math.abs(m[r])<=R*e){m[r]=0;break}}r===t?e=3:r===E-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=p[E-2];p[E-2]=0;for(let r=E-2;r>=t;r--){let o=_(m[r],e),n=m[r]/o,i=e/o;if(m[r]=o,r!==t&&(e=-i*p[r-1],p[r-1]=n*p[r-1]),u)for(let t=0;t<s;t++)o=n*w.get(t,r)+i*w.get(t,E-1),w.set(t,E-1,-i*w.get(t,r)+n*w.get(t,E-1)),w.set(t,r,o)}break}case 2:{let e=p[t-1];p[t-1]=0;for(let s=t;s<E;s++){let o=_(m[s],e),n=m[s]/o,i=e/o;if(m[s]=o,e=-i*p[s],p[s]=n*p[s],l)for(let e=0;e<r;e++)o=n*g.get(e,s)+i*g.get(e,t-1),g.set(e,t-1,-i*g.get(e,s)+n*g.get(e,t-1)),g.set(e,s,o)}break}case 3:{const e=Math.max(Math.abs(m[E-1]),Math.abs(m[E-2]),Math.abs(p[E-2]),Math.abs(m[t]),Math.abs(p[t])),o=m[E-1]/e,n=m[E-2]/e,i=p[E-2]/e,h=m[t]/e,a=p[t]/e,c=((n+o)*(n-o)+i*i)/2,f=o*i*(o*i);let d=0;0===c&&0===f||(d=c<0?0-Math.sqrt(c*c+f):Math.sqrt(c*c+f),d=f/(c+d));let y=(h+o)*(h-o)+d,M=h*a;for(let e=t;e<E-1;e++){let o=_(y,M);0===o&&(o=Number.MIN_VALUE);let n=y/o,i=M/o;if(e!==t&&(p[e-1]=o),y=n*m[e]+i*p[e],p[e]=n*p[e]-i*m[e],M=i*m[e+1],m[e+1]=n*m[e+1],u)for(let t=0;t<s;t++)o=n*w.get(t,e)+i*w.get(t,e+1),w.set(t,e+1,-i*w.get(t,e)+n*w.get(t,e+1)),w.set(t,e,o);if(o=_(y,M),0===o&&(o=Number.MIN_VALUE),n=y/o,i=M/o,m[e]=o,y=n*p[e]+i*m[e+1],m[e+1]=-i*p[e]+n*m[e+1],M=i*p[e+1],p[e+1]=n*p[e+1],l&&e<r-1)for(let t=0;t<r;t++)o=n*g.get(t,e)+i*g.get(t,e+1),g.set(t,e+1,-i*g.get(t,e)+n*g.get(t,e+1)),g.set(t,e,o)}p[E-2]=y,S+=1;break}case 4:if(m[t]<=0&&(m[t]=m[t]<0?-m[t]:0,u))for(let e=0;e<=v;e++)w.set(e,t,-w.get(e,t));for(;t<v&&!(m[t]>=m[t+1]);){let e=m[t];if(m[t]=m[t+1],m[t+1]=e,u&&t<s-1)for(let r=0;r<s;r++)e=w.get(r,t+1),w.set(r,t+1,w.get(r,t)),w.set(r,t,e);if(l&&t<r-1)for(let s=0;s<r;s++)e=g.get(s,t+1),g.set(s,t+1,g.get(s,t)),g.set(s,t,e);t++}S=0,E--}}if(a){let t=w;w=g,g=t}this.m=r,this.n=s,this.s=m,this.U=g,this.V=w}solve(t){let e=t,r=this.threshold,s=this.s.length,o=k.zeros(s,s);for(let t=0;t<s;t++)Math.abs(this.s[t])<=r?o.set(t,t,0):o.set(t,t,1/this.s[t]);let n=this.U,i=this.rightSingularVectors,h=i.mmul(o),l=i.rows,u=n.rows,a=k.zeros(l,u);for(let t=0;t<l;t++)for(let e=0;e<u;e++){let r=0;for(let o=0;o<s;o++)r+=h.get(t,o)*n.get(e,o);a.set(t,e,r)}return a.mmul(e)}solveForDiagonal(t){return this.solve(k.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,s=t.columns,o=new k(r,this.s.length);for(let n=0;n<r;n++)for(let r=0;r<s;r++)Math.abs(this.s[r])>e&&o.set(n,r,t.get(n,r)/this.s[r]);let n=this.U,i=n.rows,h=n.columns,l=new k(r,i);for(let t=0;t<r;t++)for(let e=0;e<i;e++){let r=0;for(let s=0;s<h;s++)r+=o.get(t,s)*n.get(e,s);l.set(t,e,r)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let s=0,o=r.length;s<o;s++)r[s]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return k.diag(this.s)}}function O(t,e=!1){return t=F.checkMatrix(t),e?new L(t).inverse():U(t,k.eye(t.rows))}function U(t,e,r=!1){return t=F.checkMatrix(t),e=F.checkMatrix(e),r?new L(t).solve(e):t.isSquare()?new H(t).solve(e):new $(t).solve(e)}function X(t){if((t=k.checkMatrix(t)).isSquare()){if(0===t.columns)return 1;let e,r,s,o;if(2===t.columns)return e=t.get(0,0),r=t.get(0,1),s=t.get(1,0),o=t.get(1,1),e*o-r*s;if(3===t.columns){let o,n,i;return o=new V(t,[1,2],[1,2]),n=new V(t,[1,2],[0,2]),i=new V(t,[1,2],[0,1]),e=t.get(0,0),r=t.get(0,1),s=t.get(0,2),e*X(o)-r*X(n)+s*X(i)}return new H(t).determinant}throw Error("determinant can only be calculated for a square matrix")}function Y(t,e){let r=[];for(let s=0;s<t;s++)s!==e&&r.push(s);return r}function G(t,e,r,s=1e-9,o=1e-9){if(t>o)return new Array(e.rows+1).fill(0);{let t=e.addRow(r,[0]);for(let e=0;e<t.rows;e++)Math.abs(t.get(e,0))<s&&t.set(e,0,0);return t.to1DArray()}}function Q(t,e={}){const{thresholdValue:r=1e-9,thresholdError:s=1e-9}=e;let o=(t=k.checkMatrix(t)).rows,n=new k(o,o);for(let e=0;e<o;e++){let i=k.columnVector(t.getRow(e)),h=t.subMatrixRow(Y(o,e)).transpose(),l=new L(h).solve(i),u=k.sub(i,h.mmul(l)).abs().max();n.setRow(e,G(u,l,e,r,s))}return n}function W(t,e=Number.EPSILON){if((t=k.checkMatrix(t)).isEmpty())return t.transpose();let r=new L(t,{autoTranspose:!0}),s=r.leftSingularVectors,o=r.rightSingularVectors,n=r.diagonal;for(let t=0;t<n.length;t++)Math.abs(n[t])>e?n[t]=1/n[t]:n[t]=0;return o.mmul(k.diag(n).mmul(s.transpose()))}function B(t,e=t,r={}){t=new k(t);let s=!1;if("object"!=typeof e||k.isMatrix(e)||Array.isArray(e)?e=new k(e):(r=e,e=t,s=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:o=!0}=r;o&&(t=t.center("column"),s||(e=e.center("column")));const n=t.transpose().mmul(e);for(let e=0;e<n.rows;e++)for(let r=0;r<n.columns;r++)n.set(e,r,n.get(e,r)*(1/(t.rows-1)));return n}function J(t,e=t,r={}){t=new k(t);let s=!1;if("object"!=typeof e||k.isMatrix(e)||Array.isArray(e)?e=new k(e):(r=e,e=t,s=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:o=!0,scale:n=!0}=r;o&&(t.center("column"),s||e.center("column")),n&&(t.scale("column"),s||e.scale("column"));const i=t.standardDeviation("column",{unbiased:!0}),h=s?i:e.standardDeviation("column",{unbiased:!0}),l=t.transpose().mmul(e);for(let e=0;e<l.rows;e++)for(let r=0;r<l.columns;r++)l.set(e,r,l.get(e,r)*(1/(i[e]*h[r]))*(1/(t.rows-1)));return l}class K{constructor(t,e={}){const{assumeSymmetric:r=!1}=e;if(!(t=F.checkMatrix(t)).isSquare())throw new Error("Matrix is not a square matrix");if(t.isEmpty())throw new Error("Matrix must be non-empty");let s,o,n=t.columns,i=new k(n,n),h=new Float64Array(n),l=new Float64Array(n),u=t,a=!1;if(a=!!r||t.isSymmetric(),a){for(s=0;s<n;s++)for(o=0;o<n;o++)i.set(s,o,u.get(s,o));!function(t,e,r,s){let o,n,i,h,l,u,a,c;for(l=0;l<t;l++)r[l]=s.get(t-1,l);for(h=t-1;h>0;h--){for(c=0,i=0,u=0;u<h;u++)c+=Math.abs(r[u]);if(0===c)for(e[h]=r[h-1],l=0;l<h;l++)r[l]=s.get(h-1,l),s.set(h,l,0),s.set(l,h,0);else{for(u=0;u<h;u++)r[u]/=c,i+=r[u]*r[u];for(o=r[h-1],n=Math.sqrt(i),o>0&&(n=-n),e[h]=c*n,i-=o*n,r[h-1]=o-n,l=0;l<h;l++)e[l]=0;for(l=0;l<h;l++){for(o=r[l],s.set(l,h,o),n=e[l]+s.get(l,l)*o,u=l+1;u<=h-1;u++)n+=s.get(u,l)*r[u],e[u]+=s.get(u,l)*o;e[l]=n}for(o=0,l=0;l<h;l++)e[l]/=i,o+=e[l]*r[l];for(a=o/(i+i),l=0;l<h;l++)e[l]-=a*r[l];for(l=0;l<h;l++){for(o=r[l],n=e[l],u=l;u<=h-1;u++)s.set(u,l,s.get(u,l)-(o*e[u]+n*r[u]));r[l]=s.get(h-1,l),s.set(h,l,0)}}r[h]=i}for(h=0;h<t-1;h++){if(s.set(t-1,h,s.get(h,h)),s.set(h,h,1),i=r[h+1],0!==i){for(u=0;u<=h;u++)r[u]=s.get(u,h+1)/i;for(l=0;l<=h;l++){for(n=0,u=0;u<=h;u++)n+=s.get(u,h+1)*s.get(u,l);for(u=0;u<=h;u++)s.set(u,l,s.get(u,l)-n*r[u])}}for(u=0;u<=h;u++)s.set(u,h+1,0)}for(l=0;l<t;l++)r[l]=s.get(t-1,l),s.set(t-1,l,0);s.set(t-1,t-1,1),e[0]=0}(n,l,h,i),function(t,e,r,s){let o,n,i,h,l,u,a,c,f,m,g,w,p,d,y,M,b;for(i=1;i<t;i++)e[i-1]=e[i];e[t-1]=0;let x=0,E=0,v=Number.EPSILON;for(u=0;u<t;u++){for(E=Math.max(E,Math.abs(r[u])+Math.abs(e[u])),a=u;a<t&&!(Math.abs(e[a])<=v*E);)a++;if(a>u){b=0;do{for(b+=1,o=r[u],c=(r[u+1]-o)/(2*e[u]),f=_(c,1),c<0&&(f=-f),r[u]=e[u]/(c+f),r[u+1]=e[u]*(c+f),m=r[u+1],n=o-r[u],i=u+2;i<t;i++)r[i]-=n;for(x+=n,c=r[a],g=1,w=g,p=g,d=e[u+1],y=0,M=0,i=a-1;i>=u;i--)for(p=w,w=g,M=y,o=g*e[i],n=g*c,f=_(c,e[i]),e[i+1]=y*f,y=e[i]/f,g=c/f,c=g*r[i]-y*o,r[i+1]=n+y*(g*o+y*r[i]),l=0;l<t;l++)n=s.get(l,i+1),s.set(l,i+1,y*s.get(l,i)+g*n),s.set(l,i,g*s.get(l,i)-y*n);c=-y*M*p*d*e[u]/m,e[u]=y*c,r[u]=g*c}while(Math.abs(e[u])>v*E)}r[u]=r[u]+x,e[u]=0}for(i=0;i<t-1;i++){for(l=i,c=r[i],h=i+1;h<t;h++)r[h]<c&&(l=h,c=r[h]);if(l!==i)for(r[l]=r[i],r[i]=c,h=0;h<t;h++)c=s.get(h,i),s.set(h,i,s.get(h,l)),s.set(h,l,c)}}(n,l,h,i)}else{let t=new k(n,n),e=new Float64Array(n);for(o=0;o<n;o++)for(s=0;s<n;s++)t.set(s,o,u.get(s,o));!function(t,e,r,s){let o,n,i,h,l,u,a,c=t-1;for(u=1;u<=c-1;u++){for(a=0,h=u;h<=c;h++)a+=Math.abs(e.get(h,u-1));if(0!==a){for(i=0,h=c;h>=u;h--)r[h]=e.get(h,u-1)/a,i+=r[h]*r[h];for(n=Math.sqrt(i),r[u]>0&&(n=-n),i-=r[u]*n,r[u]=r[u]-n,l=u;l<t;l++){for(o=0,h=c;h>=u;h--)o+=r[h]*e.get(h,l);for(o/=i,h=u;h<=c;h++)e.set(h,l,e.get(h,l)-o*r[h])}for(h=0;h<=c;h++){for(o=0,l=c;l>=u;l--)o+=r[l]*e.get(h,l);for(o/=i,l=u;l<=c;l++)e.set(h,l,e.get(h,l)-o*r[l])}r[u]=a*r[u],e.set(u,u-1,a*n)}}for(h=0;h<t;h++)for(l=0;l<t;l++)s.set(h,l,h===l?1:0);for(u=c-1;u>=1;u--)if(0!==e.get(u,u-1)){for(h=u+1;h<=c;h++)r[h]=e.get(h,u-1);for(l=u;l<=c;l++){for(n=0,h=u;h<=c;h++)n+=r[h]*s.get(h,l);for(n=n/r[u]/e.get(u,u-1),h=u;h<=c;h++)s.set(h,l,s.get(h,l)+n*r[h])}}}(n,t,e,i),function(t,e,r,s,o){let n,i,h,l,u,a,c,f,m,g,w,p,d,y,M,b=t-1,x=t-1,E=Number.EPSILON,v=0,S=0,k=0,R=0,I=0,T=0,A=0,q=0;for(n=0;n<t;n++)for((n<0||n>x)&&(r[n]=o.get(n,n),e[n]=0),i=Math.max(n-1,0);i<t;i++)S+=Math.abs(o.get(n,i));for(;b>=0;){for(l=b;l>0&&(T=Math.abs(o.get(l-1,l-1))+Math.abs(o.get(l,l)),0===T&&(T=S),!(Math.abs(o.get(l,l-1))<E*T));)l--;if(l===b)o.set(b,b,o.get(b,b)+v),r[b]=o.get(b,b),e[b]=0,b--,q=0;else if(l===b-1){if(c=o.get(b,b-1)*o.get(b-1,b),k=(o.get(b-1,b-1)-o.get(b,b))/2,R=k*k+c,A=Math.sqrt(Math.abs(R)),o.set(b,b,o.get(b,b)+v),o.set(b-1,b-1,o.get(b-1,b-1)+v),f=o.get(b,b),R>=0){for(A=k>=0?k+A:k-A,r[b-1]=f+A,r[b]=r[b-1],0!==A&&(r[b]=f-c/A),e[b-1]=0,e[b]=0,f=o.get(b,b-1),T=Math.abs(f)+Math.abs(A),k=f/T,R=A/T,I=Math.sqrt(k*k+R*R),k/=I,R/=I,i=b-1;i<t;i++)A=o.get(b-1,i),o.set(b-1,i,R*A+k*o.get(b,i)),o.set(b,i,R*o.get(b,i)-k*A);for(n=0;n<=b;n++)A=o.get(n,b-1),o.set(n,b-1,R*A+k*o.get(n,b)),o.set(n,b,R*o.get(n,b)-k*A);for(n=0;n<=x;n++)A=s.get(n,b-1),s.set(n,b-1,R*A+k*s.get(n,b)),s.set(n,b,R*s.get(n,b)-k*A)}else r[b-1]=f+k,r[b]=f+k,e[b-1]=A,e[b]=-A;b-=2,q=0}else{if(f=o.get(b,b),m=0,c=0,l<b&&(m=o.get(b-1,b-1),c=o.get(b,b-1)*o.get(b-1,b)),10===q){for(v+=f,n=0;n<=b;n++)o.set(n,n,o.get(n,n)-f);T=Math.abs(o.get(b,b-1))+Math.abs(o.get(b-1,b-2)),f=m=.75*T,c=-.4375*T*T}if(30===q&&(T=(m-f)/2,T=T*T+c,T>0)){for(T=Math.sqrt(T),m<f&&(T=-T),T=f-c/((m-f)/2+T),n=0;n<=b;n++)o.set(n,n,o.get(n,n)-T);v+=T,f=m=c=.964}for(q+=1,u=b-2;u>=l&&(A=o.get(u,u),I=f-A,T=m-A,k=(I*T-c)/o.get(u+1,u)+o.get(u,u+1),R=o.get(u+1,u+1)-A-I-T,I=o.get(u+2,u+1),T=Math.abs(k)+Math.abs(R)+Math.abs(I),k/=T,R/=T,I/=T,u!==l)&&!(Math.abs(o.get(u,u-1))*(Math.abs(R)+Math.abs(I))<E*(Math.abs(k)*(Math.abs(o.get(u-1,u-1))+Math.abs(A)+Math.abs(o.get(u+1,u+1)))));)u--;for(n=u+2;n<=b;n++)o.set(n,n-2,0),n>u+2&&o.set(n,n-3,0);for(h=u;h<=b-1&&(y=h!==b-1,h!==u&&(k=o.get(h,h-1),R=o.get(h+1,h-1),I=y?o.get(h+2,h-1):0,f=Math.abs(k)+Math.abs(R)+Math.abs(I),0!==f&&(k/=f,R/=f,I/=f)),0!==f);h++)if(T=Math.sqrt(k*k+R*R+I*I),k<0&&(T=-T),0!==T){for(h!==u?o.set(h,h-1,-T*f):l!==u&&o.set(h,h-1,-o.get(h,h-1)),k+=T,f=k/T,m=R/T,A=I/T,R/=k,I/=k,i=h;i<t;i++)k=o.get(h,i)+R*o.get(h+1,i),y&&(k+=I*o.get(h+2,i),o.set(h+2,i,o.get(h+2,i)-k*A)),o.set(h,i,o.get(h,i)-k*f),o.set(h+1,i,o.get(h+1,i)-k*m);for(n=0;n<=Math.min(b,h+3);n++)k=f*o.get(n,h)+m*o.get(n,h+1),y&&(k+=A*o.get(n,h+2),o.set(n,h+2,o.get(n,h+2)-k*I)),o.set(n,h,o.get(n,h)-k),o.set(n,h+1,o.get(n,h+1)-k*R);for(n=0;n<=x;n++)k=f*s.get(n,h)+m*s.get(n,h+1),y&&(k+=A*s.get(n,h+2),s.set(n,h+2,s.get(n,h+2)-k*I)),s.set(n,h,s.get(n,h)-k),s.set(n,h+1,s.get(n,h+1)-k*R)}}}if(0!==S){for(b=t-1;b>=0;b--)if(k=r[b],R=e[b],0===R)for(l=b,o.set(b,b,1),n=b-1;n>=0;n--){for(c=o.get(n,n)-k,I=0,i=l;i<=b;i++)I+=o.get(n,i)*o.get(i,b);if(e[n]<0)A=c,T=I;else if(l=n,0===e[n]?o.set(n,b,0!==c?-I/c:-I/(E*S)):(f=o.get(n,n+1),m=o.get(n+1,n),R=(r[n]-k)*(r[n]-k)+e[n]*e[n],a=(f*T-A*I)/R,o.set(n,b,a),o.set(n+1,b,Math.abs(f)>Math.abs(A)?(-I-c*a)/f:(-T-m*a)/A)),a=Math.abs(o.get(n,b)),E*a*a>1)for(i=n;i<=b;i++)o.set(i,b,o.get(i,b)/a)}else if(R<0)for(l=b-1,Math.abs(o.get(b,b-1))>Math.abs(o.get(b-1,b))?(o.set(b-1,b-1,R/o.get(b,b-1)),o.set(b-1,b,-(o.get(b,b)-k)/o.get(b,b-1))):(M=Z(0,-o.get(b-1,b),o.get(b-1,b-1)-k,R),o.set(b-1,b-1,M[0]),o.set(b-1,b,M[1])),o.set(b,b-1,0),o.set(b,b,1),n=b-2;n>=0;n--){for(g=0,w=0,i=l;i<=b;i++)g+=o.get(n,i)*o.get(i,b-1),w+=o.get(n,i)*o.get(i,b);if(c=o.get(n,n)-k,e[n]<0)A=c,I=g,T=w;else if(l=n,0===e[n]?(M=Z(-g,-w,c,R),o.set(n,b-1,M[0]),o.set(n,b,M[1])):(f=o.get(n,n+1),m=o.get(n+1,n),p=(r[n]-k)*(r[n]-k)+e[n]*e[n]-R*R,d=2*(r[n]-k)*R,0===p&&0===d&&(p=E*S*(Math.abs(c)+Math.abs(R)+Math.abs(f)+Math.abs(m)+Math.abs(A))),M=Z(f*I-A*g+R*w,f*T-A*w-R*g,p,d),o.set(n,b-1,M[0]),o.set(n,b,M[1]),Math.abs(f)>Math.abs(A)+Math.abs(R)?(o.set(n+1,b-1,(-g-c*o.get(n,b-1)+R*o.get(n,b))/f),o.set(n+1,b,(-w-c*o.get(n,b)-R*o.get(n,b-1))/f)):(M=Z(-I-m*o.get(n,b-1),-T-m*o.get(n,b),A,R),o.set(n+1,b-1,M[0]),o.set(n+1,b,M[1]))),a=Math.max(Math.abs(o.get(n,b-1)),Math.abs(o.get(n,b))),E*a*a>1)for(i=n;i<=b;i++)o.set(i,b-1,o.get(i,b-1)/a),o.set(i,b,o.get(i,b)/a)}for(n=0;n<t;n++)if(n<0||n>x)for(i=n;i<t;i++)s.set(n,i,o.get(n,i));for(i=t-1;i>=0;i--)for(n=0;n<=x;n++){for(A=0,h=0;h<=Math.min(i,x);h++)A+=s.get(n,h)*o.get(h,i);s.set(n,i,A)}}}(n,l,h,i,t)}this.n=n,this.e=l,this.d=h,this.V=i}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t,e,r=this.n,s=this.e,o=this.d,n=new k(r,r);for(t=0;t<r;t++){for(e=0;e<r;e++)n.set(t,e,0);n.set(t,t,o[t]),s[t]>0?n.set(t,t+1,s[t]):s[t]<0&&n.set(t,t-1,s[t])}return n}}function Z(t,e,r,s){let o,n;return Math.abs(r)>Math.abs(s)?(o=s/r,n=r+o*s,[(t+o*e)/n,(e-o*t)/n]):(o=r/s,n=s+o*r,[(o*t+e)/n,(o*e-t)/n])}class tt{constructor(t){if(!(t=F.checkMatrix(t)).isSymmetric())throw new Error("Matrix is not symmetric");let e,r,s,o=t,n=o.rows,i=new k(n,n),h=!0;for(r=0;r<n;r++){let t=0;for(s=0;s<r;s++){let n=0;for(e=0;e<s;e++)n+=i.get(s,e)*i.get(r,e);n=(o.get(r,s)-n)/i.get(s,s),i.set(r,s,n),t+=n*n}for(t=o.get(r,r)-t,h&=t>0,i.set(r,r,Math.sqrt(Math.max(t,0))),s=r+1;s<n;s++)i.set(r,s,0)}this.L=i,this.positiveDefinite=Boolean(h)}isPositiveDefinite(){return this.positiveDefinite}solve(t){t=F.checkMatrix(t);let e=this.L,r=e.rows;if(t.rows!==r)throw new Error("Matrix dimensions do not match");if(!1===this.isPositiveDefinite())throw new Error("Matrix is not positive definite");let s,o,n,i=t.columns,h=t.clone();for(n=0;n<r;n++)for(o=0;o<i;o++){for(s=0;s<n;s++)h.set(n,o,h.get(n,o)-h.get(s,o)*e.get(n,s));h.set(n,o,h.get(n,o)/e.get(n,n))}for(n=r-1;n>=0;n--)for(o=0;o<i;o++){for(s=n+1;s<r;s++)h.set(n,o,h.get(n,o)-h.get(s,o)*e.get(s,n));h.set(n,o,h.get(n,o)/e.get(n,n))}return h}get lowerTriangularMatrix(){return this.L}}class et{constructor(t,e={}){t=F.checkMatrix(t);let{Y:r}=e;const{scaleScores:s=!1,maxIterations:o=1e3,terminationCriteria:n=1e-10}=e;let i;if(r){if(r=Array.isArray(r)&&"number"==typeof r[0]?k.columnVector(r):F.checkMatrix(r),!r.isColumnVector()||r.rows!==t.rows)throw new Error("Y must be a column vector of length X.rows");i=r}else i=t.getColumnVector(0);let h,l,u,a,c=1;for(let e=0;e<o&&c>n;e++)u=t.transpose().mmul(i).div(i.transpose().mmul(i).get(0,0)),u=u.div(u.norm()),h=t.mmul(u).div(u.transpose().mmul(u).get(0,0)),e>0&&(c=h.clone().sub(a).pow(2).sum()),a=h.clone(),r?(l=r.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),l=l.div(l.norm()),i=r.mmul(l).div(l.transpose().mmul(l).get(0,0))):i=h;if(r){let e=t.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0));e=e.div(e.norm());let s=t.clone().sub(h.clone().mmul(e.transpose())),o=i.transpose().mmul(h).div(h.transpose().mmul(h).get(0,0)),n=r.clone().sub(h.clone().mulS(o.get(0,0)).mmul(l.transpose()));this.t=h,this.p=e.transpose(),this.w=u.transpose(),this.q=l,this.u=i,this.s=h.transpose().mmul(h),this.xResidual=s,this.yResidual=n,this.betas=o}else this.w=u.transpose(),this.s=h.transpose().mmul(h).sqrt(),this.t=s?h.clone().div(this.s.get(0,0)):h,this.xResidual=t.sub(h.mmul(u.transpose()))}}},842:(t,e,r)=>{"use strict";r.d(e,{Z:()=>s});class s{constructor(t=[],e=o){if(this.data=t,this.length=this.data.length,this.compare=e,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}peek(){return this.data[0]}_up(t){const{data:e,compare:r}=this,s=e[t];for(;t>0;){const o=t-1>>1,n=e[o];if(r(s,n)>=0)break;e[t]=n,t=o}e[t]=s}_down(t){const{data:e,compare:r}=this,s=this.length>>1,o=e[t];for(;t<s;){let s=1+(t<<1),n=e[s];const i=s+1;if(i<this.length&&r(e[i],n)<0&&(s=i,n=e[i]),r(n,o)>=0)break;e[t]=n,t=s}e[t]=o}}function o(t,e){return t<e?-1:t>e?1:0}},902:(t,e,r)=>{const{Matrix:s,inverse:o}=r(331),{solveHomography:n}=r(450);t.exports={estimate:({screenCoords:t,worldCoords:e,projectionTransform:r})=>{const i=n(e.map((t=>[t.x,t.y])),t.map((t=>[t.x,t.y]))),h=new s([[i[0],i[1],i[2]],[i[3],i[4],i[5]],[i[6],i[7],i[8]]]),l=new s(r),u=o(l).mmul(h).to1DArray(),a=Math.sqrt(u[0]*u[0]+u[3]*u[3]+u[6]*u[6]),c=Math.sqrt(u[1]*u[1]+u[4]*u[4]+u[7]*u[7]),f=(a+c)/2,m=[];m[0]=u[0]/a,m[3]=u[3]/a,m[6]=u[6]/a,m[1]=u[1]/c,m[4]=u[4]/c,m[7]=u[7]/c,m[2]=m[3]*m[7]-m[6]*m[4],m[5]=m[6]*m[1]-m[0]*m[7],m[8]=m[0]*m[4]-m[1]*m[3];const g=Math.sqrt(m[2]*m[2]+m[5]*m[5]+m[8]*m[8]);m[2]/=g,m[5]/=g,m[8]/=g;const w=[];return w[0]=u[2]/f,w[1]=u[5]/f,w[2]=u[8]/f,[[m[0],m[1],m[2],w[0]],[m[3],m[4],m[5],w[1]],[m[6],m[7],m[8],w[2]]]}}},421:(t,e,r)=>{const{estimate:s}=r(902),{refineEstimate:o}=r(269);t.exports={Estimator:class{constructor(t){this.projectionTransform=t}estimate({screenCoords:t,worldCoords:e}){return s({screenCoords:t,worldCoords:e,projectionTransform:this.projectionTransform})}refineEstimate({initialModelViewTransform:t,worldCoords:e,screenCoords:r}){return o({initialModelViewTransform:t,worldCoords:e,screenCoords:r,projectionTransform:this.projectionTransform})}}}},269:(t,e,r)=>{const{Matrix:s,inverse:o}=r(331),{normalizePoints:n,applyModelViewProjectionTransform:i,buildModelViewProjectionTransform:h,computeScreenCoordiate:l}=r(420);let u=[[],[],[]],a=[[],[]],c=[[],[],[]];const f=({initialModelViewTransform:t,projectionTransform:e,worldCoords:r,screenCoords:s,inlierProb:o})=>{const n=o<1;let i=t,u=0,a=0,c=new Array(r.length),f=new Array(r.length),p=new Array(r.length),d=new Array(r.length);for(let t=0;t<=10;t++){const y=h(e,i);for(let t=0;t<r.length;t++){const e=l(y,r[t].x,r[t].y,r[t].z),o=s[t].x-e.x,n=s[t].y-e.y;p[t]=o,d[t]=n,c[t]=o*o+n*n}let M;if(a=0,n){const t=Math.max(3,Math.floor(r.length*o)-1);for(let t=0;t<r.length;t++)f[t]=c[t];f.sort(((t,e)=>t-e)),M=Math.max(4*f[t],16);for(let t=0;t<r.length;t++)f[t]>M?a+=M/6:a+=M/6*(1-(1-f[t]/M)*(1-f[t]/M)*(1-f[t]/M))}else for(let t=0;t<r.length;t++)a+=c[t];if(a/=r.length,a<.1)break;if(t>0&&a/u>.99)break;if(10===t)break;u=a;const b=[],x=[];for(let t=0;t<r.length;t++){if(n&&c[t]>M)continue;const s=w({modelViewProjectionTransform:y,modelViewTransform:i,projectionTransform:e,worldCoord:r[t]});if(n){const e=(1-c[t]/M)*(1-c[t]/M);for(let t=0;t<2;t++)for(let r=0;r<6;r++)s[t][r]*=e;b.push([p[t]*e]),b.push([d[t]*e])}else b.push([p[t]]),b.push([d[t]]);for(let t=0;t<s.length;t++)x.push(s[t])}const E=g({dU:b,J_U_S:x});if(null===E)break;i=m({modelViewTransform:i,dS:E})}return{modelViewTransform:i,err:a}},m=({modelViewTransform:t,dS:e})=>{let r,s,o,n=e[0]*e[0]+e[1]*e[1]+e[2]*e[2];n<1e-6?(r=1,s=0,o=0,n=0):(n=Math.sqrt(n),r=e[0]/n,s=e[1]/n,o=e[2]/n);const i=Math.cos(n),h=Math.sin(n),l=1-i;u[0][0]=r*r*l+i,u[0][1]=r*s*l-o*h,u[0][2]=r*o*l+s*h,u[0][3]=e[3],u[1][0]=s*r*l+o*h,u[1][1]=s*s*l+i,u[1][2]=s*o*l-r*h,u[1][3]=e[4],u[2][0]=o*r*l-s*h,u[2][1]=o*s*l+r*h,u[2][2]=o*o*l+i,u[2][3]=e[5];const a=[[],[],[]];for(let e=0;e<3;e++){for(let r=0;r<4;r++)a[e][r]=t[e][0]*u[0][r]+t[e][1]*u[1][r]+t[e][2]*u[2][r];a[e][3]+=t[e][3]}return a},g=({dU:t,J_U_S:e})=>{const r=new s(e),n=new s(t),i=r.transpose(),h=i.mmul(r),l=i.mmul(n);let u;try{u=o(h)}catch(t){return null}return u.mmul(l).to1DArray()},w=({modelViewProjectionTransform:t,modelViewTransform:e,projectionTransform:r,worldCoord:s})=>{const o=e,{x:n,y:h,z:l}=s,u=i(t,n,h,l),f=u.z*u.z;a[0][0]=r[0][0]*u.z/f,a[0][1]=r[0][1]*u.z/f,a[0][2]=(r[0][2]*u.z-r[2][2]*u.x)/f,a[1][0]=r[1][0]*u.z/f,a[1][1]=r[1][1]*u.z/f,a[1][2]=(r[1][2]*u.z-r[2][2]*u.y)/f,c[0][0]=o[0][2]*h,c[0][1]=-o[0][2]*n,c[0][2]=o[0][1]*n-o[0][0]*h,c[0][3]=o[0][0],c[0][4]=o[0][1],c[0][5]=o[0][2],c[1][0]=o[1][2]*h,c[1][1]=-o[1][2]*n,c[1][2]=o[1][1]*n-o[1][0]*h,c[1][3]=o[1][0],c[1][4]=o[1][1],c[1][5]=o[1][2],c[2][0]=o[2][2]*h,c[2][1]=-o[2][2]*n,c[2][2]=o[2][1]*n-o[2][0]*h,c[2][3]=o[2][0],c[2][4]=o[2][1],c[2][5]=o[2][2];const m=[[],[]];for(let t=0;t<2;t++)for(let e=0;e<6;e++){m[t][e]=0;for(let r=0;r<3;r++)m[t][e]+=a[t][r]*c[r][e]}return m};t.exports={refineEstimate:({initialModelViewTransform:t,projectionTransform:e,worldCoords:r,screenCoords:s})=>{let o=0,n=0;for(let t=0;t<r.length;t++)o+=r[t].x,n+=r[t].y;o/=r.length,n/=r.length;const i=[];for(let t=0;t<r.length;t++)i.push({x:r[t].x-o,y:r[t].y-n,z:r[t].z});const h=[[],[],[]];for(let e=0;e<3;e++)for(let r=0;r<3;r++)h[e][r]=t[e][r];h[0][3]=t[0][0]*o+t[0][1]*n+t[0][3],h[1][3]=t[1][0]*o+t[1][1]*n+t[1][3],h[2][3]=t[2][0]*o+t[2][1]*n+t[2][3];const l=[1,.8,.6,.4,0];let u=h,a=null;for(let t=0;t<l.length;t++){const r=f({initialModelViewTransform:u,projectionTransform:e,worldCoords:i,screenCoords:s,inlierProb:l[t]});if(u=r.modelViewTransform,r.err<5){a=u;break}}return null===a?null:(a[0][3]=a[0][3]-a[0][0]*o-a[0][1]*n,a[1][3]=a[1][3]-a[1][0]*o-a[1][1]*n,a[2][3]=a[2][3]-a[2][0]*o-a[2][1]*n,a)}}},420:t=>{const e=(t,e,r,s)=>({x:t[0][0]*e+t[0][1]*r+t[0][3],y:t[1][0]*e+t[1][1]*r+t[1][3],z:t[2][0]*e+t[2][1]*r+t[2][3]});t.exports={buildModelViewProjectionTransform:(t,e)=>[[t[0][0]*e[0][0]+t[0][2]*e[2][0],t[0][0]*e[0][1]+t[0][2]*e[2][1],t[0][0]*e[0][2]+t[0][2]*e[2][2],t[0][0]*e[0][3]+t[0][2]*e[2][3]],[t[1][1]*e[1][0]+t[1][2]*e[2][0],t[1][1]*e[1][1]+t[1][2]*e[2][1],t[1][1]*e[1][2]+t[1][2]*e[2][2],t[1][1]*e[1][3]+t[1][2]*e[2][3]],[e[2][0],e[2][1],e[2][2],e[2][3]]],applyModelViewProjectionTransform:e,computeScreenCoordiate:(t,r,s,o)=>{const{x:n,y:i,z:h}=e(t,r,s);return{x:n/h,y:i/h}}}},233:t=>{t.exports={compute:t=>{const{v1:e,v2:r}=t;let s=0;for(let t=0;t<e.length;t++){let i=(e[t]^r[t])>>>0;s+=(n=void 0,((n=((n=((n=((n=(o=i)-(o>>1&1431655765))>>2&858993459)+(858993459&n))>>4)+n&252645135)>>8)+n&16711935)>>16)+n&65535)}var o,n;return s}}},934:t=>{const e=({querypoint:t,keypoint:e,keycenterX:r,keycenterY:s,scaleOneOverLogK:o})=>{let n=t.angle-e.angle;n<=-Math.PI?n+=2*Math.PI:n>Math.PI&&(n-=2*Math.PI);const i=t.scale/e.scale,h=i*Math.cos(n),l=i*Math.sin(n),u=[h,-l,l,h],a=[u[0]*e.x+u[1]*e.y,u[2]*e.x+u[3]*e.y],c=t.x-a[0],f=t.y-a[1];return{x:u[0]*r+u[1]*s+c,y:u[2]*r+u[3]*s+f,angle:n,scale:Math.log(i)*o}};t.exports={computeHoughMatches:t=>{const{keywidth:r,keyheight:s,querywidth:o,queryheight:n,matches:i}=t,h=1.2*o,l=-h,u=1.2*n,a=-u,c=12,f=1/Math.log(10),m=Math.max(r,s),g=Math.floor(r/2),w=Math.floor(s/2),p=[];for(let t=0;t<i.length;t++){const e=i[t].querypoint.scale,r=i[t].keypoint.scale;0==r&&console.log("ERROR divide zero");const s=e/r;p.push(s*m)}p.sort(((t,e)=>t-e));const d=.25*p[Math.floor(p.length/2)-(p.length%2==0?1:0)-1],y=Math.max(5,Math.ceil((h-l)/d)),M=Math.max(5,Math.ceil((u-a)/d)),b=y*M,x=b*c,E=[],v=[],S={};for(let t=0;t<i.length;t++){const r=i[t].querypoint,s=i[t].keypoint,{x:o,y:n,scale:m,angle:p}=e({querypoint:r,keypoint:s,keycenterX:g,keycenterY:w,scaleOneOverLogK:f});if(o<l||o>=h||n<a||n>=u||p<=-Math.PI||p>Math.PI||m<-1||m>=1){E[t]=!1;continue}let d=y*(o-l)/(h-l),k=M*(n-a)/(u-a),R=c*(p+Math.PI)/(2*Math.PI),I=10*(m- -1)/2;v[t]={binX:d,binY:k,binAngle:R,binScale:I};let T=Math.floor(d-.5),A=Math.floor(k-.5),q=Math.floor(I-.5),C=(Math.floor(R-.5)+c)%c;if(T<0||T+1>=y||A<0||A+1>=M||q<0||q+1>=10)E[t]=!1;else{for(let t=0;t<2;t++){let e=T+t;for(let t=0;t<2;t++){let r=A+t;for(let t=0;t<2;t++){let s=(C+t)%c;for(let t=0;t<2;t++){const o=e+r*y+s*b+(q+t)*x;void 0===S[o]&&(S[o]=0),S[o]+=1}}}}E[t]=!0}}let k=0,R=-1;if(Object.keys(S).forEach((t=>{S[t]>k&&(k=S[t],R=t)})),k<3)return[];const I=Math.floor(R%x%b%y),T=Math.floor((R-I)%x%b/y),A=Math.floor((R-I-T*y)%x/b),q=Math.floor((R-I-T*y-A*b)/x),C=[];for(let t=0;t<i.length;t++){if(!E[t])continue;const e=v[t];if(Math.abs(e.binX-(I+.5))>=1)continue;if(Math.abs(e.binY-(T+.5))>=1)continue;if(Math.abs(e.binScale-(q+.5))>=1)continue;const r=Math.abs(e.binAngle-(A+.5));Math.min(r,c-r)>=1||C.push(i[t])}return C}}},582:(t,e,r)=>{const{match:s}=r(492);t.exports={Matcher:class{constructor(t,e,r=!1){this.queryWidth=t,this.queryHeight=e,this.debugMode=r}matchDetection(t,e){let r={frames:[]},o=null;for(let n=0;n<t.length;n++){const{H:i,matches:h,debugExtra:l}=s({keyframe:t[n],querypoints:e,querywidth:this.queryWidth,queryheight:this.queryHeight,debugMode:this.debugMode});r.frames.push(l),i&&(null===o||o.matches.length<h.length)&&(o={keyframeIndex:n,H:i,matches:h})}if(null===o)return{keyframeIndex:-1,debugExtra:r};const n=[],i=[],h=t[o.keyframeIndex];for(let t=0;t<o.matches.length;t++){const e=o.matches[t].querypoint,r=o.matches[t].keypoint;n.push({x:e.x,y:e.y}),i.push({x:(r.x+.5)/h.scale,y:(r.y+.5)/h.scale,z:0})}return{screenCoords:n,worldCoords:i,keyframeIndex:o.keyframeIndex,debugExtra:r}}}}},492:(t,e,r)=>{const s=r(842).Z,{compute:o}=r(233),{computeHoughMatches:n}=r(934),{computeHomography:i}=r(838),{multiplyPointHomographyInhomogenous:h,matrixInverse33:l}=r(289),u=({node:t,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i})=>{if(t.leaf){for(let e=0;e<t.pointIndexes.length;e++)n.push(t.pointIndexes[e]);return}const h=[];for(let s=0;s<t.children.length;s++){const n=t.children[s].centerPointIndex,i=o({v1:e[n].descriptors,v2:r.descriptors});h.push(i)}let l=Number.MAX_SAFE_INTEGER;for(let e=0;e<t.children.length;e++)l=Math.min(l,h[e]);for(let e=0;e<t.children.length;e++)h[e]!==l&&s.push({node:t.children[e],d:h[e]});for(let o=0;o<t.children.length;o++)h[o]===l&&u({node:t.children[o],keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i});if(i<8&&s.length>0){const{node:t,d:o}=s.pop();u({node:t,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i+=1})}},a=t=>{const{H:e,matches:r,threshold:s}=t,o=s*s,n=[];for(let t=0;t<r.length;t++){const s=r[t].querypoint,i=r[t].keypoint,l=h([i.x,i.y],e);(l[0]-s.x)*(l[0]-s.x)+(l[1]-s.y)*(l[1]-s.y)<=o&&n.push(r[t])}return n};t.exports={match:({keyframe:t,querypoints:e,querywidth:r,queryheight:c,debugMode:f})=>{let m={};const g=[];for(let r=0;r<e.length;r++){const n=e[r],i=n.maxima?t.maximaPoints:t.minimaPoints;if(0===i.length)continue;const h=n.maxima?t.maximaPointsCluster.rootNode:t.minimaPointsCluster.rootNode,l=[],a=new s([],((t,e)=>t.d-e.d));u({node:h,keypoints:i,querypoint:n,queue:a,keypointIndexes:l,numPop:0});let c=-1,f=Number.MAX_SAFE_INTEGER,m=Number.MAX_SAFE_INTEGER;for(let t=0;t<l.length;t++){const e=i[l[t]],r=o({v1:e.descriptors,v2:n.descriptors});r<f?(m=f,f=r,c=l[t]):r<m&&(m=r)}-1!==c&&(m===Number.MAX_SAFE_INTEGER||1*f/m<.7)&&g.push({querypoint:n,keypoint:i[c]})}if(f&&(m.matches=g),g.length<6)return{debugExtra:m};const w=n({keywidth:t.width,keyheight:t.height,querywidth:r,queryheight:c,matches:g});f&&(m.houghMatches=w);const p=i({srcPoints:w.map((t=>[t.keypoint.x,t.keypoint.y])),dstPoints:w.map((t=>[t.querypoint.x,t.querypoint.y])),keyframe:t});if(null===p)return{debugExtra:m};const d=a({H:p,matches:w,threshold:3});if(f&&(m.inlierMatches=d),d.length<6)return{debugExtra:m};const y=l(p,1e-5),M=[];for(let r=0;r<e.length;r++){const s=e[r],n=h([s.x,s.y],y);let i=-1,l=Number.MAX_SAFE_INTEGER,u=Number.MAX_SAFE_INTEGER;const a=s.maxima?t.maximaPoints:t.minimaPoints;for(let t=0;t<a.length;t++){const e=a[t];if((e.x-n[0])*(e.x-n[0])+(e.y-n[1])*(e.y-n[1])>100)continue;const r=o({v1:e.descriptors,v2:s.descriptors});r<l?(u=l,l=r,i=t):r<u&&(u=r)}-1!==i&&(u===Number.MAX_SAFE_INTEGER||1*l/u<.7)&&M.push({querypoint:s,keypoint:a[i]})}f&&(m.matches2=M);const b=n({keywidth:t.width,keyheight:t.height,querywidth:r,queryheight:c,matches:M});f&&(m.houghMatches2=b);const x=i({srcPoints:b.map((t=>[t.keypoint.x,t.keypoint.y])),dstPoints:b.map((t=>[t.querypoint.x,t.querypoint.y])),keyframe:t});if(null===x)return{debugExtra:m};const E=a({H:x,matches:b,threshold:3});return f&&(m.inlierMatches2=E),{H:x,matches:E,debugExtra:m}}}},838:(t,e,r)=>{const{Matrix:s,inverse:o}=r(331),{createRandomizer:n}=r(48),{quadrilateralConvex:i,matrixInverse33:h,smallestTriangleArea:l,multiplyPointHomographyInhomogenous:u,checkThreePointsConsistent:a,checkFourPointsConsistent:c,determinant:f}=r(289),{solveHomography:m}=r(450),g=({H:t,testPoints:e,keyframe:r})=>{const s=h(t,1e-5);if(null===s)return!1;const o=[];for(let t=0;t<e.length;t++)o.push(u(e[t],s));return!(l(o[0],o[1],o[2],o[3])<r.width*r.height*1e-4||!i(o[0],o[1],o[2],o[3]))},w=({inH:t})=>{const e=1/t[8],r=[];for(let s=0;s<8;s++)r[s]=t[s]*e;return r[8]=1,r},p=({H:t,srcPoint:e,dstPoint:r,oneOverScale2:s})=>{const o=u(e,t),n=[o[0]-r[0],o[1]-r[1]];return Math.log(1+(n[0]*n[0]+n[1]*n[1])*s)},d=({H:t,testPoints:e})=>{const r=[];for(let s=0;s<e.length;s++)r[s]=u(e[s],t);for(let t=0;t<e.length;t++){const s=t,o=(t+1)%e.length,n=(t+2)%e.length;if(!a(e[s],e[o],e[n],r[s],r[o],r[n]))return!1}return!0};t.exports={computeHomography:t=>{const{srcPoints:e,dstPoints:r,keyframe:s,quickMode:o}=t,i=[[0,0],[s.width,0],[s.width,s.height],[0,s.height]];if(e.length<4)return null;const h=Math.min(10,e.length),l=n(),u=[];for(let t=0;t<e.length;t++)u[t]=t;l.arrayShuffle({arr:u,sampleSize:u.length});const a=o?10:20,f=2*a;let y=0;const M=[];for(;y<f&&M.length<a;){if(y+=1,l.arrayShuffle({arr:u,sampleSize:4}),!c(e[u[0]],e[u[1]],e[u[2]],e[u[3]],r[u[0]],r[u[1]],r[u[2]],r[u[3]]))continue;const t=m([e[u[0]],e[u[1]],e[u[2]],e[u[3]]],[r[u[0]],r[u[1]],r[u[2]],r[u[3]]]);null!==t&&d({H:t,testPoints:i})&&M.push(t)}if(0===M.length)return null;const b=[];for(let t=0;t<M.length;t++)b.push({H:M[t],cost:0});let x=h;for(let t=0;t<e.length&&b.length>2;t+=x){x=Math.min(h,e.length-t);let s=t+x;for(let o=0;o<b.length;o++)for(let n=t;n<s;n++){const t=p({H:b[o].H,srcPoint:e[n],dstPoint:r[n],oneOverScale2:1e4});b[o].cost+=t}b.sort(((t,e)=>t.cost-e.cost)),b.splice(-Math.floor((b.length+1)/2))}let E=null;for(let t=0;t<b.length;t++){const e=w({inH:b[t].H});if(g({H:e,testPoints:i,keyframe:s})){E=e;break}}return E}}},289:t=>{const e=(t,e,r)=>(e[0]-t[0])*(r[1]-t[1])-(e[1]-t[1])*(r[0]-t[0]),r=t=>{const e=t[4]*t[8]-t[5]*t[7],r=t[3]*t[8]-t[5]*t[6],s=t[3]*t[7]-t[4]*t[6];return t[0]*e-t[1]*r+t[2]*s},s=(t,e)=>[t[0]-e[0],t[1]-e[1]],o=(t,e)=>{const r=t[0]*e[1]-t[1]*e[0];return.5*Math.abs(r)};t.exports={matrixInverse33:(t,e)=>{const s=r(t);if(Math.abs(s)<=e)return null;const o=1/s;return[(t[4]*t[8]-t[5]*t[7])*o,(t[2]*t[7]-t[1]*t[8])*o,(t[1]*t[5]-t[2]*t[4])*o,(t[5]*t[6]-t[3]*t[8])*o,(t[0]*t[8]-t[2]*t[6])*o,(t[2]*t[3]-t[0]*t[5])*o,(t[3]*t[7]-t[4]*t[6])*o,(t[1]*t[6]-t[0]*t[7])*o,(t[0]*t[4]-t[1]*t[3])*o]},matrixMul33:(t,e)=>{const r=[];return r[0]=t[0]*e[0]+t[1]*e[3]+t[2]*e[6],r[1]=t[0]*e[1]+t[1]*e[4]+t[2]*e[7],r[2]=t[0]*e[2]+t[1]*e[5]+t[2]*e[8],r[3]=t[3]*e[0]+t[4]*e[3]+t[5]*e[6],r[4]=t[3]*e[1]+t[4]*e[4]+t[5]*e[7],r[5]=t[3]*e[2]+t[4]*e[5]+t[5]*e[8],r[6]=t[6]*e[0]+t[7]*e[3]+t[8]*e[6],r[7]=t[6]*e[1]+t[7]*e[4]+t[8]*e[7],r[8]=t[6]*e[2]+t[7]*e[5]+t[8]*e[8],r},quadrilateralConvex:(t,r,s,o)=>{const n=e(t,r,s)<=0;return e(r,s,o)<=0===n&&e(s,o,t)<=0===n&&e(o,t,r)<=0===n},smallestTriangleArea:(t,e,r,n)=>{const i=s(e,t),h=s(r,t),l=s(n,t),u=s(e,r),a=s(n,r),c=o(i,h),f=o(h,l),m=o(i,l),g=o(u,a);return Math.min(Math.min(Math.min(c,f),m),g)},multiplyPointHomographyInhomogenous:(t,e)=>{const r=e[6]*t[0]+e[7]*t[1]+e[8],s=[];return s[0]=(e[0]*t[0]+e[1]*t[1]+e[2])/r,s[1]=(e[3]*t[0]+e[4]*t[1]+e[5])/r,s},checkThreePointsConsistent:(t,r,s,o,n,i)=>e(t,r,s)>0==e(o,n,i)>0,checkFourPointsConsistent:(t,r,s,o,n,i,h,l)=>e(t,r,s)>0==e(n,i,h)>0&&e(r,s,o)>0==e(i,h,l)>0&&e(s,o,t)>0==e(h,l,n)>0&&e(o,t,r)>0==e(l,n,i)>0,determinant:r}},450:(t,e,r)=>{const{Matrix:s,inverse:o}=r(331),n=t=>{let e=0,r=0;for(let s=0;s<t.length;s++)e+=t[s][0],r+=t[s][1];let s=e/t.length,o=r/t.length,n=0;for(let e=0;e<t.length;e++){const r=t[e][0]-s,i=t[e][1]-o;n+=Math.sqrt(r*r+i*i)}let i=Math.sqrt(2)*t.length/n;const h=[];for(let e=0;e<t.length;e++)h.push([(t[e][0]-s)*i,(t[e][1]-o)*i]);return{normPoints:h,param:{meanX:s,meanY:o,s:i}}};t.exports={solveHomography:(t,e)=>{const{normPoints:r,param:i}=n(t),{normPoints:h,param:l}=n(e),u=h.length,a=[],c=[];for(let t=0;t<u;t++){const e=[r[t][0],r[t][1],1,0,0,0,-r[t][0]*h[t][0],-r[t][1]*h[t][0]],s=[0,0,0,r[t][0],r[t][1],1,-r[t][0]*h[t][1],-r[t][1]*h[t][1]];a.push(e),a.push(s),c.push([h[t][0]]),c.push([h[t][1]])}try{const t=new s(a),e=new s(c),r=t.transpose(),n=r.mmul(t),h=r.mmul(e);return((t,e,r)=>{const s=r.s*r.meanX,o=r.s*r.meanY,n=[t[0]+s*t[6],t[1]+s*t[7],(t[0]+s*t[6])*-e.meanX+(t[1]+s*t[7])*-e.meanY+(t[2]+s)/e.s,t[3]+o*t[6],t[4]+o*t[7],(t[3]+o*t[6])*-e.meanX+(t[4]+o*t[7])*-e.meanY+(t[5]+o)/e.s,r.s*t[6],r.s*t[7],r.s*t[6]*-e.meanX+r.s*t[7]*-e.meanY+r.s/e.s];for(let t=0;t<9;t++)n[t]=n[t]/n[8];return n})(o(n).mmul(h).to1DArray(),i,l)}catch(t){return null}}}},48:t=>{t.exports={createRandomizer:()=>({seed:1234,arrayShuffle(t){const{arr:e,sampleSize:r}=t;for(let t=0;t<r;t++){this.seed=(214013*this.seed+2531011)%(1<<31);let r=this.seed>>16&32767;r%=e.length;let s=e[t];e[t]=e[r],e[r]=s}},nextInt(t){this.seed=(214013*this.seed+2531011)%(1<<31);let e=this.seed>>16&32767;return e%=t,e}})}}},e={};function r(s){if(e[s])return e[s].exports;var o=e[s]={exports:{}};return t[s](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var s in e)r.o(e,s)&&!r.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{const{Matcher:t}=r(582),{Estimator:e}=r(421);let s=null,o=null,n=!1,i=null,h=null;onmessage=r=>{const{data:l}=r;if("setup"===l.type)s=l.projectionTransform,o=l.matchingDataList,n=l.debugMode,i=new t(l.inputWidth,l.inputHeight,n),h=new e(l.projectionTransform);else if("match"===l.type){const t=l.targetIndexes;let e=-1,r=null,s=null;for(let n=0;n<t.length;n++){const u=t[n],{keyframeIndex:a,screenCoords:c,worldCoords:f,debugExtra:m}=i.matchDetection(o[u],l.featurePoints);if(s=m,-1!==a){const t=h.estimate({screenCoords:c,worldCoords:f});t&&(e=u,r=t);break}}postMessage({type:"matchDone",targetIndex:e,modelViewTransform:r,debugExtra:s})}else if("trackUpdate"===l.type){const{modelViewTransform:t,worldCoords:e,screenCoords:r}=l,s=h.refineEstimate({initialModelViewTransform:t,worldCoords:e,screenCoords:r});postMessage({type:"trackUpdateDone",modelViewTransform:s})}}})()})();',I.p+"controller.worker.prod.js")}},9855:ot=>{"use strict";var ht=window.URL||window.webkitURL;ot.exports=function(I,U){try{try{var $;try{($=new(window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder)).append(I),$=$.getBlob()}catch{$=new Blob([I])}return new Worker(ht.createObjectURL($))}catch{return new Worker("data:application/javascript,"+encodeURIComponent(I))}}catch{if(!U)throw Error("Inline worker is not supported");return new Worker(U)}}},5217:(ot,ht,I)=>{const U=I(383),{Detector:$}=I(6416),{buildImageList:O,buildTrackingImageList:N}=I(7508),{build:_}=I(723),E=I(1113),D=I(4563),B=async(C,M)=>{const k=[];for(let F=0;F<C.length;F++){const G=C[F],Q=new $(G.width,G.height);await D.nextFrame(),D.tidy(()=>{const X=D.tensor(G.data,[G.data.length],"float32").reshape([G.height,G.width]),{featurePoints:lt}=Q.detect(X),rt=lt.filter(ft=>ft.maxima),pt=lt.filter(ft=>!ft.maxima),vt=_({points:rt}),bt=_({points:pt});k.push({maximaPoints:rt,minimaPoints:pt,maximaPointsCluster:vt,minimaPointsCluster:bt,width:G.width,height:G.height,scale:G.scale}),M(F)})}return k};ot.exports={Compiler:class{constructor(){this.data=null}compileImageTargets(C,M){return new Promise(async(k,F)=>{const G=[];for(let rt=0;rt<C.length;rt++){const pt=C[rt],vt=document.createElement("canvas");vt.width=pt.width,vt.height=pt.height;const bt=vt.getContext("2d");bt.drawImage(pt,0,0,pt.width,pt.height);const ft=bt.getImageData(0,0,pt.width,pt.height),wt=new Uint8Array(pt.width*pt.height);for(let xt=0;xt<wt.length;xt++){const Rt=4*xt;wt[xt]=Math.floor((ft.data[Rt]+ft.data[Rt+1]+ft.data[Rt+2])/3)}G.push({data:wt,height:pt.height,width:pt.width})}const Q=50/G.length;let X=0;this.data=[];for(let rt=0;rt<G.length;rt++){const pt=G[rt],vt=O(pt),bt=Q/vt.length,ft=await B(vt,()=>{X+=bt,M(X)});this.data.push({targetImage:pt,imageList:vt,matchingData:ft})}for(let rt=0;rt<G.length;rt++){const pt=N(G[rt]);this.data[rt].trackingImageList=pt}const lt=await new Promise((rt,pt)=>{const vt=new U;vt.onmessage=bt=>{"progress"===bt.data.type?M(50+bt.data.percent):"compileDone"===bt.data.type&&rt(bt.data.list)},vt.postMessage({type:"compile",targetImages:G})});for(let rt=0;rt<G.length;rt++)this.data[rt].trackingData=lt[rt];k(this.data)})}exportData(){const C=[];for(let M=0;M<this.data.length;M++)C.push({targetImage:{width:this.data[M].targetImage.width,height:this.data[M].targetImage.height},trackingData:this.data[M].trackingData,matchingData:this.data[M].matchingData});return E.encode({v:2,dataList:C})}importData(C){const M=E.decode(new Uint8Array(C));if(!M.v||2!==M.v)return console.error("Your compiled .mind might be outdated. Please recompile"),[];const{dataList:k}=M;this.data=[];for(let F=0;F<k.length;F++)this.data.push({targetImage:k[F].targetImage,trackingData:k[F].trackingData,matchingData:k[F].matchingData});return this.data}}}},7957:(ot,ht,I)=>{const U=I(4563),$=I(1077),{Tracker:O}=I(6417),{CropDetector:N}=I(7051),{Compiler:_}=I(5217),{InputLoader:E}=I(7325),{OneEuroFilter:D}=I(344);ot.exports={Controller:class{constructor({inputWidth:B,inputHeight:C,onUpdate:M=null,debugMode:k=!1,maxTrack:F=1,warmupTolerance:G=null,missTolerance:Q=null,filterMinCF:X=null,filterBeta:lt=null}){this.inputWidth=B,this.inputHeight=C,this.maxTrack=F,this.filterMinCF=null===X?.001:X,this.filterBeta=null===lt?1e3:lt,this.warmupTolerance=null===G?5:G,this.missTolerance=null===Q?5:Q,this.cropDetector=new N(this.inputWidth,this.inputHeight,k),this.inputLoader=new E(this.inputWidth,this.inputHeight),this.markerDimensions=null,this.onUpdate=M,this.debugMode=k,this.processingVideo=!1,this.interestedTargetIndex=-1,this.trackingStates=[];const rt=45*Math.PI/180,pt=this.inputHeight/2/Math.tan(rt/2);this.projectionTransform=[[pt,0,this.inputWidth/2],[0,pt,this.inputHeight/2],[0,0,1]],this.projectionMatrix=this._glProjectionMatrix({projectionTransform:this.projectionTransform,width:this.inputWidth,height:this.inputHeight,near:10,far:1e5}),this.worker=new $,this.workerMatchDone=null,this.workerTrackDone=null,this.worker.onmessage=vt=>{"matchDone"===vt.data.type&&null!==this.workerMatchDone&&this.workerMatchDone(vt.data),"trackUpdateDone"===vt.data.type&&null!==this.workerTrackDone&&this.workerTrackDone(vt.data)}}showTFStats(){console.log(U.memory().numTensors),console.table(U.memory())}addImageTargets(B){return new Promise(async(C,M)=>{const k=await fetch(B),F=await k.arrayBuffer();C(this.addImageTargetsFromBuffer(F))})}addImageTargetsFromBuffer(B){const C=(new _).importData(B),M=[],k=[],F=[];for(let G=0;G<C.length;G++)k.push(C[G].matchingData),M.push(C[G].trackingData),F.push([C[G].targetImage.width,C[G].targetImage.height]);return this.tracker=new O(F,M,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),this.worker.postMessage({type:"setup",inputWidth:this.inputWidth,inputHeight:this.inputHeight,projectionTransform:this.projectionTransform,debugMode:this.debugMode,matchingDataList:k}),this.markerDimensions=F,{dimensions:F,matchingDataList:k,trackingDataList:M}}dummyRun(B){const C=this.inputLoader.loadInput(B);this.cropDetector.detect(C),this.tracker.dummyRun(C),C.dispose()}getProjectionMatrix(){return this.projectionMatrix}getWorldMatrix(B,C){return this._glModelViewMatrix(B,C)}async _detectAndMatch(B,C){const{featurePoints:M}=this.cropDetector.detectMoving(B),{targetIndex:k,modelViewTransform:F}=await this._workerMatch(M,C);return{targetIndex:k,modelViewTransform:F}}async _trackAndUpdate(B,C,M){const{worldCoords:k,screenCoords:F}=this.tracker.track(B,C,M);return k.length<4?null:await this._workerTrackUpdate(C,{worldCoords:k,screenCoords:F})}processVideo(B){if(!this.processingVideo){this.processingVideo=!0,this.trackingStates=[];for(let C=0;C<this.markerDimensions.length;C++)this.trackingStates.push({showing:!1,isTracking:!1,currentModelViewTransform:null,trackCount:0,trackMiss:0,filter:new D({minCutOff:this.filterMinCF,beta:this.filterBeta})});(async()=>{for(;this.processingVideo;){const C=this.inputLoader.loadInput(B);if(this.trackingStates.reduce((M,k)=>M+(k.isTracking?1:0),0)<this.maxTrack){const M=[];for(let G=0;G<this.trackingStates.length;G++)!0!==this.trackingStates[G].isTracking&&(-1!==this.interestedTargetIndex&&this.interestedTargetIndex!==G||M.push(G));const{targetIndex:k,modelViewTransform:F}=await this._detectAndMatch(C,M);-1!==k&&(this.trackingStates[k].isTracking=!0,this.trackingStates[k].currentModelViewTransform=F)}for(let M=0;M<this.trackingStates.length;M++){const k=this.trackingStates[M];if(k.isTracking){let F=await this._trackAndUpdate(C,k.currentModelViewTransform,M);null===F?k.isTracking=!1:k.currentModelViewTransform=F}if(k.showing||k.isTracking&&(k.trackMiss=0,k.trackCount+=1,k.trackCount>this.warmupTolerance&&(k.showing=!0,k.trackingMatrix=null,k.filter.reset())),k.showing&&(k.isTracking?k.trackMiss=0:(k.trackCount=0,k.trackMiss+=1,k.trackMiss>this.missTolerance&&(k.showing=!1,k.trackingMatrix=null,this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:M,worldMatrix:null})))),k.showing){const F=this._glModelViewMatrix(k.currentModelViewTransform,M);k.trackingMatrix=k.filter.filter(Date.now(),F);const G=[];for(let Q=0;Q<k.trackingMatrix.length;Q++)G[Q]=k.trackingMatrix[Q];this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:M,worldMatrix:G})}}C.dispose(),this.onUpdate&&this.onUpdate({type:"processDone"}),await U.nextFrame()}})()}}stopProcessVideo(){this.processingVideo=!1}async detect(B){const C=this.inputLoader.loadInput(B),{featurePoints:M,debugExtra:k}=await this.cropDetector.detect(C);return C.dispose(),{featurePoints:M,debugExtra:k}}async match(B,C){const{modelViewTransform:M,debugExtra:k}=await this._workerMatch(B,[C]);return{modelViewTransform:M,debugExtra:k}}async track(B,C,M){const k=this.inputLoader.loadInput(B),F=this.tracker.track(k,C,M);return k.dispose(),F}async trackUpdate(B,C){return C.worldCoords.length<4?null:await this._workerTrackUpdate(B,C)}_workerMatch(B,C){return new Promise(async(M,k)=>{this.workerMatchDone=F=>{M({targetIndex:F.targetIndex,modelViewTransform:F.modelViewTransform,debugExtra:F.debugExtra})},this.worker.postMessage({type:"match",featurePoints:B,targetIndexes:C})})}_workerTrackUpdate(B,C){return new Promise(async(M,k)=>{this.workerTrackDone=Q=>{M(Q.modelViewTransform)};const{worldCoords:F,screenCoords:G}=C;this.worker.postMessage({type:"trackUpdate",modelViewTransform:B,worldCoords:F,screenCoords:G})})}_glModelViewMatrix(B,C){const M=this.markerDimensions[C][1];return[B[0][0],-B[1][0],-B[2][0],0,-B[0][1],B[1][1],B[2][1],0,-B[0][2],B[1][2],B[2][2],0,B[0][1]*M+B[0][3],-(B[1][1]*M+B[1][3]),-(B[2][1]*M+B[2][3]),1]}_glProjectionMatrix({projectionTransform:B,width:C,height:M,near:k,far:F}){const G=[[2*B[0][0]/C,0,-(2*B[0][2]/C-1),0],[0,2*B[1][1]/M,-(2*B[1][2]/M-1),0],[0,0,-(F+k)/(F-k),-2*F*k/(F-k)],[0,0,-1,0]],Q=[];for(let X=0;X<4;X++)for(let lt=0;lt<4;lt++)Q.push(G[lt][X]);return Q}}}},7051:(ot,ht,I)=>{I(4563);const{Detector:U}=I(6416);I(7420),ot.exports={CropDetector:class{constructor(N,_,E=!1){this.debugMode=E,this.width=N,this.height=_;let D=Math.min(N,_)/2,B=Math.pow(2,Math.round(Math.log(D)/Math.log(2)));this.cropSize=B,this.detector=new U(B,B,E),this.kernelCaches={},this.lastRandomIndex=4}detect(N){const _=Math.floor(this.height/2-this.cropSize/2),E=Math.floor(this.width/2-this.cropSize/2),D=this._detect(N,E,_);return this.debugMode&&(D.debugExtra.crop={startX:E,startY:_,cropSize:this.cropSize}),D}detectMoving(N){const _=this.lastRandomIndex%3,E=Math.floor(this.lastRandomIndex/3);let D=Math.floor(this.height/2-this.cropSize+E*this.cropSize/2),B=Math.floor(this.width/2-this.cropSize+_*this.cropSize/2);return B<0&&(B=0),D<0&&(D=0),B>=this.width-this.cropSize&&(B=this.width-this.cropSize-1),D>=this.height-this.cropSize&&(D=this.height-this.cropSize-1),this.lastRandomIndex=(this.lastRandomIndex+1)%9,this._detect(N,B,D)}_detect(N,_,E){const D=N.slice([E,_],[this.cropSize,this.cropSize]),{featurePoints:B,debugExtra:C}=this.detector.detect(D);return B.forEach(M=>{M.x+=_,M.y+=E}),this.debugMode&&(C.projectedImage=D.arraySync()),D.dispose(),{featurePoints:B,debugExtra:C}}}}},6416:(ot,ht,I)=>{const U=I(4563),{FREAKPOINTS:$}=I(2793),O=($.length-1)*$.length/2;ot.exports={Detector:class{constructor(N,_,E=!1){this.debugMode=E,this.width=N,this.height=_;let D=0;for(;N>=8&&_>=8&&(N/=2,_/=2,D++,5!==D););this.numOctaves=D,this.tensorCaches={},this.kernelCaches={}}detectImageData(N){const _=new Uint8ClampedArray(4*N.length);for(let D=0;D<N.length;D++)_[4*D]=N[D],_[4*D+1]=N[D],_[4*D+2]=N[D],_[4*D+3]=255;const E=new ImageData(_,this.width,this.height);return this.detect(E)}detect(N){let _=null;const E=[];for(let bt=0;bt<this.numOctaves;bt++){let ft,wt;ft=0===bt?this._applyFilter(N):this._downsampleBilinear(E[bt-1][E[bt-1].length-1]),wt=this._applyFilter(ft),E.push([ft,wt])}const D=[];for(let bt=0;bt<this.numOctaves;bt++){let ft=this._differenceImageBinomial(E[bt][0],E[bt][1]);D.push(ft)}const B=[];for(let bt=1;bt<this.numOctaves-1;bt++){const ft=this._buildExtremas(D[bt-1],D[bt],D[bt+1]);B.push(ft)}const C=this._applyPrune(B),M=this._computeLocalization(C,D),k=this._computeOrientationHistograms(M,E),F=this._smoothHistograms(k),G=this._computeExtremaAngles(F),Q=this._computeExtremaFreak(E,M,G),X=this._computeFreakDescriptors(Q),lt=M.arraySync(),rt=G.arraySync(),pt=X.arraySync();this.debugMode&&(_={pyramidImages:E.map(bt=>bt.map(ft=>ft.arraySync())),dogPyramidImages:D.map(bt=>bt?bt.arraySync():null),extremasResults:B.map(bt=>bt.arraySync()),extremaAngles:G.arraySync(),prunedExtremas:C,localizedExtremas:M.arraySync()}),E.forEach(bt=>bt.forEach(ft=>ft.dispose())),D.forEach(bt=>bt&&bt.dispose()),B.forEach(bt=>bt.dispose()),M.dispose(),k.dispose(),F.dispose(),G.dispose(),Q.dispose(),X.dispose();const vt=[];for(let bt=0;bt<lt.length;bt++){if(0==lt[bt][0])continue;const ft=[];for(let ve=0;ve<pt[bt].length;ve+=4)ft.push(16777216*pt[bt][ve]+65536*pt[bt][ve+1]+256*pt[bt][ve+2]+pt[bt][ve+3]);const wt=lt[bt][1],et=lt[bt][2],xt=lt[bt][3]*Math.pow(2,wt)+Math.pow(2,wt-1)-.5,Rt=et*Math.pow(2,wt)+Math.pow(2,wt-1)-.5,Yt=Math.pow(2,wt);vt.push({maxima:lt[bt][0]>0,x:xt,y:Rt,scale:Yt,angle:rt[bt],descriptors:ft})}return{featurePoints:vt,debugExtra:_}}_computeFreakDescriptors(N){if(!this.tensorCaches.computeFreakDescriptors){const D=[],B=[];for(let k=0;k<N.shape[1];k++)for(let F=k+1;F<N.shape[1];F++)D.push(k),B.push(F);const C=U.tensor(D,[D.length]).cast("int32"),M=U.tensor(B,[B.length]).cast("int32");this.tensorCaches.computeFreakDescriptors={positionT:U.keep(U.stack([C,M],1))}}const{positionT:_}=this.tensorCaches.computeFreakDescriptors,E=Math.ceil(O/8);return this.kernelCaches.computeFreakDescriptors||(this.kernelCaches.computeFreakDescriptors=[{variableNames:["freak","p"],outputShape:[N.shape[0],E],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int descIndex = coords[1] * 8;\n\n\t    int sum = 0;\n\t    for (int i = 0; i < 8; i++) {\n\t      if (descIndex + i >= ${O}) {\n\t\tcontinue;\n\t      }\n\n\t      int p1 = int(getP(descIndex + i, 0));\n\t      int p2 = int(getP(descIndex + i, 1));\n\n\t      float v1 = getFreak(featureIndex, p1);\n\t      float v2 = getFreak(featureIndex, p2);\n\n\t      if (v1 < v2 + 0.01) {\n\t        sum += int(pow(2.0, float(7 - i)));\n\t      }\n\t    }\n\t    setOutput(float(sum));\n\t  }\n\t`}]),U.tidy(()=>{const[D]=this.kernelCaches.computeFreakDescriptors;return this._runWebGLProgram(D,[N,_],"int32")})}_computeExtremaFreak(N,_,E){this.tensorCaches._computeExtremaFreak||U.tidy(()=>{const C=U.tensor($);this.tensorCaches._computeExtremaFreak={freakPointsT:U.keep(C)}});const{freakPointsT:D}=this.tensorCaches._computeExtremaFreak,B=[];for(let C=1;C<N.length;C++)B.push(N[C][1]);if(!this.kernelCaches._computeExtremaFreak){const C=[];for(let F=1;F<N.length;F++)C.push("image"+F);let M="float getPixel(int octave, int y, int x) {";for(let F=1;F<N.length;F++)M+=`\n\t  if (octave == ${F}) {\n\t    return getImage${F}(y, x);\n\t  }\n\t`;M+="}";const k={variableNames:[...C,"extrema","angles","freakPoints"],outputShape:[_.shape[0],$.length],userCode:`\n\t  ${M}\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int freakIndex = coords[1];\n\n\t    float freakSigma = getFreakPoints(freakIndex, 0);\n\t    float freakX = getFreakPoints(freakIndex, 1);\n\t    float freakY = getFreakPoints(freakIndex, 2);\n\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    float inputY = getExtrema(featureIndex, 2);\n\t    float inputX = getExtrema(featureIndex, 3);\n\t    float inputAngle = getAngles(featureIndex);\n            float cos = 7. * cos(inputAngle);\n            float sin = 7. * sin(inputAngle);\n\n\t    float yp = inputY + freakX * sin + freakY * cos;\n\t    float xp = inputX + freakX * cos + freakY * -sin;\n\n\t    int x0 = int(floor(xp));\n\t    int x1 = x0 + 1;\n\t    int y0 = int(floor(yp));\n\t    int y1 = y0 + 1;\n\n\t    float f1 = getPixel(octave, y0, x0);\n\t    float f2 = getPixel(octave, y0, x1);\n\t    float f3 = getPixel(octave, y1, x0);\n\t    float f4 = getPixel(octave, y1, x1);\n\n\t    float x1f = float(x1);\n\t    float y1f = float(y1);\n\t    float x0f = float(x0);\n\t    float y0f = float(y0);\n\n\t    // ratio for interpolation between four neighbouring points\n\t    float value = (x1f - xp) * (y1f - yp) * f1\n\t\t\t+ (xp - x0f) * (y1f - yp) * f2\n\t\t\t+ (x1f - xp) * (yp - y0f) * f3\n\t\t\t+ (xp - x0f) * (yp - y0f) * f4;\n\n\t    setOutput(value);\n\t  }\n\t`};this.kernelCaches._computeExtremaFreak=[k]}return U.tidy(()=>{const[C]=this.kernelCaches._computeExtremaFreak;return this._compileAndRun(C,[...B,_,E,D])})}_computeExtremaAngles(N){if(!this.kernelCaches.computeExtremaAngles){const _={variableNames:["histogram"],outputShape:[N.shape[0]],userCode:`\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\n\t    int maxIndex = 0;\n\t    for (int i = 1; i < 36; i++) {\n\t      if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {\n\t\tmaxIndex = i;\n\t      }\n\t    }\n\n\t    int prev = imod(maxIndex - 1 + 36, 36);\n\t    int next = imod(maxIndex + 1, 36);\n\n\t    /**\n\t     * Fit a quatratic to 3 points. The system of equations is:\n\t     *\n\t     * y0 = A*x0^2 + B*x0 + C\n\t     * y1 = A*x1^2 + B*x1 + C\n\t     * y2 = A*x2^2 + B*x2 + C\n\t     *\n\t     * This system of equations is solved for A,B,C.\n\t     */\n\t    float p10 = float(maxIndex - 1);\n\t    float p11 = getHistogram(featureIndex, prev); \n\t    float p20 = float(maxIndex);\n\t    float p21 = getHistogram(featureIndex, maxIndex); \n\t    float p30 = float(maxIndex + 1);\n\t    float p31 = getHistogram(featureIndex, next); \n\n\t    float d1 = (p30-p20)*(p30-p10);\n\t    float d2 = (p10-p20)*(p30-p10);\n\t    float d3 = p10-p20;\n\n\t    // If any of the denominators are zero then, just use maxIndex.\n            float fbin = float(maxIndex);\n\t    if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {\n\t      float a = p10*p10;\n\t      float b = p20*p20;\n\n\t      // Solve for the coefficients A,B,C\n\t      float A = ((p31-p21)/d1)-((p11-p21)/d2);\n\t      float B = ((p11-p21)+(A*(b-a)))/d3;\n\t      float C = p11-(A*a)-(B*p10);\n\t      fbin = -B / (2. * A);\n\t    }\n\n\t    float an = 2.0 *${Math.PI} * (fbin + 0.5) / 36. - ${Math.PI};\n\t    setOutput(an);\n\t  }\n\t`};this.kernelCaches.computeExtremaAngles=_}return U.tidy(()=>this._compileAndRun(this.kernelCaches.computeExtremaAngles,[N]))}_computeOrientationHistograms(N,_){const E=[];for(let B=1;B<_.length;B++)E.push(_[B][1]);this.tensorCaches.orientationHistograms||U.tidy(()=>{const B=Math.ceil(4.5),C=[];for(let M=-B;M<=B;M++)for(let k=-B;k<=B;k++){const F=k*k+M*M;if(F<=20.25){const G=-.05555555555555555*F;C.push([M,k,.0013888888*(720+G*(720+G*(360+G*(120+G*(30+G*(6+G))))))])}}this.tensorCaches.orientationHistograms={radialPropertiesT:U.keep(U.tensor(C,[C.length,3]))}});const{radialPropertiesT:D}=this.tensorCaches.orientationHistograms;if(!this.kernelCaches.computeOrientationHistograms){const B=[];for(let F=1;F<_.length;F++)B.push("image"+F);let C="float getPixel(int octave, int y, int x) {";for(let F=1;F<_.length;F++)C+=`\n\t  if (octave == ${F}) {\n\t    return getImage${F}(y, x);\n\t  }\n\t`;C+="}";const M={variableNames:[...B,"extrema","radial"],outputShape:[N.shape[0],D.shape[0],2],userCode:`\n\t  ${C}\n\n\t  void main() {\n\t    ivec3 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int radialIndex = coords[1];\n\t    int propertyIndex = coords[2];\n\n\t    int radialY = int(getRadial(radialIndex, 0));\n\t    int radialX = int(getRadial(radialIndex, 1));\n\t    float radialW = getRadial(radialIndex, 2);\n\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    int y = int(getExtrema(featureIndex, 2));\n\t    int x = int(getExtrema(featureIndex, 3));\n\n\t    int xp = x + radialX;\n\t    int yp = y + radialY;\n\n\t    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);\n\t    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);\n\n\t    if (propertyIndex == 0) {\n\t      // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0\n\t      \n\t      float angle = atan(dy, dx) + ${Math.PI};\n\t      float fbin = angle * 36. * 0.159154943091895;\n\t      setOutput(fbin);\n\t      return;\n\t    }\n\n\t    if (propertyIndex == 1) {\n\t      float mag = sqrt(dx * dx + dy * dy);\n\t      float magnitude = radialW * mag;\n\t      setOutput(magnitude);\n\t      return;\n\t    }\n\t  }\n\n\t`};this.kernelCaches.computeOrientationHistograms=[M,{variableNames:["fbinMag"],outputShape:[N.shape[0],36],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int binIndex = coords[1];\n\n\t    float sum = 0.;\n\t    for (int i = 0; i < ${D.shape[0]}; i++) {\n\t      float fbin = getFbinMag(featureIndex, i, 0);\n\t      int bin = int(floor(fbin - 0.5));\n\t      int b1 = imod(bin + 36, 36);\n\t      int b2 = imod(bin + 1 + 36, 36);\n\n\t      if (b1 == binIndex || b2 == binIndex) {\n\t\tfloat magnitude = getFbinMag(featureIndex, i, 1);\n\t\tfloat w2 = fbin - float(bin) - 0.5;\n\t\tfloat w1 = w2 * -1. + 1.;\n\n\t\tif (b1 == binIndex) {\n\t\t  sum += w1 * magnitude;\n\t\t}\n\t\tif (b2 == binIndex) {\n\t\t  sum += w2 * magnitude;\n\t\t}\n\t      }\n\t    }\n\t    setOutput(sum);\n\t  }\n\t`}]}return U.tidy(()=>{const[B,C]=this.kernelCaches.computeOrientationHistograms,M=this._compileAndRun(B,[...E,N,D]);return this._compileAndRun(C,[M])})}_smoothHistograms(N){return this.kernelCaches.smoothHistograms||(this.kernelCaches.smoothHistograms={variableNames:["histogram"],outputShape:[N.shape[0],36],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int binIndex = coords[1];\n\n\t    int prevBin = imod(binIndex - 1 + 36, 36);\n\t    int nextBin = imod(binIndex + 1, 36);\n\n            float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);\n\n\t    setOutput(result);\n\t  }\n\t"}),U.tidy(()=>{const _=this.kernelCaches.smoothHistograms;for(let E=0;E<5;E++)N=this._compileAndRun(_,[N]);return N})}_computeLocalization(N,_){if(!this.kernelCaches.computeLocalization){const E=[];let D="float getPixel(int octave, int y, int x) {";for(let C=1;C<_.length;C++)E.push("image"+C),D+=`\n\t  if (octave == ${C}) {\n\t    return getImage${C}(y, x);\n\t  }\n \t`;D+="}";const B={variableNames:[...E,"extrema"],outputShape:[N.length,3,3],userCode:`\n\t  ${D}\n\n\t  void main() {\n\t    ivec3 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    float score = getExtrema(featureIndex, 0);\n\t    if (score == 0.0) {\n\t      return;\n\t    }\n\n\t    int dy = coords[1]-1;\n\t    int dx = coords[2]-1;\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    int y = int(getExtrema(featureIndex, 2));\n\t    int x = int(getExtrema(featureIndex, 3));\n\t    setOutput(getPixel(octave, y+dy, x+dx));\n\t  }\n\t`};this.kernelCaches.computeLocalization=[B]}return U.tidy(()=>{const E=this.kernelCaches.computeLocalization[0],D=U.tensor(N,[N.length,N[0].length],"int32"),B=this._compileAndRun(E,[..._.slice(1),D]).arraySync(),C=[];for(let k=0;k<B.length;k++){C.push([]);for(let F=0;F<B[k].length;F++)C[k].push([])}const M=[];for(let k=0;k<N.length;k++)M[k]=[N[k][0],N[k][1],N[k][2],N[k][3]];for(let k=0;k<M.length;k++){if(0===M[k][0])continue;const F=B[k],G=.5*(F[1][2]-F[1][0]),Q=.5*(F[2][1]-F[0][1]),X=F[1][2]+F[1][0]-2*F[1][1],lt=F[2][1]+F[0][1]-2*F[1][1],rt=.25*(F[0][0]+F[2][2]-F[0][2]-F[2][0]),pt=X*lt-rt*rt,ft=M[k][2]+(-rt*-G+X*-Q)/pt,wt=M[k][3]+(lt*-G+-rt*-Q)/pt;Math.abs(pt)<1e-4||(M[k][2]=ft,M[k][3]=wt)}return U.tensor(M,[M.length,M[0].length],"float32")})}_applyPrune(N){if(!this.kernelCaches.applyPrune){const B=[];for(let C=0;C<N.length;C++){const k=N[C].shape[1],F={variableNames:["extrema"],outputShape:[Math.floor(N[C].shape[0]/2),Math.floor(k/2)],userCode:"\n\t    void main() {\n\t      ivec2 coords = getOutputCoords();\n\t      int y = coords[0] * 2;\n\t      int x = coords[1] * 2;\n\n\t      float location = 0.0;\n\t      float values = getExtrema(y, x);\n\n\t      if (getExtrema(y+1, x) != 0.0) {\n\t        location = 1.0;\n\t\tvalues = getExtrema(y+1, x);\n\t      }\n\t      else if (getExtrema(y, x+1) != 0.0) {\n\t        location = 2.0;\n\t\tvalues = getExtrema(y, x+1);\n\t      }\n\t      else if (getExtrema(y+1, x+1) != 0.0) {\n\t        location = 3.0;\n\t\tvalues = getExtrema(y+1, x+1);\n\t      }\n\n\t      if (values < 0.0) {\n\t        setOutput(location * -1000.0 + values);\n\t      } else {\n\t        setOutput(location * 1000.0 + values);\n\t      }\n\t    }\n\t  "};B.push(F)}this.kernelCaches.applyPrune={reductionKernels:B}}const _=[],E=[];for(let B=0;B<100;B++){E.push([]),_.push([]);for(let C=0;C<5;C++)E[B].push([0,0,0,0]),_[B].push(0)}U.tidy(()=>{const{reductionKernels:B}=this.kernelCaches.applyPrune;for(let C=0;C<N.length;C++){const k=this._compileAndRun(B[C],[N[C]]),F=C+1,G=k.arraySync(),Q=k.shape[0],X=k.shape[1],lt=2*X/10,rt=2*Q/10;for(let pt=0;pt<Q;pt++)for(let vt=0;vt<X;vt++){const bt=G[pt][vt];if(0==bt)continue;const ft=bt%1e3,wt=Math.floor(Math.abs(bt)/1e3),et=2*vt+(2===wt||3===wt?1:0),xt=2*pt+(1===wt||3===wt?1:0),Rt=Math.floor(et/lt),Yt=10*Math.floor(xt/rt)+Rt,ve=Math.abs(ft);let xe=5;for(;xe>=1&&ve>_[Yt][xe-1];)xe-=1;if(xe<5){for(let Ge=4;Ge>=xe+1;Ge--)_[Yt][Ge]=_[Yt][Ge-1],E[Yt][Ge][0]=E[Yt][Ge-1][0],E[Yt][Ge][1]=E[Yt][Ge-1][1],E[Yt][Ge][2]=E[Yt][Ge-1][2],E[Yt][Ge][3]=E[Yt][Ge-1][3];_[Yt][xe]=ve,E[Yt][xe][0]=ft,E[Yt][xe][1]=F,E[Yt][xe][2]=xt,E[Yt][xe][3]=et}}}});const D=[];for(let B=0;B<100;B++)for(let C=0;C<5;C++)D.push(E[B][C]);return D}_buildExtremas(N,_,E){const D=_.shape[0],B=_.shape[1],C="w"+B;return this.kernelCaches.buildExtremas||(this.kernelCaches.buildExtremas={}),this.kernelCaches.buildExtremas[C]||(this.kernelCaches.buildExtremas[C]={variableNames:["image0","image1","image2"],outputShape:[D,B],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int y = coords[0];\n\t    int x = coords[1];\n\n\t    float value = getImage1(y, x);\n\n\t    // Step 1: find local maxima/minima\n\t    if (value * value < 9.) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    if (y < 7 || y > ${D-1-7}) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    if (x < 7 || x > ${B-1-7}) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    bool isMax = true;\n\t    bool isMin = true;\n\t    for (int dy = -1; dy <= 1; dy++) {\n\t      for (int dx = -1; dx <= 1; dx++) {\n\t        float value0 = getImage0(y+dy, x+dx);\n\t        float value1 = getImage1(y+dy, x+dx);\n\t        float value2 = getImage2(y+dy, x+dx);\n\n\t\tif (value < value0 || value < value1 || value < value2) {\n\t\t  isMax = false;\n\t\t}\n\t\tif (value > value0 || value > value1 || value > value2) {\n\t\t  isMin = false;\n\t\t}\n\t      }\n\t    }\n\n\t    if (!isMax && !isMin) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    // compute edge score and reject based on threshold\n\t    float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);\n\t    float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);\n\t    float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));\n\n\t    float det = (dxx * dyy) - (dxy * dxy);\n\n\t    if (abs(det) < 0.0001) { // determinant undefined. no solution\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    float edgeScore = (dxx + dyy) * (dxx + dyy) / det;\n\n\t    if (abs(edgeScore) >= 6.25 ) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    setOutput(getImage1(y,x));\n\t  }\n\t`}),U.tidy(()=>{const M=this.kernelCaches.buildExtremas[C];return N=this._downsampleBilinear(N),E=this._upsampleBilinear(E,_),this._compileAndRun(M,[N,_,E])})}_differenceImageBinomial(N,_){return U.tidy(()=>N.sub(_))}_applyFilter(N){const _=N.shape[0],E=N.shape[1],D="w"+E;return this.kernelCaches.applyFilter||(this.kernelCaches.applyFilter={}),this.kernelCaches.applyFilter[D]||(this.kernelCaches.applyFilter[D]=[{variableNames:["p"],outputShape:[_,E],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float sum = getP(coords[0], coords[1]-2);\n\t    sum += getP(coords[0], coords[1]-1) * 4.;\n\t    sum += getP(coords[0], coords[1]) * 6.;\n\t    sum += getP(coords[0], coords[1]+1) * 4.;\n\t    sum += getP(coords[0], coords[1]+2);\n\t    setOutput(sum);\n\t  }\n\t"},{variableNames:["p"],outputShape:[_,E],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float sum = getP(coords[0]-2, coords[1]);\n\t    sum += getP(coords[0]-1, coords[1]) * 4.;\n\t    sum += getP(coords[0], coords[1]) * 6.;\n\t    sum += getP(coords[0]+1, coords[1]) * 4.;\n\t    sum += getP(coords[0]+2, coords[1]);\n\t    sum /= 256.;\n\t    setOutput(sum);\n\t  }\n\t"}]),U.tidy(()=>{const[B,C]=this.kernelCaches.applyFilter[D],M=this._compileAndRun(B,[N]);return this._compileAndRun(C,[M])})}_upsampleBilinear(N,_){const E="w"+N.shape[1];return this.kernelCaches.upsampleBilinear||(this.kernelCaches.upsampleBilinear={}),this.kernelCaches.upsampleBilinear[E]||(this.kernelCaches.upsampleBilinear[E]={variableNames:["p"],outputShape:[_.shape[0],_.shape[1]],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int j = coords[0];\n\t    int i = coords[1];\n\n\t    float sj = 0.5 * float(j) - 0.25; \n\t    float si = 0.5 * float(i) - 0.25;\n\n\t    float sj0 = floor(sj);\n\t    float sj1 = ceil(sj);\n\t    float si0 = floor(si);\n\t    float si1 = ceil(si);\n\n\t    int sj0I = int(sj0);\n\t    int sj1I = int(sj1);\n\t    int si0I = int(si0);\n\t    int si1I = int(si1);\n\n\t    float sum = 0.0;\n\t    sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);\n\t    sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);\n\t    sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);\n\t    sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);\n\t    setOutput(sum);\n\t  }\n\t"}),U.tidy(()=>this._compileAndRun(this.kernelCaches.upsampleBilinear[E],[N]))}_downsampleBilinear(N){const _=N.shape[0],E=N.shape[1],D="w"+E;if(this.kernelCaches.downsampleBilinear||(this.kernelCaches.downsampleBilinear={}),!this.kernelCaches.downsampleBilinear[D]){const B={variableNames:["p"],outputShape:[Math.floor(_/2),Math.floor(E/2)],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int y = coords[0] * 2;\n\t    int x = coords[1] * 2;\n\n\t    float sum = getP(y, x) * 0.25;\n\t    sum += getP(y+1,x) * 0.25; \n\t    sum += getP(y, x+1) * 0.25; \n\t    sum += getP(y+1,x+1) * 0.25;\n\t    setOutput(sum);\n\t  }\n\t"};this.kernelCaches.downsampleBilinear[D]=B}return U.tidy(()=>this._compileAndRun(this.kernelCaches.downsampleBilinear[D],[N]))}_compileAndRun(N,_){const E=U.backend().compileAndRun(N,_);return U.engine().makeTensorFromDataId(E.dataId,E.shape,E.dtype)}_runWebGLProgram(N,_,E){const D=U.backend().runWebGLProgram(N,_,E);return U.engine().makeTensorFromDataId(D.dataId,D.shape,D.dtype)}}}},2793:ot=>{const ht=[{sigma:.55,points:[[-1,0],[-.5,-.866025],[.5,-.866025],[1,-0],[.5,.866025],[-.5,.866025]]},{sigma:.475,points:[[0,.930969],[-.806243,.465485],[-.806243,-.465485],[-0,-.930969],[.806243,-.465485],[.806243,.465485]]},{sigma:.4,points:[[.847306,-0],[.423653,.733789],[-.423653,.733789],[-.847306,0],[-.423653,-.733789],[.423653,-.733789]]},{sigma:.325,points:[[-0,-.741094],[.641806,-.370547],[.641806,.370547],[0,.741094],[-.641806,.370547],[-.641806,-.370547]]},{sigma:.25,points:[[-.595502,0],[-.297751,-.51572],[.297751,-.51572],[.595502,-0],[.297751,.51572],[-.297751,.51572]]},{sigma:.175,points:[[0,.362783],[-.314179,.181391],[-.314179,-.181391],[-0,-.362783],[.314179,-.181391],[.314179,.181391]]},{sigma:.1,points:[[0,0]]}],I=[];for(let U=0;U<ht.length;U++){const $=ht[U].sigma;for(let O=0;O<ht[U].points.length;O++){const N=ht[U].points[O];I.push([$,N[0],N[1]])}}ot.exports={FREAKPOINTS:I}},7420:ot=>{const ht=(I,U,$,O)=>({x:I[0][0]*U+I[0][1]*$+I[0][3],y:I[1][0]*U+I[1][1]*$+I[1][3],z:I[2][0]*U+I[2][1]*$+I[2][3]});ot.exports={buildModelViewProjectionTransform:(I,U)=>[[I[0][0]*U[0][0]+I[0][2]*U[2][0],I[0][0]*U[0][1]+I[0][2]*U[2][1],I[0][0]*U[0][2]+I[0][2]*U[2][2],I[0][0]*U[0][3]+I[0][2]*U[2][3]],[I[1][1]*U[1][0]+I[1][2]*U[2][0],I[1][1]*U[1][1]+I[1][2]*U[2][1],I[1][1]*U[1][2]+I[1][2]*U[2][2],I[1][1]*U[1][3]+I[1][2]*U[2][3]],[U[2][0],U[2][1],U[2][2],U[2][3]]],applyModelViewProjectionTransform:ht,computeScreenCoordiate:(I,U,$,O)=>{const{x:N,y:_,z:E}=ht(I,U,$);return{x:N/E,y:_/E}}}},7508:(ot,ht,I)=>{const{resize:U}=I(9140);ot.exports={buildImageList:$=>{const O=[];let N=100/Math.min($.width,$.height);for(;;)if(O.push(N),N*=Math.pow(2,.3333333333333333),N>=.95){N=1;break}O.push(N),O.reverse();const _=[];for(let E=0;E<O.length;E++)_.push(Object.assign(U({image:$,ratio:O[E]}),{scale:O[E]}));return _},buildTrackingImageList:$=>{const O=Math.min($.width,$.height),N=[],_=[];N.push(256/O),N.push(128/O);for(let E=0;E<N.length;E++)_.push(Object.assign(U({image:$,ratio:N[E]}),{scale:N[E]}));return _}}},5260:(ot,ht,I)=>{const{Controller:U}=I(7957),{Compiler:$}=I(5217),{UI:O}=I(2749),N={Controller:U,Compiler:$,UI:O};window.MINDAR||(window.MINDAR={}),window.MINDAR.IMAGE=N,ot.exports=N},7325:(ot,ht,I)=>{const U=I(4563);ot.exports={InputLoader:class{constructor($,O){this.width=$,this.height=O,this.texShape=[O,$];const N=document.createElement("canvas").getContext("2d");N.canvas.width=$,N.canvas.height=O,this.context=N,this.program=this.buildProgram($,O);const _=U.backend();this.tempPixelHandle=_.makeTensorInfo(this.texShape,"float32"),_.texData.get(this.tempPixelHandle.dataId).usage=2}_loadInput($){return U.tidy(()=>{let O=U.browser.fromPixels($);return O=O.mean(2),O})}loadInput($){this.context.drawImage($,0,0,this.width,this.height);const O=U.backend();return O.gpgpu.uploadPixelDataToTexture(O.getTexture(this.tempPixelHandle.dataId),this.context.canvas),this._compileAndRun(this.program,[this.tempPixelHandle])}buildProgram($,O){const N=2===U.env().getNumber("WEBGL_VERSION")?"texture":"texture2D";return{variableNames:["A"],outputShape:this.texShape,userCode:`\n\tvoid main() {\n\t  ivec2 coords = getOutputCoords();\n\t  int texR = coords[0];\n\t  int texC = coords[1];\n\t  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${$}.0, ${O}.0);\n\n\t  vec4 values = ${N}(A, uv);\n\t  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);\n\t}\n      `}}_compileAndRun($,O){const N=U.backend().compileAndRun($,O);return U.engine().makeTensorFromDataId(N.dataId,N.shape,N.dtype)}_runWebGLProgram($,O,N){const _=U.backend().runWebGLProgram($,O,N);return U.engine().makeTensorFromDataId(_.dataId,_.shape,_.dtype)}}}},2233:ot=>{ot.exports={compute:ht=>{const{v1:I,v2:U}=ht;let $=0;for(let _=0;_<I.length;_++)$+=(N=void 0,((N=((N=((N=((N=(O=(I[_]^U[_])>>>0)-(O>>1&1431655765))>>2&858993459)+(858993459&N))>>4)+N&252645135)>>8)+N&16711935)>>16)+N&65535);var O,N;return $}}},723:(ot,ht,I)=>{const{compute:U}=I(2233),{createRandomizer:$}=I(6048),O=N=>{const{points:_,pointIndexes:E,centerPointIndex:D,randomizer:B}=N;let C=!1;(E.length<=8||E.length<=16)&&(C=!0);const M={};if(!C){const F=(G=>{const{points:Q,pointIndexes:X,randomizer:lt}=G,rt=[];for(let ft=0;ft<X.length;ft++)rt.push(ft);let pt=Number.MAX_SAFE_INTEGER,vt=-1;const bt=[];for(let ft=0;ft<128;ft++){lt.arrayShuffle({arr:rt,sampleSize:8});let wt=0;const et=[];for(let xt=0;xt<X.length;xt++){let Rt=Number.MAX_SAFE_INTEGER;for(let Yt=0;Yt<8;Yt++){const xe=U({v1:Q[X[xt]].descriptors,v2:Q[X[rt[Yt]]].descriptors});xe<Rt&&(et[xt]=rt[Yt],Rt=xe)}wt+=Rt}bt.push(et),wt<pt&&(pt=wt,vt=ft)}return bt[vt]})({points:_,pointIndexes:E,randomizer:B});for(let G=0;G<F.length;G++)void 0===M[E[F[G]]]&&(M[E[F[G]]]=[]),M[E[F[G]]].push(E[G])}1===Object.keys(M).length&&(C=!0);const k={centerPointIndex:D};if(C){k.leaf=!0,k.pointIndexes=[];for(let F=0;F<E.length;F++)k.pointIndexes.push(E[F]);return k}return k.leaf=!1,k.children=[],Object.keys(M).forEach(F=>{k.children.push(O({points:_,pointIndexes:M[F],centerPointIndex:F,randomizer:B}))}),k};ot.exports={build:({points:N})=>{const _=[];for(let D=0;D<N.length;D++)_.push(D);const E=$();return{rootNode:O({points:N,pointIndexes:_,centerPointIndex:null,randomizer:E})}}}},6417:(ot,ht,I)=>{const U=I(4563),{buildModelViewProjectionTransform:$,computeScreenCoordiate:O}=I(7420);ot.exports={Tracker:class{constructor(N,_,E,D,B,C=!1){this.markerDimensions=N,this.trackingDataList=_,this.projectionTransform=E,this.debugMode=C,this.trackingKeyframeList=[];for(let k=0;k<_.length;k++)this.trackingKeyframeList.push(_[k][1]);let M=0;for(let k=0;k<this.trackingKeyframeList.length;k++)M=Math.max(M,this.trackingKeyframeList[k].points.length);this.featurePointsListT=[],this.imagePixelsListT=[],this.imagePropertiesListT=[];for(let k=0;k<this.trackingKeyframeList.length;k++){const{featurePoints:F,imagePixels:G,imageProperties:Q}=this._prebuild(this.trackingKeyframeList[k],M);this.featurePointsListT[k]=F,this.imagePixelsListT[k]=G,this.imagePropertiesListT[k]=Q}this.kernelCaches={}}dummyRun(N){let _=[[1,1,1,1],[1,1,1,1],[1,1,1,1]];for(let E=0;E<this.featurePointsListT.length;E++)this.track(N,_,E)}track(N,_,E){let D={};const B=$(this.projectionTransform,_),C=this._buildAdjustedModelViewTransform(B),M=this.featurePointsListT[E],k=this.imagePixelsListT[E],F=this.imagePropertiesListT[E],G=this._computeProjection(C,N,E),{matchingPointsT:Q,simT:X}=this._computeMatching(M,k,F,G),lt=Q.arraySync(),rt=X.arraySync(),pt=this.trackingKeyframeList[E],vt=[],bt=[],ft=[];for(let wt=0;wt<lt.length;wt++)if(rt[wt]>.8&&wt<pt.points.length){ft.push(wt);const et=O(B,lt[wt][0],lt[wt][1]);bt.push(et),vt.push({x:pt.points[wt].x/pt.scale,y:pt.points[wt].y/pt.scale,z:0})}return this.debugMode&&(D={projectedImage:G.arraySync(),matchingPoints:Q.arraySync(),goodTrack:ft,trackedPoints:bt}),C.dispose(),G.dispose(),Q.dispose(),X.dispose(),{worldCoords:vt,screenCoords:bt,debugExtra:D}}_computeMatching(N,_,E,D){const M=N.shape[0];return this.kernelCaches.computeMatching||(this.kernelCaches.computeMatching=[{variableNames:["features","markerPixels","markerProperties","targetPixels"],outputShape:[M,441],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int searchOffsetIndex = coords[1];\n\n\t    int markerWidth = int(getMarkerProperties(0));\n\t    int markerHeight = int(getMarkerProperties(1));\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int searchOffsetX = imod(searchOffsetIndex, 21) * 1;\n\t    int searchOffsetY = searchOffsetIndex / 21 * 1;\n\n\t    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);\n\t    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);\n\n\t    int sx = sCenterX + searchOffsetX - 10;\n\t    int sy = sCenterY + searchOffsetY - 10;\n\n\t    if (sx < 6 || sx >= (${D.shape[1]} - 6) || sy < 6 || sy >= (${D.shape[0]} - 6)) {\n\t      setOutput(-2.);\n\t    } \n\t    else {\n\t      float sumPoint = 0.;\n\t      float sumPointSquare = 0.;\n\t      float sumTemplate = 0.;\n\t      float sumTemplateSquare = 0.;\n\t      float sumPointTemplate = 0.;\n\n\t      for (int templateOffsetY = 0; templateOffsetY < 13; templateOffsetY++) {\n\t\tfor (int templateOffsetX = 0; templateOffsetX < 13; templateOffsetX++) {\n\t\t  int fx2 = sCenterX + templateOffsetX - 6;\n\t\t  int fy2 = sCenterY + templateOffsetY - 6;\n\n\t\t  int sx2 = sx + templateOffsetX - 6;\n\t\t  int sy2 = sy + templateOffsetY - 6;\n\n\t\t  int markerPixelIndex = fy2 * markerWidth + fx2;\n\t\t  float markerPixel = getMarkerPixels(markerPixelIndex);\n\t\t  float targetPixel = getTargetPixels(sy2, sx2);\n\n\t\t  sumTemplate += markerPixel;\n\t\t  sumTemplateSquare += markerPixel * markerPixel;\n\t\t  sumPoint += targetPixel;\n\t\t  sumPointSquare += targetPixel * targetPixel;\n\t\t  sumPointTemplate += targetPixel * markerPixel;\n\t\t}\n\t      }\n\n\t      // Normalized cross-correlation\n\t      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)\n\t      float count = float(13 * 13);\n\t      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);\n\t      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);\n\n\t      if (pointVariance < 0.0000001) {\n\t\tsetOutput(-3.);\n\t      } else if (templateVariance < 0.0000001) {\n\t\t//setOutput(sumTemplate);\n\t\tsetOutput(-4.);\n\t      } else {\n\t\tsumPointTemplate -= sumPoint / count * sumTemplate;\n\t\tfloat sim = sumPointTemplate / pointVariance / templateVariance;  \n\t\tsetOutput(sim);\n\t      }\n\t    }\n\t  }\n\t`},{variableNames:["featurePoints","markerProperties","maxIndex"],outputShape:[M,2],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int featureIndex = coords[0];\n\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    int searchLocationIndex = maxIndex / 441;\n\t    int searchOffsetIndex = imod(maxIndex, 441);\n\n\t    if (coords[1] == 0) {\n\t      int searchOffsetX = imod(searchOffsetIndex, 21) * 1;\n\t      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - 10) / markerScale);\n\t    }\n\t    else if (coords[1] == 1) {\n\t      int searchOffsetY = searchOffsetIndex / 21 * 1;\n\t      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - 10) / markerScale);\n\t    }\n\t  }\n\t"},{variableNames:["sims","maxIndex"],outputShape:[M],userCode:"\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    setOutput(getSims(featureIndex, maxIndex));\n\t  }\n\t"}]),U.tidy(()=>{const k=this.kernelCaches.computeMatching,F=this._compileAndRun(k[0],[N,_,E,D]),G=F.argMax(1);return{matchingPointsT:this._compileAndRun(k[1],[N,E,G]),simT:this._compileAndRun(k[2],[F,G])}})}_computeProjection(N,_,E){const D=this.trackingKeyframeList[E].width,B=this.trackingKeyframeList[E].height,C=this.trackingKeyframeList[E].scale,M=D+"-"+B+"-"+C;return this.kernelCaches.computeProjection||(this.kernelCaches.computeProjection={}),this.kernelCaches.computeProjection[M]||(this.kernelCaches.computeProjection[M]={variableNames:["M","pixel"],outputShape:[B,D],userCode:`\n\t  void main() {\n\t      ivec2 coords = getOutputCoords();\n\n\t      float m00 = getM(0, 0) * 1000.;\n\t      float m01 = getM(0, 1) * 1000.;\n\t      float m03 = getM(0, 3) * 1000.;\n\t      float m10 = getM(1, 0) * 1000.;\n\t      float m11 = getM(1, 1) * 1000.;\n\t      float m13 = getM(1, 3) * 1000.;\n\t      float m20 = getM(2, 0) * 1000.;\n\t      float m21 = getM(2, 1) * 1000.;\n\t      float m23 = getM(2, 3) * 1000.;\n\n\t      float y = float(coords[0]) / float(${C});\n\t      float x = float(coords[1]) / float(${C});\n\t      float uz = (x * m20) + (y * m21) + m23;\n\t      float oneOverUz = 1. / uz;\n\n\t      float ux = (x * m00) + (y * m01) + m03;\n\t      float uy = (x * m10) + (y * m11) + m13;\n\n\t      ux = floor(ux * oneOverUz + 0.5);\n\t      uy = floor(uy * oneOverUz + 0.5);\n\t      setOutput(getPixel(int(uy), int(ux)));\n\t    }\n\t`}),U.tidy(()=>this._compileAndRun(this.kernelCaches.computeProjection[M],[N,_]))}_buildAdjustedModelViewTransform(N){return U.tidy(()=>{let _=[];for(let E=0;E<N.length;E++){_.push([]);for(let D=0;D<N[E].length;D++)_[E].push(N[E][D]/1e3)}return U.tensor(_,[3,4])})}_prebuild(N,_){return U.tidy(()=>{const E=N.scale,D=[];for(let M=0;M<_;M++)D.push(M<N.points.length?[N.points[M].x/E,N.points[M].y/E]:[-1,-1]);const B=U.tensor(N.data,[N.width*N.height]),C=U.tensor([N.width,N.height,N.scale],[3]);return{featurePoints:U.tensor(D,[D.length,2],"float32"),imagePixels:B,imageProperties:C}})}_compileAndRun(N,_){const E=U.backend().compileAndRun(N,_);return U.engine().makeTensorFromDataId(E.dataId,E.shape,E.dtype)}}}},9140:ot=>{ot.exports={downsampleBilinear:({image:ht})=>{const{data:I,width:U,height:$}=ht,O=Math.floor(U/2),N=Math.floor($/2),_=new Float32Array(O*N),E=[0,1,U,U+1];for(let D=0;D<N;D++)for(let B=0;B<O;B++){let C=2*D*U+2*B,M=0;for(let k=0;k<E.length;k++)M+=I[C+E[k]];M*=.25,_[D*O+B]=M}return{data:_,width:O,height:N}},upsampleBilinear:({image:ht,padOneWidth:I,padOneHeight:U})=>{const{width:$,height:O,data:N}=ht,_=2*ht.width+(I?1:0),E=2*ht.height+(U?1:0),D=new Float32Array(_*E);for(let B=0;B<_;B++){const C=.5*B-.25;let M=Math.floor(C),k=Math.ceil(C);M<0&&(M=0),k>=$&&(k=$-1);for(let F=0;F<E;F++){const G=.5*F-.25;let Q=Math.floor(G),X=Math.ceil(G);Q<0&&(Q=0),X>=O&&(X=O-1),D[F*_+B]=(k-C)*(X-G)*N[Q*$+M]+(k-C)*(G-Q)*N[X*$+M]+(C-M)*(X-G)*N[Q*$+k]+(C-M)*(G-Q)*N[X*$+k]}}return{data:D,width:_,height:E}},resize:({image:ht,ratio:I})=>{const U=Math.round(ht.width*I),$=Math.round(ht.height*I),O=new Uint8Array(U*$);for(let N=0;N<U;N++){let _=Math.round(1*N/I),E=Math.round(1*(N+1)/I)-1;E>=ht.width&&(E=ht.width-1);for(let D=0;D<$;D++){let B=Math.round(1*D/I),C=Math.round(1*(D+1)/I)-1;C>=ht.height&&(C=ht.height-1);let M=0,k=0;for(let F=_;F<=E;F++)for(let G=B;G<=C;G++)M+=1*ht.data[G*ht.width+F],k+=1;O[D*U+N]=Math.floor(M/k)}}return{data:O,width:U,height:$}}}},6048:ot=>{ot.exports={createRandomizer:()=>({seed:1234,arrayShuffle(ht){const{arr:I,sampleSize:U}=ht;for(let $=0;$<U;$++){this.seed=(214013*this.seed+2531011)%-2147483648;let O=this.seed>>16&32767;O%=I.length;let N=I[$];I[$]=I[O],I[O]=N}},nextInt(ht){this.seed=(214013*this.seed+2531011)%-2147483648;let I=this.seed>>16&32767;return I%=ht,I}})}},344:ot=>{const ht=(U,$)=>{const O=2*Math.PI*$*U;return O/(O+1)},I=(U,$,O)=>U*$+(1-U)*O;ot.exports={OneEuroFilter:class{constructor({minCutOff:U,beta:$}){this.minCutOff=U,this.beta=$,this.dCutOff=.001,this.xPrev=null,this.dxPrev=null,this.tPrev=null,this.initialized=!1}reset(){this.initialized=!1}filter(U,$){if(!this.initialized)return this.initialized=!0,this.xPrev=$,this.dxPrev=$.map(()=>0),this.tPrev=U,$;const{xPrev:O,tPrev:N,dxPrev:_}=this,E=U-N,D=ht(E,this.dCutOff),B=[],C=[],M=[];for(let k=0;k<$.length;k++){B[k]=($[k]-O[k])/E,C[k]=I(D,B[k],_[k]);const F=this.minCutOff+this.beta*Math.abs(C[k]),G=ht(E,F);M[k]=I(G,$[k],O[k])}return this.xPrev=M,this.dxPrev=C,this.tPrev=U,M}}}},2749:(ot,ht,I)=>{I(4412);const U=I(9894).Z,$=I(7676).Z,O=I(2810).Z;ot.exports={UI:class{constructor({uiLoading:N,uiScanning:_,uiError:E}){"yes"===N?this.loadingModal=this._loadHTML(U):"no"!==N&&(this.loadingModal=document.querySelector(N)),"yes"===E?this.compatibilityModal=this._loadHTML($):"no"!==E&&(this.compatibilityModal=document.querySelector(E)),"yes"===_?this.scanningMask=this._loadHTML(O):"no"!==_&&(this.scanningMask=document.querySelector(_)),this.hideLoading(),this.hideCompatibility(),this.hideScanning()}showLoading(){this.loadingModal&&this.loadingModal.classList.remove("hidden")}hideLoading(){this.loadingModal&&this.loadingModal.classList.add("hidden")}showCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.remove("hidden")}hideCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.add("hidden")}showScanning(){this.scanningMask&&this.scanningMask.classList.remove("hidden")}hideScanning(){this.scanningMask&&this.scanningMask.classList.add("hidden")}_loadHTML(N){const _=document.createElement("template");_.innerHTML=N.trim();const E=_.content.firstChild;return document.getElementsByTagName("body")[0].appendChild(E),E}}}},3906:()=>{},2993:()=>{},8352:()=>{},4589:()=>{},1758:()=>{}},Fl={};function Qn(ot){if(Fl[ot])return Fl[ot].exports;var ht=Fl[ot]={id:ot,loaded:!1,exports:{}};return Cd[ot].call(ht.exports,ht,ht.exports,Qn),ht.loaded=!0,ht.exports}Qn.amdD=function(){throw new Error("define cannot be used indirect")},Qn.amdO={},Qn.n=ot=>{var ht=ot&&ot.__esModule?()=>ot.default:()=>ot;return Qn.d(ht,{a:ht}),ht},Qn.d=(ot,ht)=>{for(var I in ht)Qn.o(ht,I)&&!Qn.o(ot,I)&&Object.defineProperty(ot,I,{enumerable:!0,get:ht[I]})},Qn.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch{if("object"==typeof window)return window}}(),Qn.o=(ot,ht)=>Object.prototype.hasOwnProperty.call(ot,ht),Qn.r=ot=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(ot,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(ot,"__esModule",{value:!0})},Qn.nmd=ot=>(ot.paths=[],ot.children||(ot.children=[]),ot),Qn.p="",Qn(5260)})(),(()=>{const{Controller:Cd,UI:Fl}=window.MINDAR.IMAGE;AFRAME.registerSystem("mindar-image-system",{container:null,video:null,processingImage:!1,init:function(){this.anchorEntities=[]},tick:function(){},setup:function({imageTargetSrc:Qn,maxTrack:ot,showStats:ht,uiLoading:I,uiScanning:U,uiError:$,missTolerance:O,warmupTolerance:N,filterMinCF:_,filterBeta:E}){this.imageTargetSrc=Qn,this.maxTrack=ot,this.filterMinCF=_,this.filterBeta=E,this.missTolerance=O,this.warmupTolerance=N,this.showStats=ht,this.ui=new Fl({uiLoading:I,uiScanning:U,uiError:$})},registerAnchor:function(Qn,ot){this.anchorEntities.push({el:Qn,targetIndex:ot})},start:function(){this.container=this.el.sceneEl.parentNode,this.showStats&&(this.mainStats=new Stats,this.mainStats.showPanel(0),this.mainStats.domElement.style.cssText="position:absolute;top:0px;left:0px;z-index:999",this.container.appendChild(this.mainStats.domElement)),this.ui.showLoading(),this._startVideo()},switchTarget:function(Qn){this.controller.interestedTargetIndex=Qn},stop:function(){this.pause(),this.video.srcObject.getTracks().forEach(function(Qn){Qn.stop()}),this.video.remove()},pause:function(Qn=!1){Qn||this.video.pause(),this.controller.stopProcessVideo()},unpause:function(){this.video.play(),this.controller.processVideo(this.video)},_startVideo:function(){if(this.video=document.createElement("video"),this.video.setAttribute("autoplay",""),this.video.setAttribute("muted",""),this.video.setAttribute("playsinline",""),this.video.style.position="absolute",this.video.style.top="0px",this.video.style.left="0px",this.video.style.zIndex="-2",this.container.appendChild(this.video),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)return this.el.emit("arError",{error:"VIDEO_FAIL"}),void this.ui.showCompatibility();navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"environment"}}).then(Qn=>{this.video.addEventListener("loadedmetadata",()=>{this.video.setAttribute("width",this.video.videoWidth),this.video.setAttribute("height",this.video.videoHeight),this._startAR()}),this.video.srcObject=Qn}).catch(Qn=>{console.log("getUserMedia error",Qn),this.el.emit("arError",{error:"VIDEO_FAIL"})})},_startAR:async function(){const Qn=this.video;this.controller=new Cd({inputWidth:Qn.videoWidth,inputHeight:Qn.videoHeight,maxTrack:this.maxTrack,filterMinCF:this.filterMinCF,filterBeta:this.filterBeta,missTolerance:this.missTolerance,warmupTolerance:this.warmupTolerance,onUpdate:ht=>{if("processDone"===ht.type)this.mainStats&&this.mainStats.update();else if("updateMatrix"===ht.type){const{targetIndex:I,worldMatrix:U}=ht;for(let $=0;$<this.anchorEntities.length;$++)this.anchorEntities[$].targetIndex===I&&(this.anchorEntities[$].el.updateWorldMatrix(U),U&&this.ui.hideScanning())}}}),this._resize(),window.addEventListener("resize",this._resize.bind(this));const{dimensions:ot}=await this.controller.addImageTargets(this.imageTargetSrc);for(let ht=0;ht<this.anchorEntities.length;ht++){const{el:I,targetIndex:U}=this.anchorEntities[ht];U<ot.length&&I.setupMarker(ot[U])}await this.controller.dummyRun(this.video),this.el.emit("arReady"),this.ui.hideLoading(),this.ui.showScanning(),this.controller.processVideo(this.video)},_resize:function(){const Qn=this.video,ot=this.container;let ht,I;const U=Qn.videoWidth/Qn.videoHeight;U>ot.clientWidth/ot.clientHeight?(I=ot.clientHeight,ht=I*U):(ht=ot.clientWidth,I=ht/U);const $=this.controller.getProjectionMatrix(),O=2*Math.atan(1/$[5]/I*ot.clientHeight)*180/Math.PI,N=$[14]/($[10]-1),_=$[14]/($[10]+1),E=ot.clientWidth/ot.clientHeight,D=ot.getElementsByTagName("a-camera")[0].getObject3D("camera");D.fov=O,D.aspect=E,D.near=N,D.far=_,D.updateProjectionMatrix(),this.video.style.top=-(I-ot.clientHeight)/2+"px",this.video.style.left=-(ht-ot.clientWidth)/2+"px",this.video.style.width=ht+"px",this.video.style.height=I+"px"}}),AFRAME.registerComponent("mindar-image",{dependencies:["mindar-image-system"],schema:{imageTargetSrc:{type:"string"},maxTrack:{type:"int",default:1},filterMinCF:{type:"number",default:-1},filterBeta:{type:"number",default:-1},missTolerance:{type:"int",default:-1},warmupTolerance:{type:"int",default:-1},showStats:{type:"boolean",default:!1},autoStart:{type:"boolean",default:!0},uiLoading:{type:"string",default:"yes"},uiScanning:{type:"string",default:"yes"},uiError:{type:"string",default:"yes"}},init:function(){const Qn=this.el.sceneEl.systems["mindar-image-system"];Qn.setup({imageTargetSrc:this.data.imageTargetSrc,maxTrack:this.data.maxTrack,filterMinCF:-1===this.data.filterMinCF?null:this.data.filterMinCF,filterBeta:-1===this.data.filterBeta?null:this.data.filterBeta,missTolerance:-1===this.data.missTolerance?null:this.data.missTolerance,warmupTolerance:-1===this.data.warmupTolerance?null:this.data.warmupTolerance,showStats:this.data.showStats,uiLoading:this.data.uiLoading,uiScanning:this.data.uiScanning,uiError:this.data.uiError}),this.data.autoStart&&this.el.sceneEl.addEventListener("renderstart",()=>{Qn.start()})}}),AFRAME.registerComponent("mindar-image-target",{dependencies:["mindar-image-system"],schema:{targetIndex:{type:"number"}},postMatrix:null,init:function(){this.el.sceneEl.systems["mindar-image-system"].registerAnchor(this,this.data.targetIndex);const Qn=this.el.object3D;Qn.visible=!1,Qn.matrixAutoUpdate=!1},setupMarker([Qn,ot]){const ht=new AFRAME.THREE.Vector3,I=new AFRAME.THREE.Quaternion,U=new AFRAME.THREE.Vector3;ht.x=Qn/2,ht.y=Qn/2+(ot-Qn)/2,U.x=Qn,U.y=Qn,U.z=Qn,this.postMatrix=new AFRAME.THREE.Matrix4,this.postMatrix.compose(ht,I,U)},updateWorldMatrix(Qn){if(this.el.object3D.visible||null===Qn?this.el.object3D.visible&&null===Qn&&this.el.emit("targetLost"):this.el.emit("targetFound"),this.el.object3D.visible=null!==Qn,null!==Qn){var ot=new AFRAME.THREE.Matrix4;ot.elements=Qn,ot.multiply(this.postMatrix),this.el.object3D.matrix=ot}}})})();